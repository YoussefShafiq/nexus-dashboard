var YP = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports); var wce = YP((Fi, Bi) => {
  (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const s of i) if (s.type === "childList") for (const a of s.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && r(a) }).observe(document, { childList: !0, subtree: !0 }); function n(i) { const s = {}; return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function r(i) { if (i.ep) return; i.ep = !0; const s = n(i); fetch(i.href, s) } })(); var _p = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function Ha(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var Yv = { exports: {} }, Rd = {};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var lj; function GP() { if (lj) return Rd; lj = 1; var t = Symbol.for("react.transitional.element"), e = Symbol.for("react.fragment"); function n(r, i, s) { var a = null; if (s !== void 0 && (a = "" + s), i.key !== void 0 && (a = "" + i.key), "key" in i) { s = {}; for (var l in i) l !== "key" && (s[l] = i[l]) } else s = i; return i = s.ref, { $$typeof: t, type: r, key: a, ref: i !== void 0 ? i : null, props: s } } return Rd.Fragment = e, Rd.jsx = n, Rd.jsxs = n, Rd } var cj; function XP() { return cj || (cj = 1, Yv.exports = GP()), Yv.exports } var d = XP(), Gv = { exports: {} }, Bt = {};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var uj; function QP() { if (uj) return Bt; uj = 1; var t = Symbol.for("react.transitional.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.consumer"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), f = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), g = Symbol.iterator; function y(B) { return B === null || typeof B != "object" ? null : (B = g && B[g] || B["@@iterator"], typeof B == "function" ? B : null) } var v = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, b = Object.assign, S = {}; function C(B, ie, oe) { this.props = B, this.context = ie, this.refs = S, this.updater = oe || v } C.prototype.isReactComponent = {}, C.prototype.setState = function (B, ie) { if (typeof B != "object" && typeof B != "function" && B != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, B, ie, "setState") }, C.prototype.forceUpdate = function (B) { this.updater.enqueueForceUpdate(this, B, "forceUpdate") }; function T() { } T.prototype = C.prototype; function A(B, ie, oe) { this.props = B, this.context = ie, this.refs = S, this.updater = oe || v } var M = A.prototype = new T; M.constructor = A, b(M, C.prototype), M.isPureReactComponent = !0; var O = Array.isArray, E = { H: null, A: null, T: null, S: null, V: null }, k = Object.prototype.hasOwnProperty; function z(B, ie, oe, pe, Ee, fe) { return oe = fe.ref, { $$typeof: t, type: B, key: ie, ref: oe !== void 0 ? oe : null, props: fe } } function V(B, ie) { return z(B.type, ie, void 0, void 0, void 0, B.props) } function q(B) { return typeof B == "object" && B !== null && B.$$typeof === t } function ue(B) { var ie = { "=": "=0", ":": "=2" }; return "$" + B.replace(/[=:]/g, function (oe) { return ie[oe] }) } var W = /\/+/g; function ne(B, ie) { return typeof B == "object" && B !== null && B.key != null ? ue("" + B.key) : ie.toString(36) } function H() { } function we(B) { switch (B.status) { case "fulfilled": return B.value; case "rejected": throw B.reason; default: switch (typeof B.status == "string" ? B.then(H, H) : (B.status = "pending", B.then(function (ie) { B.status === "pending" && (B.status = "fulfilled", B.value = ie) }, function (ie) { B.status === "pending" && (B.status = "rejected", B.reason = ie) })), B.status) { case "fulfilled": return B.value; case "rejected": throw B.reason } }throw B } function xe(B, ie, oe, pe, Ee) { var fe = typeof B; (fe === "undefined" || fe === "boolean") && (B = null); var Oe = !1; if (B === null) Oe = !0; else switch (fe) { case "bigint": case "string": case "number": Oe = !0; break; case "object": switch (B.$$typeof) { case t: case e: Oe = !0; break; case p: return Oe = B._init, xe(Oe(B._payload), ie, oe, pe, Ee) } }if (Oe) return Ee = Ee(B), Oe = pe === "" ? "." + ne(B, 0) : pe, O(Ee) ? (oe = "", Oe != null && (oe = Oe.replace(W, "$&/") + "/"), xe(Ee, ie, oe, "", function (De) { return De })) : Ee != null && (q(Ee) && (Ee = V(Ee, oe + (Ee.key == null || B && B.key === Ee.key ? "" : ("" + Ee.key).replace(W, "$&/") + "/") + Oe)), ie.push(Ee)), 1; Oe = 0; var et = pe === "" ? "." : pe + ":"; if (O(B)) for (var Xe = 0; Xe < B.length; Xe++)pe = B[Xe], fe = et + ne(pe, Xe), Oe += xe(pe, ie, oe, fe, Ee); else if (Xe = y(B), typeof Xe == "function") for (B = Xe.call(B), Xe = 0; !(pe = B.next()).done;)pe = pe.value, fe = et + ne(pe, Xe++), Oe += xe(pe, ie, oe, fe, Ee); else if (fe === "object") { if (typeof B.then == "function") return xe(we(B), ie, oe, pe, Ee); throw ie = String(B), Error("Objects are not valid as a React child (found: " + (ie === "[object Object]" ? "object with keys {" + Object.keys(B).join(", ") + "}" : ie) + "). If you meant to render a collection of children, use an array instead.") } return Oe } function K(B, ie, oe) { if (B == null) return B; var pe = [], Ee = 0; return xe(B, pe, "", "", function (fe) { return ie.call(oe, fe, Ee++) }), pe } function te(B) { if (B._status === -1) { var ie = B._result; ie = ie(), ie.then(function (oe) { (B._status === 0 || B._status === -1) && (B._status = 1, B._result = oe) }, function (oe) { (B._status === 0 || B._status === -1) && (B._status = 2, B._result = oe) }), B._status === -1 && (B._status = 0, B._result = ie) } if (B._status === 1) return B._result.default; throw B._result } var ye = typeof reportError == "function" ? reportError : function (B) { if (typeof window == "object" && typeof window.ErrorEvent == "function") { var ie = new window.ErrorEvent("error", { bubbles: !0, cancelable: !0, message: typeof B == "object" && B !== null && typeof B.message == "string" ? String(B.message) : String(B), error: B }); if (!window.dispatchEvent(ie)) return } else if (typeof process == "object" && typeof process.emit == "function") { process.emit("uncaughtException", B); return } console.error(B) }; function He() { } return Bt.Children = { map: K, forEach: function (B, ie, oe) { K(B, function () { ie.apply(this, arguments) }, oe) }, count: function (B) { var ie = 0; return K(B, function () { ie++ }), ie }, toArray: function (B) { return K(B, function (ie) { return ie }) || [] }, only: function (B) { if (!q(B)) throw Error("React.Children.only expected to receive a single React element child."); return B } }, Bt.Component = C, Bt.Fragment = n, Bt.Profiler = i, Bt.PureComponent = A, Bt.StrictMode = r, Bt.Suspense = u, Bt.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = E, Bt.__COMPILER_RUNTIME = { __proto__: null, c: function (B) { return E.H.useMemoCache(B) } }, Bt.cache = function (B) { return function () { return B.apply(null, arguments) } }, Bt.cloneElement = function (B, ie, oe) { if (B == null) throw Error("The argument must be a React element, but you passed " + B + "."); var pe = b({}, B.props), Ee = B.key, fe = void 0; if (ie != null) for (Oe in ie.ref !== void 0 && (fe = void 0), ie.key !== void 0 && (Ee = "" + ie.key), ie) !k.call(ie, Oe) || Oe === "key" || Oe === "__self" || Oe === "__source" || Oe === "ref" && ie.ref === void 0 || (pe[Oe] = ie[Oe]); var Oe = arguments.length - 2; if (Oe === 1) pe.children = oe; else if (1 < Oe) { for (var et = Array(Oe), Xe = 0; Xe < Oe; Xe++)et[Xe] = arguments[Xe + 2]; pe.children = et } return z(B.type, Ee, void 0, void 0, fe, pe) }, Bt.createContext = function (B) { return B = { $$typeof: a, _currentValue: B, _currentValue2: B, _threadCount: 0, Provider: null, Consumer: null }, B.Provider = B, B.Consumer = { $$typeof: s, _context: B }, B }, Bt.createElement = function (B, ie, oe) { var pe, Ee = {}, fe = null; if (ie != null) for (pe in ie.key !== void 0 && (fe = "" + ie.key), ie) k.call(ie, pe) && pe !== "key" && pe !== "__self" && pe !== "__source" && (Ee[pe] = ie[pe]); var Oe = arguments.length - 2; if (Oe === 1) Ee.children = oe; else if (1 < Oe) { for (var et = Array(Oe), Xe = 0; Xe < Oe; Xe++)et[Xe] = arguments[Xe + 2]; Ee.children = et } if (B && B.defaultProps) for (pe in Oe = B.defaultProps, Oe) Ee[pe] === void 0 && (Ee[pe] = Oe[pe]); return z(B, fe, void 0, void 0, null, Ee) }, Bt.createRef = function () { return { current: null } }, Bt.forwardRef = function (B) { return { $$typeof: l, render: B } }, Bt.isValidElement = q, Bt.lazy = function (B) { return { $$typeof: p, _payload: { _status: -1, _result: B }, _init: te } }, Bt.memo = function (B, ie) { return { $$typeof: f, type: B, compare: ie === void 0 ? null : ie } }, Bt.startTransition = function (B) { var ie = E.T, oe = {}; E.T = oe; try { var pe = B(), Ee = E.S; Ee !== null && Ee(oe, pe), typeof pe == "object" && pe !== null && typeof pe.then == "function" && pe.then(He, ye) } catch (fe) { ye(fe) } finally { E.T = ie } }, Bt.unstable_useCacheRefresh = function () { return E.H.useCacheRefresh() }, Bt.use = function (B) { return E.H.use(B) }, Bt.useActionState = function (B, ie, oe) { return E.H.useActionState(B, ie, oe) }, Bt.useCallback = function (B, ie) { return E.H.useCallback(B, ie) }, Bt.useContext = function (B) { return E.H.useContext(B) }, Bt.useDebugValue = function () { }, Bt.useDeferredValue = function (B, ie) { return E.H.useDeferredValue(B, ie) }, Bt.useEffect = function (B, ie, oe) { var pe = E.H; if (typeof oe == "function") throw Error("useEffect CRUD overload is not enabled in this build of React."); return pe.useEffect(B, ie) }, Bt.useId = function () { return E.H.useId() }, Bt.useImperativeHandle = function (B, ie, oe) { return E.H.useImperativeHandle(B, ie, oe) }, Bt.useInsertionEffect = function (B, ie) { return E.H.useInsertionEffect(B, ie) }, Bt.useLayoutEffect = function (B, ie) { return E.H.useLayoutEffect(B, ie) }, Bt.useMemo = function (B, ie) { return E.H.useMemo(B, ie) }, Bt.useOptimistic = function (B, ie) { return E.H.useOptimistic(B, ie) }, Bt.useReducer = function (B, ie, oe) { return E.H.useReducer(B, ie, oe) }, Bt.useRef = function (B) { return E.H.useRef(B) }, Bt.useState = function (B) { return E.H.useState(B) }, Bt.useSyncExternalStore = function (B, ie, oe) { return E.H.useSyncExternalStore(B, ie, oe) }, Bt.useTransition = function () { return E.H.useTransition() }, Bt.version = "19.1.0", Bt } var dj; function sy() { return dj || (dj = 1, Gv.exports = QP()), Gv.exports } var N = sy(); const Pt = Ha(N); var Xv = { exports: {} }, _d = {}, Qv = { exports: {} }, Jv = {};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var fj; function JP() { return fj || (fj = 1, function (t) { function e(K, te) { var ye = K.length; K.push(te); e: for (; 0 < ye;) { var He = ye - 1 >>> 1, B = K[He]; if (0 < i(B, te)) K[He] = te, K[ye] = B, ye = He; else break e } } function n(K) { return K.length === 0 ? null : K[0] } function r(K) { if (K.length === 0) return null; var te = K[0], ye = K.pop(); if (ye !== te) { K[0] = ye; e: for (var He = 0, B = K.length, ie = B >>> 1; He < ie;) { var oe = 2 * (He + 1) - 1, pe = K[oe], Ee = oe + 1, fe = K[Ee]; if (0 > i(pe, ye)) Ee < B && 0 > i(fe, pe) ? (K[He] = fe, K[Ee] = ye, He = Ee) : (K[He] = pe, K[oe] = ye, He = oe); else if (Ee < B && 0 > i(fe, ye)) K[He] = fe, K[Ee] = ye, He = Ee; else break e } } return te } function i(K, te) { var ye = K.sortIndex - te.sortIndex; return ye !== 0 ? ye : K.id - te.id } if (t.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") { var s = performance; t.unstable_now = function () { return s.now() } } else { var a = Date, l = a.now(); t.unstable_now = function () { return a.now() - l } } var u = [], f = [], p = 1, g = null, y = 3, v = !1, b = !1, S = !1, C = !1, T = typeof setTimeout == "function" ? setTimeout : null, A = typeof clearTimeout == "function" ? clearTimeout : null, M = typeof setImmediate < "u" ? setImmediate : null; function O(K) { for (var te = n(f); te !== null;) { if (te.callback === null) r(f); else if (te.startTime <= K) r(f), te.sortIndex = te.expirationTime, e(u, te); else break; te = n(f) } } function E(K) { if (S = !1, O(K), !b) if (n(u) !== null) b = !0, k || (k = !0, ne()); else { var te = n(f); te !== null && xe(E, te.startTime - K) } } var k = !1, z = -1, V = 5, q = -1; function ue() { return C ? !0 : !(t.unstable_now() - q < V) } function W() { if (C = !1, k) { var K = t.unstable_now(); q = K; var te = !0; try { e: { b = !1, S && (S = !1, A(z), z = -1), v = !0; var ye = y; try { t: { for (O(K), g = n(u); g !== null && !(g.expirationTime > K && ue());) { var He = g.callback; if (typeof He == "function") { g.callback = null, y = g.priorityLevel; var B = He(g.expirationTime <= K); if (K = t.unstable_now(), typeof B == "function") { g.callback = B, O(K), te = !0; break t } g === n(u) && r(u), O(K) } else r(u); g = n(u) } if (g !== null) te = !0; else { var ie = n(f); ie !== null && xe(E, ie.startTime - K), te = !1 } } break e } finally { g = null, y = ye, v = !1 } te = void 0 } } finally { te ? ne() : k = !1 } } } var ne; if (typeof M == "function") ne = function () { M(W) }; else if (typeof MessageChannel < "u") { var H = new MessageChannel, we = H.port2; H.port1.onmessage = W, ne = function () { we.postMessage(null) } } else ne = function () { T(W, 0) }; function xe(K, te) { z = T(function () { K(t.unstable_now()) }, te) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (K) { K.callback = null }, t.unstable_forceFrameRate = function (K) { 0 > K || 125 < K ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : V = 0 < K ? Math.floor(1e3 / K) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return y }, t.unstable_next = function (K) { switch (y) { case 1: case 2: case 3: var te = 3; break; default: te = y }var ye = y; y = te; try { return K() } finally { y = ye } }, t.unstable_requestPaint = function () { C = !0 }, t.unstable_runWithPriority = function (K, te) { switch (K) { case 1: case 2: case 3: case 4: case 5: break; default: K = 3 }var ye = y; y = K; try { return te() } finally { y = ye } }, t.unstable_scheduleCallback = function (K, te, ye) { var He = t.unstable_now(); switch (typeof ye == "object" && ye !== null ? (ye = ye.delay, ye = typeof ye == "number" && 0 < ye ? He + ye : He) : ye = He, K) { case 1: var B = -1; break; case 2: B = 250; break; case 5: B = 1073741823; break; case 4: B = 1e4; break; default: B = 5e3 }return B = ye + B, K = { id: p++, callback: te, priorityLevel: K, startTime: ye, expirationTime: B, sortIndex: -1 }, ye > He ? (K.sortIndex = ye, e(f, K), n(u) === null && K === n(f) && (S ? (A(z), z = -1) : S = !0, xe(E, ye - He))) : (K.sortIndex = B, e(u, K), b || v || (b = !0, k || (k = !0, ne()))), K }, t.unstable_shouldYield = ue, t.unstable_wrapCallback = function (K) { var te = y; return function () { var ye = y; y = te; try { return K.apply(this, arguments) } finally { y = ye } } } }(Jv)), Jv } var hj; function ZP() { return hj || (hj = 1, Qv.exports = JP()), Qv.exports } var Zv = { exports: {} }, Hr = {};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var pj; function e8() { if (pj) return Hr; pj = 1; var t = sy(); function e(u) { var f = "https://react.dev/errors/" + u; if (1 < arguments.length) { f += "?args[]=" + encodeURIComponent(arguments[1]); for (var p = 2; p < arguments.length; p++)f += "&args[]=" + encodeURIComponent(arguments[p]) } return "Minified React error #" + u + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } function n() { } var r = { d: { f: n, r: function () { throw Error(e(522)) }, D: n, C: n, L: n, m: n, X: n, S: n, M: n }, p: 0, findDOMNode: null }, i = Symbol.for("react.portal"); function s(u, f, p) { var g = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: i, key: g == null ? null : "" + g, children: u, containerInfo: f, implementation: p } } var a = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE; function l(u, f) { if (u === "font") return ""; if (typeof f == "string") return f === "use-credentials" ? f : "" } return Hr.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r, Hr.createPortal = function (u, f) { var p = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!f || f.nodeType !== 1 && f.nodeType !== 9 && f.nodeType !== 11) throw Error(e(299)); return s(u, f, null, p) }, Hr.flushSync = function (u) { var f = a.T, p = r.p; try { if (a.T = null, r.p = 2, u) return u() } finally { a.T = f, r.p = p, r.d.f() } }, Hr.preconnect = function (u, f) { typeof u == "string" && (f ? (f = f.crossOrigin, f = typeof f == "string" ? f === "use-credentials" ? f : "" : void 0) : f = null, r.d.C(u, f)) }, Hr.prefetchDNS = function (u) { typeof u == "string" && r.d.D(u) }, Hr.preinit = function (u, f) { if (typeof u == "string" && f && typeof f.as == "string") { var p = f.as, g = l(p, f.crossOrigin), y = typeof f.integrity == "string" ? f.integrity : void 0, v = typeof f.fetchPriority == "string" ? f.fetchPriority : void 0; p === "style" ? r.d.S(u, typeof f.precedence == "string" ? f.precedence : void 0, { crossOrigin: g, integrity: y, fetchPriority: v }) : p === "script" && r.d.X(u, { crossOrigin: g, integrity: y, fetchPriority: v, nonce: typeof f.nonce == "string" ? f.nonce : void 0 }) } }, Hr.preinitModule = function (u, f) { if (typeof u == "string") if (typeof f == "object" && f !== null) { if (f.as == null || f.as === "script") { var p = l(f.as, f.crossOrigin); r.d.M(u, { crossOrigin: p, integrity: typeof f.integrity == "string" ? f.integrity : void 0, nonce: typeof f.nonce == "string" ? f.nonce : void 0 }) } } else f == null && r.d.M(u) }, Hr.preload = function (u, f) { if (typeof u == "string" && typeof f == "object" && f !== null && typeof f.as == "string") { var p = f.as, g = l(p, f.crossOrigin); r.d.L(u, p, { crossOrigin: g, integrity: typeof f.integrity == "string" ? f.integrity : void 0, nonce: typeof f.nonce == "string" ? f.nonce : void 0, type: typeof f.type == "string" ? f.type : void 0, fetchPriority: typeof f.fetchPriority == "string" ? f.fetchPriority : void 0, referrerPolicy: typeof f.referrerPolicy == "string" ? f.referrerPolicy : void 0, imageSrcSet: typeof f.imageSrcSet == "string" ? f.imageSrcSet : void 0, imageSizes: typeof f.imageSizes == "string" ? f.imageSizes : void 0, media: typeof f.media == "string" ? f.media : void 0 }) } }, Hr.preloadModule = function (u, f) { if (typeof u == "string") if (f) { var p = l(f.as, f.crossOrigin); r.d.m(u, { as: typeof f.as == "string" && f.as !== "script" ? f.as : void 0, crossOrigin: p, integrity: typeof f.integrity == "string" ? f.integrity : void 0 }) } else r.d.m(u) }, Hr.requestFormReset = function (u) { r.d.r(u) }, Hr.unstable_batchedUpdates = function (u, f) { return u(f) }, Hr.useFormState = function (u, f, p) { return a.H.useFormState(u, f, p) }, Hr.useFormStatus = function () { return a.H.useHostTransitionStatus() }, Hr.version = "19.1.0", Hr } var mj; function J3() { if (mj) return Zv.exports; mj = 1; function t() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t) } catch (e) { console.error(e) } } return t(), Zv.exports = e8(), Zv.exports }/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var gj; function t8() {
    if (gj) return _d; gj = 1; var t = ZP(), e = sy(), n = J3(); function r(o) { var c = "https://react.dev/errors/" + o; if (1 < arguments.length) { c += "?args[]=" + encodeURIComponent(arguments[1]); for (var h = 2; h < arguments.length; h++)c += "&args[]=" + encodeURIComponent(arguments[h]) } return "Minified React error #" + o + "; visit " + c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } function i(o) { return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11) } function s(o) { var c = o, h = o; if (o.alternate) for (; c.return;)c = c.return; else { o = c; do c = o, (c.flags & 4098) !== 0 && (h = c.return), o = c.return; while (o) } return c.tag === 3 ? h : null } function a(o) { if (o.tag === 13) { var c = o.memoizedState; if (c === null && (o = o.alternate, o !== null && (c = o.memoizedState)), c !== null) return c.dehydrated } return null } function l(o) { if (s(o) !== o) throw Error(r(188)) } function u(o) { var c = o.alternate; if (!c) { if (c = s(o), c === null) throw Error(r(188)); return c !== o ? null : o } for (var h = o, m = c; ;) { var x = h.return; if (x === null) break; var w = x.alternate; if (w === null) { if (m = x.return, m !== null) { h = m; continue } break } if (x.child === w.child) { for (w = x.child; w;) { if (w === h) return l(x), o; if (w === m) return l(x), c; w = w.sibling } throw Error(r(188)) } if (h.return !== m.return) h = x, m = w; else { for (var D = !1, R = x.child; R;) { if (R === h) { D = !0, h = x, m = w; break } if (R === m) { D = !0, m = x, h = w; break } R = R.sibling } if (!D) { for (R = w.child; R;) { if (R === h) { D = !0, h = w, m = x; break } if (R === m) { D = !0, m = w, h = x; break } R = R.sibling } if (!D) throw Error(r(189)) } } if (h.alternate !== m) throw Error(r(190)) } if (h.tag !== 3) throw Error(r(188)); return h.stateNode.current === h ? o : c } function f(o) { var c = o.tag; if (c === 5 || c === 26 || c === 27 || c === 6) return o; for (o = o.child; o !== null;) { if (c = f(o), c !== null) return c; o = o.sibling } return null } var p = Object.assign, g = Symbol.for("react.element"), y = Symbol.for("react.transitional.element"), v = Symbol.for("react.portal"), b = Symbol.for("react.fragment"), S = Symbol.for("react.strict_mode"), C = Symbol.for("react.profiler"), T = Symbol.for("react.provider"), A = Symbol.for("react.consumer"), M = Symbol.for("react.context"), O = Symbol.for("react.forward_ref"), E = Symbol.for("react.suspense"), k = Symbol.for("react.suspense_list"), z = Symbol.for("react.memo"), V = Symbol.for("react.lazy"), q = Symbol.for("react.activity"), ue = Symbol.for("react.memo_cache_sentinel"), W = Symbol.iterator; function ne(o) { return o === null || typeof o != "object" ? null : (o = W && o[W] || o["@@iterator"], typeof o == "function" ? o : null) } var H = Symbol.for("react.client.reference"); function we(o) { if (o == null) return null; if (typeof o == "function") return o.$$typeof === H ? null : o.displayName || o.name || null; if (typeof o == "string") return o; switch (o) { case b: return "Fragment"; case C: return "Profiler"; case S: return "StrictMode"; case E: return "Suspense"; case k: return "SuspenseList"; case q: return "Activity" }if (typeof o == "object") switch (o.$$typeof) { case v: return "Portal"; case M: return (o.displayName || "Context") + ".Provider"; case A: return (o._context.displayName || "Context") + ".Consumer"; case O: var c = o.render; return o = o.displayName, o || (o = c.displayName || c.name || "", o = o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef"), o; case z: return c = o.displayName || null, c !== null ? c : we(o.type) || "Memo"; case V: c = o._payload, o = o._init; try { return we(o(c)) } catch { } }return null } var xe = Array.isArray, K = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, te = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ye = { pending: !1, data: null, method: null, action: null }, He = [], B = -1; function ie(o) { return { current: o } } function oe(o) { 0 > B || (o.current = He[B], He[B] = null, B--) } function pe(o, c) { B++, He[B] = o.current, o.current = c } var Ee = ie(null), fe = ie(null), Oe = ie(null), et = ie(null); function Xe(o, c) { switch (pe(Oe, c), pe(fe, o), pe(Ee, null), c.nodeType) { case 9: case 11: o = (o = c.documentElement) && (o = o.namespaceURI) ? PN(o) : 0; break; default: if (o = c.tagName, c = c.namespaceURI) c = PN(c), o = zN(c, o); else switch (o) { case "svg": o = 1; break; case "math": o = 2; break; default: o = 0 } }oe(Ee), pe(Ee, o) } function De() { oe(Ee), oe(fe), oe(Oe) } function he(o) { o.memoizedState !== null && pe(et, o); var c = Ee.current, h = zN(c, o.type); c !== h && (pe(fe, o), pe(Ee, h)) } function Be(o) { fe.current === o && (oe(Ee), oe(fe)), et.current === o && (oe(et), Ad._currentValue = ye) } var Y = Object.prototype.hasOwnProperty, Je = t.unstable_scheduleCallback, $e = t.unstable_cancelCallback, $ = t.unstable_shouldYield, U = t.unstable_requestPaint, be = t.unstable_now, Ie = t.unstable_getCurrentPriorityLevel, it = t.unstable_ImmediatePriority, P = t.unstable_UserBlockingPriority, ee = t.unstable_NormalPriority, _ = t.unstable_LowPriority, I = t.unstable_IdlePriority, se = t.log, ae = t.unstable_setDisableYieldValue, Ae = null, qe = null; function rt(o) { if (typeof se == "function" && ae(o), qe && typeof qe.setStrictMode == "function") try { qe.setStrictMode(Ae, o) } catch { } } var Tt = Math.clz32 ? Math.clz32 : $n, yn = Math.log, Gt = Math.LN2; function $n(o) { return o >>>= 0, o === 0 ? 32 : 31 - (yn(o) / Gt | 0) | 0 } var cn = 256, je = 4194304; function tt(o) { var c = o & 42; if (c !== 0) return c; switch (o & -o) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: return 64; case 128: return 128; case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return o & 4194048; case 4194304: case 8388608: case 16777216: case 33554432: return o & 62914560; case 67108864: return 67108864; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 0; default: return o } } function lt(o, c, h) { var m = o.pendingLanes; if (m === 0) return 0; var x = 0, w = o.suspendedLanes, D = o.pingedLanes; o = o.warmLanes; var R = m & 134217727; return R !== 0 ? (m = R & ~w, m !== 0 ? x = tt(m) : (D &= R, D !== 0 ? x = tt(D) : h || (h = R & ~o, h !== 0 && (x = tt(h))))) : (R = m & ~w, R !== 0 ? x = tt(R) : D !== 0 ? x = tt(D) : h || (h = m & ~o, h !== 0 && (x = tt(h)))), x === 0 ? 0 : c !== 0 && c !== x && (c & w) === 0 && (w = x & -x, h = c & -c, w >= h || w === 32 && (h & 4194048) !== 0) ? c : x } function le(o, c) { return (o.pendingLanes & ~(o.suspendedLanes & ~o.pingedLanes) & c) === 0 } function st(o, c) { switch (o) { case 1: case 2: case 4: case 8: case 64: return c + 250; case 16: case 32: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return c + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: return -1; case 67108864: case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function wt() { var o = cn; return cn <<= 1, (cn & 4194048) === 0 && (cn = 256), o } function Qe() { var o = je; return je <<= 1, (je & 62914560) === 0 && (je = 4194304), o } function Te(o) { for (var c = [], h = 0; 31 > h; h++)c.push(o); return c } function Ze(o, c) { o.pendingLanes |= c, c !== 268435456 && (o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0) } function gt(o, c, h, m, x, w) { var D = o.pendingLanes; o.pendingLanes = h, o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0, o.expiredLanes &= h, o.entangledLanes &= h, o.errorRecoveryDisabledLanes &= h, o.shellSuspendCounter = 0; var R = o.entanglements, G = o.expirationTimes, ve = o.hiddenUpdates; for (h = D & ~h; 0 < h;) { var _e = 31 - Tt(h), Fe = 1 << _e; R[_e] = 0, G[_e] = -1; var Ce = ve[_e]; if (Ce !== null) for (ve[_e] = null, _e = 0; _e < Ce.length; _e++) { var Ne = Ce[_e]; Ne !== null && (Ne.lane &= -536870913) } h &= ~Fe } m !== 0 && vt(o, m, 0), w !== 0 && x === 0 && o.tag !== 0 && (o.suspendedLanes |= w & ~(D & ~c)) } function vt(o, c, h) { o.pendingLanes |= c, o.suspendedLanes &= ~c; var m = 31 - Tt(c); o.entangledLanes |= c, o.entanglements[m] = o.entanglements[m] | 1073741824 | h & 4194090 } function Nt(o, c) { var h = o.entangledLanes |= c; for (o = o.entanglements; h;) { var m = 31 - Tt(h), x = 1 << m; x & c | o[m] & c && (o[m] |= c), h &= ~x } } function rn(o) { switch (o) { case 2: o = 1; break; case 8: o = 4; break; case 32: o = 16; break; case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: o = 128; break; case 268435456: o = 134217728; break; default: o = 0 }return o } function Un(o) { return o &= -o, 2 < o ? 8 < o ? (o & 134217727) !== 0 ? 32 : 268435456 : 8 : 2 } function Z() { var o = te.p; return o !== 0 ? o : (o = window.event, o === void 0 ? 32 : nj(o.type)) } function ce(o, c) { var h = te.p; try { return te.p = o, c() } finally { te.p = h } } var Se = Math.random().toString(36).slice(2), Le = "__reactFiber$" + Se, We = "__reactProps$" + Se, ct = "__reactContainer$" + Se, xt = "__reactEvents$" + Se, at = "__reactListeners$" + Se, dt = "__reactHandles$" + Se, ut = "__reactResources$" + Se, jt = "__reactMarker$" + Se; function St(o) { delete o[Le], delete o[We], delete o[xt], delete o[at], delete o[dt] } function Mt(o) { var c = o[Le]; if (c) return c; for (var h = o.parentNode; h;) { if (c = h[ct] || h[Le]) { if (h = c.alternate, c.child !== null || h !== null && h.child !== null) for (o = $N(o); o !== null;) { if (h = o[Le]) return h; o = $N(o) } return c } o = h, h = o.parentNode } return null } function zt(o) { if (o = o[Le] || o[ct]) { var c = o.tag; if (c === 5 || c === 6 || c === 13 || c === 26 || c === 27 || c === 3) return o } return null } function hn(o) { var c = o.tag; if (c === 5 || c === 26 || c === 27 || c === 6) return o.stateNode; throw Error(r(33)) } function pn(o) { var c = o[ut]; return c || (c = o[ut] = { hoistableStyles: new Map, hoistableScripts: new Map }), c } function Zt(o) { o[jt] = !0 } var Ht = new Set, Hi = {}; function pr(o, c) { $r(o, c), $r(o + "Capture", c) } function $r(o, c) { for (Hi[o] = c, o = 0; o < c.length; o++)Ht.add(c[o]) } var Pn = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), Ur = {}, Mr = {}; function Ls(o) { return Y.call(Mr, o) ? !0 : Y.call(Ur, o) ? !1 : Pn.test(o) ? Mr[o] = !0 : (Ur[o] = !0, !1) } function Jn(o, c, h) { if (Ls(c)) if (h === null) o.removeAttribute(c); else { switch (typeof h) { case "undefined": case "function": case "symbol": o.removeAttribute(c); return; case "boolean": var m = c.toLowerCase().slice(0, 5); if (m !== "data-" && m !== "aria-") { o.removeAttribute(c); return } }o.setAttribute(c, "" + h) } } function Ni(o, c, h) { if (h === null) o.removeAttribute(c); else { switch (typeof h) { case "undefined": case "function": case "symbol": case "boolean": o.removeAttribute(c); return }o.setAttribute(c, "" + h) } } function _t(o, c, h, m) { if (m === null) o.removeAttribute(h); else { switch (typeof m) { case "undefined": case "function": case "symbol": case "boolean": o.removeAttribute(h); return }o.setAttributeNS(c, h, "" + m) } } var Vn, Jr; function Zr(o) {
      if (Vn === void 0) try { throw Error() } catch (h) {
        var c = h.stack.trim().match(/\n( *(at )?)/); Vn = c && c[1] || "", Jr = -1 < h.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < h.stack.indexOf("@") ? "@unknown:0:0" : ""
      } return `
`+ Vn + o + Jr
    } var ji = !1; function un(o, c) {
      if (!o || ji) return ""; ji = !0; var h = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try {
        var m = { DetermineComponentFrameRoot: function () { try { if (c) { var Fe = function () { throw Error() }; if (Object.defineProperty(Fe.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(Fe, []) } catch (Ne) { var Ce = Ne } Reflect.construct(o, [], Fe) } else { try { Fe.call() } catch (Ne) { Ce = Ne } o.call(Fe.prototype) } } else { try { throw Error() } catch (Ne) { Ce = Ne } (Fe = o()) && typeof Fe.catch == "function" && Fe.catch(function () { }) } } catch (Ne) { if (Ne && Ce && typeof Ne.stack == "string") return [Ne.stack, Ce.stack] } return [null, null] } }; m.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot"; var x = Object.getOwnPropertyDescriptor(m.DetermineComponentFrameRoot, "name"); x && x.configurable && Object.defineProperty(m.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" }); var w = m.DetermineComponentFrameRoot(), D = w[0], R = w[1]; if (D && R) {
          var G = D.split(`
`), ve = R.split(`
`); for (x = m = 0; m < G.length && !G[m].includes("DetermineComponentFrameRoot");)m++; for (; x < ve.length && !ve[x].includes("DetermineComponentFrameRoot");)x++; if (m === G.length || x === ve.length) for (m = G.length - 1, x = ve.length - 1; 1 <= m && 0 <= x && G[m] !== ve[x];)x--; for (; 1 <= m && 0 <= x; m--, x--)if (G[m] !== ve[x]) {
            if (m !== 1 || x !== 1) do if (m--, x--, 0 > x || G[m] !== ve[x]) {
              var _e = `
`+ G[m].replace(" at new ", " at "); return o.displayName && _e.includes("<anonymous>") && (_e = _e.replace("<anonymous>", o.displayName)), _e
            } while (1 <= m && 0 <= x); break
          }
        }
      } finally { ji = !1, Error.prepareStackTrace = h } return (h = o ? o.displayName || o.name : "") ? Zr(h) : ""
    } function qi(o) { switch (o.tag) { case 26: case 27: case 5: return Zr(o.type); case 16: return Zr("Lazy"); case 13: return Zr("Suspense"); case 19: return Zr("SuspenseList"); case 0: case 15: return un(o.type, !1); case 11: return un(o.type.render, !1); case 1: return un(o.type, !0); case 31: return Zr("Activity"); default: return "" } } function L(o) {
      try { var c = ""; do c += qi(o), o = o.return; while (o); return c } catch (h) {
        return `
Error generating stack: `+ h.message + `
`+ h.stack
      }
    } function Q(o) { switch (typeof o) { case "bigint": case "boolean": case "number": case "string": case "undefined": return o; case "object": return o; default: return "" } } function j(o) { var c = o.type; return (o = o.nodeName) && o.toLowerCase() === "input" && (c === "checkbox" || c === "radio") } function F(o) { var c = j(o) ? "checked" : "value", h = Object.getOwnPropertyDescriptor(o.constructor.prototype, c), m = "" + o[c]; if (!o.hasOwnProperty(c) && typeof h < "u" && typeof h.get == "function" && typeof h.set == "function") { var x = h.get, w = h.set; return Object.defineProperty(o, c, { configurable: !0, get: function () { return x.call(this) }, set: function (D) { m = "" + D, w.call(this, D) } }), Object.defineProperty(o, c, { enumerable: h.enumerable }), { getValue: function () { return m }, setValue: function (D) { m = "" + D }, stopTracking: function () { o._valueTracker = null, delete o[c] } } } } function J(o) { o._valueTracker || (o._valueTracker = F(o)) } function X(o) { if (!o) return !1; var c = o._valueTracker; if (!c) return !0; var h = c.getValue(), m = ""; return o && (m = j(o) ? o.checked ? "true" : "false" : o.value), o = m, o !== h ? (c.setValue(o), !0) : !1 } function Me(o) { if (o = o || (typeof document < "u" ? document : void 0), typeof o > "u") return null; try { return o.activeElement || o.body } catch { return o.body } } var Pe = /[\n"\\]/g; function Re(o) { return o.replace(Pe, function (c) { return "\\" + c.charCodeAt(0).toString(16) + " " }) } function Ke(o, c, h, m, x, w, D, R) { o.name = "", D != null && typeof D != "function" && typeof D != "symbol" && typeof D != "boolean" ? o.type = D : o.removeAttribute("type"), c != null ? D === "number" ? (c === 0 && o.value === "" || o.value != c) && (o.value = "" + Q(c)) : o.value !== "" + Q(c) && (o.value = "" + Q(c)) : D !== "submit" && D !== "reset" || o.removeAttribute("value"), c != null ? ft(o, D, Q(c)) : h != null ? ft(o, D, Q(h)) : m != null && o.removeAttribute("value"), x == null && w != null && (o.defaultChecked = !!w), x != null && (o.checked = x && typeof x != "function" && typeof x != "symbol"), R != null && typeof R != "function" && typeof R != "symbol" && typeof R != "boolean" ? o.name = "" + Q(R) : o.removeAttribute("name") } function Ge(o, c, h, m, x, w, D, R) { if (w != null && typeof w != "function" && typeof w != "symbol" && typeof w != "boolean" && (o.type = w), c != null || h != null) { if (!(w !== "submit" && w !== "reset" || c != null)) return; h = h != null ? "" + Q(h) : "", c = c != null ? "" + Q(c) : h, R || c === o.value || (o.value = c), o.defaultValue = c } m = m ?? x, m = typeof m != "function" && typeof m != "symbol" && !!m, o.checked = R ? o.checked : !!m, o.defaultChecked = !!m, D != null && typeof D != "function" && typeof D != "symbol" && typeof D != "boolean" && (o.name = D) } function ft(o, c, h) { c === "number" && Me(o.ownerDocument) === o || o.defaultValue === "" + h || (o.defaultValue = "" + h) } function Lt(o, c, h, m) { if (o = o.options, c) { c = {}; for (var x = 0; x < h.length; x++)c["$" + h[x]] = !0; for (h = 0; h < o.length; h++)x = c.hasOwnProperty("$" + o[h].value), o[h].selected !== x && (o[h].selected = x), x && m && (o[h].defaultSelected = !0) } else { for (h = "" + Q(h), c = null, x = 0; x < o.length; x++) { if (o[x].value === h) { o[x].selected = !0, m && (o[x].defaultSelected = !0); return } c !== null || o[x].disabled || (c = o[x]) } c !== null && (c.selected = !0) } } function sn(o, c, h) { if (c != null && (c = "" + Q(c), c !== o.value && (o.value = c), h == null)) { o.defaultValue !== c && (o.defaultValue = c); return } o.defaultValue = h != null ? "" + Q(h) : "" } function an(o, c, h, m) { if (c == null) { if (m != null) { if (h != null) throw Error(r(92)); if (xe(m)) { if (1 < m.length) throw Error(r(93)); m = m[0] } h = m } h == null && (h = ""), c = h } h = Q(c), o.defaultValue = h, m = o.textContent, m === h && m !== "" && m !== null && (o.value = m) } function wn(o, c) { if (c) { var h = o.firstChild; if (h && h === o.lastChild && h.nodeType === 3) { h.nodeValue = c; return } } o.textContent = c } var zn = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")); function ei(o, c, h) { var m = c.indexOf("--") === 0; h == null || typeof h == "boolean" || h === "" ? m ? o.setProperty(c, "") : c === "float" ? o.cssFloat = "" : o[c] = "" : m ? o.setProperty(c, h) : typeof h != "number" || h === 0 || zn.has(c) ? c === "float" ? o.cssFloat = h : o[c] = ("" + h).trim() : o[c] = h + "px" } function Ka(o, c, h) { if (c != null && typeof c != "object") throw Error(r(62)); if (o = o.style, h != null) { for (var m in h) !h.hasOwnProperty(m) || c != null && c.hasOwnProperty(m) || (m.indexOf("--") === 0 ? o.setProperty(m, "") : m === "float" ? o.cssFloat = "" : o[m] = ""); for (var x in c) m = c[x], c.hasOwnProperty(x) && h[x] !== m && ei(o, x, m) } else for (var w in c) c.hasOwnProperty(w) && ei(o, w, c[w]) } function el(o) { if (o.indexOf("-") === -1) return !1; switch (o) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Gy = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]]), zu = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i; function Iu(o) { return zu.test("" + o) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : o } var Fu = null; function Bu(o) { return o = o.target || o.srcElement || window, o.correspondingUseElement && (o = o.correspondingUseElement), o.nodeType === 3 ? o.parentNode : o } var la = null, pc = null; function I2(o) { var c = zt(o); if (c && (o = c.stateNode)) { var h = o[We] || null; e: switch (o = c.stateNode, c.type) { case "input": if (Ke(o, h.value, h.defaultValue, h.defaultValue, h.checked, h.defaultChecked, h.type, h.name), c = h.name, h.type === "radio" && c != null) { for (h = o; h.parentNode;)h = h.parentNode; for (h = h.querySelectorAll('input[name="' + Re("" + c) + '"][type="radio"]'), c = 0; c < h.length; c++) { var m = h[c]; if (m !== o && m.form === o.form) { var x = m[We] || null; if (!x) throw Error(r(90)); Ke(m, x.value, x.defaultValue, x.defaultValue, x.checked, x.defaultChecked, x.type, x.name) } } for (c = 0; c < h.length; c++)m = h[c], m.form === o.form && X(m) } break e; case "textarea": sn(o, h.value, h.defaultValue); break e; case "select": c = h.value, c != null && Lt(o, !!h.multiple, c, !1) } } } var Xy = !1; function F2(o, c, h) { if (Xy) return o(c, h); Xy = !0; try { var m = o(c); return m } finally { if (Xy = !1, (la !== null || pc !== null) && (hp(), la && (c = la, o = pc, pc = la = null, I2(c), o))) for (c = 0; c < o.length; c++)I2(o[c]) } } function $u(o, c) { var h = o.stateNode; if (h === null) return null; var m = h[We] || null; if (m === null) return null; h = m[c]; e: switch (c) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (m = !m.disabled) || (o = o.type, m = !(o === "button" || o === "input" || o === "select" || o === "textarea")), o = !m; break e; default: o = !1 }if (o) return null; if (h && typeof h != "function") throw Error(r(231, c, typeof h)); return h } var ca = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Qy = !1; if (ca) try { var Uu = {}; Object.defineProperty(Uu, "passive", { get: function () { Qy = !0 } }), window.addEventListener("test", Uu, Uu), window.removeEventListener("test", Uu, Uu) } catch { Qy = !1 } var Wa = null, Jy = null, kh = null; function B2() { if (kh) return kh; var o, c = Jy, h = c.length, m, x = "value" in Wa ? Wa.value : Wa.textContent, w = x.length; for (o = 0; o < h && c[o] === x[o]; o++); var D = h - o; for (m = 1; m <= D && c[h - m] === x[w - m]; m++); return kh = x.slice(o, 1 < m ? 1 - m : void 0) } function Oh(o) { var c = o.keyCode; return "charCode" in o ? (o = o.charCode, o === 0 && c === 13 && (o = 13)) : o = c, o === 10 && (o = 13), 32 <= o || o === 13 ? o : 0 } function Mh() { return !0 } function $2() { return !1 } function ci(o) { function c(h, m, x, w, D) { this._reactName = h, this._targetInst = x, this.type = m, this.nativeEvent = w, this.target = D, this.currentTarget = null; for (var R in o) o.hasOwnProperty(R) && (h = o[R], this[R] = h ? h(w) : w[R]); return this.isDefaultPrevented = (w.defaultPrevented != null ? w.defaultPrevented : w.returnValue === !1) ? Mh : $2, this.isPropagationStopped = $2, this } return p(c.prototype, { preventDefault: function () { this.defaultPrevented = !0; var h = this.nativeEvent; h && (h.preventDefault ? h.preventDefault() : typeof h.returnValue != "unknown" && (h.returnValue = !1), this.isDefaultPrevented = Mh) }, stopPropagation: function () { var h = this.nativeEvent; h && (h.stopPropagation ? h.stopPropagation() : typeof h.cancelBubble != "unknown" && (h.cancelBubble = !0), this.isPropagationStopped = Mh) }, persist: function () { }, isPersistent: Mh }), c } var tl = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (o) { return o.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Dh = ci(tl), Vu = p({}, tl, { view: 0, detail: 0 }), Y6 = ci(Vu), Zy, e0, Hu, Rh = p({}, Vu, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: n0, button: 0, buttons: 0, relatedTarget: function (o) { return o.relatedTarget === void 0 ? o.fromElement === o.srcElement ? o.toElement : o.fromElement : o.relatedTarget }, movementX: function (o) { return "movementX" in o ? o.movementX : (o !== Hu && (Hu && o.type === "mousemove" ? (Zy = o.screenX - Hu.screenX, e0 = o.screenY - Hu.screenY) : e0 = Zy = 0, Hu = o), Zy) }, movementY: function (o) { return "movementY" in o ? o.movementY : e0 } }), U2 = ci(Rh), G6 = p({}, Rh, { dataTransfer: 0 }), X6 = ci(G6), Q6 = p({}, Vu, { relatedTarget: 0 }), t0 = ci(Q6), J6 = p({}, tl, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Z6 = ci(J6), eL = p({}, tl, { clipboardData: function (o) { return "clipboardData" in o ? o.clipboardData : window.clipboardData } }), tL = ci(eL), nL = p({}, tl, { data: 0 }), V2 = ci(nL), rL = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, iL = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, sL = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function aL(o) { var c = this.nativeEvent; return c.getModifierState ? c.getModifierState(o) : (o = sL[o]) ? !!c[o] : !1 } function n0() { return aL } var oL = p({}, Vu, { key: function (o) { if (o.key) { var c = rL[o.key] || o.key; if (c !== "Unidentified") return c } return o.type === "keypress" ? (o = Oh(o), o === 13 ? "Enter" : String.fromCharCode(o)) : o.type === "keydown" || o.type === "keyup" ? iL[o.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: n0, charCode: function (o) { return o.type === "keypress" ? Oh(o) : 0 }, keyCode: function (o) { return o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0 }, which: function (o) { return o.type === "keypress" ? Oh(o) : o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0 } }), lL = ci(oL), cL = p({}, Rh, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), H2 = ci(cL), uL = p({}, Vu, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: n0 }), dL = ci(uL), fL = p({}, tl, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), hL = ci(fL), pL = p({}, Rh, { deltaX: function (o) { return "deltaX" in o ? o.deltaX : "wheelDeltaX" in o ? -o.wheelDeltaX : 0 }, deltaY: function (o) { return "deltaY" in o ? o.deltaY : "wheelDeltaY" in o ? -o.wheelDeltaY : "wheelDelta" in o ? -o.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), mL = ci(pL), gL = p({}, tl, { newState: 0, oldState: 0 }), yL = ci(gL), vL = [9, 13, 27, 32], r0 = ca && "CompositionEvent" in window, qu = null; ca && "documentMode" in document && (qu = document.documentMode); var xL = ca && "TextEvent" in window && !qu, q2 = ca && (!r0 || qu && 8 < qu && 11 >= qu), K2 = " ", W2 = !1; function Y2(o, c) { switch (o) { case "keyup": return vL.indexOf(c.keyCode) !== -1; case "keydown": return c.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function G2(o) { return o = o.detail, typeof o == "object" && "data" in o ? o.data : null } var mc = !1; function bL(o, c) { switch (o) { case "compositionend": return G2(c); case "keypress": return c.which !== 32 ? null : (W2 = !0, K2); case "textInput": return o = c.data, o === K2 && W2 ? null : o; default: return null } } function wL(o, c) { if (mc) return o === "compositionend" || !r0 && Y2(o, c) ? (o = B2(), kh = Jy = Wa = null, mc = !1, o) : null; switch (o) { case "paste": return null; case "keypress": if (!(c.ctrlKey || c.altKey || c.metaKey) || c.ctrlKey && c.altKey) { if (c.char && 1 < c.char.length) return c.char; if (c.which) return String.fromCharCode(c.which) } return null; case "compositionend": return q2 && c.locale !== "ko" ? null : c.data; default: return null } } var SL = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function X2(o) { var c = o && o.nodeName && o.nodeName.toLowerCase(); return c === "input" ? !!SL[o.type] : c === "textarea" } function Q2(o, c, h, m) { la ? pc ? pc.push(m) : pc = [m] : la = m, c = xp(c, "onChange"), 0 < c.length && (h = new Dh("onChange", "change", null, h, m), o.push({ event: h, listeners: c })) } var Ku = null, Wu = null; function CL(o) { MN(o, 0) } function _h(o) { var c = hn(o); if (X(c)) return o } function J2(o, c) { if (o === "change") return c } var Z2 = !1; if (ca) { var i0; if (ca) { var s0 = "oninput" in document; if (!s0) { var eC = document.createElement("div"); eC.setAttribute("oninput", "return;"), s0 = typeof eC.oninput == "function" } i0 = s0 } else i0 = !1; Z2 = i0 && (!document.documentMode || 9 < document.documentMode) } function tC() { Ku && (Ku.detachEvent("onpropertychange", nC), Wu = Ku = null) } function nC(o) { if (o.propertyName === "value" && _h(Wu)) { var c = []; Q2(c, Wu, o, Bu(o)), F2(CL, c) } } function TL(o, c, h) { o === "focusin" ? (tC(), Ku = c, Wu = h, Ku.attachEvent("onpropertychange", nC)) : o === "focusout" && tC() } function NL(o) { if (o === "selectionchange" || o === "keyup" || o === "keydown") return _h(Wu) } function jL(o, c) { if (o === "click") return _h(c) } function EL(o, c) { if (o === "input" || o === "change") return _h(c) } function AL(o, c) { return o === c && (o !== 0 || 1 / o === 1 / c) || o !== o && c !== c } var Ei = typeof Object.is == "function" ? Object.is : AL; function Yu(o, c) { if (Ei(o, c)) return !0; if (typeof o != "object" || o === null || typeof c != "object" || c === null) return !1; var h = Object.keys(o), m = Object.keys(c); if (h.length !== m.length) return !1; for (m = 0; m < h.length; m++) { var x = h[m]; if (!Y.call(c, x) || !Ei(o[x], c[x])) return !1 } return !0 } function rC(o) { for (; o && o.firstChild;)o = o.firstChild; return o } function iC(o, c) { var h = rC(o); o = 0; for (var m; h;) { if (h.nodeType === 3) { if (m = o + h.textContent.length, o <= c && m >= c) return { node: h, offset: c - o }; o = m } e: { for (; h;) { if (h.nextSibling) { h = h.nextSibling; break e } h = h.parentNode } h = void 0 } h = rC(h) } } function sC(o, c) { return o && c ? o === c ? !0 : o && o.nodeType === 3 ? !1 : c && c.nodeType === 3 ? sC(o, c.parentNode) : "contains" in o ? o.contains(c) : o.compareDocumentPosition ? !!(o.compareDocumentPosition(c) & 16) : !1 : !1 } function aC(o) { o = o != null && o.ownerDocument != null && o.ownerDocument.defaultView != null ? o.ownerDocument.defaultView : window; for (var c = Me(o.document); c instanceof o.HTMLIFrameElement;) { try { var h = typeof c.contentWindow.location.href == "string" } catch { h = !1 } if (h) o = c.contentWindow; else break; c = Me(o.document) } return c } function a0(o) { var c = o && o.nodeName && o.nodeName.toLowerCase(); return c && (c === "input" && (o.type === "text" || o.type === "search" || o.type === "tel" || o.type === "url" || o.type === "password") || c === "textarea" || o.contentEditable === "true") } var kL = ca && "documentMode" in document && 11 >= document.documentMode, gc = null, o0 = null, Gu = null, l0 = !1; function oC(o, c, h) { var m = h.window === h ? h.document : h.nodeType === 9 ? h : h.ownerDocument; l0 || gc == null || gc !== Me(m) || (m = gc, "selectionStart" in m && a0(m) ? m = { start: m.selectionStart, end: m.selectionEnd } : (m = (m.ownerDocument && m.ownerDocument.defaultView || window).getSelection(), m = { anchorNode: m.anchorNode, anchorOffset: m.anchorOffset, focusNode: m.focusNode, focusOffset: m.focusOffset }), Gu && Yu(Gu, m) || (Gu = m, m = xp(o0, "onSelect"), 0 < m.length && (c = new Dh("onSelect", "select", null, c, h), o.push({ event: c, listeners: m }), c.target = gc))) } function nl(o, c) { var h = {}; return h[o.toLowerCase()] = c.toLowerCase(), h["Webkit" + o] = "webkit" + c, h["Moz" + o] = "moz" + c, h } var yc = { animationend: nl("Animation", "AnimationEnd"), animationiteration: nl("Animation", "AnimationIteration"), animationstart: nl("Animation", "AnimationStart"), transitionrun: nl("Transition", "TransitionRun"), transitionstart: nl("Transition", "TransitionStart"), transitioncancel: nl("Transition", "TransitionCancel"), transitionend: nl("Transition", "TransitionEnd") }, c0 = {}, lC = {}; ca && (lC = document.createElement("div").style, "AnimationEvent" in window || (delete yc.animationend.animation, delete yc.animationiteration.animation, delete yc.animationstart.animation), "TransitionEvent" in window || delete yc.transitionend.transition); function rl(o) { if (c0[o]) return c0[o]; if (!yc[o]) return o; var c = yc[o], h; for (h in c) if (c.hasOwnProperty(h) && h in lC) return c0[o] = c[h]; return o } var cC = rl("animationend"), uC = rl("animationiteration"), dC = rl("animationstart"), OL = rl("transitionrun"), ML = rl("transitionstart"), DL = rl("transitioncancel"), fC = rl("transitionend"), hC = new Map, u0 = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); u0.push("scrollEnd"); function ps(o, c) { hC.set(o, c), pr(c, [o]) } var pC = new WeakMap; function Ki(o, c) { if (typeof o == "object" && o !== null) { var h = pC.get(o); return h !== void 0 ? h : (c = { value: o, source: c, stack: L(c) }, pC.set(o, c), c) } return { value: o, source: c, stack: L(c) } } var Wi = [], vc = 0, d0 = 0; function Lh() { for (var o = vc, c = d0 = vc = 0; c < o;) { var h = Wi[c]; Wi[c++] = null; var m = Wi[c]; Wi[c++] = null; var x = Wi[c]; Wi[c++] = null; var w = Wi[c]; if (Wi[c++] = null, m !== null && x !== null) { var D = m.pending; D === null ? x.next = x : (x.next = D.next, D.next = x), m.pending = x } w !== 0 && mC(h, x, w) } } function Ph(o, c, h, m) { Wi[vc++] = o, Wi[vc++] = c, Wi[vc++] = h, Wi[vc++] = m, d0 |= m, o.lanes |= m, o = o.alternate, o !== null && (o.lanes |= m) } function f0(o, c, h, m) { return Ph(o, c, h, m), zh(o) } function xc(o, c) { return Ph(o, null, null, c), zh(o) } function mC(o, c, h) { o.lanes |= h; var m = o.alternate; m !== null && (m.lanes |= h); for (var x = !1, w = o.return; w !== null;)w.childLanes |= h, m = w.alternate, m !== null && (m.childLanes |= h), w.tag === 22 && (o = w.stateNode, o === null || o._visibility & 1 || (x = !0)), o = w, w = w.return; return o.tag === 3 ? (w = o.stateNode, x && c !== null && (x = 31 - Tt(h), o = w.hiddenUpdates, m = o[x], m === null ? o[x] = [c] : m.push(c), c.lane = h | 536870912), w) : null } function zh(o) { if (50 < bd) throw bd = 0, vv = null, Error(r(185)); for (var c = o.return; c !== null;)o = c, c = o.return; return o.tag === 3 ? o.stateNode : null } var bc = {}; function RL(o, c, h, m) { this.tag = o, this.key = h, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = c, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = m, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Ai(o, c, h, m) { return new RL(o, c, h, m) } function h0(o) { return o = o.prototype, !(!o || !o.isReactComponent) } function ua(o, c) { var h = o.alternate; return h === null ? (h = Ai(o.tag, c, o.key, o.mode), h.elementType = o.elementType, h.type = o.type, h.stateNode = o.stateNode, h.alternate = o, o.alternate = h) : (h.pendingProps = c, h.type = o.type, h.flags = 0, h.subtreeFlags = 0, h.deletions = null), h.flags = o.flags & 65011712, h.childLanes = o.childLanes, h.lanes = o.lanes, h.child = o.child, h.memoizedProps = o.memoizedProps, h.memoizedState = o.memoizedState, h.updateQueue = o.updateQueue, c = o.dependencies, h.dependencies = c === null ? null : { lanes: c.lanes, firstContext: c.firstContext }, h.sibling = o.sibling, h.index = o.index, h.ref = o.ref, h.refCleanup = o.refCleanup, h } function gC(o, c) { o.flags &= 65011714; var h = o.alternate; return h === null ? (o.childLanes = 0, o.lanes = c, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = h.childLanes, o.lanes = h.lanes, o.child = h.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = h.memoizedProps, o.memoizedState = h.memoizedState, o.updateQueue = h.updateQueue, o.type = h.type, c = h.dependencies, o.dependencies = c === null ? null : { lanes: c.lanes, firstContext: c.firstContext }), o } function Ih(o, c, h, m, x, w) { var D = 0; if (m = o, typeof o == "function") h0(o) && (D = 1); else if (typeof o == "string") D = LP(o, h, Ee.current) ? 26 : o === "html" || o === "head" || o === "body" ? 27 : 5; else e: switch (o) { case q: return o = Ai(31, h, c, x), o.elementType = q, o.lanes = w, o; case b: return il(h.children, x, w, c); case S: D = 8, x |= 24; break; case C: return o = Ai(12, h, c, x | 2), o.elementType = C, o.lanes = w, o; case E: return o = Ai(13, h, c, x), o.elementType = E, o.lanes = w, o; case k: return o = Ai(19, h, c, x), o.elementType = k, o.lanes = w, o; default: if (typeof o == "object" && o !== null) switch (o.$$typeof) { case T: case M: D = 10; break e; case A: D = 9; break e; case O: D = 11; break e; case z: D = 14; break e; case V: D = 16, m = null; break e }D = 29, h = Error(r(130, o === null ? "null" : typeof o, "")), m = null }return c = Ai(D, h, c, x), c.elementType = o, c.type = m, c.lanes = w, c } function il(o, c, h, m) { return o = Ai(7, o, m, c), o.lanes = h, o } function p0(o, c, h) { return o = Ai(6, o, null, c), o.lanes = h, o } function m0(o, c, h) { return c = Ai(4, o.children !== null ? o.children : [], o.key, c), c.lanes = h, c.stateNode = { containerInfo: o.containerInfo, pendingChildren: null, implementation: o.implementation }, c } var wc = [], Sc = 0, Fh = null, Bh = 0, Yi = [], Gi = 0, sl = null, da = 1, fa = ""; function al(o, c) { wc[Sc++] = Bh, wc[Sc++] = Fh, Fh = o, Bh = c } function yC(o, c, h) { Yi[Gi++] = da, Yi[Gi++] = fa, Yi[Gi++] = sl, sl = o; var m = da; o = fa; var x = 32 - Tt(m) - 1; m &= ~(1 << x), h += 1; var w = 32 - Tt(c) + x; if (30 < w) { var D = x - x % 5; w = (m & (1 << D) - 1).toString(32), m >>= D, x -= D, da = 1 << 32 - Tt(c) + x | h << x | m, fa = w + o } else da = 1 << w | h << x | m, fa = o } function g0(o) { o.return !== null && (al(o, 1), yC(o, 1, 0)) } function y0(o) { for (; o === Fh;)Fh = wc[--Sc], wc[Sc] = null, Bh = wc[--Sc], wc[Sc] = null; for (; o === sl;)sl = Yi[--Gi], Yi[Gi] = null, fa = Yi[--Gi], Yi[Gi] = null, da = Yi[--Gi], Yi[Gi] = null } var ti = null, Hn = null, dn = !1, ol = null, Ps = !1, v0 = Error(r(519)); function ll(o) { var c = Error(r(418, "")); throw Ju(Ki(c, o)), v0 } function vC(o) { var c = o.stateNode, h = o.type, m = o.memoizedProps; switch (c[Le] = o, c[We] = m, h) { case "dialog": Qt("cancel", c), Qt("close", c); break; case "iframe": case "object": case "embed": Qt("load", c); break; case "video": case "audio": for (h = 0; h < Sd.length; h++)Qt(Sd[h], c); break; case "source": Qt("error", c); break; case "img": case "image": case "link": Qt("error", c), Qt("load", c); break; case "details": Qt("toggle", c); break; case "input": Qt("invalid", c), Ge(c, m.value, m.defaultValue, m.checked, m.defaultChecked, m.type, m.name, !0), J(c); break; case "select": Qt("invalid", c); break; case "textarea": Qt("invalid", c), an(c, m.value, m.defaultValue, m.children), J(c) }h = m.children, typeof h != "string" && typeof h != "number" && typeof h != "bigint" || c.textContent === "" + h || m.suppressHydrationWarning === !0 || LN(c.textContent, h) ? (m.popover != null && (Qt("beforetoggle", c), Qt("toggle", c)), m.onScroll != null && Qt("scroll", c), m.onScrollEnd != null && Qt("scrollend", c), m.onClick != null && (c.onclick = bp), c = !0) : c = !1, c || ll(o) } function xC(o) { for (ti = o.return; ti;)switch (ti.tag) { case 5: case 13: Ps = !1; return; case 27: case 3: Ps = !0; return; default: ti = ti.return } } function Xu(o) { if (o !== ti) return !1; if (!dn) return xC(o), dn = !0, !1; var c = o.tag, h; if ((h = c !== 3 && c !== 27) && ((h = c === 5) && (h = o.type, h = !(h !== "form" && h !== "button") || _v(o.type, o.memoizedProps)), h = !h), h && Hn && ll(o), xC(o), c === 13) { if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(r(317)); e: { for (o = o.nextSibling, c = 0; o;) { if (o.nodeType === 8) if (h = o.data, h === "/$") { if (c === 0) { Hn = gs(o.nextSibling); break e } c-- } else h !== "$" && h !== "$!" && h !== "$?" || c++; o = o.nextSibling } Hn = null } } else c === 27 ? (c = Hn, co(o.type) ? (o = Iv, Iv = null, Hn = o) : Hn = c) : Hn = ti ? gs(o.stateNode.nextSibling) : null; return !0 } function Qu() { Hn = ti = null, dn = !1 } function bC() { var o = ol; return o !== null && (fi === null ? fi = o : fi.push.apply(fi, o), ol = null), o } function Ju(o) { ol === null ? ol = [o] : ol.push(o) } var x0 = ie(null), cl = null, ha = null; function Ya(o, c, h) { pe(x0, c._currentValue), c._currentValue = h } function pa(o) { o._currentValue = x0.current, oe(x0) } function b0(o, c, h) { for (; o !== null;) { var m = o.alternate; if ((o.childLanes & c) !== c ? (o.childLanes |= c, m !== null && (m.childLanes |= c)) : m !== null && (m.childLanes & c) !== c && (m.childLanes |= c), o === h) break; o = o.return } } function w0(o, c, h, m) { var x = o.child; for (x !== null && (x.return = o); x !== null;) { var w = x.dependencies; if (w !== null) { var D = x.child; w = w.firstContext; e: for (; w !== null;) { var R = w; w = x; for (var G = 0; G < c.length; G++)if (R.context === c[G]) { w.lanes |= h, R = w.alternate, R !== null && (R.lanes |= h), b0(w.return, h, o), m || (D = null); break e } w = R.next } } else if (x.tag === 18) { if (D = x.return, D === null) throw Error(r(341)); D.lanes |= h, w = D.alternate, w !== null && (w.lanes |= h), b0(D, h, o), D = null } else D = x.child; if (D !== null) D.return = x; else for (D = x; D !== null;) { if (D === o) { D = null; break } if (x = D.sibling, x !== null) { x.return = D.return, D = x; break } D = D.return } x = D } } function Zu(o, c, h, m) { o = null; for (var x = c, w = !1; x !== null;) { if (!w) { if ((x.flags & 524288) !== 0) w = !0; else if ((x.flags & 262144) !== 0) break } if (x.tag === 10) { var D = x.alternate; if (D === null) throw Error(r(387)); if (D = D.memoizedProps, D !== null) { var R = x.type; Ei(x.pendingProps.value, D.value) || (o !== null ? o.push(R) : o = [R]) } } else if (x === et.current) { if (D = x.alternate, D === null) throw Error(r(387)); D.memoizedState.memoizedState !== x.memoizedState.memoizedState && (o !== null ? o.push(Ad) : o = [Ad]) } x = x.return } o !== null && w0(c, o, h, m), c.flags |= 262144 } function $h(o) { for (o = o.firstContext; o !== null;) { if (!Ei(o.context._currentValue, o.memoizedValue)) return !0; o = o.next } return !1 } function ul(o) { cl = o, ha = null, o = o.dependencies, o !== null && (o.firstContext = null) } function Vr(o) { return wC(cl, o) } function Uh(o, c) { return cl === null && ul(o), wC(o, c) } function wC(o, c) { var h = c._currentValue; if (c = { context: c, memoizedValue: h, next: null }, ha === null) { if (o === null) throw Error(r(308)); ha = c, o.dependencies = { lanes: 0, firstContext: c }, o.flags |= 524288 } else ha = ha.next = c; return h } var _L = typeof AbortController < "u" ? AbortController : function () { var o = [], c = this.signal = { aborted: !1, addEventListener: function (h, m) { o.push(m) } }; this.abort = function () { c.aborted = !0, o.forEach(function (h) { return h() }) } }, LL = t.unstable_scheduleCallback, PL = t.unstable_NormalPriority, mr = { $$typeof: M, Consumer: null, Provider: null, _currentValue: null, _currentValue2: null, _threadCount: 0 }; function S0() { return { controller: new _L, data: new Map, refCount: 0 } } function ed(o) { o.refCount--, o.refCount === 0 && LL(PL, function () { o.controller.abort() }) } var td = null, C0 = 0, Cc = 0, Tc = null; function zL(o, c) { if (td === null) { var h = td = []; C0 = 0, Cc = Nv(), Tc = { status: "pending", value: void 0, then: function (m) { h.push(m) } } } return C0++, c.then(SC, SC), c } function SC() { if (--C0 === 0 && td !== null) { Tc !== null && (Tc.status = "fulfilled"); var o = td; td = null, Cc = 0, Tc = null; for (var c = 0; c < o.length; c++)(0, o[c])() } } function IL(o, c) { var h = [], m = { status: "pending", value: null, reason: null, then: function (x) { h.push(x) } }; return o.then(function () { m.status = "fulfilled", m.value = c; for (var x = 0; x < h.length; x++)(0, h[x])(c) }, function (x) { for (m.status = "rejected", m.reason = x, x = 0; x < h.length; x++)(0, h[x])(void 0) }), m } var CC = K.S; K.S = function (o, c) { typeof c == "object" && c !== null && typeof c.then == "function" && zL(o, c), CC !== null && CC(o, c) }; var dl = ie(null); function T0() { var o = dl.current; return o !== null ? o : Nn.pooledCache } function Vh(o, c) { c === null ? pe(dl, dl.current) : pe(dl, c.pool) } function TC() { var o = T0(); return o === null ? null : { parent: mr._currentValue, pool: o } } var nd = Error(r(460)), NC = Error(r(474)), Hh = Error(r(542)), N0 = { then: function () { } }; function jC(o) { return o = o.status, o === "fulfilled" || o === "rejected" } function qh() { } function EC(o, c, h) { switch (h = o[h], h === void 0 ? o.push(c) : h !== c && (c.then(qh, qh), c = h), c.status) { case "fulfilled": return c.value; case "rejected": throw o = c.reason, kC(o), o; default: if (typeof c.status == "string") c.then(qh, qh); else { if (o = Nn, o !== null && 100 < o.shellSuspendCounter) throw Error(r(482)); o = c, o.status = "pending", o.then(function (m) { if (c.status === "pending") { var x = c; x.status = "fulfilled", x.value = m } }, function (m) { if (c.status === "pending") { var x = c; x.status = "rejected", x.reason = m } }) } switch (c.status) { case "fulfilled": return c.value; case "rejected": throw o = c.reason, kC(o), o }throw rd = c, nd } } var rd = null; function AC() { if (rd === null) throw Error(r(459)); var o = rd; return rd = null, o } function kC(o) { if (o === nd || o === Hh) throw Error(r(483)) } var Ga = !1; function j0(o) { o.updateQueue = { baseState: o.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, lanes: 0, hiddenCallbacks: null }, callbacks: null } } function E0(o, c) { o = o.updateQueue, c.updateQueue === o && (c.updateQueue = { baseState: o.baseState, firstBaseUpdate: o.firstBaseUpdate, lastBaseUpdate: o.lastBaseUpdate, shared: o.shared, callbacks: null }) } function Xa(o) { return { lane: o, tag: 0, payload: null, callback: null, next: null } } function Qa(o, c, h) { var m = o.updateQueue; if (m === null) return null; if (m = m.shared, (mn & 2) !== 0) { var x = m.pending; return x === null ? c.next = c : (c.next = x.next, x.next = c), m.pending = c, c = zh(o), mC(o, null, h), c } return Ph(o, m, c, h), zh(o) } function id(o, c, h) { if (c = c.updateQueue, c !== null && (c = c.shared, (h & 4194048) !== 0)) { var m = c.lanes; m &= o.pendingLanes, h |= m, c.lanes = h, Nt(o, h) } } function A0(o, c) { var h = o.updateQueue, m = o.alternate; if (m !== null && (m = m.updateQueue, h === m)) { var x = null, w = null; if (h = h.firstBaseUpdate, h !== null) { do { var D = { lane: h.lane, tag: h.tag, payload: h.payload, callback: null, next: null }; w === null ? x = w = D : w = w.next = D, h = h.next } while (h !== null); w === null ? x = w = c : w = w.next = c } else x = w = c; h = { baseState: m.baseState, firstBaseUpdate: x, lastBaseUpdate: w, shared: m.shared, callbacks: m.callbacks }, o.updateQueue = h; return } o = h.lastBaseUpdate, o === null ? h.firstBaseUpdate = c : o.next = c, h.lastBaseUpdate = c } var k0 = !1; function sd() { if (k0) { var o = Tc; if (o !== null) throw o } } function ad(o, c, h, m) { k0 = !1; var x = o.updateQueue; Ga = !1; var w = x.firstBaseUpdate, D = x.lastBaseUpdate, R = x.shared.pending; if (R !== null) { x.shared.pending = null; var G = R, ve = G.next; G.next = null, D === null ? w = ve : D.next = ve, D = G; var _e = o.alternate; _e !== null && (_e = _e.updateQueue, R = _e.lastBaseUpdate, R !== D && (R === null ? _e.firstBaseUpdate = ve : R.next = ve, _e.lastBaseUpdate = G)) } if (w !== null) { var Fe = x.baseState; D = 0, _e = ve = G = null, R = w; do { var Ce = R.lane & -536870913, Ne = Ce !== R.lane; if (Ne ? (tn & Ce) === Ce : (m & Ce) === Ce) { Ce !== 0 && Ce === Cc && (k0 = !0), _e !== null && (_e = _e.next = { lane: 0, tag: R.tag, payload: R.payload, callback: null, next: null }); e: { var Dt = o, At = R; Ce = c; var bn = h; switch (At.tag) { case 1: if (Dt = At.payload, typeof Dt == "function") { Fe = Dt.call(bn, Fe, Ce); break e } Fe = Dt; break e; case 3: Dt.flags = Dt.flags & -65537 | 128; case 0: if (Dt = At.payload, Ce = typeof Dt == "function" ? Dt.call(bn, Fe, Ce) : Dt, Ce == null) break e; Fe = p({}, Fe, Ce); break e; case 2: Ga = !0 } } Ce = R.callback, Ce !== null && (o.flags |= 64, Ne && (o.flags |= 8192), Ne = x.callbacks, Ne === null ? x.callbacks = [Ce] : Ne.push(Ce)) } else Ne = { lane: Ce, tag: R.tag, payload: R.payload, callback: R.callback, next: null }, _e === null ? (ve = _e = Ne, G = Fe) : _e = _e.next = Ne, D |= Ce; if (R = R.next, R === null) { if (R = x.shared.pending, R === null) break; Ne = R, R = Ne.next, Ne.next = null, x.lastBaseUpdate = Ne, x.shared.pending = null } } while (!0); _e === null && (G = Fe), x.baseState = G, x.firstBaseUpdate = ve, x.lastBaseUpdate = _e, w === null && (x.shared.lanes = 0), so |= D, o.lanes = D, o.memoizedState = Fe } } function OC(o, c) { if (typeof o != "function") throw Error(r(191, o)); o.call(c) } function MC(o, c) { var h = o.callbacks; if (h !== null) for (o.callbacks = null, o = 0; o < h.length; o++)OC(h[o], c) } var Nc = ie(null), Kh = ie(0); function DC(o, c) { o = wa, pe(Kh, o), pe(Nc, c), wa = o | c.baseLanes } function O0() { pe(Kh, wa), pe(Nc, Nc.current) } function M0() { wa = Kh.current, oe(Nc), oe(Kh) } var Ja = 0, qt = null, vn = null, sr = null, Wh = !1, jc = !1, fl = !1, Yh = 0, od = 0, Ec = null, FL = 0; function Zn() { throw Error(r(321)) } function D0(o, c) { if (c === null) return !1; for (var h = 0; h < c.length && h < o.length; h++)if (!Ei(o[h], c[h])) return !1; return !0 } function R0(o, c, h, m, x, w) { return Ja = w, qt = c, c.memoizedState = null, c.updateQueue = null, c.lanes = 0, K.H = o === null || o.memoizedState === null ? mT : gT, fl = !1, w = h(m, x), fl = !1, jc && (w = _C(c, h, m, x)), RC(o), w } function RC(o) { K.H = ep; var c = vn !== null && vn.next !== null; if (Ja = 0, sr = vn = qt = null, Wh = !1, od = 0, Ec = null, c) throw Error(r(300)); o === null || wr || (o = o.dependencies, o !== null && $h(o) && (wr = !0)) } function _C(o, c, h, m) { qt = o; var x = 0; do { if (jc && (Ec = null), od = 0, jc = !1, 25 <= x) throw Error(r(301)); if (x += 1, sr = vn = null, o.updateQueue != null) { var w = o.updateQueue; w.lastEffect = null, w.events = null, w.stores = null, w.memoCache != null && (w.memoCache.index = 0) } K.H = KL, w = c(h, m) } while (jc); return w } function BL() { var o = K.H, c = o.useState()[0]; return c = typeof c.then == "function" ? ld(c) : c, o = o.useState()[0], (vn !== null ? vn.memoizedState : null) !== o && (qt.flags |= 1024), c } function _0() { var o = Yh !== 0; return Yh = 0, o } function L0(o, c, h) { c.updateQueue = o.updateQueue, c.flags &= -2053, o.lanes &= ~h } function P0(o) { if (Wh) { for (o = o.memoizedState; o !== null;) { var c = o.queue; c !== null && (c.pending = null), o = o.next } Wh = !1 } Ja = 0, sr = vn = qt = null, jc = !1, od = Yh = 0, Ec = null } function ui() { var o = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return sr === null ? qt.memoizedState = sr = o : sr = sr.next = o, sr } function ar() { if (vn === null) { var o = qt.alternate; o = o !== null ? o.memoizedState : null } else o = vn.next; var c = sr === null ? qt.memoizedState : sr.next; if (c !== null) sr = c, vn = o; else { if (o === null) throw qt.alternate === null ? Error(r(467)) : Error(r(310)); vn = o, o = { memoizedState: vn.memoizedState, baseState: vn.baseState, baseQueue: vn.baseQueue, queue: vn.queue, next: null }, sr === null ? qt.memoizedState = sr = o : sr = sr.next = o } return sr } function z0() { return { lastEffect: null, events: null, stores: null, memoCache: null } } function ld(o) { var c = od; return od += 1, Ec === null && (Ec = []), o = EC(Ec, o, c), c = qt, (sr === null ? c.memoizedState : sr.next) === null && (c = c.alternate, K.H = c === null || c.memoizedState === null ? mT : gT), o } function Gh(o) { if (o !== null && typeof o == "object") { if (typeof o.then == "function") return ld(o); if (o.$$typeof === M) return Vr(o) } throw Error(r(438, String(o))) } function I0(o) { var c = null, h = qt.updateQueue; if (h !== null && (c = h.memoCache), c == null) { var m = qt.alternate; m !== null && (m = m.updateQueue, m !== null && (m = m.memoCache, m != null && (c = { data: m.data.map(function (x) { return x.slice() }), index: 0 }))) } if (c == null && (c = { data: [], index: 0 }), h === null && (h = z0(), qt.updateQueue = h), h.memoCache = c, h = c.data[c.index], h === void 0) for (h = c.data[c.index] = Array(o), m = 0; m < o; m++)h[m] = ue; return c.index++, h } function ma(o, c) { return typeof c == "function" ? c(o) : c } function Xh(o) { var c = ar(); return F0(c, vn, o) } function F0(o, c, h) { var m = o.queue; if (m === null) throw Error(r(311)); m.lastRenderedReducer = h; var x = o.baseQueue, w = m.pending; if (w !== null) { if (x !== null) { var D = x.next; x.next = w.next, w.next = D } c.baseQueue = x = w, m.pending = null } if (w = o.baseState, x === null) o.memoizedState = w; else { c = x.next; var R = D = null, G = null, ve = c, _e = !1; do { var Fe = ve.lane & -536870913; if (Fe !== ve.lane ? (tn & Fe) === Fe : (Ja & Fe) === Fe) { var Ce = ve.revertLane; if (Ce === 0) G !== null && (G = G.next = { lane: 0, revertLane: 0, action: ve.action, hasEagerState: ve.hasEagerState, eagerState: ve.eagerState, next: null }), Fe === Cc && (_e = !0); else if ((Ja & Ce) === Ce) { ve = ve.next, Ce === Cc && (_e = !0); continue } else Fe = { lane: 0, revertLane: ve.revertLane, action: ve.action, hasEagerState: ve.hasEagerState, eagerState: ve.eagerState, next: null }, G === null ? (R = G = Fe, D = w) : G = G.next = Fe, qt.lanes |= Ce, so |= Ce; Fe = ve.action, fl && h(w, Fe), w = ve.hasEagerState ? ve.eagerState : h(w, Fe) } else Ce = { lane: Fe, revertLane: ve.revertLane, action: ve.action, hasEagerState: ve.hasEagerState, eagerState: ve.eagerState, next: null }, G === null ? (R = G = Ce, D = w) : G = G.next = Ce, qt.lanes |= Fe, so |= Fe; ve = ve.next } while (ve !== null && ve !== c); if (G === null ? D = w : G.next = R, !Ei(w, o.memoizedState) && (wr = !0, _e && (h = Tc, h !== null))) throw h; o.memoizedState = w, o.baseState = D, o.baseQueue = G, m.lastRenderedState = w } return x === null && (m.lanes = 0), [o.memoizedState, m.dispatch] } function B0(o) { var c = ar(), h = c.queue; if (h === null) throw Error(r(311)); h.lastRenderedReducer = o; var m = h.dispatch, x = h.pending, w = c.memoizedState; if (x !== null) { h.pending = null; var D = x = x.next; do w = o(w, D.action), D = D.next; while (D !== x); Ei(w, c.memoizedState) || (wr = !0), c.memoizedState = w, c.baseQueue === null && (c.baseState = w), h.lastRenderedState = w } return [w, m] } function LC(o, c, h) { var m = qt, x = ar(), w = dn; if (w) { if (h === void 0) throw Error(r(407)); h = h() } else h = c(); var D = !Ei((vn || x).memoizedState, h); D && (x.memoizedState = h, wr = !0), x = x.queue; var R = IC.bind(null, m, x, o); if (cd(2048, 8, R, [o]), x.getSnapshot !== c || D || sr !== null && sr.memoizedState.tag & 1) { if (m.flags |= 2048, Ac(9, Qh(), zC.bind(null, m, x, h, c), null), Nn === null) throw Error(r(349)); w || (Ja & 124) !== 0 || PC(m, c, h) } return h } function PC(o, c, h) { o.flags |= 16384, o = { getSnapshot: c, value: h }, c = qt.updateQueue, c === null ? (c = z0(), qt.updateQueue = c, c.stores = [o]) : (h = c.stores, h === null ? c.stores = [o] : h.push(o)) } function zC(o, c, h, m) { c.value = h, c.getSnapshot = m, FC(c) && BC(o) } function IC(o, c, h) { return h(function () { FC(c) && BC(o) }) } function FC(o) { var c = o.getSnapshot; o = o.value; try { var h = c(); return !Ei(o, h) } catch { return !0 } } function BC(o) { var c = xc(o, 2); c !== null && Ri(c, o, 2) } function $0(o) { var c = ui(); if (typeof o == "function") { var h = o; if (o = h(), fl) { rt(!0); try { h() } finally { rt(!1) } } } return c.memoizedState = c.baseState = o, c.queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: ma, lastRenderedState: o }, c } function $C(o, c, h, m) { return o.baseState = h, F0(o, vn, typeof m == "function" ? m : ma) } function $L(o, c, h, m, x) { if (Zh(o)) throw Error(r(485)); if (o = c.action, o !== null) { var w = { payload: x, action: o, next: null, isTransition: !0, status: "pending", value: null, reason: null, listeners: [], then: function (D) { w.listeners.push(D) } }; K.T !== null ? h(!0) : w.isTransition = !1, m(w), h = c.pending, h === null ? (w.next = c.pending = w, UC(c, w)) : (w.next = h.next, c.pending = h.next = w) } } function UC(o, c) { var h = c.action, m = c.payload, x = o.state; if (c.isTransition) { var w = K.T, D = {}; K.T = D; try { var R = h(x, m), G = K.S; G !== null && G(D, R), VC(o, c, R) } catch (ve) { U0(o, c, ve) } finally { K.T = w } } else try { w = h(x, m), VC(o, c, w) } catch (ve) { U0(o, c, ve) } } function VC(o, c, h) { h !== null && typeof h == "object" && typeof h.then == "function" ? h.then(function (m) { HC(o, c, m) }, function (m) { return U0(o, c, m) }) : HC(o, c, h) } function HC(o, c, h) { c.status = "fulfilled", c.value = h, qC(c), o.state = h, c = o.pending, c !== null && (h = c.next, h === c ? o.pending = null : (h = h.next, c.next = h, UC(o, h))) } function U0(o, c, h) { var m = o.pending; if (o.pending = null, m !== null) { m = m.next; do c.status = "rejected", c.reason = h, qC(c), c = c.next; while (c !== m) } o.action = null } function qC(o) { o = o.listeners; for (var c = 0; c < o.length; c++)(0, o[c])() } function KC(o, c) { return c } function WC(o, c) { if (dn) { var h = Nn.formState; if (h !== null) { e: { var m = qt; if (dn) { if (Hn) { t: { for (var x = Hn, w = Ps; x.nodeType !== 8;) { if (!w) { x = null; break t } if (x = gs(x.nextSibling), x === null) { x = null; break t } } w = x.data, x = w === "F!" || w === "F" ? x : null } if (x) { Hn = gs(x.nextSibling), m = x.data === "F!"; break e } } ll(m) } m = !1 } m && (c = h[0]) } } return h = ui(), h.memoizedState = h.baseState = c, m = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: KC, lastRenderedState: c }, h.queue = m, h = fT.bind(null, qt, m), m.dispatch = h, m = $0(!1), w = W0.bind(null, qt, !1, m.queue), m = ui(), x = { state: c, dispatch: null, action: o, pending: null }, m.queue = x, h = $L.bind(null, qt, x, w, h), x.dispatch = h, m.memoizedState = o, [c, h, !1] } function YC(o) { var c = ar(); return GC(c, vn, o) } function GC(o, c, h) { if (c = F0(o, c, KC)[0], o = Xh(ma)[0], typeof c == "object" && c !== null && typeof c.then == "function") try { var m = ld(c) } catch (D) { throw D === nd ? Hh : D } else m = c; c = ar(); var x = c.queue, w = x.dispatch; return h !== c.memoizedState && (qt.flags |= 2048, Ac(9, Qh(), UL.bind(null, x, h), null)), [m, w, o] } function UL(o, c) { o.action = c } function XC(o) { var c = ar(), h = vn; if (h !== null) return GC(c, h, o); ar(), c = c.memoizedState, h = ar(); var m = h.queue.dispatch; return h.memoizedState = o, [c, m, !1] } function Ac(o, c, h, m) { return o = { tag: o, create: h, deps: m, inst: c, next: null }, c = qt.updateQueue, c === null && (c = z0(), qt.updateQueue = c), h = c.lastEffect, h === null ? c.lastEffect = o.next = o : (m = h.next, h.next = o, o.next = m, c.lastEffect = o), o } function Qh() { return { destroy: void 0, resource: void 0 } } function QC() { return ar().memoizedState } function Jh(o, c, h, m) { var x = ui(); m = m === void 0 ? null : m, qt.flags |= o, x.memoizedState = Ac(1 | c, Qh(), h, m) } function cd(o, c, h, m) { var x = ar(); m = m === void 0 ? null : m; var w = x.memoizedState.inst; vn !== null && m !== null && D0(m, vn.memoizedState.deps) ? x.memoizedState = Ac(c, w, h, m) : (qt.flags |= o, x.memoizedState = Ac(1 | c, w, h, m)) } function JC(o, c) { Jh(8390656, 8, o, c) } function ZC(o, c) { cd(2048, 8, o, c) } function eT(o, c) { return cd(4, 2, o, c) } function tT(o, c) { return cd(4, 4, o, c) } function nT(o, c) { if (typeof c == "function") { o = o(); var h = c(o); return function () { typeof h == "function" ? h() : c(null) } } if (c != null) return o = o(), c.current = o, function () { c.current = null } } function rT(o, c, h) { h = h != null ? h.concat([o]) : null, cd(4, 4, nT.bind(null, c, o), h) } function V0() { } function iT(o, c) { var h = ar(); c = c === void 0 ? null : c; var m = h.memoizedState; return c !== null && D0(c, m[1]) ? m[0] : (h.memoizedState = [o, c], o) } function sT(o, c) { var h = ar(); c = c === void 0 ? null : c; var m = h.memoizedState; if (c !== null && D0(c, m[1])) return m[0]; if (m = o(), fl) { rt(!0); try { o() } finally { rt(!1) } } return h.memoizedState = [m, c], m } function H0(o, c, h) { return h === void 0 || (Ja & 1073741824) !== 0 ? o.memoizedState = c : (o.memoizedState = h, o = lN(), qt.lanes |= o, so |= o, h) } function aT(o, c, h, m) { return Ei(h, c) ? h : Nc.current !== null ? (o = H0(o, h, m), Ei(o, c) || (wr = !0), o) : (Ja & 42) === 0 ? (wr = !0, o.memoizedState = h) : (o = lN(), qt.lanes |= o, so |= o, c) } function oT(o, c, h, m, x) { var w = te.p; te.p = w !== 0 && 8 > w ? w : 8; var D = K.T, R = {}; K.T = R, W0(o, !1, c, h); try { var G = x(), ve = K.S; if (ve !== null && ve(R, G), G !== null && typeof G == "object" && typeof G.then == "function") { var _e = IL(G, m); ud(o, c, _e, Di(o)) } else ud(o, c, m, Di(o)) } catch (Fe) { ud(o, c, { then: function () { }, status: "rejected", reason: Fe }, Di()) } finally { te.p = w, K.T = D } } function VL() { } function q0(o, c, h, m) { if (o.tag !== 5) throw Error(r(476)); var x = lT(o).queue; oT(o, x, c, ye, h === null ? VL : function () { return cT(o), h(m) }) } function lT(o) { var c = o.memoizedState; if (c !== null) return c; c = { memoizedState: ye, baseState: ye, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: ma, lastRenderedState: ye }, next: null }; var h = {}; return c.next = { memoizedState: h, baseState: h, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: ma, lastRenderedState: h }, next: null }, o.memoizedState = c, o = o.alternate, o !== null && (o.memoizedState = c), c } function cT(o) { var c = lT(o).next.queue; ud(o, c, {}, Di()) } function K0() { return Vr(Ad) } function uT() { return ar().memoizedState } function dT() { return ar().memoizedState } function HL(o) { for (var c = o.return; c !== null;) { switch (c.tag) { case 24: case 3: var h = Di(); o = Xa(h); var m = Qa(c, o, h); m !== null && (Ri(m, c, h), id(m, c, h)), c = { cache: S0() }, o.payload = c; return }c = c.return } } function qL(o, c, h) { var m = Di(); h = { lane: m, revertLane: 0, action: h, hasEagerState: !1, eagerState: null, next: null }, Zh(o) ? hT(c, h) : (h = f0(o, c, h, m), h !== null && (Ri(h, o, m), pT(h, c, m))) } function fT(o, c, h) { var m = Di(); ud(o, c, h, m) } function ud(o, c, h, m) { var x = { lane: m, revertLane: 0, action: h, hasEagerState: !1, eagerState: null, next: null }; if (Zh(o)) hT(c, x); else { var w = o.alternate; if (o.lanes === 0 && (w === null || w.lanes === 0) && (w = c.lastRenderedReducer, w !== null)) try { var D = c.lastRenderedState, R = w(D, h); if (x.hasEagerState = !0, x.eagerState = R, Ei(R, D)) return Ph(o, c, x, 0), Nn === null && Lh(), !1 } catch { } finally { } if (h = f0(o, c, x, m), h !== null) return Ri(h, o, m), pT(h, c, m), !0 } return !1 } function W0(o, c, h, m) { if (m = { lane: 2, revertLane: Nv(), action: m, hasEagerState: !1, eagerState: null, next: null }, Zh(o)) { if (c) throw Error(r(479)) } else c = f0(o, h, m, 2), c !== null && Ri(c, o, 2) } function Zh(o) { var c = o.alternate; return o === qt || c !== null && c === qt } function hT(o, c) { jc = Wh = !0; var h = o.pending; h === null ? c.next = c : (c.next = h.next, h.next = c), o.pending = c } function pT(o, c, h) { if ((h & 4194048) !== 0) { var m = c.lanes; m &= o.pendingLanes, h |= m, c.lanes = h, Nt(o, h) } } var ep = { readContext: Vr, use: Gh, useCallback: Zn, useContext: Zn, useEffect: Zn, useImperativeHandle: Zn, useLayoutEffect: Zn, useInsertionEffect: Zn, useMemo: Zn, useReducer: Zn, useRef: Zn, useState: Zn, useDebugValue: Zn, useDeferredValue: Zn, useTransition: Zn, useSyncExternalStore: Zn, useId: Zn, useHostTransitionStatus: Zn, useFormState: Zn, useActionState: Zn, useOptimistic: Zn, useMemoCache: Zn, useCacheRefresh: Zn }, mT = { readContext: Vr, use: Gh, useCallback: function (o, c) { return ui().memoizedState = [o, c === void 0 ? null : c], o }, useContext: Vr, useEffect: JC, useImperativeHandle: function (o, c, h) { h = h != null ? h.concat([o]) : null, Jh(4194308, 4, nT.bind(null, c, o), h) }, useLayoutEffect: function (o, c) { return Jh(4194308, 4, o, c) }, useInsertionEffect: function (o, c) { Jh(4, 2, o, c) }, useMemo: function (o, c) { var h = ui(); c = c === void 0 ? null : c; var m = o(); if (fl) { rt(!0); try { o() } finally { rt(!1) } } return h.memoizedState = [m, c], m }, useReducer: function (o, c, h) { var m = ui(); if (h !== void 0) { var x = h(c); if (fl) { rt(!0); try { h(c) } finally { rt(!1) } } } else x = c; return m.memoizedState = m.baseState = x, o = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: o, lastRenderedState: x }, m.queue = o, o = o.dispatch = qL.bind(null, qt, o), [m.memoizedState, o] }, useRef: function (o) { var c = ui(); return o = { current: o }, c.memoizedState = o }, useState: function (o) { o = $0(o); var c = o.queue, h = fT.bind(null, qt, c); return c.dispatch = h, [o.memoizedState, h] }, useDebugValue: V0, useDeferredValue: function (o, c) { var h = ui(); return H0(h, o, c) }, useTransition: function () { var o = $0(!1); return o = oT.bind(null, qt, o.queue, !0, !1), ui().memoizedState = o, [!1, o] }, useSyncExternalStore: function (o, c, h) { var m = qt, x = ui(); if (dn) { if (h === void 0) throw Error(r(407)); h = h() } else { if (h = c(), Nn === null) throw Error(r(349)); (tn & 124) !== 0 || PC(m, c, h) } x.memoizedState = h; var w = { value: h, getSnapshot: c }; return x.queue = w, JC(IC.bind(null, m, w, o), [o]), m.flags |= 2048, Ac(9, Qh(), zC.bind(null, m, w, h, c), null), h }, useId: function () { var o = ui(), c = Nn.identifierPrefix; if (dn) { var h = fa, m = da; h = (m & ~(1 << 32 - Tt(m) - 1)).toString(32) + h, c = "" + c + "R" + h, h = Yh++, 0 < h && (c += "H" + h.toString(32)), c += "" } else h = FL++, c = "" + c + "r" + h.toString(32) + ""; return o.memoizedState = c }, useHostTransitionStatus: K0, useFormState: WC, useActionState: WC, useOptimistic: function (o) { var c = ui(); c.memoizedState = c.baseState = o; var h = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null }; return c.queue = h, c = W0.bind(null, qt, !0, h), h.dispatch = c, [o, c] }, useMemoCache: I0, useCacheRefresh: function () { return ui().memoizedState = HL.bind(null, qt) } }, gT = { readContext: Vr, use: Gh, useCallback: iT, useContext: Vr, useEffect: ZC, useImperativeHandle: rT, useInsertionEffect: eT, useLayoutEffect: tT, useMemo: sT, useReducer: Xh, useRef: QC, useState: function () { return Xh(ma) }, useDebugValue: V0, useDeferredValue: function (o, c) { var h = ar(); return aT(h, vn.memoizedState, o, c) }, useTransition: function () { var o = Xh(ma)[0], c = ar().memoizedState; return [typeof o == "boolean" ? o : ld(o), c] }, useSyncExternalStore: LC, useId: uT, useHostTransitionStatus: K0, useFormState: YC, useActionState: YC, useOptimistic: function (o, c) { var h = ar(); return $C(h, vn, o, c) }, useMemoCache: I0, useCacheRefresh: dT }, KL = { readContext: Vr, use: Gh, useCallback: iT, useContext: Vr, useEffect: ZC, useImperativeHandle: rT, useInsertionEffect: eT, useLayoutEffect: tT, useMemo: sT, useReducer: B0, useRef: QC, useState: function () { return B0(ma) }, useDebugValue: V0, useDeferredValue: function (o, c) { var h = ar(); return vn === null ? H0(h, o, c) : aT(h, vn.memoizedState, o, c) }, useTransition: function () { var o = B0(ma)[0], c = ar().memoizedState; return [typeof o == "boolean" ? o : ld(o), c] }, useSyncExternalStore: LC, useId: uT, useHostTransitionStatus: K0, useFormState: XC, useActionState: XC, useOptimistic: function (o, c) { var h = ar(); return vn !== null ? $C(h, vn, o, c) : (h.baseState = o, [o, h.queue.dispatch]) }, useMemoCache: I0, useCacheRefresh: dT }, kc = null, dd = 0; function tp(o) { var c = dd; return dd += 1, kc === null && (kc = []), EC(kc, o, c) } function fd(o, c) { c = c.props.ref, o.ref = c !== void 0 ? c : null } function np(o, c) { throw c.$$typeof === g ? Error(r(525)) : (o = Object.prototype.toString.call(c), Error(r(31, o === "[object Object]" ? "object with keys {" + Object.keys(c).join(", ") + "}" : o))) } function yT(o) { var c = o._init; return c(o._payload) } function vT(o) { function c(de, re) { if (o) { var ge = de.deletions; ge === null ? (de.deletions = [re], de.flags |= 16) : ge.push(re) } } function h(de, re) { if (!o) return null; for (; re !== null;)c(de, re), re = re.sibling; return null } function m(de) { for (var re = new Map; de !== null;)de.key !== null ? re.set(de.key, de) : re.set(de.index, de), de = de.sibling; return re } function x(de, re) { return de = ua(de, re), de.index = 0, de.sibling = null, de } function w(de, re, ge) { return de.index = ge, o ? (ge = de.alternate, ge !== null ? (ge = ge.index, ge < re ? (de.flags |= 67108866, re) : ge) : (de.flags |= 67108866, re)) : (de.flags |= 1048576, re) } function D(de) { return o && de.alternate === null && (de.flags |= 67108866), de } function R(de, re, ge, ze) { return re === null || re.tag !== 6 ? (re = p0(ge, de.mode, ze), re.return = de, re) : (re = x(re, ge), re.return = de, re) } function G(de, re, ge, ze) { var ht = ge.type; return ht === b ? _e(de, re, ge.props.children, ze, ge.key) : re !== null && (re.elementType === ht || typeof ht == "object" && ht !== null && ht.$$typeof === V && yT(ht) === re.type) ? (re = x(re, ge.props), fd(re, ge), re.return = de, re) : (re = Ih(ge.type, ge.key, ge.props, null, de.mode, ze), fd(re, ge), re.return = de, re) } function ve(de, re, ge, ze) { return re === null || re.tag !== 4 || re.stateNode.containerInfo !== ge.containerInfo || re.stateNode.implementation !== ge.implementation ? (re = m0(ge, de.mode, ze), re.return = de, re) : (re = x(re, ge.children || []), re.return = de, re) } function _e(de, re, ge, ze, ht) { return re === null || re.tag !== 7 ? (re = il(ge, de.mode, ze, ht), re.return = de, re) : (re = x(re, ge), re.return = de, re) } function Fe(de, re, ge) { if (typeof re == "string" && re !== "" || typeof re == "number" || typeof re == "bigint") return re = p0("" + re, de.mode, ge), re.return = de, re; if (typeof re == "object" && re !== null) { switch (re.$$typeof) { case y: return ge = Ih(re.type, re.key, re.props, null, de.mode, ge), fd(ge, re), ge.return = de, ge; case v: return re = m0(re, de.mode, ge), re.return = de, re; case V: var ze = re._init; return re = ze(re._payload), Fe(de, re, ge) }if (xe(re) || ne(re)) return re = il(re, de.mode, ge, null), re.return = de, re; if (typeof re.then == "function") return Fe(de, tp(re), ge); if (re.$$typeof === M) return Fe(de, Uh(de, re), ge); np(de, re) } return null } function Ce(de, re, ge, ze) { var ht = re !== null ? re.key : null; if (typeof ge == "string" && ge !== "" || typeof ge == "number" || typeof ge == "bigint") return ht !== null ? null : R(de, re, "" + ge, ze); if (typeof ge == "object" && ge !== null) { switch (ge.$$typeof) { case y: return ge.key === ht ? G(de, re, ge, ze) : null; case v: return ge.key === ht ? ve(de, re, ge, ze) : null; case V: return ht = ge._init, ge = ht(ge._payload), Ce(de, re, ge, ze) }if (xe(ge) || ne(ge)) return ht !== null ? null : _e(de, re, ge, ze, null); if (typeof ge.then == "function") return Ce(de, re, tp(ge), ze); if (ge.$$typeof === M) return Ce(de, re, Uh(de, ge), ze); np(de, ge) } return null } function Ne(de, re, ge, ze, ht) { if (typeof ze == "string" && ze !== "" || typeof ze == "number" || typeof ze == "bigint") return de = de.get(ge) || null, R(re, de, "" + ze, ht); if (typeof ze == "object" && ze !== null) { switch (ze.$$typeof) { case y: return de = de.get(ze.key === null ? ge : ze.key) || null, G(re, de, ze, ht); case v: return de = de.get(ze.key === null ? ge : ze.key) || null, ve(re, de, ze, ht); case V: var Wt = ze._init; return ze = Wt(ze._payload), Ne(de, re, ge, ze, ht) }if (xe(ze) || ne(ze)) return de = de.get(ge) || null, _e(re, de, ze, ht, null); if (typeof ze.then == "function") return Ne(de, re, ge, tp(ze), ht); if (ze.$$typeof === M) return Ne(de, re, ge, Uh(re, ze), ht); np(re, ze) } return null } function Dt(de, re, ge, ze) { for (var ht = null, Wt = null, bt = re, kt = re = 0, Cr = null; bt !== null && kt < ge.length; kt++) { bt.index > kt ? (Cr = bt, bt = null) : Cr = bt.sibling; var on = Ce(de, bt, ge[kt], ze); if (on === null) { bt === null && (bt = Cr); break } o && bt && on.alternate === null && c(de, bt), re = w(on, re, kt), Wt === null ? ht = on : Wt.sibling = on, Wt = on, bt = Cr } if (kt === ge.length) return h(de, bt), dn && al(de, kt), ht; if (bt === null) { for (; kt < ge.length; kt++)bt = Fe(de, ge[kt], ze), bt !== null && (re = w(bt, re, kt), Wt === null ? ht = bt : Wt.sibling = bt, Wt = bt); return dn && al(de, kt), ht } for (bt = m(bt); kt < ge.length; kt++)Cr = Ne(bt, de, kt, ge[kt], ze), Cr !== null && (o && Cr.alternate !== null && bt.delete(Cr.key === null ? kt : Cr.key), re = w(Cr, re, kt), Wt === null ? ht = Cr : Wt.sibling = Cr, Wt = Cr); return o && bt.forEach(function (mo) { return c(de, mo) }), dn && al(de, kt), ht } function At(de, re, ge, ze) { if (ge == null) throw Error(r(151)); for (var ht = null, Wt = null, bt = re, kt = re = 0, Cr = null, on = ge.next(); bt !== null && !on.done; kt++, on = ge.next()) { bt.index > kt ? (Cr = bt, bt = null) : Cr = bt.sibling; var mo = Ce(de, bt, on.value, ze); if (mo === null) { bt === null && (bt = Cr); break } o && bt && mo.alternate === null && c(de, bt), re = w(mo, re, kt), Wt === null ? ht = mo : Wt.sibling = mo, Wt = mo, bt = Cr } if (on.done) return h(de, bt), dn && al(de, kt), ht; if (bt === null) { for (; !on.done; kt++, on = ge.next())on = Fe(de, on.value, ze), on !== null && (re = w(on, re, kt), Wt === null ? ht = on : Wt.sibling = on, Wt = on); return dn && al(de, kt), ht } for (bt = m(bt); !on.done; kt++, on = ge.next())on = Ne(bt, de, kt, on.value, ze), on !== null && (o && on.alternate !== null && bt.delete(on.key === null ? kt : on.key), re = w(on, re, kt), Wt === null ? ht = on : Wt.sibling = on, Wt = on); return o && bt.forEach(function (WP) { return c(de, WP) }), dn && al(de, kt), ht } function bn(de, re, ge, ze) { if (typeof ge == "object" && ge !== null && ge.type === b && ge.key === null && (ge = ge.props.children), typeof ge == "object" && ge !== null) { switch (ge.$$typeof) { case y: e: { for (var ht = ge.key; re !== null;) { if (re.key === ht) { if (ht = ge.type, ht === b) { if (re.tag === 7) { h(de, re.sibling), ze = x(re, ge.props.children), ze.return = de, de = ze; break e } } else if (re.elementType === ht || typeof ht == "object" && ht !== null && ht.$$typeof === V && yT(ht) === re.type) { h(de, re.sibling), ze = x(re, ge.props), fd(ze, ge), ze.return = de, de = ze; break e } h(de, re); break } else c(de, re); re = re.sibling } ge.type === b ? (ze = il(ge.props.children, de.mode, ze, ge.key), ze.return = de, de = ze) : (ze = Ih(ge.type, ge.key, ge.props, null, de.mode, ze), fd(ze, ge), ze.return = de, de = ze) } return D(de); case v: e: { for (ht = ge.key; re !== null;) { if (re.key === ht) if (re.tag === 4 && re.stateNode.containerInfo === ge.containerInfo && re.stateNode.implementation === ge.implementation) { h(de, re.sibling), ze = x(re, ge.children || []), ze.return = de, de = ze; break e } else { h(de, re); break } else c(de, re); re = re.sibling } ze = m0(ge, de.mode, ze), ze.return = de, de = ze } return D(de); case V: return ht = ge._init, ge = ht(ge._payload), bn(de, re, ge, ze) }if (xe(ge)) return Dt(de, re, ge, ze); if (ne(ge)) { if (ht = ne(ge), typeof ht != "function") throw Error(r(150)); return ge = ht.call(ge), At(de, re, ge, ze) } if (typeof ge.then == "function") return bn(de, re, tp(ge), ze); if (ge.$$typeof === M) return bn(de, re, Uh(de, ge), ze); np(de, ge) } return typeof ge == "string" && ge !== "" || typeof ge == "number" || typeof ge == "bigint" ? (ge = "" + ge, re !== null && re.tag === 6 ? (h(de, re.sibling), ze = x(re, ge), ze.return = de, de = ze) : (h(de, re), ze = p0(ge, de.mode, ze), ze.return = de, de = ze), D(de)) : h(de, re) } return function (de, re, ge, ze) { try { dd = 0; var ht = bn(de, re, ge, ze); return kc = null, ht } catch (bt) { if (bt === nd || bt === Hh) throw bt; var Wt = Ai(29, bt, null, de.mode); return Wt.lanes = ze, Wt.return = de, Wt } finally { } } } var Oc = vT(!0), xT = vT(!1), Xi = ie(null), zs = null; function Za(o) { var c = o.alternate; pe(gr, gr.current & 1), pe(Xi, o), zs === null && (c === null || Nc.current !== null || c.memoizedState !== null) && (zs = o) } function bT(o) { if (o.tag === 22) { if (pe(gr, gr.current), pe(Xi, o), zs === null) { var c = o.alternate; c !== null && c.memoizedState !== null && (zs = o) } } else eo() } function eo() { pe(gr, gr.current), pe(Xi, Xi.current) } function ga(o) { oe(Xi), zs === o && (zs = null), oe(gr) } var gr = ie(0); function rp(o) { for (var c = o; c !== null;) { if (c.tag === 13) { var h = c.memoizedState; if (h !== null && (h = h.dehydrated, h === null || h.data === "$?" || zv(h))) return c } else if (c.tag === 19 && c.memoizedProps.revealOrder !== void 0) { if ((c.flags & 128) !== 0) return c } else if (c.child !== null) { c.child.return = c, c = c.child; continue } if (c === o) break; for (; c.sibling === null;) { if (c.return === null || c.return === o) return null; c = c.return } c.sibling.return = c.return, c = c.sibling } return null } function Y0(o, c, h, m) { c = o.memoizedState, h = h(m, c), h = h == null ? c : p({}, c, h), o.memoizedState = h, o.lanes === 0 && (o.updateQueue.baseState = h) } var G0 = { enqueueSetState: function (o, c, h) { o = o._reactInternals; var m = Di(), x = Xa(m); x.payload = c, h != null && (x.callback = h), c = Qa(o, x, m), c !== null && (Ri(c, o, m), id(c, o, m)) }, enqueueReplaceState: function (o, c, h) { o = o._reactInternals; var m = Di(), x = Xa(m); x.tag = 1, x.payload = c, h != null && (x.callback = h), c = Qa(o, x, m), c !== null && (Ri(c, o, m), id(c, o, m)) }, enqueueForceUpdate: function (o, c) { o = o._reactInternals; var h = Di(), m = Xa(h); m.tag = 2, c != null && (m.callback = c), c = Qa(o, m, h), c !== null && (Ri(c, o, h), id(c, o, h)) } }; function wT(o, c, h, m, x, w, D) { return o = o.stateNode, typeof o.shouldComponentUpdate == "function" ? o.shouldComponentUpdate(m, w, D) : c.prototype && c.prototype.isPureReactComponent ? !Yu(h, m) || !Yu(x, w) : !0 } function ST(o, c, h, m) { o = c.state, typeof c.componentWillReceiveProps == "function" && c.componentWillReceiveProps(h, m), typeof c.UNSAFE_componentWillReceiveProps == "function" && c.UNSAFE_componentWillReceiveProps(h, m), c.state !== o && G0.enqueueReplaceState(c, c.state, null) } function hl(o, c) { var h = c; if ("ref" in c) { h = {}; for (var m in c) m !== "ref" && (h[m] = c[m]) } if (o = o.defaultProps) { h === c && (h = p({}, h)); for (var x in o) h[x] === void 0 && (h[x] = o[x]) } return h } var ip = typeof reportError == "function" ? reportError : function (o) { if (typeof window == "object" && typeof window.ErrorEvent == "function") { var c = new window.ErrorEvent("error", { bubbles: !0, cancelable: !0, message: typeof o == "object" && o !== null && typeof o.message == "string" ? String(o.message) : String(o), error: o }); if (!window.dispatchEvent(c)) return } else if (typeof process == "object" && typeof process.emit == "function") { process.emit("uncaughtException", o); return } console.error(o) }; function CT(o) { ip(o) } function TT(o) { console.error(o) } function NT(o) { ip(o) } function sp(o, c) { try { var h = o.onUncaughtError; h(c.value, { componentStack: c.stack }) } catch (m) { setTimeout(function () { throw m }) } } function jT(o, c, h) { try { var m = o.onCaughtError; m(h.value, { componentStack: h.stack, errorBoundary: c.tag === 1 ? c.stateNode : null }) } catch (x) { setTimeout(function () { throw x }) } } function X0(o, c, h) { return h = Xa(h), h.tag = 3, h.payload = { element: null }, h.callback = function () { sp(o, c) }, h } function ET(o) { return o = Xa(o), o.tag = 3, o } function AT(o, c, h, m) { var x = h.type.getDerivedStateFromError; if (typeof x == "function") { var w = m.value; o.payload = function () { return x(w) }, o.callback = function () { jT(c, h, m) } } var D = h.stateNode; D !== null && typeof D.componentDidCatch == "function" && (o.callback = function () { jT(c, h, m), typeof x != "function" && (ao === null ? ao = new Set([this]) : ao.add(this)); var R = m.stack; this.componentDidCatch(m.value, { componentStack: R !== null ? R : "" }) }) } function WL(o, c, h, m, x) { if (h.flags |= 32768, m !== null && typeof m == "object" && typeof m.then == "function") { if (c = h.alternate, c !== null && Zu(c, h, x, !0), h = Xi.current, h !== null) { switch (h.tag) { case 13: return zs === null ? bv() : h.alternate === null && qn === 0 && (qn = 3), h.flags &= -257, h.flags |= 65536, h.lanes = x, m === N0 ? h.flags |= 16384 : (c = h.updateQueue, c === null ? h.updateQueue = new Set([m]) : c.add(m), Sv(o, m, x)), !1; case 22: return h.flags |= 65536, m === N0 ? h.flags |= 16384 : (c = h.updateQueue, c === null ? (c = { transitions: null, markerInstances: null, retryQueue: new Set([m]) }, h.updateQueue = c) : (h = c.retryQueue, h === null ? c.retryQueue = new Set([m]) : h.add(m)), Sv(o, m, x)), !1 }throw Error(r(435, h.tag)) } return Sv(o, m, x), bv(), !1 } if (dn) return c = Xi.current, c !== null ? ((c.flags & 65536) === 0 && (c.flags |= 256), c.flags |= 65536, c.lanes = x, m !== v0 && (o = Error(r(422), { cause: m }), Ju(Ki(o, h)))) : (m !== v0 && (c = Error(r(423), { cause: m }), Ju(Ki(c, h))), o = o.current.alternate, o.flags |= 65536, x &= -x, o.lanes |= x, m = Ki(m, h), x = X0(o.stateNode, m, x), A0(o, x), qn !== 4 && (qn = 2)), !1; var w = Error(r(520), { cause: m }); if (w = Ki(w, h), xd === null ? xd = [w] : xd.push(w), qn !== 4 && (qn = 2), c === null) return !0; m = Ki(m, h), h = c; do { switch (h.tag) { case 3: return h.flags |= 65536, o = x & -x, h.lanes |= o, o = X0(h.stateNode, m, o), A0(h, o), !1; case 1: if (c = h.type, w = h.stateNode, (h.flags & 128) === 0 && (typeof c.getDerivedStateFromError == "function" || w !== null && typeof w.componentDidCatch == "function" && (ao === null || !ao.has(w)))) return h.flags |= 65536, x &= -x, h.lanes |= x, x = ET(x), AT(x, o, h, m), A0(h, x), !1 }h = h.return } while (h !== null); return !1 } var kT = Error(r(461)), wr = !1; function Dr(o, c, h, m) { c.child = o === null ? xT(c, null, h, m) : Oc(c, o.child, h, m) } function OT(o, c, h, m, x) { h = h.render; var w = c.ref; if ("ref" in m) { var D = {}; for (var R in m) R !== "ref" && (D[R] = m[R]) } else D = m; return ul(c), m = R0(o, c, h, D, w, x), R = _0(), o !== null && !wr ? (L0(o, c, x), ya(o, c, x)) : (dn && R && g0(c), c.flags |= 1, Dr(o, c, m, x), c.child) } function MT(o, c, h, m, x) { if (o === null) { var w = h.type; return typeof w == "function" && !h0(w) && w.defaultProps === void 0 && h.compare === null ? (c.tag = 15, c.type = w, DT(o, c, w, m, x)) : (o = Ih(h.type, null, m, c, c.mode, x), o.ref = c.ref, o.return = c, c.child = o) } if (w = o.child, !iv(o, x)) { var D = w.memoizedProps; if (h = h.compare, h = h !== null ? h : Yu, h(D, m) && o.ref === c.ref) return ya(o, c, x) } return c.flags |= 1, o = ua(w, m), o.ref = c.ref, o.return = c, c.child = o } function DT(o, c, h, m, x) { if (o !== null) { var w = o.memoizedProps; if (Yu(w, m) && o.ref === c.ref) if (wr = !1, c.pendingProps = m = w, iv(o, x)) (o.flags & 131072) !== 0 && (wr = !0); else return c.lanes = o.lanes, ya(o, c, x) } return Q0(o, c, h, m, x) } function RT(o, c, h) { var m = c.pendingProps, x = m.children, w = o !== null ? o.memoizedState : null; if (m.mode === "hidden") { if ((c.flags & 128) !== 0) { if (m = w !== null ? w.baseLanes | h : h, o !== null) { for (x = c.child = o.child, w = 0; x !== null;)w = w | x.lanes | x.childLanes, x = x.sibling; c.childLanes = w & ~m } else c.childLanes = 0, c.child = null; return _T(o, c, m, h) } if ((h & 536870912) !== 0) c.memoizedState = { baseLanes: 0, cachePool: null }, o !== null && Vh(c, w !== null ? w.cachePool : null), w !== null ? DC(c, w) : O0(), bT(c); else return c.lanes = c.childLanes = 536870912, _T(o, c, w !== null ? w.baseLanes | h : h, h) } else w !== null ? (Vh(c, w.cachePool), DC(c, w), eo(), c.memoizedState = null) : (o !== null && Vh(c, null), O0(), eo()); return Dr(o, c, x, h), c.child } function _T(o, c, h, m) { var x = T0(); return x = x === null ? null : { parent: mr._currentValue, pool: x }, c.memoizedState = { baseLanes: h, cachePool: x }, o !== null && Vh(c, null), O0(), bT(c), o !== null && Zu(o, c, m, !0), null } function ap(o, c) { var h = c.ref; if (h === null) o !== null && o.ref !== null && (c.flags |= 4194816); else { if (typeof h != "function" && typeof h != "object") throw Error(r(284)); (o === null || o.ref !== h) && (c.flags |= 4194816) } } function Q0(o, c, h, m, x) { return ul(c), h = R0(o, c, h, m, void 0, x), m = _0(), o !== null && !wr ? (L0(o, c, x), ya(o, c, x)) : (dn && m && g0(c), c.flags |= 1, Dr(o, c, h, x), c.child) } function LT(o, c, h, m, x, w) { return ul(c), c.updateQueue = null, h = _C(c, m, h, x), RC(o), m = _0(), o !== null && !wr ? (L0(o, c, w), ya(o, c, w)) : (dn && m && g0(c), c.flags |= 1, Dr(o, c, h, w), c.child) } function PT(o, c, h, m, x) { if (ul(c), c.stateNode === null) { var w = bc, D = h.contextType; typeof D == "object" && D !== null && (w = Vr(D)), w = new h(m, w), c.memoizedState = w.state !== null && w.state !== void 0 ? w.state : null, w.updater = G0, c.stateNode = w, w._reactInternals = c, w = c.stateNode, w.props = m, w.state = c.memoizedState, w.refs = {}, j0(c), D = h.contextType, w.context = typeof D == "object" && D !== null ? Vr(D) : bc, w.state = c.memoizedState, D = h.getDerivedStateFromProps, typeof D == "function" && (Y0(c, h, D, m), w.state = c.memoizedState), typeof h.getDerivedStateFromProps == "function" || typeof w.getSnapshotBeforeUpdate == "function" || typeof w.UNSAFE_componentWillMount != "function" && typeof w.componentWillMount != "function" || (D = w.state, typeof w.componentWillMount == "function" && w.componentWillMount(), typeof w.UNSAFE_componentWillMount == "function" && w.UNSAFE_componentWillMount(), D !== w.state && G0.enqueueReplaceState(w, w.state, null), ad(c, m, w, x), sd(), w.state = c.memoizedState), typeof w.componentDidMount == "function" && (c.flags |= 4194308), m = !0 } else if (o === null) { w = c.stateNode; var R = c.memoizedProps, G = hl(h, R); w.props = G; var ve = w.context, _e = h.contextType; D = bc, typeof _e == "object" && _e !== null && (D = Vr(_e)); var Fe = h.getDerivedStateFromProps; _e = typeof Fe == "function" || typeof w.getSnapshotBeforeUpdate == "function", R = c.pendingProps !== R, _e || typeof w.UNSAFE_componentWillReceiveProps != "function" && typeof w.componentWillReceiveProps != "function" || (R || ve !== D) && ST(c, w, m, D), Ga = !1; var Ce = c.memoizedState; w.state = Ce, ad(c, m, w, x), sd(), ve = c.memoizedState, R || Ce !== ve || Ga ? (typeof Fe == "function" && (Y0(c, h, Fe, m), ve = c.memoizedState), (G = Ga || wT(c, h, G, m, Ce, ve, D)) ? (_e || typeof w.UNSAFE_componentWillMount != "function" && typeof w.componentWillMount != "function" || (typeof w.componentWillMount == "function" && w.componentWillMount(), typeof w.UNSAFE_componentWillMount == "function" && w.UNSAFE_componentWillMount()), typeof w.componentDidMount == "function" && (c.flags |= 4194308)) : (typeof w.componentDidMount == "function" && (c.flags |= 4194308), c.memoizedProps = m, c.memoizedState = ve), w.props = m, w.state = ve, w.context = D, m = G) : (typeof w.componentDidMount == "function" && (c.flags |= 4194308), m = !1) } else { w = c.stateNode, E0(o, c), D = c.memoizedProps, _e = hl(h, D), w.props = _e, Fe = c.pendingProps, Ce = w.context, ve = h.contextType, G = bc, typeof ve == "object" && ve !== null && (G = Vr(ve)), R = h.getDerivedStateFromProps, (ve = typeof R == "function" || typeof w.getSnapshotBeforeUpdate == "function") || typeof w.UNSAFE_componentWillReceiveProps != "function" && typeof w.componentWillReceiveProps != "function" || (D !== Fe || Ce !== G) && ST(c, w, m, G), Ga = !1, Ce = c.memoizedState, w.state = Ce, ad(c, m, w, x), sd(); var Ne = c.memoizedState; D !== Fe || Ce !== Ne || Ga || o !== null && o.dependencies !== null && $h(o.dependencies) ? (typeof R == "function" && (Y0(c, h, R, m), Ne = c.memoizedState), (_e = Ga || wT(c, h, _e, m, Ce, Ne, G) || o !== null && o.dependencies !== null && $h(o.dependencies)) ? (ve || typeof w.UNSAFE_componentWillUpdate != "function" && typeof w.componentWillUpdate != "function" || (typeof w.componentWillUpdate == "function" && w.componentWillUpdate(m, Ne, G), typeof w.UNSAFE_componentWillUpdate == "function" && w.UNSAFE_componentWillUpdate(m, Ne, G)), typeof w.componentDidUpdate == "function" && (c.flags |= 4), typeof w.getSnapshotBeforeUpdate == "function" && (c.flags |= 1024)) : (typeof w.componentDidUpdate != "function" || D === o.memoizedProps && Ce === o.memoizedState || (c.flags |= 4), typeof w.getSnapshotBeforeUpdate != "function" || D === o.memoizedProps && Ce === o.memoizedState || (c.flags |= 1024), c.memoizedProps = m, c.memoizedState = Ne), w.props = m, w.state = Ne, w.context = G, m = _e) : (typeof w.componentDidUpdate != "function" || D === o.memoizedProps && Ce === o.memoizedState || (c.flags |= 4), typeof w.getSnapshotBeforeUpdate != "function" || D === o.memoizedProps && Ce === o.memoizedState || (c.flags |= 1024), m = !1) } return w = m, ap(o, c), m = (c.flags & 128) !== 0, w || m ? (w = c.stateNode, h = m && typeof h.getDerivedStateFromError != "function" ? null : w.render(), c.flags |= 1, o !== null && m ? (c.child = Oc(c, o.child, null, x), c.child = Oc(c, null, h, x)) : Dr(o, c, h, x), c.memoizedState = w.state, o = c.child) : o = ya(o, c, x), o } function zT(o, c, h, m) { return Qu(), c.flags |= 256, Dr(o, c, h, m), c.child } var J0 = { dehydrated: null, treeContext: null, retryLane: 0, hydrationErrors: null }; function Z0(o) { return { baseLanes: o, cachePool: TC() } } function ev(o, c, h) { return o = o !== null ? o.childLanes & ~h : 0, c && (o |= Qi), o } function IT(o, c, h) { var m = c.pendingProps, x = !1, w = (c.flags & 128) !== 0, D; if ((D = w) || (D = o !== null && o.memoizedState === null ? !1 : (gr.current & 2) !== 0), D && (x = !0, c.flags &= -129), D = (c.flags & 32) !== 0, c.flags &= -33, o === null) { if (dn) { if (x ? Za(c) : eo(), dn) { var R = Hn, G; if (G = R) { e: { for (G = R, R = Ps; G.nodeType !== 8;) { if (!R) { R = null; break e } if (G = gs(G.nextSibling), G === null) { R = null; break e } } R = G } R !== null ? (c.memoizedState = { dehydrated: R, treeContext: sl !== null ? { id: da, overflow: fa } : null, retryLane: 536870912, hydrationErrors: null }, G = Ai(18, null, null, 0), G.stateNode = R, G.return = c, c.child = G, ti = c, Hn = null, G = !0) : G = !1 } G || ll(c) } if (R = c.memoizedState, R !== null && (R = R.dehydrated, R !== null)) return zv(R) ? c.lanes = 32 : c.lanes = 536870912, null; ga(c) } return R = m.children, m = m.fallback, x ? (eo(), x = c.mode, R = op({ mode: "hidden", children: R }, x), m = il(m, x, h, null), R.return = c, m.return = c, R.sibling = m, c.child = R, x = c.child, x.memoizedState = Z0(h), x.childLanes = ev(o, D, h), c.memoizedState = J0, m) : (Za(c), tv(c, R)) } if (G = o.memoizedState, G !== null && (R = G.dehydrated, R !== null)) { if (w) c.flags & 256 ? (Za(c), c.flags &= -257, c = nv(o, c, h)) : c.memoizedState !== null ? (eo(), c.child = o.child, c.flags |= 128, c = null) : (eo(), x = m.fallback, R = c.mode, m = op({ mode: "visible", children: m.children }, R), x = il(x, R, h, null), x.flags |= 2, m.return = c, x.return = c, m.sibling = x, c.child = m, Oc(c, o.child, null, h), m = c.child, m.memoizedState = Z0(h), m.childLanes = ev(o, D, h), c.memoizedState = J0, c = x); else if (Za(c), zv(R)) { if (D = R.nextSibling && R.nextSibling.dataset, D) var ve = D.dgst; D = ve, m = Error(r(419)), m.stack = "", m.digest = D, Ju({ value: m, source: null, stack: null }), c = nv(o, c, h) } else if (wr || Zu(o, c, h, !1), D = (h & o.childLanes) !== 0, wr || D) { if (D = Nn, D !== null && (m = h & -h, m = (m & 42) !== 0 ? 1 : rn(m), m = (m & (D.suspendedLanes | h)) !== 0 ? 0 : m, m !== 0 && m !== G.retryLane)) throw G.retryLane = m, xc(o, m), Ri(D, o, m), kT; R.data === "$?" || bv(), c = nv(o, c, h) } else R.data === "$?" ? (c.flags |= 192, c.child = o.child, c = null) : (o = G.treeContext, Hn = gs(R.nextSibling), ti = c, dn = !0, ol = null, Ps = !1, o !== null && (Yi[Gi++] = da, Yi[Gi++] = fa, Yi[Gi++] = sl, da = o.id, fa = o.overflow, sl = c), c = tv(c, m.children), c.flags |= 4096); return c } return x ? (eo(), x = m.fallback, R = c.mode, G = o.child, ve = G.sibling, m = ua(G, { mode: "hidden", children: m.children }), m.subtreeFlags = G.subtreeFlags & 65011712, ve !== null ? x = ua(ve, x) : (x = il(x, R, h, null), x.flags |= 2), x.return = c, m.return = c, m.sibling = x, c.child = m, m = x, x = c.child, R = o.child.memoizedState, R === null ? R = Z0(h) : (G = R.cachePool, G !== null ? (ve = mr._currentValue, G = G.parent !== ve ? { parent: ve, pool: ve } : G) : G = TC(), R = { baseLanes: R.baseLanes | h, cachePool: G }), x.memoizedState = R, x.childLanes = ev(o, D, h), c.memoizedState = J0, m) : (Za(c), h = o.child, o = h.sibling, h = ua(h, { mode: "visible", children: m.children }), h.return = c, h.sibling = null, o !== null && (D = c.deletions, D === null ? (c.deletions = [o], c.flags |= 16) : D.push(o)), c.child = h, c.memoizedState = null, h) } function tv(o, c) { return c = op({ mode: "visible", children: c }, o.mode), c.return = o, o.child = c } function op(o, c) { return o = Ai(22, o, null, c), o.lanes = 0, o.stateNode = { _visibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null }, o } function nv(o, c, h) { return Oc(c, o.child, null, h), o = tv(c, c.pendingProps.children), o.flags |= 2, c.memoizedState = null, o } function FT(o, c, h) { o.lanes |= c; var m = o.alternate; m !== null && (m.lanes |= c), b0(o.return, c, h) } function rv(o, c, h, m, x) { var w = o.memoizedState; w === null ? o.memoizedState = { isBackwards: c, rendering: null, renderingStartTime: 0, last: m, tail: h, tailMode: x } : (w.isBackwards = c, w.rendering = null, w.renderingStartTime = 0, w.last = m, w.tail = h, w.tailMode = x) } function BT(o, c, h) { var m = c.pendingProps, x = m.revealOrder, w = m.tail; if (Dr(o, c, m.children, h), m = gr.current, (m & 2) !== 0) m = m & 1 | 2, c.flags |= 128; else { if (o !== null && (o.flags & 128) !== 0) e: for (o = c.child; o !== null;) { if (o.tag === 13) o.memoizedState !== null && FT(o, h, c); else if (o.tag === 19) FT(o, h, c); else if (o.child !== null) { o.child.return = o, o = o.child; continue } if (o === c) break e; for (; o.sibling === null;) { if (o.return === null || o.return === c) break e; o = o.return } o.sibling.return = o.return, o = o.sibling } m &= 1 } switch (pe(gr, m), x) { case "forwards": for (h = c.child, x = null; h !== null;)o = h.alternate, o !== null && rp(o) === null && (x = h), h = h.sibling; h = x, h === null ? (x = c.child, c.child = null) : (x = h.sibling, h.sibling = null), rv(c, !1, x, h, w); break; case "backwards": for (h = null, x = c.child, c.child = null; x !== null;) { if (o = x.alternate, o !== null && rp(o) === null) { c.child = x; break } o = x.sibling, x.sibling = h, h = x, x = o } rv(c, !0, h, null, w); break; case "together": rv(c, !1, null, null, void 0); break; default: c.memoizedState = null }return c.child } function ya(o, c, h) { if (o !== null && (c.dependencies = o.dependencies), so |= c.lanes, (h & c.childLanes) === 0) if (o !== null) { if (Zu(o, c, h, !1), (h & c.childLanes) === 0) return null } else return null; if (o !== null && c.child !== o.child) throw Error(r(153)); if (c.child !== null) { for (o = c.child, h = ua(o, o.pendingProps), c.child = h, h.return = c; o.sibling !== null;)o = o.sibling, h = h.sibling = ua(o, o.pendingProps), h.return = c; h.sibling = null } return c.child } function iv(o, c) { return (o.lanes & c) !== 0 ? !0 : (o = o.dependencies, !!(o !== null && $h(o))) } function YL(o, c, h) { switch (c.tag) { case 3: Xe(c, c.stateNode.containerInfo), Ya(c, mr, o.memoizedState.cache), Qu(); break; case 27: case 5: he(c); break; case 4: Xe(c, c.stateNode.containerInfo); break; case 10: Ya(c, c.type, c.memoizedProps.value); break; case 13: var m = c.memoizedState; if (m !== null) return m.dehydrated !== null ? (Za(c), c.flags |= 128, null) : (h & c.child.childLanes) !== 0 ? IT(o, c, h) : (Za(c), o = ya(o, c, h), o !== null ? o.sibling : null); Za(c); break; case 19: var x = (o.flags & 128) !== 0; if (m = (h & c.childLanes) !== 0, m || (Zu(o, c, h, !1), m = (h & c.childLanes) !== 0), x) { if (m) return BT(o, c, h); c.flags |= 128 } if (x = c.memoizedState, x !== null && (x.rendering = null, x.tail = null, x.lastEffect = null), pe(gr, gr.current), m) break; return null; case 22: case 23: return c.lanes = 0, RT(o, c, h); case 24: Ya(c, mr, o.memoizedState.cache) }return ya(o, c, h) } function $T(o, c, h) { if (o !== null) if (o.memoizedProps !== c.pendingProps) wr = !0; else { if (!iv(o, h) && (c.flags & 128) === 0) return wr = !1, YL(o, c, h); wr = (o.flags & 131072) !== 0 } else wr = !1, dn && (c.flags & 1048576) !== 0 && yC(c, Bh, c.index); switch (c.lanes = 0, c.tag) { case 16: e: { o = c.pendingProps; var m = c.elementType, x = m._init; if (m = x(m._payload), c.type = m, typeof m == "function") h0(m) ? (o = hl(m, o), c.tag = 1, c = PT(null, c, m, o, h)) : (c.tag = 0, c = Q0(null, c, m, o, h)); else { if (m != null) { if (x = m.$$typeof, x === O) { c.tag = 11, c = OT(null, c, m, o, h); break e } else if (x === z) { c.tag = 14, c = MT(null, c, m, o, h); break e } } throw c = we(m) || m, Error(r(306, c, "")) } } return c; case 0: return Q0(o, c, c.type, c.pendingProps, h); case 1: return m = c.type, x = hl(m, c.pendingProps), PT(o, c, m, x, h); case 3: e: { if (Xe(c, c.stateNode.containerInfo), o === null) throw Error(r(387)); m = c.pendingProps; var w = c.memoizedState; x = w.element, E0(o, c), ad(c, m, null, h); var D = c.memoizedState; if (m = D.cache, Ya(c, mr, m), m !== w.cache && w0(c, [mr], h, !0), sd(), m = D.element, w.isDehydrated) if (w = { element: m, isDehydrated: !1, cache: D.cache }, c.updateQueue.baseState = w, c.memoizedState = w, c.flags & 256) { c = zT(o, c, m, h); break e } else if (m !== x) { x = Ki(Error(r(424)), c), Ju(x), c = zT(o, c, m, h); break e } else { switch (o = c.stateNode.containerInfo, o.nodeType) { case 9: o = o.body; break; default: o = o.nodeName === "HTML" ? o.ownerDocument.body : o }for (Hn = gs(o.firstChild), ti = c, dn = !0, ol = null, Ps = !0, h = xT(c, null, m, h), c.child = h; h;)h.flags = h.flags & -3 | 4096, h = h.sibling } else { if (Qu(), m === x) { c = ya(o, c, h); break e } Dr(o, c, m, h) } c = c.child } return c; case 26: return ap(o, c), o === null ? (h = qN(c.type, null, c.pendingProps, null)) ? c.memoizedState = h : dn || (h = c.type, o = c.pendingProps, m = wp(Oe.current).createElement(h), m[Le] = c, m[We] = o, _r(m, h, o), Zt(m), c.stateNode = m) : c.memoizedState = qN(c.type, o.memoizedProps, c.pendingProps, o.memoizedState), null; case 27: return he(c), o === null && dn && (m = c.stateNode = UN(c.type, c.pendingProps, Oe.current), ti = c, Ps = !0, x = Hn, co(c.type) ? (Iv = x, Hn = gs(m.firstChild)) : Hn = x), Dr(o, c, c.pendingProps.children, h), ap(o, c), o === null && (c.flags |= 4194304), c.child; case 5: return o === null && dn && ((x = m = Hn) && (m = SP(m, c.type, c.pendingProps, Ps), m !== null ? (c.stateNode = m, ti = c, Hn = gs(m.firstChild), Ps = !1, x = !0) : x = !1), x || ll(c)), he(c), x = c.type, w = c.pendingProps, D = o !== null ? o.memoizedProps : null, m = w.children, _v(x, w) ? m = null : D !== null && _v(x, D) && (c.flags |= 32), c.memoizedState !== null && (x = R0(o, c, BL, null, null, h), Ad._currentValue = x), ap(o, c), Dr(o, c, m, h), c.child; case 6: return o === null && dn && ((o = h = Hn) && (h = CP(h, c.pendingProps, Ps), h !== null ? (c.stateNode = h, ti = c, Hn = null, o = !0) : o = !1), o || ll(c)), null; case 13: return IT(o, c, h); case 4: return Xe(c, c.stateNode.containerInfo), m = c.pendingProps, o === null ? c.child = Oc(c, null, m, h) : Dr(o, c, m, h), c.child; case 11: return OT(o, c, c.type, c.pendingProps, h); case 7: return Dr(o, c, c.pendingProps, h), c.child; case 8: return Dr(o, c, c.pendingProps.children, h), c.child; case 12: return Dr(o, c, c.pendingProps.children, h), c.child; case 10: return m = c.pendingProps, Ya(c, c.type, m.value), Dr(o, c, m.children, h), c.child; case 9: return x = c.type._context, m = c.pendingProps.children, ul(c), x = Vr(x), m = m(x), c.flags |= 1, Dr(o, c, m, h), c.child; case 14: return MT(o, c, c.type, c.pendingProps, h); case 15: return DT(o, c, c.type, c.pendingProps, h); case 19: return BT(o, c, h); case 31: return m = c.pendingProps, h = c.mode, m = { mode: m.mode, children: m.children }, o === null ? (h = op(m, h), h.ref = c.ref, c.child = h, h.return = c, c = h) : (h = ua(o.child, m), h.ref = c.ref, c.child = h, h.return = c, c = h), c; case 22: return RT(o, c, h); case 24: return ul(c), m = Vr(mr), o === null ? (x = T0(), x === null && (x = Nn, w = S0(), x.pooledCache = w, w.refCount++, w !== null && (x.pooledCacheLanes |= h), x = w), c.memoizedState = { parent: m, cache: x }, j0(c), Ya(c, mr, x)) : ((o.lanes & h) !== 0 && (E0(o, c), ad(c, null, null, h), sd()), x = o.memoizedState, w = c.memoizedState, x.parent !== m ? (x = { parent: m, cache: m }, c.memoizedState = x, c.lanes === 0 && (c.memoizedState = c.updateQueue.baseState = x), Ya(c, mr, m)) : (m = w.cache, Ya(c, mr, m), m !== x.cache && w0(c, [mr], h, !0))), Dr(o, c, c.pendingProps.children, h), c.child; case 29: throw c.pendingProps }throw Error(r(156, c.tag)) } function va(o) { o.flags |= 4 } function UT(o, c) { if (c.type !== "stylesheet" || (c.state.loading & 4) !== 0) o.flags &= -16777217; else if (o.flags |= 16777216, !XN(c)) { if (c = Xi.current, c !== null && ((tn & 4194048) === tn ? zs !== null : (tn & 62914560) !== tn && (tn & 536870912) === 0 || c !== zs)) throw rd = N0, NC; o.flags |= 8192 } } function lp(o, c) { c !== null && (o.flags |= 4), o.flags & 16384 && (c = o.tag !== 22 ? Qe() : 536870912, o.lanes |= c, _c |= c) } function hd(o, c) { if (!dn) switch (o.tailMode) { case "hidden": c = o.tail; for (var h = null; c !== null;)c.alternate !== null && (h = c), c = c.sibling; h === null ? o.tail = null : h.sibling = null; break; case "collapsed": h = o.tail; for (var m = null; h !== null;)h.alternate !== null && (m = h), h = h.sibling; m === null ? c || o.tail === null ? o.tail = null : o.tail.sibling = null : m.sibling = null } } function In(o) { var c = o.alternate !== null && o.alternate.child === o.child, h = 0, m = 0; if (c) for (var x = o.child; x !== null;)h |= x.lanes | x.childLanes, m |= x.subtreeFlags & 65011712, m |= x.flags & 65011712, x.return = o, x = x.sibling; else for (x = o.child; x !== null;)h |= x.lanes | x.childLanes, m |= x.subtreeFlags, m |= x.flags, x.return = o, x = x.sibling; return o.subtreeFlags |= m, o.childLanes = h, c } function GL(o, c, h) { var m = c.pendingProps; switch (y0(c), c.tag) { case 31: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return In(c), null; case 1: return In(c), null; case 3: return h = c.stateNode, m = null, o !== null && (m = o.memoizedState.cache), c.memoizedState.cache !== m && (c.flags |= 2048), pa(mr), De(), h.pendingContext && (h.context = h.pendingContext, h.pendingContext = null), (o === null || o.child === null) && (Xu(c) ? va(c) : o === null || o.memoizedState.isDehydrated && (c.flags & 256) === 0 || (c.flags |= 1024, bC())), In(c), null; case 26: return h = c.memoizedState, o === null ? (va(c), h !== null ? (In(c), UT(c, h)) : (In(c), c.flags &= -16777217)) : h ? h !== o.memoizedState ? (va(c), In(c), UT(c, h)) : (In(c), c.flags &= -16777217) : (o.memoizedProps !== m && va(c), In(c), c.flags &= -16777217), null; case 27: Be(c), h = Oe.current; var x = c.type; if (o !== null && c.stateNode != null) o.memoizedProps !== m && va(c); else { if (!m) { if (c.stateNode === null) throw Error(r(166)); return In(c), null } o = Ee.current, Xu(c) ? vC(c) : (o = UN(x, m, h), c.stateNode = o, va(c)) } return In(c), null; case 5: if (Be(c), h = c.type, o !== null && c.stateNode != null) o.memoizedProps !== m && va(c); else { if (!m) { if (c.stateNode === null) throw Error(r(166)); return In(c), null } if (o = Ee.current, Xu(c)) vC(c); else { switch (x = wp(Oe.current), o) { case 1: o = x.createElementNS("http://www.w3.org/2000/svg", h); break; case 2: o = x.createElementNS("http://www.w3.org/1998/Math/MathML", h); break; default: switch (h) { case "svg": o = x.createElementNS("http://www.w3.org/2000/svg", h); break; case "math": o = x.createElementNS("http://www.w3.org/1998/Math/MathML", h); break; case "script": o = x.createElement("div"), o.innerHTML = "<script><\/script>", o = o.removeChild(o.firstChild); break; case "select": o = typeof m.is == "string" ? x.createElement("select", { is: m.is }) : x.createElement("select"), m.multiple ? o.multiple = !0 : m.size && (o.size = m.size); break; default: o = typeof m.is == "string" ? x.createElement(h, { is: m.is }) : x.createElement(h) } }o[Le] = c, o[We] = m; e: for (x = c.child; x !== null;) { if (x.tag === 5 || x.tag === 6) o.appendChild(x.stateNode); else if (x.tag !== 4 && x.tag !== 27 && x.child !== null) { x.child.return = x, x = x.child; continue } if (x === c) break e; for (; x.sibling === null;) { if (x.return === null || x.return === c) break e; x = x.return } x.sibling.return = x.return, x = x.sibling } c.stateNode = o; e: switch (_r(o, h, m), h) { case "button": case "input": case "select": case "textarea": o = !!m.autoFocus; break e; case "img": o = !0; break e; default: o = !1 }o && va(c) } } return In(c), c.flags &= -16777217, null; case 6: if (o && c.stateNode != null) o.memoizedProps !== m && va(c); else { if (typeof m != "string" && c.stateNode === null) throw Error(r(166)); if (o = Oe.current, Xu(c)) { if (o = c.stateNode, h = c.memoizedProps, m = null, x = ti, x !== null) switch (x.tag) { case 27: case 5: m = x.memoizedProps }o[Le] = c, o = !!(o.nodeValue === h || m !== null && m.suppressHydrationWarning === !0 || LN(o.nodeValue, h)), o || ll(c) } else o = wp(o).createTextNode(m), o[Le] = c, c.stateNode = o } return In(c), null; case 13: if (m = c.memoizedState, o === null || o.memoizedState !== null && o.memoizedState.dehydrated !== null) { if (x = Xu(c), m !== null && m.dehydrated !== null) { if (o === null) { if (!x) throw Error(r(318)); if (x = c.memoizedState, x = x !== null ? x.dehydrated : null, !x) throw Error(r(317)); x[Le] = c } else Qu(), (c.flags & 128) === 0 && (c.memoizedState = null), c.flags |= 4; In(c), x = !1 } else x = bC(), o !== null && o.memoizedState !== null && (o.memoizedState.hydrationErrors = x), x = !0; if (!x) return c.flags & 256 ? (ga(c), c) : (ga(c), null) } if (ga(c), (c.flags & 128) !== 0) return c.lanes = h, c; if (h = m !== null, o = o !== null && o.memoizedState !== null, h) { m = c.child, x = null, m.alternate !== null && m.alternate.memoizedState !== null && m.alternate.memoizedState.cachePool !== null && (x = m.alternate.memoizedState.cachePool.pool); var w = null; m.memoizedState !== null && m.memoizedState.cachePool !== null && (w = m.memoizedState.cachePool.pool), w !== x && (m.flags |= 2048) } return h !== o && h && (c.child.flags |= 8192), lp(c, c.updateQueue), In(c), null; case 4: return De(), o === null && kv(c.stateNode.containerInfo), In(c), null; case 10: return pa(c.type), In(c), null; case 19: if (oe(gr), x = c.memoizedState, x === null) return In(c), null; if (m = (c.flags & 128) !== 0, w = x.rendering, w === null) if (m) hd(x, !1); else { if (qn !== 0 || o !== null && (o.flags & 128) !== 0) for (o = c.child; o !== null;) { if (w = rp(o), w !== null) { for (c.flags |= 128, hd(x, !1), o = w.updateQueue, c.updateQueue = o, lp(c, o), c.subtreeFlags = 0, o = h, h = c.child; h !== null;)gC(h, o), h = h.sibling; return pe(gr, gr.current & 1 | 2), c.child } o = o.sibling } x.tail !== null && be() > dp && (c.flags |= 128, m = !0, hd(x, !1), c.lanes = 4194304) } else { if (!m) if (o = rp(w), o !== null) { if (c.flags |= 128, m = !0, o = o.updateQueue, c.updateQueue = o, lp(c, o), hd(x, !0), x.tail === null && x.tailMode === "hidden" && !w.alternate && !dn) return In(c), null } else 2 * be() - x.renderingStartTime > dp && h !== 536870912 && (c.flags |= 128, m = !0, hd(x, !1), c.lanes = 4194304); x.isBackwards ? (w.sibling = c.child, c.child = w) : (o = x.last, o !== null ? o.sibling = w : c.child = w, x.last = w) } return x.tail !== null ? (c = x.tail, x.rendering = c, x.tail = c.sibling, x.renderingStartTime = be(), c.sibling = null, o = gr.current, pe(gr, m ? o & 1 | 2 : o & 1), c) : (In(c), null); case 22: case 23: return ga(c), M0(), m = c.memoizedState !== null, o !== null ? o.memoizedState !== null !== m && (c.flags |= 8192) : m && (c.flags |= 8192), m ? (h & 536870912) !== 0 && (c.flags & 128) === 0 && (In(c), c.subtreeFlags & 6 && (c.flags |= 8192)) : In(c), h = c.updateQueue, h !== null && lp(c, h.retryQueue), h = null, o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (h = o.memoizedState.cachePool.pool), m = null, c.memoizedState !== null && c.memoizedState.cachePool !== null && (m = c.memoizedState.cachePool.pool), m !== h && (c.flags |= 2048), o !== null && oe(dl), null; case 24: return h = null, o !== null && (h = o.memoizedState.cache), c.memoizedState.cache !== h && (c.flags |= 2048), pa(mr), In(c), null; case 25: return null; case 30: return null }throw Error(r(156, c.tag)) } function XL(o, c) { switch (y0(c), c.tag) { case 1: return o = c.flags, o & 65536 ? (c.flags = o & -65537 | 128, c) : null; case 3: return pa(mr), De(), o = c.flags, (o & 65536) !== 0 && (o & 128) === 0 ? (c.flags = o & -65537 | 128, c) : null; case 26: case 27: case 5: return Be(c), null; case 13: if (ga(c), o = c.memoizedState, o !== null && o.dehydrated !== null) { if (c.alternate === null) throw Error(r(340)); Qu() } return o = c.flags, o & 65536 ? (c.flags = o & -65537 | 128, c) : null; case 19: return oe(gr), null; case 4: return De(), null; case 10: return pa(c.type), null; case 22: case 23: return ga(c), M0(), o !== null && oe(dl), o = c.flags, o & 65536 ? (c.flags = o & -65537 | 128, c) : null; case 24: return pa(mr), null; case 25: return null; default: return null } } function VT(o, c) { switch (y0(c), c.tag) { case 3: pa(mr), De(); break; case 26: case 27: case 5: Be(c); break; case 4: De(); break; case 13: ga(c); break; case 19: oe(gr); break; case 10: pa(c.type); break; case 22: case 23: ga(c), M0(), o !== null && oe(dl); break; case 24: pa(mr) } } function pd(o, c) { try { var h = c.updateQueue, m = h !== null ? h.lastEffect : null; if (m !== null) { var x = m.next; h = x; do { if ((h.tag & o) === o) { m = void 0; var w = h.create, D = h.inst; m = w(), D.destroy = m } h = h.next } while (h !== x) } } catch (R) { Sn(c, c.return, R) } } function to(o, c, h) { try { var m = c.updateQueue, x = m !== null ? m.lastEffect : null; if (x !== null) { var w = x.next; m = w; do { if ((m.tag & o) === o) { var D = m.inst, R = D.destroy; if (R !== void 0) { D.destroy = void 0, x = c; var G = h, ve = R; try { ve() } catch (_e) { Sn(x, G, _e) } } } m = m.next } while (m !== w) } } catch (_e) { Sn(c, c.return, _e) } } function HT(o) { var c = o.updateQueue; if (c !== null) { var h = o.stateNode; try { MC(c, h) } catch (m) { Sn(o, o.return, m) } } } function qT(o, c, h) { h.props = hl(o.type, o.memoizedProps), h.state = o.memoizedState; try { h.componentWillUnmount() } catch (m) { Sn(o, c, m) } } function md(o, c) { try { var h = o.ref; if (h !== null) { switch (o.tag) { case 26: case 27: case 5: var m = o.stateNode; break; case 30: m = o.stateNode; break; default: m = o.stateNode }typeof h == "function" ? o.refCleanup = h(m) : h.current = m } } catch (x) { Sn(o, c, x) } } function Is(o, c) { var h = o.ref, m = o.refCleanup; if (h !== null) if (typeof m == "function") try { m() } catch (x) { Sn(o, c, x) } finally { o.refCleanup = null, o = o.alternate, o != null && (o.refCleanup = null) } else if (typeof h == "function") try { h(null) } catch (x) { Sn(o, c, x) } else h.current = null } function KT(o) { var c = o.type, h = o.memoizedProps, m = o.stateNode; try { e: switch (c) { case "button": case "input": case "select": case "textarea": h.autoFocus && m.focus(); break e; case "img": h.src ? m.src = h.src : h.srcSet && (m.srcset = h.srcSet) } } catch (x) { Sn(o, o.return, x) } } function sv(o, c, h) { try { var m = o.stateNode; yP(m, o.type, h, c), m[We] = c } catch (x) { Sn(o, o.return, x) } } function WT(o) { return o.tag === 5 || o.tag === 3 || o.tag === 26 || o.tag === 27 && co(o.type) || o.tag === 4 } function av(o) { e: for (; ;) { for (; o.sibling === null;) { if (o.return === null || WT(o.return)) return null; o = o.return } for (o.sibling.return = o.return, o = o.sibling; o.tag !== 5 && o.tag !== 6 && o.tag !== 18;) { if (o.tag === 27 && co(o.type) || o.flags & 2 || o.child === null || o.tag === 4) continue e; o.child.return = o, o = o.child } if (!(o.flags & 2)) return o.stateNode } } function ov(o, c, h) { var m = o.tag; if (m === 5 || m === 6) o = o.stateNode, c ? (h.nodeType === 9 ? h.body : h.nodeName === "HTML" ? h.ownerDocument.body : h).insertBefore(o, c) : (c = h.nodeType === 9 ? h.body : h.nodeName === "HTML" ? h.ownerDocument.body : h, c.appendChild(o), h = h._reactRootContainer, h != null || c.onclick !== null || (c.onclick = bp)); else if (m !== 4 && (m === 27 && co(o.type) && (h = o.stateNode, c = null), o = o.child, o !== null)) for (ov(o, c, h), o = o.sibling; o !== null;)ov(o, c, h), o = o.sibling } function cp(o, c, h) { var m = o.tag; if (m === 5 || m === 6) o = o.stateNode, c ? h.insertBefore(o, c) : h.appendChild(o); else if (m !== 4 && (m === 27 && co(o.type) && (h = o.stateNode), o = o.child, o !== null)) for (cp(o, c, h), o = o.sibling; o !== null;)cp(o, c, h), o = o.sibling } function YT(o) { var c = o.stateNode, h = o.memoizedProps; try { for (var m = o.type, x = c.attributes; x.length;)c.removeAttributeNode(x[0]); _r(c, m, h), c[Le] = o, c[We] = h } catch (w) { Sn(o, o.return, w) } } var xa = !1, er = !1, lv = !1, GT = typeof WeakSet == "function" ? WeakSet : Set, Sr = null; function QL(o, c) { if (o = o.containerInfo, Dv = Ep, o = aC(o), a0(o)) { if ("selectionStart" in o) var h = { start: o.selectionStart, end: o.selectionEnd }; else e: { h = (h = o.ownerDocument) && h.defaultView || window; var m = h.getSelection && h.getSelection(); if (m && m.rangeCount !== 0) { h = m.anchorNode; var x = m.anchorOffset, w = m.focusNode; m = m.focusOffset; try { h.nodeType, w.nodeType } catch { h = null; break e } var D = 0, R = -1, G = -1, ve = 0, _e = 0, Fe = o, Ce = null; t: for (; ;) { for (var Ne; Fe !== h || x !== 0 && Fe.nodeType !== 3 || (R = D + x), Fe !== w || m !== 0 && Fe.nodeType !== 3 || (G = D + m), Fe.nodeType === 3 && (D += Fe.nodeValue.length), (Ne = Fe.firstChild) !== null;)Ce = Fe, Fe = Ne; for (; ;) { if (Fe === o) break t; if (Ce === h && ++ve === x && (R = D), Ce === w && ++_e === m && (G = D), (Ne = Fe.nextSibling) !== null) break; Fe = Ce, Ce = Fe.parentNode } Fe = Ne } h = R === -1 || G === -1 ? null : { start: R, end: G } } else h = null } h = h || { start: 0, end: 0 } } else h = null; for (Rv = { focusedElem: o, selectionRange: h }, Ep = !1, Sr = c; Sr !== null;)if (c = Sr, o = c.child, (c.subtreeFlags & 1024) !== 0 && o !== null) o.return = c, Sr = o; else for (; Sr !== null;) { switch (c = Sr, w = c.alternate, o = c.flags, c.tag) { case 0: break; case 11: case 15: break; case 1: if ((o & 1024) !== 0 && w !== null) { o = void 0, h = c, x = w.memoizedProps, w = w.memoizedState, m = h.stateNode; try { var Dt = hl(h.type, x, h.elementType === h.type); o = m.getSnapshotBeforeUpdate(Dt, w), m.__reactInternalSnapshotBeforeUpdate = o } catch (At) { Sn(h, h.return, At) } } break; case 3: if ((o & 1024) !== 0) { if (o = c.stateNode.containerInfo, h = o.nodeType, h === 9) Pv(o); else if (h === 1) switch (o.nodeName) { case "HEAD": case "HTML": case "BODY": Pv(o); break; default: o.textContent = "" } } break; case 5: case 26: case 27: case 6: case 4: case 17: break; default: if ((o & 1024) !== 0) throw Error(r(163)) }if (o = c.sibling, o !== null) { o.return = c.return, Sr = o; break } Sr = c.return } } function XT(o, c, h) { var m = h.flags; switch (h.tag) { case 0: case 11: case 15: no(o, h), m & 4 && pd(5, h); break; case 1: if (no(o, h), m & 4) if (o = h.stateNode, c === null) try { o.componentDidMount() } catch (D) { Sn(h, h.return, D) } else { var x = hl(h.type, c.memoizedProps); c = c.memoizedState; try { o.componentDidUpdate(x, c, o.__reactInternalSnapshotBeforeUpdate) } catch (D) { Sn(h, h.return, D) } } m & 64 && HT(h), m & 512 && md(h, h.return); break; case 3: if (no(o, h), m & 64 && (o = h.updateQueue, o !== null)) { if (c = null, h.child !== null) switch (h.child.tag) { case 27: case 5: c = h.child.stateNode; break; case 1: c = h.child.stateNode }try { MC(o, c) } catch (D) { Sn(h, h.return, D) } } break; case 27: c === null && m & 4 && YT(h); case 26: case 5: no(o, h), c === null && m & 4 && KT(h), m & 512 && md(h, h.return); break; case 12: no(o, h); break; case 13: no(o, h), m & 4 && ZT(o, h), m & 64 && (o = h.memoizedState, o !== null && (o = o.dehydrated, o !== null && (h = aP.bind(null, h), TP(o, h)))); break; case 22: if (m = h.memoizedState !== null || xa, !m) { c = c !== null && c.memoizedState !== null || er, x = xa; var w = er; xa = m, (er = c) && !w ? ro(o, h, (h.subtreeFlags & 8772) !== 0) : no(o, h), xa = x, er = w } break; case 30: break; default: no(o, h) } } function QT(o) { var c = o.alternate; c !== null && (o.alternate = null, QT(c)), o.child = null, o.deletions = null, o.sibling = null, o.tag === 5 && (c = o.stateNode, c !== null && St(c)), o.stateNode = null, o.return = null, o.dependencies = null, o.memoizedProps = null, o.memoizedState = null, o.pendingProps = null, o.stateNode = null, o.updateQueue = null } var Mn = null, di = !1; function ba(o, c, h) { for (h = h.child; h !== null;)JT(o, c, h), h = h.sibling } function JT(o, c, h) { if (qe && typeof qe.onCommitFiberUnmount == "function") try { qe.onCommitFiberUnmount(Ae, h) } catch { } switch (h.tag) { case 26: er || Is(h, c), ba(o, c, h), h.memoizedState ? h.memoizedState.count-- : h.stateNode && (h = h.stateNode, h.parentNode.removeChild(h)); break; case 27: er || Is(h, c); var m = Mn, x = di; co(h.type) && (Mn = h.stateNode, di = !1), ba(o, c, h), Td(h.stateNode), Mn = m, di = x; break; case 5: er || Is(h, c); case 6: if (m = Mn, x = di, Mn = null, ba(o, c, h), Mn = m, di = x, Mn !== null) if (di) try { (Mn.nodeType === 9 ? Mn.body : Mn.nodeName === "HTML" ? Mn.ownerDocument.body : Mn).removeChild(h.stateNode) } catch (w) { Sn(h, c, w) } else try { Mn.removeChild(h.stateNode) } catch (w) { Sn(h, c, w) } break; case 18: Mn !== null && (di ? (o = Mn, BN(o.nodeType === 9 ? o.body : o.nodeName === "HTML" ? o.ownerDocument.body : o, h.stateNode), Dd(o)) : BN(Mn, h.stateNode)); break; case 4: m = Mn, x = di, Mn = h.stateNode.containerInfo, di = !0, ba(o, c, h), Mn = m, di = x; break; case 0: case 11: case 14: case 15: er || to(2, h, c), er || to(4, h, c), ba(o, c, h); break; case 1: er || (Is(h, c), m = h.stateNode, typeof m.componentWillUnmount == "function" && qT(h, c, m)), ba(o, c, h); break; case 21: ba(o, c, h); break; case 22: er = (m = er) || h.memoizedState !== null, ba(o, c, h), er = m; break; default: ba(o, c, h) } } function ZT(o, c) { if (c.memoizedState === null && (o = c.alternate, o !== null && (o = o.memoizedState, o !== null && (o = o.dehydrated, o !== null)))) try { Dd(o) } catch (h) { Sn(c, c.return, h) } } function JL(o) { switch (o.tag) { case 13: case 19: var c = o.stateNode; return c === null && (c = o.stateNode = new GT), c; case 22: return o = o.stateNode, c = o._retryCache, c === null && (c = o._retryCache = new GT), c; default: throw Error(r(435, o.tag)) } } function cv(o, c) { var h = JL(o); c.forEach(function (m) { var x = oP.bind(null, o, m); h.has(m) || (h.add(m), m.then(x, x)) }) } function ki(o, c) { var h = c.deletions; if (h !== null) for (var m = 0; m < h.length; m++) { var x = h[m], w = o, D = c, R = D; e: for (; R !== null;) { switch (R.tag) { case 27: if (co(R.type)) { Mn = R.stateNode, di = !1; break e } break; case 5: Mn = R.stateNode, di = !1; break e; case 3: case 4: Mn = R.stateNode.containerInfo, di = !0; break e }R = R.return } if (Mn === null) throw Error(r(160)); JT(w, D, x), Mn = null, di = !1, w = x.alternate, w !== null && (w.return = null), x.return = null } if (c.subtreeFlags & 13878) for (c = c.child; c !== null;)eN(c, o), c = c.sibling } var ms = null; function eN(o, c) { var h = o.alternate, m = o.flags; switch (o.tag) { case 0: case 11: case 14: case 15: ki(c, o), Oi(o), m & 4 && (to(3, o, o.return), pd(3, o), to(5, o, o.return)); break; case 1: ki(c, o), Oi(o), m & 512 && (er || h === null || Is(h, h.return)), m & 64 && xa && (o = o.updateQueue, o !== null && (m = o.callbacks, m !== null && (h = o.shared.hiddenCallbacks, o.shared.hiddenCallbacks = h === null ? m : h.concat(m)))); break; case 26: var x = ms; if (ki(c, o), Oi(o), m & 512 && (er || h === null || Is(h, h.return)), m & 4) { var w = h !== null ? h.memoizedState : null; if (m = o.memoizedState, h === null) if (m === null) if (o.stateNode === null) { e: { m = o.type, h = o.memoizedProps, x = x.ownerDocument || x; t: switch (m) { case "title": w = x.getElementsByTagName("title")[0], (!w || w[jt] || w[Le] || w.namespaceURI === "http://www.w3.org/2000/svg" || w.hasAttribute("itemprop")) && (w = x.createElement(m), x.head.insertBefore(w, x.querySelector("head > title"))), _r(w, m, h), w[Le] = o, Zt(w), m = w; break e; case "link": var D = YN("link", "href", x).get(m + (h.href || "")); if (D) { for (var R = 0; R < D.length; R++)if (w = D[R], w.getAttribute("href") === (h.href == null || h.href === "" ? null : h.href) && w.getAttribute("rel") === (h.rel == null ? null : h.rel) && w.getAttribute("title") === (h.title == null ? null : h.title) && w.getAttribute("crossorigin") === (h.crossOrigin == null ? null : h.crossOrigin)) { D.splice(R, 1); break t } } w = x.createElement(m), _r(w, m, h), x.head.appendChild(w); break; case "meta": if (D = YN("meta", "content", x).get(m + (h.content || ""))) { for (R = 0; R < D.length; R++)if (w = D[R], w.getAttribute("content") === (h.content == null ? null : "" + h.content) && w.getAttribute("name") === (h.name == null ? null : h.name) && w.getAttribute("property") === (h.property == null ? null : h.property) && w.getAttribute("http-equiv") === (h.httpEquiv == null ? null : h.httpEquiv) && w.getAttribute("charset") === (h.charSet == null ? null : h.charSet)) { D.splice(R, 1); break t } } w = x.createElement(m), _r(w, m, h), x.head.appendChild(w); break; default: throw Error(r(468, m)) }w[Le] = o, Zt(w), m = w } o.stateNode = m } else GN(x, o.type, o.stateNode); else o.stateNode = WN(x, m, o.memoizedProps); else w !== m ? (w === null ? h.stateNode !== null && (h = h.stateNode, h.parentNode.removeChild(h)) : w.count--, m === null ? GN(x, o.type, o.stateNode) : WN(x, m, o.memoizedProps)) : m === null && o.stateNode !== null && sv(o, o.memoizedProps, h.memoizedProps) } break; case 27: ki(c, o), Oi(o), m & 512 && (er || h === null || Is(h, h.return)), h !== null && m & 4 && sv(o, o.memoizedProps, h.memoizedProps); break; case 5: if (ki(c, o), Oi(o), m & 512 && (er || h === null || Is(h, h.return)), o.flags & 32) { x = o.stateNode; try { wn(x, "") } catch (Ne) { Sn(o, o.return, Ne) } } m & 4 && o.stateNode != null && (x = o.memoizedProps, sv(o, x, h !== null ? h.memoizedProps : x)), m & 1024 && (lv = !0); break; case 6: if (ki(c, o), Oi(o), m & 4) { if (o.stateNode === null) throw Error(r(162)); m = o.memoizedProps, h = o.stateNode; try { h.nodeValue = m } catch (Ne) { Sn(o, o.return, Ne) } } break; case 3: if (Tp = null, x = ms, ms = Sp(c.containerInfo), ki(c, o), ms = x, Oi(o), m & 4 && h !== null && h.memoizedState.isDehydrated) try { Dd(c.containerInfo) } catch (Ne) { Sn(o, o.return, Ne) } lv && (lv = !1, tN(o)); break; case 4: m = ms, ms = Sp(o.stateNode.containerInfo), ki(c, o), Oi(o), ms = m; break; case 12: ki(c, o), Oi(o); break; case 13: ki(c, o), Oi(o), o.child.flags & 8192 && o.memoizedState !== null != (h !== null && h.memoizedState !== null) && (mv = be()), m & 4 && (m = o.updateQueue, m !== null && (o.updateQueue = null, cv(o, m))); break; case 22: x = o.memoizedState !== null; var G = h !== null && h.memoizedState !== null, ve = xa, _e = er; if (xa = ve || x, er = _e || G, ki(c, o), er = _e, xa = ve, Oi(o), m & 8192) e: for (c = o.stateNode, c._visibility = x ? c._visibility & -2 : c._visibility | 1, x && (h === null || G || xa || er || pl(o)), h = null, c = o; ;) { if (c.tag === 5 || c.tag === 26) { if (h === null) { G = h = c; try { if (w = G.stateNode, x) D = w.style, typeof D.setProperty == "function" ? D.setProperty("display", "none", "important") : D.display = "none"; else { R = G.stateNode; var Fe = G.memoizedProps.style, Ce = Fe != null && Fe.hasOwnProperty("display") ? Fe.display : null; R.style.display = Ce == null || typeof Ce == "boolean" ? "" : ("" + Ce).trim() } } catch (Ne) { Sn(G, G.return, Ne) } } } else if (c.tag === 6) { if (h === null) { G = c; try { G.stateNode.nodeValue = x ? "" : G.memoizedProps } catch (Ne) { Sn(G, G.return, Ne) } } } else if ((c.tag !== 22 && c.tag !== 23 || c.memoizedState === null || c === o) && c.child !== null) { c.child.return = c, c = c.child; continue } if (c === o) break e; for (; c.sibling === null;) { if (c.return === null || c.return === o) break e; h === c && (h = null), c = c.return } h === c && (h = null), c.sibling.return = c.return, c = c.sibling } m & 4 && (m = o.updateQueue, m !== null && (h = m.retryQueue, h !== null && (m.retryQueue = null, cv(o, h)))); break; case 19: ki(c, o), Oi(o), m & 4 && (m = o.updateQueue, m !== null && (o.updateQueue = null, cv(o, m))); break; case 30: break; case 21: break; default: ki(c, o), Oi(o) } } function Oi(o) { var c = o.flags; if (c & 2) { try { for (var h, m = o.return; m !== null;) { if (WT(m)) { h = m; break } m = m.return } if (h == null) throw Error(r(160)); switch (h.tag) { case 27: var x = h.stateNode, w = av(o); cp(o, w, x); break; case 5: var D = h.stateNode; h.flags & 32 && (wn(D, ""), h.flags &= -33); var R = av(o); cp(o, R, D); break; case 3: case 4: var G = h.stateNode.containerInfo, ve = av(o); ov(o, ve, G); break; default: throw Error(r(161)) } } catch (_e) { Sn(o, o.return, _e) } o.flags &= -3 } c & 4096 && (o.flags &= -4097) } function tN(o) { if (o.subtreeFlags & 1024) for (o = o.child; o !== null;) { var c = o; tN(c), c.tag === 5 && c.flags & 1024 && c.stateNode.reset(), o = o.sibling } } function no(o, c) { if (c.subtreeFlags & 8772) for (c = c.child; c !== null;)XT(o, c.alternate, c), c = c.sibling } function pl(o) { for (o = o.child; o !== null;) { var c = o; switch (c.tag) { case 0: case 11: case 14: case 15: to(4, c, c.return), pl(c); break; case 1: Is(c, c.return); var h = c.stateNode; typeof h.componentWillUnmount == "function" && qT(c, c.return, h), pl(c); break; case 27: Td(c.stateNode); case 26: case 5: Is(c, c.return), pl(c); break; case 22: c.memoizedState === null && pl(c); break; case 30: pl(c); break; default: pl(c) }o = o.sibling } } function ro(o, c, h) { for (h = h && (c.subtreeFlags & 8772) !== 0, c = c.child; c !== null;) { var m = c.alternate, x = o, w = c, D = w.flags; switch (w.tag) { case 0: case 11: case 15: ro(x, w, h), pd(4, w); break; case 1: if (ro(x, w, h), m = w, x = m.stateNode, typeof x.componentDidMount == "function") try { x.componentDidMount() } catch (ve) { Sn(m, m.return, ve) } if (m = w, x = m.updateQueue, x !== null) { var R = m.stateNode; try { var G = x.shared.hiddenCallbacks; if (G !== null) for (x.shared.hiddenCallbacks = null, x = 0; x < G.length; x++)OC(G[x], R) } catch (ve) { Sn(m, m.return, ve) } } h && D & 64 && HT(w), md(w, w.return); break; case 27: YT(w); case 26: case 5: ro(x, w, h), h && m === null && D & 4 && KT(w), md(w, w.return); break; case 12: ro(x, w, h); break; case 13: ro(x, w, h), h && D & 4 && ZT(x, w); break; case 22: w.memoizedState === null && ro(x, w, h), md(w, w.return); break; case 30: break; default: ro(x, w, h) }c = c.sibling } } function uv(o, c) { var h = null; o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (h = o.memoizedState.cachePool.pool), o = null, c.memoizedState !== null && c.memoizedState.cachePool !== null && (o = c.memoizedState.cachePool.pool), o !== h && (o != null && o.refCount++, h != null && ed(h)) } function dv(o, c) { o = null, c.alternate !== null && (o = c.alternate.memoizedState.cache), c = c.memoizedState.cache, c !== o && (c.refCount++, o != null && ed(o)) } function Fs(o, c, h, m) { if (c.subtreeFlags & 10256) for (c = c.child; c !== null;)nN(o, c, h, m), c = c.sibling } function nN(o, c, h, m) { var x = c.flags; switch (c.tag) { case 0: case 11: case 15: Fs(o, c, h, m), x & 2048 && pd(9, c); break; case 1: Fs(o, c, h, m); break; case 3: Fs(o, c, h, m), x & 2048 && (o = null, c.alternate !== null && (o = c.alternate.memoizedState.cache), c = c.memoizedState.cache, c !== o && (c.refCount++, o != null && ed(o))); break; case 12: if (x & 2048) { Fs(o, c, h, m), o = c.stateNode; try { var w = c.memoizedProps, D = w.id, R = w.onPostCommit; typeof R == "function" && R(D, c.alternate === null ? "mount" : "update", o.passiveEffectDuration, -0) } catch (G) { Sn(c, c.return, G) } } else Fs(o, c, h, m); break; case 13: Fs(o, c, h, m); break; case 23: break; case 22: w = c.stateNode, D = c.alternate, c.memoizedState !== null ? w._visibility & 2 ? Fs(o, c, h, m) : gd(o, c) : w._visibility & 2 ? Fs(o, c, h, m) : (w._visibility |= 2, Mc(o, c, h, m, (c.subtreeFlags & 10256) !== 0)), x & 2048 && uv(D, c); break; case 24: Fs(o, c, h, m), x & 2048 && dv(c.alternate, c); break; default: Fs(o, c, h, m) } } function Mc(o, c, h, m, x) { for (x = x && (c.subtreeFlags & 10256) !== 0, c = c.child; c !== null;) { var w = o, D = c, R = h, G = m, ve = D.flags; switch (D.tag) { case 0: case 11: case 15: Mc(w, D, R, G, x), pd(8, D); break; case 23: break; case 22: var _e = D.stateNode; D.memoizedState !== null ? _e._visibility & 2 ? Mc(w, D, R, G, x) : gd(w, D) : (_e._visibility |= 2, Mc(w, D, R, G, x)), x && ve & 2048 && uv(D.alternate, D); break; case 24: Mc(w, D, R, G, x), x && ve & 2048 && dv(D.alternate, D); break; default: Mc(w, D, R, G, x) }c = c.sibling } } function gd(o, c) { if (c.subtreeFlags & 10256) for (c = c.child; c !== null;) { var h = o, m = c, x = m.flags; switch (m.tag) { case 22: gd(h, m), x & 2048 && uv(m.alternate, m); break; case 24: gd(h, m), x & 2048 && dv(m.alternate, m); break; default: gd(h, m) }c = c.sibling } } var yd = 8192; function Dc(o) { if (o.subtreeFlags & yd) for (o = o.child; o !== null;)rN(o), o = o.sibling } function rN(o) { switch (o.tag) { case 26: Dc(o), o.flags & yd && o.memoizedState !== null && zP(ms, o.memoizedState, o.memoizedProps); break; case 5: Dc(o); break; case 3: case 4: var c = ms; ms = Sp(o.stateNode.containerInfo), Dc(o), ms = c; break; case 22: o.memoizedState === null && (c = o.alternate, c !== null && c.memoizedState !== null ? (c = yd, yd = 16777216, Dc(o), yd = c) : Dc(o)); break; default: Dc(o) } } function iN(o) { var c = o.alternate; if (c !== null && (o = c.child, o !== null)) { c.child = null; do c = o.sibling, o.sibling = null, o = c; while (o !== null) } } function vd(o) { var c = o.deletions; if ((o.flags & 16) !== 0) { if (c !== null) for (var h = 0; h < c.length; h++) { var m = c[h]; Sr = m, aN(m, o) } iN(o) } if (o.subtreeFlags & 10256) for (o = o.child; o !== null;)sN(o), o = o.sibling } function sN(o) { switch (o.tag) { case 0: case 11: case 15: vd(o), o.flags & 2048 && to(9, o, o.return); break; case 3: vd(o); break; case 12: vd(o); break; case 22: var c = o.stateNode; o.memoizedState !== null && c._visibility & 2 && (o.return === null || o.return.tag !== 13) ? (c._visibility &= -3, up(o)) : vd(o); break; default: vd(o) } } function up(o) { var c = o.deletions; if ((o.flags & 16) !== 0) { if (c !== null) for (var h = 0; h < c.length; h++) { var m = c[h]; Sr = m, aN(m, o) } iN(o) } for (o = o.child; o !== null;) { switch (c = o, c.tag) { case 0: case 11: case 15: to(8, c, c.return), up(c); break; case 22: h = c.stateNode, h._visibility & 2 && (h._visibility &= -3, up(c)); break; default: up(c) }o = o.sibling } } function aN(o, c) { for (; Sr !== null;) { var h = Sr; switch (h.tag) { case 0: case 11: case 15: to(8, h, c); break; case 23: case 22: if (h.memoizedState !== null && h.memoizedState.cachePool !== null) { var m = h.memoizedState.cachePool.pool; m != null && m.refCount++ } break; case 24: ed(h.memoizedState.cache) }if (m = h.child, m !== null) m.return = h, Sr = m; else e: for (h = o; Sr !== null;) { m = Sr; var x = m.sibling, w = m.return; if (QT(m), m === h) { Sr = null; break e } if (x !== null) { x.return = w, Sr = x; break e } Sr = w } } } var ZL = { getCacheForType: function (o) { var c = Vr(mr), h = c.data.get(o); return h === void 0 && (h = o(), c.data.set(o, h)), h } }, eP = typeof WeakMap == "function" ? WeakMap : Map, mn = 0, Nn = null, Xt = null, tn = 0, gn = 0, Mi = null, io = !1, Rc = !1, fv = !1, wa = 0, qn = 0, so = 0, ml = 0, hv = 0, Qi = 0, _c = 0, xd = null, fi = null, pv = !1, mv = 0, dp = 1 / 0, fp = null, ao = null, Rr = 0, oo = null, Lc = null, Pc = 0, gv = 0, yv = null, oN = null, bd = 0, vv = null; function Di() { if ((mn & 2) !== 0 && tn !== 0) return tn & -tn; if (K.T !== null) { var o = Cc; return o !== 0 ? o : Nv() } return Z() } function lN() { Qi === 0 && (Qi = (tn & 536870912) === 0 || dn ? wt() : 536870912); var o = Xi.current; return o !== null && (o.flags |= 32), Qi } function Ri(o, c, h) { (o === Nn && (gn === 2 || gn === 9) || o.cancelPendingCommit !== null) && (zc(o, 0), lo(o, tn, Qi, !1)), Ze(o, h), ((mn & 2) === 0 || o !== Nn) && (o === Nn && ((mn & 2) === 0 && (ml |= h), qn === 4 && lo(o, tn, Qi, !1)), Bs(o)) } function cN(o, c, h) { if ((mn & 6) !== 0) throw Error(r(327)); var m = !h && (c & 124) === 0 && (c & o.expiredLanes) === 0 || le(o, c), x = m ? rP(o, c) : wv(o, c, !0), w = m; do { if (x === 0) { Rc && !m && lo(o, c, 0, !1); break } else { if (h = o.current.alternate, w && !tP(h)) { x = wv(o, c, !1), w = !1; continue } if (x === 2) { if (w = c, o.errorRecoveryDisabledLanes & w) var D = 0; else D = o.pendingLanes & -536870913, D = D !== 0 ? D : D & 536870912 ? 536870912 : 0; if (D !== 0) { c = D; e: { var R = o; x = xd; var G = R.current.memoizedState.isDehydrated; if (G && (zc(R, D).flags |= 256), D = wv(R, D, !1), D !== 2) { if (fv && !G) { R.errorRecoveryDisabledLanes |= w, ml |= w, x = 4; break e } w = fi, fi = x, w !== null && (fi === null ? fi = w : fi.push.apply(fi, w)) } x = D } if (w = !1, x !== 2) continue } } if (x === 1) { zc(o, 0), lo(o, c, 0, !0); break } e: { switch (m = o, w = x, w) { case 0: case 1: throw Error(r(345)); case 4: if ((c & 4194048) !== c) break; case 6: lo(m, c, Qi, !io); break e; case 2: fi = null; break; case 3: case 5: break; default: throw Error(r(329)) }if ((c & 62914560) === c && (x = mv + 300 - be(), 10 < x)) { if (lo(m, c, Qi, !io), lt(m, 0, !0) !== 0) break e; m.timeoutHandle = IN(uN.bind(null, m, h, fi, fp, pv, c, Qi, ml, _c, io, w, 2, -0, 0), x); break e } uN(m, h, fi, fp, pv, c, Qi, ml, _c, io, w, 0, -0, 0) } } break } while (!0); Bs(o) } function uN(o, c, h, m, x, w, D, R, G, ve, _e, Fe, Ce, Ne) { if (o.timeoutHandle = -1, Fe = c.subtreeFlags, (Fe & 8192 || (Fe & 16785408) === 16785408) && (Ed = { stylesheets: null, count: 0, unsuspend: PP }, rN(c), Fe = IP(), Fe !== null)) { o.cancelPendingCommit = Fe(yN.bind(null, o, c, w, h, m, x, D, R, G, _e, 1, Ce, Ne)), lo(o, w, D, !ve); return } yN(o, c, w, h, m, x, D, R, G) } function tP(o) { for (var c = o; ;) { var h = c.tag; if ((h === 0 || h === 11 || h === 15) && c.flags & 16384 && (h = c.updateQueue, h !== null && (h = h.stores, h !== null))) for (var m = 0; m < h.length; m++) { var x = h[m], w = x.getSnapshot; x = x.value; try { if (!Ei(w(), x)) return !1 } catch { return !1 } } if (h = c.child, c.subtreeFlags & 16384 && h !== null) h.return = c, c = h; else { if (c === o) break; for (; c.sibling === null;) { if (c.return === null || c.return === o) return !0; c = c.return } c.sibling.return = c.return, c = c.sibling } } return !0 } function lo(o, c, h, m) { c &= ~hv, c &= ~ml, o.suspendedLanes |= c, o.pingedLanes &= ~c, m && (o.warmLanes |= c), m = o.expirationTimes; for (var x = c; 0 < x;) { var w = 31 - Tt(x), D = 1 << w; m[w] = -1, x &= ~D } h !== 0 && vt(o, h, c) } function hp() { return (mn & 6) === 0 ? (wd(0), !1) : !0 } function xv() { if (Xt !== null) { if (gn === 0) var o = Xt.return; else o = Xt, ha = cl = null, P0(o), kc = null, dd = 0, o = Xt; for (; o !== null;)VT(o.alternate, o), o = o.return; Xt = null } } function zc(o, c) { var h = o.timeoutHandle; h !== -1 && (o.timeoutHandle = -1, xP(h)), h = o.cancelPendingCommit, h !== null && (o.cancelPendingCommit = null, h()), xv(), Nn = o, Xt = h = ua(o.current, null), tn = c, gn = 0, Mi = null, io = !1, Rc = le(o, c), fv = !1, _c = Qi = hv = ml = so = qn = 0, fi = xd = null, pv = !1, (c & 8) !== 0 && (c |= c & 32); var m = o.entangledLanes; if (m !== 0) for (o = o.entanglements, m &= c; 0 < m;) { var x = 31 - Tt(m), w = 1 << x; c |= o[x], m &= ~w } return wa = c, Lh(), h } function dN(o, c) { qt = null, K.H = ep, c === nd || c === Hh ? (c = AC(), gn = 3) : c === NC ? (c = AC(), gn = 4) : gn = c === kT ? 8 : c !== null && typeof c == "object" && typeof c.then == "function" ? 6 : 1, Mi = c, Xt === null && (qn = 1, sp(o, Ki(c, o.current))) } function fN() { var o = K.H; return K.H = ep, o === null ? ep : o } function hN() { var o = K.A; return K.A = ZL, o } function bv() { qn = 4, io || (tn & 4194048) !== tn && Xi.current !== null || (Rc = !0), (so & 134217727) === 0 && (ml & 134217727) === 0 || Nn === null || lo(Nn, tn, Qi, !1) } function wv(o, c, h) { var m = mn; mn |= 2; var x = fN(), w = hN(); (Nn !== o || tn !== c) && (fp = null, zc(o, c)), c = !1; var D = qn; e: do try { if (gn !== 0 && Xt !== null) { var R = Xt, G = Mi; switch (gn) { case 8: xv(), D = 6; break e; case 3: case 2: case 9: case 6: Xi.current === null && (c = !0); var ve = gn; if (gn = 0, Mi = null, Ic(o, R, G, ve), h && Rc) { D = 0; break e } break; default: ve = gn, gn = 0, Mi = null, Ic(o, R, G, ve) } } nP(), D = qn; break } catch (_e) { dN(o, _e) } while (!0); return c && o.shellSuspendCounter++, ha = cl = null, mn = m, K.H = x, K.A = w, Xt === null && (Nn = null, tn = 0, Lh()), D } function nP() { for (; Xt !== null;)pN(Xt) } function rP(o, c) { var h = mn; mn |= 2; var m = fN(), x = hN(); Nn !== o || tn !== c ? (fp = null, dp = be() + 500, zc(o, c)) : Rc = le(o, c); e: do try { if (gn !== 0 && Xt !== null) { c = Xt; var w = Mi; t: switch (gn) { case 1: gn = 0, Mi = null, Ic(o, c, w, 1); break; case 2: case 9: if (jC(w)) { gn = 0, Mi = null, mN(c); break } c = function () { gn !== 2 && gn !== 9 || Nn !== o || (gn = 7), Bs(o) }, w.then(c, c); break e; case 3: gn = 7; break e; case 4: gn = 5; break e; case 7: jC(w) ? (gn = 0, Mi = null, mN(c)) : (gn = 0, Mi = null, Ic(o, c, w, 7)); break; case 5: var D = null; switch (Xt.tag) { case 26: D = Xt.memoizedState; case 5: case 27: var R = Xt; if (!D || XN(D)) { gn = 0, Mi = null; var G = R.sibling; if (G !== null) Xt = G; else { var ve = R.return; ve !== null ? (Xt = ve, pp(ve)) : Xt = null } break t } }gn = 0, Mi = null, Ic(o, c, w, 5); break; case 6: gn = 0, Mi = null, Ic(o, c, w, 6); break; case 8: xv(), qn = 6; break e; default: throw Error(r(462)) } } iP(); break } catch (_e) { dN(o, _e) } while (!0); return ha = cl = null, K.H = m, K.A = x, mn = h, Xt !== null ? 0 : (Nn = null, tn = 0, Lh(), qn) } function iP() { for (; Xt !== null && !$();)pN(Xt) } function pN(o) { var c = $T(o.alternate, o, wa); o.memoizedProps = o.pendingProps, c === null ? pp(o) : Xt = c } function mN(o) { var c = o, h = c.alternate; switch (c.tag) { case 15: case 0: c = LT(h, c, c.pendingProps, c.type, void 0, tn); break; case 11: c = LT(h, c, c.pendingProps, c.type.render, c.ref, tn); break; case 5: P0(c); default: VT(h, c), c = Xt = gC(c, wa), c = $T(h, c, wa) }o.memoizedProps = o.pendingProps, c === null ? pp(o) : Xt = c } function Ic(o, c, h, m) { ha = cl = null, P0(c), kc = null, dd = 0; var x = c.return; try { if (WL(o, x, c, h, tn)) { qn = 1, sp(o, Ki(h, o.current)), Xt = null; return } } catch (w) { if (x !== null) throw Xt = x, w; qn = 1, sp(o, Ki(h, o.current)), Xt = null; return } c.flags & 32768 ? (dn || m === 1 ? o = !0 : Rc || (tn & 536870912) !== 0 ? o = !1 : (io = o = !0, (m === 2 || m === 9 || m === 3 || m === 6) && (m = Xi.current, m !== null && m.tag === 13 && (m.flags |= 16384))), gN(c, o)) : pp(c) } function pp(o) { var c = o; do { if ((c.flags & 32768) !== 0) { gN(c, io); return } o = c.return; var h = GL(c.alternate, c, wa); if (h !== null) { Xt = h; return } if (c = c.sibling, c !== null) { Xt = c; return } Xt = c = o } while (c !== null); qn === 0 && (qn = 5) } function gN(o, c) { do { var h = XL(o.alternate, o); if (h !== null) { h.flags &= 32767, Xt = h; return } if (h = o.return, h !== null && (h.flags |= 32768, h.subtreeFlags = 0, h.deletions = null), !c && (o = o.sibling, o !== null)) { Xt = o; return } Xt = o = h } while (o !== null); qn = 6, Xt = null } function yN(o, c, h, m, x, w, D, R, G) { o.cancelPendingCommit = null; do mp(); while (Rr !== 0); if ((mn & 6) !== 0) throw Error(r(327)); if (c !== null) { if (c === o.current) throw Error(r(177)); if (w = c.lanes | c.childLanes, w |= d0, gt(o, h, w, D, R, G), o === Nn && (Xt = Nn = null, tn = 0), Lc = c, oo = o, Pc = h, gv = w, yv = x, oN = m, (c.subtreeFlags & 10256) !== 0 || (c.flags & 10256) !== 0 ? (o.callbackNode = null, o.callbackPriority = 0, lP(ee, function () { return SN(), null })) : (o.callbackNode = null, o.callbackPriority = 0), m = (c.flags & 13878) !== 0, (c.subtreeFlags & 13878) !== 0 || m) { m = K.T, K.T = null, x = te.p, te.p = 2, D = mn, mn |= 4; try { QL(o, c, h) } finally { mn = D, te.p = x, K.T = m } } Rr = 1, vN(), xN(), bN() } } function vN() { if (Rr === 1) { Rr = 0; var o = oo, c = Lc, h = (c.flags & 13878) !== 0; if ((c.subtreeFlags & 13878) !== 0 || h) { h = K.T, K.T = null; var m = te.p; te.p = 2; var x = mn; mn |= 4; try { eN(c, o); var w = Rv, D = aC(o.containerInfo), R = w.focusedElem, G = w.selectionRange; if (D !== R && R && R.ownerDocument && sC(R.ownerDocument.documentElement, R)) { if (G !== null && a0(R)) { var ve = G.start, _e = G.end; if (_e === void 0 && (_e = ve), "selectionStart" in R) R.selectionStart = ve, R.selectionEnd = Math.min(_e, R.value.length); else { var Fe = R.ownerDocument || document, Ce = Fe && Fe.defaultView || window; if (Ce.getSelection) { var Ne = Ce.getSelection(), Dt = R.textContent.length, At = Math.min(G.start, Dt), bn = G.end === void 0 ? At : Math.min(G.end, Dt); !Ne.extend && At > bn && (D = bn, bn = At, At = D); var de = iC(R, At), re = iC(R, bn); if (de && re && (Ne.rangeCount !== 1 || Ne.anchorNode !== de.node || Ne.anchorOffset !== de.offset || Ne.focusNode !== re.node || Ne.focusOffset !== re.offset)) { var ge = Fe.createRange(); ge.setStart(de.node, de.offset), Ne.removeAllRanges(), At > bn ? (Ne.addRange(ge), Ne.extend(re.node, re.offset)) : (ge.setEnd(re.node, re.offset), Ne.addRange(ge)) } } } } for (Fe = [], Ne = R; Ne = Ne.parentNode;)Ne.nodeType === 1 && Fe.push({ element: Ne, left: Ne.scrollLeft, top: Ne.scrollTop }); for (typeof R.focus == "function" && R.focus(), R = 0; R < Fe.length; R++) { var ze = Fe[R]; ze.element.scrollLeft = ze.left, ze.element.scrollTop = ze.top } } Ep = !!Dv, Rv = Dv = null } finally { mn = x, te.p = m, K.T = h } } o.current = c, Rr = 2 } } function xN() { if (Rr === 2) { Rr = 0; var o = oo, c = Lc, h = (c.flags & 8772) !== 0; if ((c.subtreeFlags & 8772) !== 0 || h) { h = K.T, K.T = null; var m = te.p; te.p = 2; var x = mn; mn |= 4; try { XT(o, c.alternate, c) } finally { mn = x, te.p = m, K.T = h } } Rr = 3 } } function bN() { if (Rr === 4 || Rr === 3) { Rr = 0, U(); var o = oo, c = Lc, h = Pc, m = oN; (c.subtreeFlags & 10256) !== 0 || (c.flags & 10256) !== 0 ? Rr = 5 : (Rr = 0, Lc = oo = null, wN(o, o.pendingLanes)); var x = o.pendingLanes; if (x === 0 && (ao = null), Un(h), c = c.stateNode, qe && typeof qe.onCommitFiberRoot == "function") try { qe.onCommitFiberRoot(Ae, c, void 0, (c.current.flags & 128) === 128) } catch { } if (m !== null) { c = K.T, x = te.p, te.p = 2, K.T = null; try { for (var w = o.onRecoverableError, D = 0; D < m.length; D++) { var R = m[D]; w(R.value, { componentStack: R.stack }) } } finally { K.T = c, te.p = x } } (Pc & 3) !== 0 && mp(), Bs(o), x = o.pendingLanes, (h & 4194090) !== 0 && (x & 42) !== 0 ? o === vv ? bd++ : (bd = 0, vv = o) : bd = 0, wd(0) } } function wN(o, c) { (o.pooledCacheLanes &= c) === 0 && (c = o.pooledCache, c != null && (o.pooledCache = null, ed(c))) } function mp(o) { return vN(), xN(), bN(), SN() } function SN() { if (Rr !== 5) return !1; var o = oo, c = gv; gv = 0; var h = Un(Pc), m = K.T, x = te.p; try { te.p = 32 > h ? 32 : h, K.T = null, h = yv, yv = null; var w = oo, D = Pc; if (Rr = 0, Lc = oo = null, Pc = 0, (mn & 6) !== 0) throw Error(r(331)); var R = mn; if (mn |= 4, sN(w.current), nN(w, w.current, D, h), mn = R, wd(0, !1), qe && typeof qe.onPostCommitFiberRoot == "function") try { qe.onPostCommitFiberRoot(Ae, w) } catch { } return !0 } finally { te.p = x, K.T = m, wN(o, c) } } function CN(o, c, h) { c = Ki(h, c), c = X0(o.stateNode, c, 2), o = Qa(o, c, 2), o !== null && (Ze(o, 2), Bs(o)) } function Sn(o, c, h) { if (o.tag === 3) CN(o, o, h); else for (; c !== null;) { if (c.tag === 3) { CN(c, o, h); break } else if (c.tag === 1) { var m = c.stateNode; if (typeof c.type.getDerivedStateFromError == "function" || typeof m.componentDidCatch == "function" && (ao === null || !ao.has(m))) { o = Ki(h, o), h = ET(2), m = Qa(c, h, 2), m !== null && (AT(h, m, c, o), Ze(m, 2), Bs(m)); break } } c = c.return } } function Sv(o, c, h) { var m = o.pingCache; if (m === null) { m = o.pingCache = new eP; var x = new Set; m.set(c, x) } else x = m.get(c), x === void 0 && (x = new Set, m.set(c, x)); x.has(h) || (fv = !0, x.add(h), o = sP.bind(null, o, c, h), c.then(o, o)) } function sP(o, c, h) { var m = o.pingCache; m !== null && m.delete(c), o.pingedLanes |= o.suspendedLanes & h, o.warmLanes &= ~h, Nn === o && (tn & h) === h && (qn === 4 || qn === 3 && (tn & 62914560) === tn && 300 > be() - mv ? (mn & 2) === 0 && zc(o, 0) : hv |= h, _c === tn && (_c = 0)), Bs(o) } function TN(o, c) { c === 0 && (c = Qe()), o = xc(o, c), o !== null && (Ze(o, c), Bs(o)) } function aP(o) { var c = o.memoizedState, h = 0; c !== null && (h = c.retryLane), TN(o, h) } function oP(o, c) { var h = 0; switch (o.tag) { case 13: var m = o.stateNode, x = o.memoizedState; x !== null && (h = x.retryLane); break; case 19: m = o.stateNode; break; case 22: m = o.stateNode._retryCache; break; default: throw Error(r(314)) }m !== null && m.delete(c), TN(o, h) } function lP(o, c) { return Je(o, c) } var gp = null, Fc = null, Cv = !1, yp = !1, Tv = !1, gl = 0; function Bs(o) { o !== Fc && o.next === null && (Fc === null ? gp = Fc = o : Fc = Fc.next = o), yp = !0, Cv || (Cv = !0, uP()) } function wd(o, c) { if (!Tv && yp) { Tv = !0; do for (var h = !1, m = gp; m !== null;) { if (o !== 0) { var x = m.pendingLanes; if (x === 0) var w = 0; else { var D = m.suspendedLanes, R = m.pingedLanes; w = (1 << 31 - Tt(42 | o) + 1) - 1, w &= x & ~(D & ~R), w = w & 201326741 ? w & 201326741 | 1 : w ? w | 2 : 0 } w !== 0 && (h = !0, AN(m, w)) } else w = tn, w = lt(m, m === Nn ? w : 0, m.cancelPendingCommit !== null || m.timeoutHandle !== -1), (w & 3) === 0 || le(m, w) || (h = !0, AN(m, w)); m = m.next } while (h); Tv = !1 } } function cP() { NN() } function NN() { yp = Cv = !1; var o = 0; gl !== 0 && (vP() && (o = gl), gl = 0); for (var c = be(), h = null, m = gp; m !== null;) { var x = m.next, w = jN(m, c); w === 0 ? (m.next = null, h === null ? gp = x : h.next = x, x === null && (Fc = h)) : (h = m, (o !== 0 || (w & 3) !== 0) && (yp = !0)), m = x } wd(o) } function jN(o, c) { for (var h = o.suspendedLanes, m = o.pingedLanes, x = o.expirationTimes, w = o.pendingLanes & -62914561; 0 < w;) { var D = 31 - Tt(w), R = 1 << D, G = x[D]; G === -1 ? ((R & h) === 0 || (R & m) !== 0) && (x[D] = st(R, c)) : G <= c && (o.expiredLanes |= R), w &= ~R } if (c = Nn, h = tn, h = lt(o, o === c ? h : 0, o.cancelPendingCommit !== null || o.timeoutHandle !== -1), m = o.callbackNode, h === 0 || o === c && (gn === 2 || gn === 9) || o.cancelPendingCommit !== null) return m !== null && m !== null && $e(m), o.callbackNode = null, o.callbackPriority = 0; if ((h & 3) === 0 || le(o, h)) { if (c = h & -h, c === o.callbackPriority) return c; switch (m !== null && $e(m), Un(h)) { case 2: case 8: h = P; break; case 32: h = ee; break; case 268435456: h = I; break; default: h = ee }return m = EN.bind(null, o), h = Je(h, m), o.callbackPriority = c, o.callbackNode = h, c } return m !== null && m !== null && $e(m), o.callbackPriority = 2, o.callbackNode = null, 2 } function EN(o, c) { if (Rr !== 0 && Rr !== 5) return o.callbackNode = null, o.callbackPriority = 0, null; var h = o.callbackNode; if (mp() && o.callbackNode !== h) return null; var m = tn; return m = lt(o, o === Nn ? m : 0, o.cancelPendingCommit !== null || o.timeoutHandle !== -1), m === 0 ? null : (cN(o, m, c), jN(o, be()), o.callbackNode != null && o.callbackNode === h ? EN.bind(null, o) : null) } function AN(o, c) { if (mp()) return null; cN(o, c, !0) } function uP() { bP(function () { (mn & 6) !== 0 ? Je(it, cP) : NN() }) } function Nv() { return gl === 0 && (gl = wt()), gl } function kN(o) { return o == null || typeof o == "symbol" || typeof o == "boolean" ? null : typeof o == "function" ? o : Iu("" + o) } function ON(o, c) { var h = c.ownerDocument.createElement("input"); return h.name = c.name, h.value = c.value, o.id && h.setAttribute("form", o.id), c.parentNode.insertBefore(h, c), o = new FormData(o), h.parentNode.removeChild(h), o } function dP(o, c, h, m, x) { if (c === "submit" && h && h.stateNode === x) { var w = kN((x[We] || null).action), D = m.submitter; D && (c = (c = D[We] || null) ? kN(c.formAction) : D.getAttribute("formAction"), c !== null && (w = c, D = null)); var R = new Dh("action", "action", null, m, x); o.push({ event: R, listeners: [{ instance: null, listener: function () { if (m.defaultPrevented) { if (gl !== 0) { var G = D ? ON(x, D) : new FormData(x); q0(h, { pending: !0, data: G, method: x.method, action: w }, null, G) } } else typeof w == "function" && (R.preventDefault(), G = D ? ON(x, D) : new FormData(x), q0(h, { pending: !0, data: G, method: x.method, action: w }, w, G)) }, currentTarget: x }] }) } } for (var jv = 0; jv < u0.length; jv++) { var Ev = u0[jv], fP = Ev.toLowerCase(), hP = Ev[0].toUpperCase() + Ev.slice(1); ps(fP, "on" + hP) } ps(cC, "onAnimationEnd"), ps(uC, "onAnimationIteration"), ps(dC, "onAnimationStart"), ps("dblclick", "onDoubleClick"), ps("focusin", "onFocus"), ps("focusout", "onBlur"), ps(OL, "onTransitionRun"), ps(ML, "onTransitionStart"), ps(DL, "onTransitionCancel"), ps(fC, "onTransitionEnd"), $r("onMouseEnter", ["mouseout", "mouseover"]), $r("onMouseLeave", ["mouseout", "mouseover"]), $r("onPointerEnter", ["pointerout", "pointerover"]), $r("onPointerLeave", ["pointerout", "pointerover"]), pr("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), pr("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), pr("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), pr("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), pr("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), pr("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Sd = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), pP = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Sd)); function MN(o, c) { c = (c & 4) !== 0; for (var h = 0; h < o.length; h++) { var m = o[h], x = m.event; m = m.listeners; e: { var w = void 0; if (c) for (var D = m.length - 1; 0 <= D; D--) { var R = m[D], G = R.instance, ve = R.currentTarget; if (R = R.listener, G !== w && x.isPropagationStopped()) break e; w = R, x.currentTarget = ve; try { w(x) } catch (_e) { ip(_e) } x.currentTarget = null, w = G } else for (D = 0; D < m.length; D++) { if (R = m[D], G = R.instance, ve = R.currentTarget, R = R.listener, G !== w && x.isPropagationStopped()) break e; w = R, x.currentTarget = ve; try { w(x) } catch (_e) { ip(_e) } x.currentTarget = null, w = G } } } } function Qt(o, c) { var h = c[xt]; h === void 0 && (h = c[xt] = new Set); var m = o + "__bubble"; h.has(m) || (DN(c, o, 2, !1), h.add(m)) } function Av(o, c, h) { var m = 0; c && (m |= 4), DN(h, o, m, c) } var vp = "_reactListening" + Math.random().toString(36).slice(2); function kv(o) { if (!o[vp]) { o[vp] = !0, Ht.forEach(function (h) { h !== "selectionchange" && (pP.has(h) || Av(h, !1, o), Av(h, !0, o)) }); var c = o.nodeType === 9 ? o : o.ownerDocument; c === null || c[vp] || (c[vp] = !0, Av("selectionchange", !1, c)) } } function DN(o, c, h, m) { switch (nj(c)) { case 2: var x = $P; break; case 8: x = UP; break; default: x = Vv }h = x.bind(null, c, h, o), x = void 0, !Qy || c !== "touchstart" && c !== "touchmove" && c !== "wheel" || (x = !0), m ? x !== void 0 ? o.addEventListener(c, h, { capture: !0, passive: x }) : o.addEventListener(c, h, !0) : x !== void 0 ? o.addEventListener(c, h, { passive: x }) : o.addEventListener(c, h, !1) } function Ov(o, c, h, m, x) { var w = m; if ((c & 1) === 0 && (c & 2) === 0 && m !== null) e: for (; ;) { if (m === null) return; var D = m.tag; if (D === 3 || D === 4) { var R = m.stateNode.containerInfo; if (R === x) break; if (D === 4) for (D = m.return; D !== null;) { var G = D.tag; if ((G === 3 || G === 4) && D.stateNode.containerInfo === x) return; D = D.return } for (; R !== null;) { if (D = Mt(R), D === null) return; if (G = D.tag, G === 5 || G === 6 || G === 26 || G === 27) { m = w = D; continue e } R = R.parentNode } } m = m.return } F2(function () { var ve = w, _e = Bu(h), Fe = []; e: { var Ce = hC.get(o); if (Ce !== void 0) { var Ne = Dh, Dt = o; switch (o) { case "keypress": if (Oh(h) === 0) break e; case "keydown": case "keyup": Ne = lL; break; case "focusin": Dt = "focus", Ne = t0; break; case "focusout": Dt = "blur", Ne = t0; break; case "beforeblur": case "afterblur": Ne = t0; break; case "click": if (h.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": Ne = U2; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": Ne = X6; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": Ne = dL; break; case cC: case uC: case dC: Ne = Z6; break; case fC: Ne = hL; break; case "scroll": case "scrollend": Ne = Y6; break; case "wheel": Ne = mL; break; case "copy": case "cut": case "paste": Ne = tL; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": Ne = H2; break; case "toggle": case "beforetoggle": Ne = yL }var At = (c & 4) !== 0, bn = !At && (o === "scroll" || o === "scrollend"), de = At ? Ce !== null ? Ce + "Capture" : null : Ce; At = []; for (var re = ve, ge; re !== null;) { var ze = re; if (ge = ze.stateNode, ze = ze.tag, ze !== 5 && ze !== 26 && ze !== 27 || ge === null || de === null || (ze = $u(re, de), ze != null && At.push(Cd(re, ze, ge))), bn) break; re = re.return } 0 < At.length && (Ce = new Ne(Ce, Dt, null, h, _e), Fe.push({ event: Ce, listeners: At })) } } if ((c & 7) === 0) { e: { if (Ce = o === "mouseover" || o === "pointerover", Ne = o === "mouseout" || o === "pointerout", Ce && h !== Fu && (Dt = h.relatedTarget || h.fromElement) && (Mt(Dt) || Dt[ct])) break e; if ((Ne || Ce) && (Ce = _e.window === _e ? _e : (Ce = _e.ownerDocument) ? Ce.defaultView || Ce.parentWindow : window, Ne ? (Dt = h.relatedTarget || h.toElement, Ne = ve, Dt = Dt ? Mt(Dt) : null, Dt !== null && (bn = s(Dt), At = Dt.tag, Dt !== bn || At !== 5 && At !== 27 && At !== 6) && (Dt = null)) : (Ne = null, Dt = ve), Ne !== Dt)) { if (At = U2, ze = "onMouseLeave", de = "onMouseEnter", re = "mouse", (o === "pointerout" || o === "pointerover") && (At = H2, ze = "onPointerLeave", de = "onPointerEnter", re = "pointer"), bn = Ne == null ? Ce : hn(Ne), ge = Dt == null ? Ce : hn(Dt), Ce = new At(ze, re + "leave", Ne, h, _e), Ce.target = bn, Ce.relatedTarget = ge, ze = null, Mt(_e) === ve && (At = new At(de, re + "enter", Dt, h, _e), At.target = ge, At.relatedTarget = bn, ze = At), bn = ze, Ne && Dt) t: { for (At = Ne, de = Dt, re = 0, ge = At; ge; ge = Bc(ge))re++; for (ge = 0, ze = de; ze; ze = Bc(ze))ge++; for (; 0 < re - ge;)At = Bc(At), re--; for (; 0 < ge - re;)de = Bc(de), ge--; for (; re--;) { if (At === de || de !== null && At === de.alternate) break t; At = Bc(At), de = Bc(de) } At = null } else At = null; Ne !== null && RN(Fe, Ce, Ne, At, !1), Dt !== null && bn !== null && RN(Fe, bn, Dt, At, !0) } } e: { if (Ce = ve ? hn(ve) : window, Ne = Ce.nodeName && Ce.nodeName.toLowerCase(), Ne === "select" || Ne === "input" && Ce.type === "file") var ht = J2; else if (X2(Ce)) if (Z2) ht = EL; else { ht = NL; var Wt = TL } else Ne = Ce.nodeName, !Ne || Ne.toLowerCase() !== "input" || Ce.type !== "checkbox" && Ce.type !== "radio" ? ve && el(ve.elementType) && (ht = J2) : ht = jL; if (ht && (ht = ht(o, ve))) { Q2(Fe, ht, h, _e); break e } Wt && Wt(o, Ce, ve), o === "focusout" && ve && Ce.type === "number" && ve.memoizedProps.value != null && ft(Ce, "number", Ce.value) } switch (Wt = ve ? hn(ve) : window, o) { case "focusin": (X2(Wt) || Wt.contentEditable === "true") && (gc = Wt, o0 = ve, Gu = null); break; case "focusout": Gu = o0 = gc = null; break; case "mousedown": l0 = !0; break; case "contextmenu": case "mouseup": case "dragend": l0 = !1, oC(Fe, h, _e); break; case "selectionchange": if (kL) break; case "keydown": case "keyup": oC(Fe, h, _e) }var bt; if (r0) e: { switch (o) { case "compositionstart": var kt = "onCompositionStart"; break e; case "compositionend": kt = "onCompositionEnd"; break e; case "compositionupdate": kt = "onCompositionUpdate"; break e }kt = void 0 } else mc ? Y2(o, h) && (kt = "onCompositionEnd") : o === "keydown" && h.keyCode === 229 && (kt = "onCompositionStart"); kt && (q2 && h.locale !== "ko" && (mc || kt !== "onCompositionStart" ? kt === "onCompositionEnd" && mc && (bt = B2()) : (Wa = _e, Jy = "value" in Wa ? Wa.value : Wa.textContent, mc = !0)), Wt = xp(ve, kt), 0 < Wt.length && (kt = new V2(kt, o, null, h, _e), Fe.push({ event: kt, listeners: Wt }), bt ? kt.data = bt : (bt = G2(h), bt !== null && (kt.data = bt)))), (bt = xL ? bL(o, h) : wL(o, h)) && (kt = xp(ve, "onBeforeInput"), 0 < kt.length && (Wt = new V2("onBeforeInput", "beforeinput", null, h, _e), Fe.push({ event: Wt, listeners: kt }), Wt.data = bt)), dP(Fe, o, ve, h, _e) } MN(Fe, c) }) } function Cd(o, c, h) { return { instance: o, listener: c, currentTarget: h } } function xp(o, c) { for (var h = c + "Capture", m = []; o !== null;) { var x = o, w = x.stateNode; if (x = x.tag, x !== 5 && x !== 26 && x !== 27 || w === null || (x = $u(o, h), x != null && m.unshift(Cd(o, x, w)), x = $u(o, c), x != null && m.push(Cd(o, x, w))), o.tag === 3) return m; o = o.return } return [] } function Bc(o) { if (o === null) return null; do o = o.return; while (o && o.tag !== 5 && o.tag !== 27); return o || null } function RN(o, c, h, m, x) { for (var w = c._reactName, D = []; h !== null && h !== m;) { var R = h, G = R.alternate, ve = R.stateNode; if (R = R.tag, G !== null && G === m) break; R !== 5 && R !== 26 && R !== 27 || ve === null || (G = ve, x ? (ve = $u(h, w), ve != null && D.unshift(Cd(h, ve, G))) : x || (ve = $u(h, w), ve != null && D.push(Cd(h, ve, G)))), h = h.return } D.length !== 0 && o.push({ event: c, listeners: D }) } var mP = /\r\n?/g, gP = /\u0000|\uFFFD/g; function _N(o) {
      return (typeof o == "string" ? o : "" + o).replace(mP, `
`).replace(gP, "")
    } function LN(o, c) { return c = _N(c), _N(o) === c } function bp() { } function xn(o, c, h, m, x, w) { switch (h) { case "children": typeof m == "string" ? c === "body" || c === "textarea" && m === "" || wn(o, m) : (typeof m == "number" || typeof m == "bigint") && c !== "body" && wn(o, "" + m); break; case "className": Ni(o, "class", m); break; case "tabIndex": Ni(o, "tabindex", m); break; case "dir": case "role": case "viewBox": case "width": case "height": Ni(o, h, m); break; case "style": Ka(o, m, w); break; case "data": if (c !== "object") { Ni(o, "data", m); break } case "src": case "href": if (m === "" && (c !== "a" || h !== "href")) { o.removeAttribute(h); break } if (m == null || typeof m == "function" || typeof m == "symbol" || typeof m == "boolean") { o.removeAttribute(h); break } m = Iu("" + m), o.setAttribute(h, m); break; case "action": case "formAction": if (typeof m == "function") { o.setAttribute(h, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"); break } else typeof w == "function" && (h === "formAction" ? (c !== "input" && xn(o, c, "name", x.name, x, null), xn(o, c, "formEncType", x.formEncType, x, null), xn(o, c, "formMethod", x.formMethod, x, null), xn(o, c, "formTarget", x.formTarget, x, null)) : (xn(o, c, "encType", x.encType, x, null), xn(o, c, "method", x.method, x, null), xn(o, c, "target", x.target, x, null))); if (m == null || typeof m == "symbol" || typeof m == "boolean") { o.removeAttribute(h); break } m = Iu("" + m), o.setAttribute(h, m); break; case "onClick": m != null && (o.onclick = bp); break; case "onScroll": m != null && Qt("scroll", o); break; case "onScrollEnd": m != null && Qt("scrollend", o); break; case "dangerouslySetInnerHTML": if (m != null) { if (typeof m != "object" || !("__html" in m)) throw Error(r(61)); if (h = m.__html, h != null) { if (x.children != null) throw Error(r(60)); o.innerHTML = h } } break; case "multiple": o.multiple = m && typeof m != "function" && typeof m != "symbol"; break; case "muted": o.muted = m && typeof m != "function" && typeof m != "symbol"; break; case "suppressContentEditableWarning": case "suppressHydrationWarning": case "defaultValue": case "defaultChecked": case "innerHTML": case "ref": break; case "autoFocus": break; case "xlinkHref": if (m == null || typeof m == "function" || typeof m == "boolean" || typeof m == "symbol") { o.removeAttribute("xlink:href"); break } h = Iu("" + m), o.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", h); break; case "contentEditable": case "spellCheck": case "draggable": case "value": case "autoReverse": case "externalResourcesRequired": case "focusable": case "preserveAlpha": m != null && typeof m != "function" && typeof m != "symbol" ? o.setAttribute(h, "" + m) : o.removeAttribute(h); break; case "inert": case "allowFullScreen": case "async": case "autoPlay": case "controls": case "default": case "defer": case "disabled": case "disablePictureInPicture": case "disableRemotePlayback": case "formNoValidate": case "hidden": case "loop": case "noModule": case "noValidate": case "open": case "playsInline": case "readOnly": case "required": case "reversed": case "scoped": case "seamless": case "itemScope": m && typeof m != "function" && typeof m != "symbol" ? o.setAttribute(h, "") : o.removeAttribute(h); break; case "capture": case "download": m === !0 ? o.setAttribute(h, "") : m !== !1 && m != null && typeof m != "function" && typeof m != "symbol" ? o.setAttribute(h, m) : o.removeAttribute(h); break; case "cols": case "rows": case "size": case "span": m != null && typeof m != "function" && typeof m != "symbol" && !isNaN(m) && 1 <= m ? o.setAttribute(h, m) : o.removeAttribute(h); break; case "rowSpan": case "start": m == null || typeof m == "function" || typeof m == "symbol" || isNaN(m) ? o.removeAttribute(h) : o.setAttribute(h, m); break; case "popover": Qt("beforetoggle", o), Qt("toggle", o), Jn(o, "popover", m); break; case "xlinkActuate": _t(o, "http://www.w3.org/1999/xlink", "xlink:actuate", m); break; case "xlinkArcrole": _t(o, "http://www.w3.org/1999/xlink", "xlink:arcrole", m); break; case "xlinkRole": _t(o, "http://www.w3.org/1999/xlink", "xlink:role", m); break; case "xlinkShow": _t(o, "http://www.w3.org/1999/xlink", "xlink:show", m); break; case "xlinkTitle": _t(o, "http://www.w3.org/1999/xlink", "xlink:title", m); break; case "xlinkType": _t(o, "http://www.w3.org/1999/xlink", "xlink:type", m); break; case "xmlBase": _t(o, "http://www.w3.org/XML/1998/namespace", "xml:base", m); break; case "xmlLang": _t(o, "http://www.w3.org/XML/1998/namespace", "xml:lang", m); break; case "xmlSpace": _t(o, "http://www.w3.org/XML/1998/namespace", "xml:space", m); break; case "is": Jn(o, "is", m); break; case "innerText": case "textContent": break; default: (!(2 < h.length) || h[0] !== "o" && h[0] !== "O" || h[1] !== "n" && h[1] !== "N") && (h = Gy.get(h) || h, Jn(o, h, m)) } } function Mv(o, c, h, m, x, w) { switch (h) { case "style": Ka(o, m, w); break; case "dangerouslySetInnerHTML": if (m != null) { if (typeof m != "object" || !("__html" in m)) throw Error(r(61)); if (h = m.__html, h != null) { if (x.children != null) throw Error(r(60)); o.innerHTML = h } } break; case "children": typeof m == "string" ? wn(o, m) : (typeof m == "number" || typeof m == "bigint") && wn(o, "" + m); break; case "onScroll": m != null && Qt("scroll", o); break; case "onScrollEnd": m != null && Qt("scrollend", o); break; case "onClick": m != null && (o.onclick = bp); break; case "suppressContentEditableWarning": case "suppressHydrationWarning": case "innerHTML": case "ref": break; case "innerText": case "textContent": break; default: if (!Hi.hasOwnProperty(h)) e: { if (h[0] === "o" && h[1] === "n" && (x = h.endsWith("Capture"), c = h.slice(2, x ? h.length - 7 : void 0), w = o[We] || null, w = w != null ? w[h] : null, typeof w == "function" && o.removeEventListener(c, w, x), typeof m == "function")) { typeof w != "function" && w !== null && (h in o ? o[h] = null : o.hasAttribute(h) && o.removeAttribute(h)), o.addEventListener(c, m, x); break e } h in o ? o[h] = m : m === !0 ? o.setAttribute(h, "") : Jn(o, h, m) } } } function _r(o, c, h) { switch (c) { case "div": case "span": case "svg": case "path": case "a": case "g": case "p": case "li": break; case "img": Qt("error", o), Qt("load", o); var m = !1, x = !1, w; for (w in h) if (h.hasOwnProperty(w)) { var D = h[w]; if (D != null) switch (w) { case "src": m = !0; break; case "srcSet": x = !0; break; case "children": case "dangerouslySetInnerHTML": throw Error(r(137, c)); default: xn(o, c, w, D, h, null) } } x && xn(o, c, "srcSet", h.srcSet, h, null), m && xn(o, c, "src", h.src, h, null); return; case "input": Qt("invalid", o); var R = w = D = x = null, G = null, ve = null; for (m in h) if (h.hasOwnProperty(m)) { var _e = h[m]; if (_e != null) switch (m) { case "name": x = _e; break; case "type": D = _e; break; case "checked": G = _e; break; case "defaultChecked": ve = _e; break; case "value": w = _e; break; case "defaultValue": R = _e; break; case "children": case "dangerouslySetInnerHTML": if (_e != null) throw Error(r(137, c)); break; default: xn(o, c, m, _e, h, null) } } Ge(o, w, R, G, ve, D, x, !1), J(o); return; case "select": Qt("invalid", o), m = D = w = null; for (x in h) if (h.hasOwnProperty(x) && (R = h[x], R != null)) switch (x) { case "value": w = R; break; case "defaultValue": D = R; break; case "multiple": m = R; default: xn(o, c, x, R, h, null) }c = w, h = D, o.multiple = !!m, c != null ? Lt(o, !!m, c, !1) : h != null && Lt(o, !!m, h, !0); return; case "textarea": Qt("invalid", o), w = x = m = null; for (D in h) if (h.hasOwnProperty(D) && (R = h[D], R != null)) switch (D) { case "value": m = R; break; case "defaultValue": x = R; break; case "children": w = R; break; case "dangerouslySetInnerHTML": if (R != null) throw Error(r(91)); break; default: xn(o, c, D, R, h, null) }an(o, m, x, w), J(o); return; case "option": for (G in h) if (h.hasOwnProperty(G) && (m = h[G], m != null)) switch (G) { case "selected": o.selected = m && typeof m != "function" && typeof m != "symbol"; break; default: xn(o, c, G, m, h, null) }return; case "dialog": Qt("beforetoggle", o), Qt("toggle", o), Qt("cancel", o), Qt("close", o); break; case "iframe": case "object": Qt("load", o); break; case "video": case "audio": for (m = 0; m < Sd.length; m++)Qt(Sd[m], o); break; case "image": Qt("error", o), Qt("load", o); break; case "details": Qt("toggle", o); break; case "embed": case "source": case "link": Qt("error", o), Qt("load", o); case "area": case "base": case "br": case "col": case "hr": case "keygen": case "meta": case "param": case "track": case "wbr": case "menuitem": for (ve in h) if (h.hasOwnProperty(ve) && (m = h[ve], m != null)) switch (ve) { case "children": case "dangerouslySetInnerHTML": throw Error(r(137, c)); default: xn(o, c, ve, m, h, null) }return; default: if (el(c)) { for (_e in h) h.hasOwnProperty(_e) && (m = h[_e], m !== void 0 && Mv(o, c, _e, m, h, void 0)); return } }for (R in h) h.hasOwnProperty(R) && (m = h[R], m != null && xn(o, c, R, m, h, null)) } function yP(o, c, h, m) { switch (c) { case "div": case "span": case "svg": case "path": case "a": case "g": case "p": case "li": break; case "input": var x = null, w = null, D = null, R = null, G = null, ve = null, _e = null; for (Ne in h) { var Fe = h[Ne]; if (h.hasOwnProperty(Ne) && Fe != null) switch (Ne) { case "checked": break; case "value": break; case "defaultValue": G = Fe; default: m.hasOwnProperty(Ne) || xn(o, c, Ne, null, m, Fe) } } for (var Ce in m) { var Ne = m[Ce]; if (Fe = h[Ce], m.hasOwnProperty(Ce) && (Ne != null || Fe != null)) switch (Ce) { case "type": w = Ne; break; case "name": x = Ne; break; case "checked": ve = Ne; break; case "defaultChecked": _e = Ne; break; case "value": D = Ne; break; case "defaultValue": R = Ne; break; case "children": case "dangerouslySetInnerHTML": if (Ne != null) throw Error(r(137, c)); break; default: Ne !== Fe && xn(o, c, Ce, Ne, m, Fe) } } Ke(o, D, R, G, ve, _e, w, x); return; case "select": Ne = D = R = Ce = null; for (w in h) if (G = h[w], h.hasOwnProperty(w) && G != null) switch (w) { case "value": break; case "multiple": Ne = G; default: m.hasOwnProperty(w) || xn(o, c, w, null, m, G) }for (x in m) if (w = m[x], G = h[x], m.hasOwnProperty(x) && (w != null || G != null)) switch (x) { case "value": Ce = w; break; case "defaultValue": R = w; break; case "multiple": D = w; default: w !== G && xn(o, c, x, w, m, G) }c = R, h = D, m = Ne, Ce != null ? Lt(o, !!h, Ce, !1) : !!m != !!h && (c != null ? Lt(o, !!h, c, !0) : Lt(o, !!h, h ? [] : "", !1)); return; case "textarea": Ne = Ce = null; for (R in h) if (x = h[R], h.hasOwnProperty(R) && x != null && !m.hasOwnProperty(R)) switch (R) { case "value": break; case "children": break; default: xn(o, c, R, null, m, x) }for (D in m) if (x = m[D], w = h[D], m.hasOwnProperty(D) && (x != null || w != null)) switch (D) { case "value": Ce = x; break; case "defaultValue": Ne = x; break; case "children": break; case "dangerouslySetInnerHTML": if (x != null) throw Error(r(91)); break; default: x !== w && xn(o, c, D, x, m, w) }sn(o, Ce, Ne); return; case "option": for (var Dt in h) if (Ce = h[Dt], h.hasOwnProperty(Dt) && Ce != null && !m.hasOwnProperty(Dt)) switch (Dt) { case "selected": o.selected = !1; break; default: xn(o, c, Dt, null, m, Ce) }for (G in m) if (Ce = m[G], Ne = h[G], m.hasOwnProperty(G) && Ce !== Ne && (Ce != null || Ne != null)) switch (G) { case "selected": o.selected = Ce && typeof Ce != "function" && typeof Ce != "symbol"; break; default: xn(o, c, G, Ce, m, Ne) }return; case "img": case "link": case "area": case "base": case "br": case "col": case "embed": case "hr": case "keygen": case "meta": case "param": case "source": case "track": case "wbr": case "menuitem": for (var At in h) Ce = h[At], h.hasOwnProperty(At) && Ce != null && !m.hasOwnProperty(At) && xn(o, c, At, null, m, Ce); for (ve in m) if (Ce = m[ve], Ne = h[ve], m.hasOwnProperty(ve) && Ce !== Ne && (Ce != null || Ne != null)) switch (ve) { case "children": case "dangerouslySetInnerHTML": if (Ce != null) throw Error(r(137, c)); break; default: xn(o, c, ve, Ce, m, Ne) }return; default: if (el(c)) { for (var bn in h) Ce = h[bn], h.hasOwnProperty(bn) && Ce !== void 0 && !m.hasOwnProperty(bn) && Mv(o, c, bn, void 0, m, Ce); for (_e in m) Ce = m[_e], Ne = h[_e], !m.hasOwnProperty(_e) || Ce === Ne || Ce === void 0 && Ne === void 0 || Mv(o, c, _e, Ce, m, Ne); return } }for (var de in h) Ce = h[de], h.hasOwnProperty(de) && Ce != null && !m.hasOwnProperty(de) && xn(o, c, de, null, m, Ce); for (Fe in m) Ce = m[Fe], Ne = h[Fe], !m.hasOwnProperty(Fe) || Ce === Ne || Ce == null && Ne == null || xn(o, c, Fe, Ce, m, Ne) } var Dv = null, Rv = null; function wp(o) { return o.nodeType === 9 ? o : o.ownerDocument } function PN(o) { switch (o) { case "http://www.w3.org/2000/svg": return 1; case "http://www.w3.org/1998/Math/MathML": return 2; default: return 0 } } function zN(o, c) { if (o === 0) switch (c) { case "svg": return 1; case "math": return 2; default: return 0 }return o === 1 && c === "foreignObject" ? 0 : o } function _v(o, c) { return o === "textarea" || o === "noscript" || typeof c.children == "string" || typeof c.children == "number" || typeof c.children == "bigint" || typeof c.dangerouslySetInnerHTML == "object" && c.dangerouslySetInnerHTML !== null && c.dangerouslySetInnerHTML.__html != null } var Lv = null; function vP() { var o = window.event; return o && o.type === "popstate" ? o === Lv ? !1 : (Lv = o, !0) : (Lv = null, !1) } var IN = typeof setTimeout == "function" ? setTimeout : void 0, xP = typeof clearTimeout == "function" ? clearTimeout : void 0, FN = typeof Promise == "function" ? Promise : void 0, bP = typeof queueMicrotask == "function" ? queueMicrotask : typeof FN < "u" ? function (o) { return FN.resolve(null).then(o).catch(wP) } : IN; function wP(o) { setTimeout(function () { throw o }) } function co(o) { return o === "head" } function BN(o, c) { var h = c, m = 0, x = 0; do { var w = h.nextSibling; if (o.removeChild(h), w && w.nodeType === 8) if (h = w.data, h === "/$") { if (0 < m && 8 > m) { h = m; var D = o.ownerDocument; if (h & 1 && Td(D.documentElement), h & 2 && Td(D.body), h & 4) for (h = D.head, Td(h), D = h.firstChild; D;) { var R = D.nextSibling, G = D.nodeName; D[jt] || G === "SCRIPT" || G === "STYLE" || G === "LINK" && D.rel.toLowerCase() === "stylesheet" || h.removeChild(D), D = R } } if (x === 0) { o.removeChild(w), Dd(c); return } x-- } else h === "$" || h === "$?" || h === "$!" ? x++ : m = h.charCodeAt(0) - 48; else m = 0; h = w } while (h); Dd(c) } function Pv(o) { var c = o.firstChild; for (c && c.nodeType === 10 && (c = c.nextSibling); c;) { var h = c; switch (c = c.nextSibling, h.nodeName) { case "HTML": case "HEAD": case "BODY": Pv(h), St(h); continue; case "SCRIPT": case "STYLE": continue; case "LINK": if (h.rel.toLowerCase() === "stylesheet") continue }o.removeChild(h) } } function SP(o, c, h, m) { for (; o.nodeType === 1;) { var x = h; if (o.nodeName.toLowerCase() !== c.toLowerCase()) { if (!m && (o.nodeName !== "INPUT" || o.type !== "hidden")) break } else if (m) { if (!o[jt]) switch (c) { case "meta": if (!o.hasAttribute("itemprop")) break; return o; case "link": if (w = o.getAttribute("rel"), w === "stylesheet" && o.hasAttribute("data-precedence")) break; if (w !== x.rel || o.getAttribute("href") !== (x.href == null || x.href === "" ? null : x.href) || o.getAttribute("crossorigin") !== (x.crossOrigin == null ? null : x.crossOrigin) || o.getAttribute("title") !== (x.title == null ? null : x.title)) break; return o; case "style": if (o.hasAttribute("data-precedence")) break; return o; case "script": if (w = o.getAttribute("src"), (w !== (x.src == null ? null : x.src) || o.getAttribute("type") !== (x.type == null ? null : x.type) || o.getAttribute("crossorigin") !== (x.crossOrigin == null ? null : x.crossOrigin)) && w && o.hasAttribute("async") && !o.hasAttribute("itemprop")) break; return o; default: return o } } else if (c === "input" && o.type === "hidden") { var w = x.name == null ? null : "" + x.name; if (x.type === "hidden" && o.getAttribute("name") === w) return o } else return o; if (o = gs(o.nextSibling), o === null) break } return null } function CP(o, c, h) { if (c === "") return null; for (; o.nodeType !== 3;)if ((o.nodeType !== 1 || o.nodeName !== "INPUT" || o.type !== "hidden") && !h || (o = gs(o.nextSibling), o === null)) return null; return o } function zv(o) { return o.data === "$!" || o.data === "$?" && o.ownerDocument.readyState === "complete" } function TP(o, c) { var h = o.ownerDocument; if (o.data !== "$?" || h.readyState === "complete") c(); else { var m = function () { c(), h.removeEventListener("DOMContentLoaded", m) }; h.addEventListener("DOMContentLoaded", m), o._reactRetry = m } } function gs(o) { for (; o != null; o = o.nextSibling) { var c = o.nodeType; if (c === 1 || c === 3) break; if (c === 8) { if (c = o.data, c === "$" || c === "$!" || c === "$?" || c === "F!" || c === "F") break; if (c === "/$") return null } } return o } var Iv = null; function $N(o) { o = o.previousSibling; for (var c = 0; o;) { if (o.nodeType === 8) { var h = o.data; if (h === "$" || h === "$!" || h === "$?") { if (c === 0) return o; c-- } else h === "/$" && c++ } o = o.previousSibling } return null } function UN(o, c, h) { switch (c = wp(h), o) { case "html": if (o = c.documentElement, !o) throw Error(r(452)); return o; case "head": if (o = c.head, !o) throw Error(r(453)); return o; case "body": if (o = c.body, !o) throw Error(r(454)); return o; default: throw Error(r(451)) } } function Td(o) { for (var c = o.attributes; c.length;)o.removeAttributeNode(c[0]); St(o) } var Ji = new Map, VN = new Set; function Sp(o) { return typeof o.getRootNode == "function" ? o.getRootNode() : o.nodeType === 9 ? o : o.ownerDocument } var Sa = te.d; te.d = { f: NP, r: jP, D: EP, C: AP, L: kP, m: OP, X: DP, S: MP, M: RP }; function NP() { var o = Sa.f(), c = hp(); return o || c } function jP(o) { var c = zt(o); c !== null && c.tag === 5 && c.type === "form" ? cT(c) : Sa.r(o) } var $c = typeof document > "u" ? null : document; function HN(o, c, h) { var m = $c; if (m && typeof c == "string" && c) { var x = Re(c); x = 'link[rel="' + o + '"][href="' + x + '"]', typeof h == "string" && (x += '[crossorigin="' + h + '"]'), VN.has(x) || (VN.add(x), o = { rel: o, crossOrigin: h, href: c }, m.querySelector(x) === null && (c = m.createElement("link"), _r(c, "link", o), Zt(c), m.head.appendChild(c))) } } function EP(o) { Sa.D(o), HN("dns-prefetch", o, null) } function AP(o, c) { Sa.C(o, c), HN("preconnect", o, c) } function kP(o, c, h) { Sa.L(o, c, h); var m = $c; if (m && o && c) { var x = 'link[rel="preload"][as="' + Re(c) + '"]'; c === "image" && h && h.imageSrcSet ? (x += '[imagesrcset="' + Re(h.imageSrcSet) + '"]', typeof h.imageSizes == "string" && (x += '[imagesizes="' + Re(h.imageSizes) + '"]')) : x += '[href="' + Re(o) + '"]'; var w = x; switch (c) { case "style": w = Uc(o); break; case "script": w = Vc(o) }Ji.has(w) || (o = p({ rel: "preload", href: c === "image" && h && h.imageSrcSet ? void 0 : o, as: c }, h), Ji.set(w, o), m.querySelector(x) !== null || c === "style" && m.querySelector(Nd(w)) || c === "script" && m.querySelector(jd(w)) || (c = m.createElement("link"), _r(c, "link", o), Zt(c), m.head.appendChild(c))) } } function OP(o, c) { Sa.m(o, c); var h = $c; if (h && o) { var m = c && typeof c.as == "string" ? c.as : "script", x = 'link[rel="modulepreload"][as="' + Re(m) + '"][href="' + Re(o) + '"]', w = x; switch (m) { case "audioworklet": case "paintworklet": case "serviceworker": case "sharedworker": case "worker": case "script": w = Vc(o) }if (!Ji.has(w) && (o = p({ rel: "modulepreload", href: o }, c), Ji.set(w, o), h.querySelector(x) === null)) { switch (m) { case "audioworklet": case "paintworklet": case "serviceworker": case "sharedworker": case "worker": case "script": if (h.querySelector(jd(w))) return }m = h.createElement("link"), _r(m, "link", o), Zt(m), h.head.appendChild(m) } } } function MP(o, c, h) { Sa.S(o, c, h); var m = $c; if (m && o) { var x = pn(m).hoistableStyles, w = Uc(o); c = c || "default"; var D = x.get(w); if (!D) { var R = { loading: 0, preload: null }; if (D = m.querySelector(Nd(w))) R.loading = 5; else { o = p({ rel: "stylesheet", href: o, "data-precedence": c }, h), (h = Ji.get(w)) && Fv(o, h); var G = D = m.createElement("link"); Zt(G), _r(G, "link", o), G._p = new Promise(function (ve, _e) { G.onload = ve, G.onerror = _e }), G.addEventListener("load", function () { R.loading |= 1 }), G.addEventListener("error", function () { R.loading |= 2 }), R.loading |= 4, Cp(D, c, m) } D = { type: "stylesheet", instance: D, count: 1, state: R }, x.set(w, D) } } } function DP(o, c) { Sa.X(o, c); var h = $c; if (h && o) { var m = pn(h).hoistableScripts, x = Vc(o), w = m.get(x); w || (w = h.querySelector(jd(x)), w || (o = p({ src: o, async: !0 }, c), (c = Ji.get(x)) && Bv(o, c), w = h.createElement("script"), Zt(w), _r(w, "link", o), h.head.appendChild(w)), w = { type: "script", instance: w, count: 1, state: null }, m.set(x, w)) } } function RP(o, c) { Sa.M(o, c); var h = $c; if (h && o) { var m = pn(h).hoistableScripts, x = Vc(o), w = m.get(x); w || (w = h.querySelector(jd(x)), w || (o = p({ src: o, async: !0, type: "module" }, c), (c = Ji.get(x)) && Bv(o, c), w = h.createElement("script"), Zt(w), _r(w, "link", o), h.head.appendChild(w)), w = { type: "script", instance: w, count: 1, state: null }, m.set(x, w)) } } function qN(o, c, h, m) { var x = (x = Oe.current) ? Sp(x) : null; if (!x) throw Error(r(446)); switch (o) { case "meta": case "title": return null; case "style": return typeof h.precedence == "string" && typeof h.href == "string" ? (c = Uc(h.href), h = pn(x).hoistableStyles, m = h.get(c), m || (m = { type: "style", instance: null, count: 0, state: null }, h.set(c, m)), m) : { type: "void", instance: null, count: 0, state: null }; case "link": if (h.rel === "stylesheet" && typeof h.href == "string" && typeof h.precedence == "string") { o = Uc(h.href); var w = pn(x).hoistableStyles, D = w.get(o); if (D || (x = x.ownerDocument || x, D = { type: "stylesheet", instance: null, count: 0, state: { loading: 0, preload: null } }, w.set(o, D), (w = x.querySelector(Nd(o))) && !w._p && (D.instance = w, D.state.loading = 5), Ji.has(o) || (h = { rel: "preload", as: "style", href: h.href, crossOrigin: h.crossOrigin, integrity: h.integrity, media: h.media, hrefLang: h.hrefLang, referrerPolicy: h.referrerPolicy }, Ji.set(o, h), w || _P(x, o, h, D.state))), c && m === null) throw Error(r(528, "")); return D } if (c && m !== null) throw Error(r(529, "")); return null; case "script": return c = h.async, h = h.src, typeof h == "string" && c && typeof c != "function" && typeof c != "symbol" ? (c = Vc(h), h = pn(x).hoistableScripts, m = h.get(c), m || (m = { type: "script", instance: null, count: 0, state: null }, h.set(c, m)), m) : { type: "void", instance: null, count: 0, state: null }; default: throw Error(r(444, o)) } } function Uc(o) { return 'href="' + Re(o) + '"' } function Nd(o) { return 'link[rel="stylesheet"][' + o + "]" } function KN(o) { return p({}, o, { "data-precedence": o.precedence, precedence: null }) } function _P(o, c, h, m) { o.querySelector('link[rel="preload"][as="style"][' + c + "]") ? m.loading = 1 : (c = o.createElement("link"), m.preload = c, c.addEventListener("load", function () { return m.loading |= 1 }), c.addEventListener("error", function () { return m.loading |= 2 }), _r(c, "link", h), Zt(c), o.head.appendChild(c)) } function Vc(o) { return '[src="' + Re(o) + '"]' } function jd(o) { return "script[async]" + o } function WN(o, c, h) { if (c.count++, c.instance === null) switch (c.type) { case "style": var m = o.querySelector('style[data-href~="' + Re(h.href) + '"]'); if (m) return c.instance = m, Zt(m), m; var x = p({}, h, { "data-href": h.href, "data-precedence": h.precedence, href: null, precedence: null }); return m = (o.ownerDocument || o).createElement("style"), Zt(m), _r(m, "style", x), Cp(m, h.precedence, o), c.instance = m; case "stylesheet": x = Uc(h.href); var w = o.querySelector(Nd(x)); if (w) return c.state.loading |= 4, c.instance = w, Zt(w), w; m = KN(h), (x = Ji.get(x)) && Fv(m, x), w = (o.ownerDocument || o).createElement("link"), Zt(w); var D = w; return D._p = new Promise(function (R, G) { D.onload = R, D.onerror = G }), _r(w, "link", m), c.state.loading |= 4, Cp(w, h.precedence, o), c.instance = w; case "script": return w = Vc(h.src), (x = o.querySelector(jd(w))) ? (c.instance = x, Zt(x), x) : (m = h, (x = Ji.get(w)) && (m = p({}, h), Bv(m, x)), o = o.ownerDocument || o, x = o.createElement("script"), Zt(x), _r(x, "link", m), o.head.appendChild(x), c.instance = x); case "void": return null; default: throw Error(r(443, c.type)) } else c.type === "stylesheet" && (c.state.loading & 4) === 0 && (m = c.instance, c.state.loading |= 4, Cp(m, h.precedence, o)); return c.instance } function Cp(o, c, h) { for (var m = h.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), x = m.length ? m[m.length - 1] : null, w = x, D = 0; D < m.length; D++) { var R = m[D]; if (R.dataset.precedence === c) w = R; else if (w !== x) break } w ? w.parentNode.insertBefore(o, w.nextSibling) : (c = h.nodeType === 9 ? h.head : h, c.insertBefore(o, c.firstChild)) } function Fv(o, c) { o.crossOrigin == null && (o.crossOrigin = c.crossOrigin), o.referrerPolicy == null && (o.referrerPolicy = c.referrerPolicy), o.title == null && (o.title = c.title) } function Bv(o, c) { o.crossOrigin == null && (o.crossOrigin = c.crossOrigin), o.referrerPolicy == null && (o.referrerPolicy = c.referrerPolicy), o.integrity == null && (o.integrity = c.integrity) } var Tp = null; function YN(o, c, h) { if (Tp === null) { var m = new Map, x = Tp = new Map; x.set(h, m) } else x = Tp, m = x.get(h), m || (m = new Map, x.set(h, m)); if (m.has(o)) return m; for (m.set(o, null), h = h.getElementsByTagName(o), x = 0; x < h.length; x++) { var w = h[x]; if (!(w[jt] || w[Le] || o === "link" && w.getAttribute("rel") === "stylesheet") && w.namespaceURI !== "http://www.w3.org/2000/svg") { var D = w.getAttribute(c) || ""; D = o + D; var R = m.get(D); R ? R.push(w) : m.set(D, [w]) } } return m } function GN(o, c, h) { o = o.ownerDocument || o, o.head.insertBefore(h, c === "title" ? o.querySelector("head > title") : null) } function LP(o, c, h) { if (h === 1 || c.itemProp != null) return !1; switch (o) { case "meta": case "title": return !0; case "style": if (typeof c.precedence != "string" || typeof c.href != "string" || c.href === "") break; return !0; case "link": if (typeof c.rel != "string" || typeof c.href != "string" || c.href === "" || c.onLoad || c.onError) break; switch (c.rel) { case "stylesheet": return o = c.disabled, typeof c.precedence == "string" && o == null; default: return !0 }case "script": if (c.async && typeof c.async != "function" && typeof c.async != "symbol" && !c.onLoad && !c.onError && c.src && typeof c.src == "string") return !0 }return !1 } function XN(o) { return !(o.type === "stylesheet" && (o.state.loading & 3) === 0) } var Ed = null; function PP() { } function zP(o, c, h) { if (Ed === null) throw Error(r(475)); var m = Ed; if (c.type === "stylesheet" && (typeof h.media != "string" || matchMedia(h.media).matches !== !1) && (c.state.loading & 4) === 0) { if (c.instance === null) { var x = Uc(h.href), w = o.querySelector(Nd(x)); if (w) { o = w._p, o !== null && typeof o == "object" && typeof o.then == "function" && (m.count++, m = Np.bind(m), o.then(m, m)), c.state.loading |= 4, c.instance = w, Zt(w); return } w = o.ownerDocument || o, h = KN(h), (x = Ji.get(x)) && Fv(h, x), w = w.createElement("link"), Zt(w); var D = w; D._p = new Promise(function (R, G) { D.onload = R, D.onerror = G }), _r(w, "link", h), c.instance = w } m.stylesheets === null && (m.stylesheets = new Map), m.stylesheets.set(c, o), (o = c.state.preload) && (c.state.loading & 3) === 0 && (m.count++, c = Np.bind(m), o.addEventListener("load", c), o.addEventListener("error", c)) } } function IP() { if (Ed === null) throw Error(r(475)); var o = Ed; return o.stylesheets && o.count === 0 && $v(o, o.stylesheets), 0 < o.count ? function (c) { var h = setTimeout(function () { if (o.stylesheets && $v(o, o.stylesheets), o.unsuspend) { var m = o.unsuspend; o.unsuspend = null, m() } }, 6e4); return o.unsuspend = c, function () { o.unsuspend = null, clearTimeout(h) } } : null } function Np() { if (this.count--, this.count === 0) { if (this.stylesheets) $v(this, this.stylesheets); else if (this.unsuspend) { var o = this.unsuspend; this.unsuspend = null, o() } } } var jp = null; function $v(o, c) { o.stylesheets = null, o.unsuspend !== null && (o.count++, jp = new Map, c.forEach(FP, o), jp = null, Np.call(o)) } function FP(o, c) { if (!(c.state.loading & 4)) { var h = jp.get(o); if (h) var m = h.get(null); else { h = new Map, jp.set(o, h); for (var x = o.querySelectorAll("link[data-precedence],style[data-precedence]"), w = 0; w < x.length; w++) { var D = x[w]; (D.nodeName === "LINK" || D.getAttribute("media") !== "not all") && (h.set(D.dataset.precedence, D), m = D) } m && h.set(null, m) } x = c.instance, D = x.getAttribute("data-precedence"), w = h.get(D) || m, w === m && h.set(null, x), h.set(D, x), this.count++, m = Np.bind(this), x.addEventListener("load", m), x.addEventListener("error", m), w ? w.parentNode.insertBefore(x, w.nextSibling) : (o = o.nodeType === 9 ? o.head : o, o.insertBefore(x, o.firstChild)), c.state.loading |= 4 } } var Ad = { $$typeof: M, Provider: null, Consumer: null, _currentValue: ye, _currentValue2: ye, _threadCount: 0 }; function BP(o, c, h, m, x, w, D, R) { this.tag = 1, this.containerInfo = o, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Te(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Te(0), this.hiddenUpdates = Te(null), this.identifierPrefix = m, this.onUncaughtError = x, this.onCaughtError = w, this.onRecoverableError = D, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = R, this.incompleteTransitions = new Map } function QN(o, c, h, m, x, w, D, R, G, ve, _e, Fe) { return o = new BP(o, c, h, D, R, G, ve, Fe), c = 1, w === !0 && (c |= 24), w = Ai(3, null, null, c), o.current = w, w.stateNode = o, c = S0(), c.refCount++, o.pooledCache = c, c.refCount++, w.memoizedState = { element: m, isDehydrated: h, cache: c }, j0(w), o } function JN(o) { return o ? (o = bc, o) : bc } function ZN(o, c, h, m, x, w) { x = JN(x), m.context === null ? m.context = x : m.pendingContext = x, m = Xa(c), m.payload = { element: h }, w = w === void 0 ? null : w, w !== null && (m.callback = w), h = Qa(o, m, c), h !== null && (Ri(h, o, c), id(h, o, c)) } function ej(o, c) { if (o = o.memoizedState, o !== null && o.dehydrated !== null) { var h = o.retryLane; o.retryLane = h !== 0 && h < c ? h : c } } function Uv(o, c) { ej(o, c), (o = o.alternate) && ej(o, c) } function tj(o) { if (o.tag === 13) { var c = xc(o, 67108864); c !== null && Ri(c, o, 67108864), Uv(o, 67108864) } } var Ep = !0; function $P(o, c, h, m) { var x = K.T; K.T = null; var w = te.p; try { te.p = 2, Vv(o, c, h, m) } finally { te.p = w, K.T = x } } function UP(o, c, h, m) { var x = K.T; K.T = null; var w = te.p; try { te.p = 8, Vv(o, c, h, m) } finally { te.p = w, K.T = x } } function Vv(o, c, h, m) { if (Ep) { var x = Hv(m); if (x === null) Ov(o, c, m, Ap, h), rj(o, m); else if (HP(x, o, c, h, m)) m.stopPropagation(); else if (rj(o, m), c & 4 && -1 < VP.indexOf(o)) { for (; x !== null;) { var w = zt(x); if (w !== null) switch (w.tag) { case 3: if (w = w.stateNode, w.current.memoizedState.isDehydrated) { var D = tt(w.pendingLanes); if (D !== 0) { var R = w; for (R.pendingLanes |= 2, R.entangledLanes |= 2; D;) { var G = 1 << 31 - Tt(D); R.entanglements[1] |= G, D &= ~G } Bs(w), (mn & 6) === 0 && (dp = be() + 500, wd(0)) } } break; case 13: R = xc(w, 2), R !== null && Ri(R, w, 2), hp(), Uv(w, 2) }if (w = Hv(m), w === null && Ov(o, c, m, Ap, h), w === x) break; x = w } x !== null && m.stopPropagation() } else Ov(o, c, m, null, h) } } function Hv(o) { return o = Bu(o), qv(o) } var Ap = null; function qv(o) { if (Ap = null, o = Mt(o), o !== null) { var c = s(o); if (c === null) o = null; else { var h = c.tag; if (h === 13) { if (o = a(c), o !== null) return o; o = null } else if (h === 3) { if (c.stateNode.current.memoizedState.isDehydrated) return c.tag === 3 ? c.stateNode.containerInfo : null; o = null } else c !== o && (o = null) } } return Ap = o, null } function nj(o) { switch (o) { case "beforetoggle": case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "toggle": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 2; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 8; case "message": switch (Ie()) { case it: return 2; case P: return 8; case ee: case _: return 32; case I: return 268435456; default: return 32 }default: return 32 } } var Kv = !1, uo = null, fo = null, ho = null, kd = new Map, Od = new Map, po = [], VP = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" "); function rj(o, c) { switch (o) { case "focusin": case "focusout": uo = null; break; case "dragenter": case "dragleave": fo = null; break; case "mouseover": case "mouseout": ho = null; break; case "pointerover": case "pointerout": kd.delete(c.pointerId); break; case "gotpointercapture": case "lostpointercapture": Od.delete(c.pointerId) } } function Md(o, c, h, m, x, w) { return o === null || o.nativeEvent !== w ? (o = { blockedOn: c, domEventName: h, eventSystemFlags: m, nativeEvent: w, targetContainers: [x] }, c !== null && (c = zt(c), c !== null && tj(c)), o) : (o.eventSystemFlags |= m, c = o.targetContainers, x !== null && c.indexOf(x) === -1 && c.push(x), o) } function HP(o, c, h, m, x) { switch (c) { case "focusin": return uo = Md(uo, o, c, h, m, x), !0; case "dragenter": return fo = Md(fo, o, c, h, m, x), !0; case "mouseover": return ho = Md(ho, o, c, h, m, x), !0; case "pointerover": var w = x.pointerId; return kd.set(w, Md(kd.get(w) || null, o, c, h, m, x)), !0; case "gotpointercapture": return w = x.pointerId, Od.set(w, Md(Od.get(w) || null, o, c, h, m, x)), !0 }return !1 } function ij(o) { var c = Mt(o.target); if (c !== null) { var h = s(c); if (h !== null) { if (c = h.tag, c === 13) { if (c = a(h), c !== null) { o.blockedOn = c, ce(o.priority, function () { if (h.tag === 13) { var m = Di(); m = rn(m); var x = xc(h, m); x !== null && Ri(x, h, m), Uv(h, m) } }); return } } else if (c === 3 && h.stateNode.current.memoizedState.isDehydrated) { o.blockedOn = h.tag === 3 ? h.stateNode.containerInfo : null; return } } } o.blockedOn = null } function kp(o) { if (o.blockedOn !== null) return !1; for (var c = o.targetContainers; 0 < c.length;) { var h = Hv(o.nativeEvent); if (h === null) { h = o.nativeEvent; var m = new h.constructor(h.type, h); Fu = m, h.target.dispatchEvent(m), Fu = null } else return c = zt(h), c !== null && tj(c), o.blockedOn = h, !1; c.shift() } return !0 } function sj(o, c, h) { kp(o) && h.delete(c) } function qP() { Kv = !1, uo !== null && kp(uo) && (uo = null), fo !== null && kp(fo) && (fo = null), ho !== null && kp(ho) && (ho = null), kd.forEach(sj), Od.forEach(sj) } function Op(o, c) { o.blockedOn === c && (o.blockedOn = null, Kv || (Kv = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, qP))) } var Mp = null; function aj(o) { Mp !== o && (Mp = o, t.unstable_scheduleCallback(t.unstable_NormalPriority, function () { Mp === o && (Mp = null); for (var c = 0; c < o.length; c += 3) { var h = o[c], m = o[c + 1], x = o[c + 2]; if (typeof m != "function") { if (qv(m || h) === null) continue; break } var w = zt(h); w !== null && (o.splice(c, 3), c -= 3, q0(w, { pending: !0, data: x, method: h.method, action: m }, m, x)) } })) } function Dd(o) { function c(G) { return Op(G, o) } uo !== null && Op(uo, o), fo !== null && Op(fo, o), ho !== null && Op(ho, o), kd.forEach(c), Od.forEach(c); for (var h = 0; h < po.length; h++) { var m = po[h]; m.blockedOn === o && (m.blockedOn = null) } for (; 0 < po.length && (h = po[0], h.blockedOn === null);)ij(h), h.blockedOn === null && po.shift(); if (h = (o.ownerDocument || o).$$reactFormReplay, h != null) for (m = 0; m < h.length; m += 3) { var x = h[m], w = h[m + 1], D = x[We] || null; if (typeof w == "function") D || aj(h); else if (D) { var R = null; if (w && w.hasAttribute("formAction")) { if (x = w, D = w[We] || null) R = D.formAction; else if (qv(x) !== null) continue } else R = D.action; typeof R == "function" ? h[m + 1] = R : (h.splice(m, 3), m -= 3), aj(h) } } } function Wv(o) { this._internalRoot = o } Dp.prototype.render = Wv.prototype.render = function (o) { var c = this._internalRoot; if (c === null) throw Error(r(409)); var h = c.current, m = Di(); ZN(h, m, o, c, null, null) }, Dp.prototype.unmount = Wv.prototype.unmount = function () { var o = this._internalRoot; if (o !== null) { this._internalRoot = null; var c = o.containerInfo; ZN(o.current, 2, null, o, null, null), hp(), c[ct] = null } }; function Dp(o) { this._internalRoot = o } Dp.prototype.unstable_scheduleHydration = function (o) { if (o) { var c = Z(); o = { blockedOn: null, target: o, priority: c }; for (var h = 0; h < po.length && c !== 0 && c < po[h].priority; h++); po.splice(h, 0, o), h === 0 && ij(o) } }; var oj = e.version; if (oj !== "19.1.0") throw Error(r(527, oj, "19.1.0")); te.findDOMNode = function (o) { var c = o._reactInternals; if (c === void 0) throw typeof o.render == "function" ? Error(r(188)) : (o = Object.keys(o).join(","), Error(r(268, o))); return o = u(c), o = o !== null ? f(o) : null, o = o === null ? null : o.stateNode, o }; var KP = { bundleType: 0, version: "19.1.0", rendererPackageName: "react-dom", currentDispatcherRef: K, reconcilerVersion: "19.1.0" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Rp = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Rp.isDisabled && Rp.supportsFiber) try { Ae = Rp.inject(KP), qe = Rp } catch { } } return _d.createRoot = function (o, c) { if (!i(o)) throw Error(r(299)); var h = !1, m = "", x = CT, w = TT, D = NT, R = null; return c != null && (c.unstable_strictMode === !0 && (h = !0), c.identifierPrefix !== void 0 && (m = c.identifierPrefix), c.onUncaughtError !== void 0 && (x = c.onUncaughtError), c.onCaughtError !== void 0 && (w = c.onCaughtError), c.onRecoverableError !== void 0 && (D = c.onRecoverableError), c.unstable_transitionCallbacks !== void 0 && (R = c.unstable_transitionCallbacks)), c = QN(o, 1, !1, null, null, h, m, x, w, D, R, null), o[ct] = c.current, kv(o), new Wv(c) }, _d.hydrateRoot = function (o, c, h) { if (!i(o)) throw Error(r(299)); var m = !1, x = "", w = CT, D = TT, R = NT, G = null, ve = null; return h != null && (h.unstable_strictMode === !0 && (m = !0), h.identifierPrefix !== void 0 && (x = h.identifierPrefix), h.onUncaughtError !== void 0 && (w = h.onUncaughtError), h.onCaughtError !== void 0 && (D = h.onCaughtError), h.onRecoverableError !== void 0 && (R = h.onRecoverableError), h.unstable_transitionCallbacks !== void 0 && (G = h.unstable_transitionCallbacks), h.formState !== void 0 && (ve = h.formState)), c = QN(o, 1, !0, c, h ?? null, m, x, w, D, R, G, ve), c.context = JN(null), h = c.current, m = Di(), m = rn(m), x = Xa(m), x.callback = null, Qa(h, x, m), h = m, c.current.lanes = h, Ze(c, h), Bs(c), o[ct] = c.current, kv(o), new Dp(c) }, _d.version = "19.1.0", _d
  } var yj; function n8() { if (yj) return Xv.exports; yj = 1; function t() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t) } catch (e) { console.error(e) } } return t(), Xv.exports = t8(), Xv.exports } var r8 = n8(), Ld = {}, vj; function i8() { if (vj) return Ld; vj = 1, Object.defineProperty(Ld, "__esModule", { value: !0 }), Ld.parse = a, Ld.serialize = f; const t = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, e = /^[\u0021-\u003A\u003C-\u007E]*$/, n = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, r = /^[\u0020-\u003A\u003D-\u007E]*$/, i = Object.prototype.toString, s = (() => { const y = function () { }; return y.prototype = Object.create(null), y })(); function a(y, v) { const b = new s, S = y.length; if (S < 2) return b; const C = v?.decode || p; let T = 0; do { const A = y.indexOf("=", T); if (A === -1) break; const M = y.indexOf(";", T), O = M === -1 ? S : M; if (A > O) { T = y.lastIndexOf(";", A - 1) + 1; continue } const E = l(y, T, A), k = u(y, A, E), z = y.slice(E, k); if (b[z] === void 0) { let V = l(y, A + 1, O), q = u(y, O, V); const ue = C(y.slice(V, q)); b[z] = ue } T = O + 1 } while (T < S); return b } function l(y, v, b) { do { const S = y.charCodeAt(v); if (S !== 32 && S !== 9) return v } while (++v < b); return b } function u(y, v, b) { for (; v > b;) { const S = y.charCodeAt(--v); if (S !== 32 && S !== 9) return v + 1 } return b } function f(y, v, b) { const S = b?.encode || encodeURIComponent; if (!t.test(y)) throw new TypeError(`argument name is invalid: ${y}`); const C = S(v); if (!e.test(C)) throw new TypeError(`argument val is invalid: ${v}`); let T = y + "=" + C; if (!b) return T; if (b.maxAge !== void 0) { if (!Number.isInteger(b.maxAge)) throw new TypeError(`option maxAge is invalid: ${b.maxAge}`); T += "; Max-Age=" + b.maxAge } if (b.domain) { if (!n.test(b.domain)) throw new TypeError(`option domain is invalid: ${b.domain}`); T += "; Domain=" + b.domain } if (b.path) { if (!r.test(b.path)) throw new TypeError(`option path is invalid: ${b.path}`); T += "; Path=" + b.path } if (b.expires) { if (!g(b.expires) || !Number.isFinite(b.expires.valueOf())) throw new TypeError(`option expires is invalid: ${b.expires}`); T += "; Expires=" + b.expires.toUTCString() } if (b.httpOnly && (T += "; HttpOnly"), b.secure && (T += "; Secure"), b.partitioned && (T += "; Partitioned"), b.priority) switch (typeof b.priority == "string" ? b.priority.toLowerCase() : void 0) { case "low": T += "; Priority=Low"; break; case "medium": T += "; Priority=Medium"; break; case "high": T += "; Priority=High"; break; default: throw new TypeError(`option priority is invalid: ${b.priority}`) }if (b.sameSite) switch (typeof b.sameSite == "string" ? b.sameSite.toLowerCase() : b.sameSite) { case !0: case "strict": T += "; SameSite=Strict"; break; case "lax": T += "; SameSite=Lax"; break; case "none": T += "; SameSite=None"; break; default: throw new TypeError(`option sameSite is invalid: ${b.sameSite}`) }return T } function p(y) { if (y.indexOf("%") === -1) return y; try { return decodeURIComponent(y) } catch { return y } } function g(y) { return i.call(y) === "[object Date]" } return Ld } i8();/**
 * react-router v7.6.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */var Z3 = t => { throw TypeError(t) }, s8 = (t, e, n) => e.has(t) || Z3("Cannot " + n), ex = (t, e, n) => (s8(t, e, "read from private field"), n ? n.call(t) : e.get(t)), a8 = (t, e, n) => e.has(t) ? Z3("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, n), xj = "popstate"; function o8(t = {}) { function e(r, i) { let { pathname: s, search: a, hash: l } = r.location; return kf("", { pathname: s, search: a, hash: l }, i.state && i.state.usr || null, i.state && i.state.key || "default") } function n(r, i) { return typeof i == "string" ? i : Fo(i) } return c8(e, n, null, t) } function Yt(t, e) { if (t === !1 || t === null || typeof t > "u") throw new Error(e) } function rr(t, e) { if (!t) { typeof console < "u" && console.warn(e); try { throw new Error(e) } catch { } } } function l8() { return Math.random().toString(36).substring(2, 10) } function bj(t, e) { return { usr: t.state, key: t.key, idx: e } } function kf(t, e, n = null, r) { return { pathname: typeof t == "string" ? t : t.pathname, search: "", hash: "", ...typeof e == "string" ? qo(e) : e, state: n, key: e && e.key || r || l8() } } function Fo({ pathname: t = "/", search: e = "", hash: n = "" }) { return e && e !== "?" && (t += e.charAt(0) === "?" ? e : "?" + e), n && n !== "#" && (t += n.charAt(0) === "#" ? n : "#" + n), t } function qo(t) { let e = {}; if (t) { let n = t.indexOf("#"); n >= 0 && (e.hash = t.substring(n), t = t.substring(0, n)); let r = t.indexOf("?"); r >= 0 && (e.search = t.substring(r), t = t.substring(0, r)), t && (e.pathname = t) } return e } function c8(t, e, n, r = {}) { let { window: i = document.defaultView, v5Compat: s = !1 } = r, a = i.history, l = "POP", u = null, f = p(); f == null && (f = 0, a.replaceState({ ...a.state, idx: f }, "")); function p() { return (a.state || { idx: null }).idx } function g() { l = "POP"; let C = p(), T = C == null ? null : C - f; f = C, u && u({ action: l, location: S.location, delta: T }) } function y(C, T) { l = "PUSH"; let A = kf(S.location, C, T); f = p() + 1; let M = bj(A, f), O = S.createHref(A); try { a.pushState(M, "", O) } catch (E) { if (E instanceof DOMException && E.name === "DataCloneError") throw E; i.location.assign(O) } s && u && u({ action: l, location: S.location, delta: 1 }) } function v(C, T) { l = "REPLACE"; let A = kf(S.location, C, T); f = p(); let M = bj(A, f), O = S.createHref(A); a.replaceState(M, "", O), s && u && u({ action: l, location: S.location, delta: 0 }) } function b(C) { return eO(C) } let S = { get action() { return l }, get location() { return t(i, a) }, listen(C) { if (u) throw new Error("A history only accepts one active listener"); return i.addEventListener(xj, g), u = C, () => { i.removeEventListener(xj, g), u = null } }, createHref(C) { return e(i, C) }, createURL: b, encodeLocation(C) { let T = b(C); return { pathname: T.pathname, search: T.search, hash: T.hash } }, push: y, replace: v, go(C) { return a.go(C) } }; return S } function eO(t, e = !1) { let n = "http://localhost"; typeof window < "u" && (n = window.location.origin !== "null" ? window.location.origin : window.location.href), Yt(n, "No window.location.(origin|href) available to create URL"); let r = typeof t == "string" ? t : Fo(t); return r = r.replace(/ $/, "%20"), !e && r.startsWith("//") && (r = n + r), new URL(r, n) } var Gd, wj = class { constructor(t) { if (a8(this, Gd, new Map), t) for (let [e, n] of t) this.set(e, n) } get(t) { if (ex(this, Gd).has(t)) return ex(this, Gd).get(t); if (t.defaultValue !== void 0) return t.defaultValue; throw new Error("No value found for context") } set(t, e) { ex(this, Gd).set(t, e) } }; Gd = new WeakMap; var u8 = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]); function d8(t) { return u8.has(t) } var f8 = new Set(["lazy", "caseSensitive", "path", "id", "index", "unstable_middleware", "children"]); function h8(t) { return f8.has(t) } function p8(t) { return t.index === !0 } function Bm(t, e, n = [], r = {}) { return t.map((i, s) => { let a = [...n, String(s)], l = typeof i.id == "string" ? i.id : a.join("-"); if (Yt(i.index !== !0 || !i.children, "Cannot specify children on an index route"), Yt(!r[l], `Found a route id collision on id "${l}".  Route id's must be globally unique within Data Router usages`), p8(i)) { let u = { ...i, ...e(i), id: l }; return r[l] = u, u } else { let u = { ...i, ...e(i), id: l, children: void 0 }; return r[l] = u, i.children && (u.children = Bm(i.children, e, a, r)), u } }) } function To(t, e, n = "/") { return gm(t, e, n, !1) } function gm(t, e, n, r) { let i = typeof e == "string" ? qo(e) : e, s = ds(i.pathname || "/", n); if (s == null) return null; let a = tO(t); g8(a); let l = null; for (let u = 0; l == null && u < a.length; ++u) { let f = E8(s); l = N8(a[u], f, r) } return l } function m8(t, e) { let { route: n, pathname: r, params: i } = t; return { id: n.id, pathname: r, params: i, data: e[n.id], handle: n.handle } } function tO(t, e = [], n = [], r = "") { let i = (s, a, l) => { let u = { relativePath: l === void 0 ? s.path || "" : l, caseSensitive: s.caseSensitive === !0, childrenIndex: a, route: s }; u.relativePath.startsWith("/") && (Yt(u.relativePath.startsWith(r), `Absolute route path "${u.relativePath}" nested under path "${r}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`), u.relativePath = u.relativePath.slice(r.length)); let f = Xs([r, u.relativePath]), p = n.concat(u); s.children && s.children.length > 0 && (Yt(s.index !== !0, `Index routes must not have child routes. Please remove all child routes from route path "${f}".`), tO(s.children, e, p, f)), !(s.path == null && !s.index) && e.push({ path: f, score: C8(f, s.index), routesMeta: p }) }; return t.forEach((s, a) => { if (s.path === "" || !s.path?.includes("?")) i(s, a); else for (let l of nO(s.path)) i(s, a, l) }), e } function nO(t) { let e = t.split("/"); if (e.length === 0) return []; let [n, ...r] = e, i = n.endsWith("?"), s = n.replace(/\?$/, ""); if (r.length === 0) return i ? [s, ""] : [s]; let a = nO(r.join("/")), l = []; return l.push(...a.map(u => u === "" ? s : [s, u].join("/"))), i && l.push(...a), l.map(u => t.startsWith("/") && u === "" ? "/" : u) } function g8(t) { t.sort((e, n) => e.score !== n.score ? n.score - e.score : T8(e.routesMeta.map(r => r.childrenIndex), n.routesMeta.map(r => r.childrenIndex))) } var y8 = /^:[\w-]+$/, v8 = 3, x8 = 2, b8 = 1, w8 = 10, S8 = -2, Sj = t => t === "*"; function C8(t, e) { let n = t.split("/"), r = n.length; return n.some(Sj) && (r += S8), e && (r += x8), n.filter(i => !Sj(i)).reduce((i, s) => i + (y8.test(s) ? v8 : s === "" ? b8 : w8), r) } function T8(t, e) { return t.length === e.length && t.slice(0, -1).every((r, i) => r === e[i]) ? t[t.length - 1] - e[e.length - 1] : 0 } function N8(t, e, n = !1) { let { routesMeta: r } = t, i = {}, s = "/", a = []; for (let l = 0; l < r.length; ++l) { let u = r[l], f = l === r.length - 1, p = s === "/" ? e : e.slice(s.length) || "/", g = $m({ path: u.relativePath, caseSensitive: u.caseSensitive, end: f }, p), y = u.route; if (!g && f && n && !r[r.length - 1].route.index && (g = $m({ path: u.relativePath, caseSensitive: u.caseSensitive, end: !1 }, p)), !g) return null; Object.assign(i, g.params), a.push({ params: i, pathname: Xs([s, g.pathname]), pathnameBase: O8(Xs([s, g.pathnameBase])), route: y }), g.pathnameBase !== "/" && (s = Xs([s, g.pathnameBase])) } return a } function $m(t, e) { typeof t == "string" && (t = { path: t, caseSensitive: !1, end: !0 }); let [n, r] = j8(t.path, t.caseSensitive, t.end), i = e.match(n); if (!i) return null; let s = i[0], a = s.replace(/(.)\/+$/, "$1"), l = i.slice(1); return { params: r.reduce((f, { paramName: p, isOptional: g }, y) => { if (p === "*") { let b = l[y] || ""; a = s.slice(0, s.length - b.length).replace(/(.)\/+$/, "$1") } const v = l[y]; return g && !v ? f[p] = void 0 : f[p] = (v || "").replace(/%2F/g, "/"), f }, {}), pathname: s, pathnameBase: a, pattern: t } } function j8(t, e = !1, n = !0) { rr(t === "*" || !t.endsWith("*") || t.endsWith("/*"), `Route path "${t}" will be treated as if it were "${t.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${t.replace(/\*$/, "/*")}".`); let r = [], i = "^" + t.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (a, l, u) => (r.push({ paramName: l, isOptional: u != null }), u ? "/?([^\\/]+)?" : "/([^\\/]+)")); return t.endsWith("*") ? (r.push({ paramName: "*" }), i += t === "*" || t === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : t !== "" && t !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, e ? void 0 : "i"), r] } function E8(t) { try { return t.split("/").map(e => decodeURIComponent(e).replace(/\//g, "%2F")).join("/") } catch (e) { return rr(!1, `The URL path "${t}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`), t } } function ds(t, e) { if (e === "/") return t; if (!t.toLowerCase().startsWith(e.toLowerCase())) return null; let n = e.endsWith("/") ? e.length - 1 : e.length, r = t.charAt(n); return r && r !== "/" ? null : t.slice(n) || "/" } function A8(t, e = "/") { let { pathname: n, search: r = "", hash: i = "" } = typeof t == "string" ? qo(t) : t; return { pathname: n ? n.startsWith("/") ? n : k8(n, e) : e, search: M8(r), hash: D8(i) } } function k8(t, e) { let n = e.replace(/\/+$/, "").split("/"); return t.split("/").forEach(i => { i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i) }), n.length > 1 ? n.join("/") : "/" } function tx(t, e, n, r) { return `Cannot include a '${t}' character in a manually specified \`to.${e}\` field [${JSON.stringify(r)}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.` } function rO(t) { return t.filter((e, n) => n === 0 || e.route.path && e.route.path.length > 0) } function ay(t) { let e = rO(t); return e.map((n, r) => r === e.length - 1 ? n.pathname : n.pathnameBase) } function oy(t, e, n, r = !1) { let i; typeof t == "string" ? i = qo(t) : (i = { ...t }, Yt(!i.pathname || !i.pathname.includes("?"), tx("?", "pathname", "search", i)), Yt(!i.pathname || !i.pathname.includes("#"), tx("#", "pathname", "hash", i)), Yt(!i.search || !i.search.includes("#"), tx("#", "search", "hash", i))); let s = t === "" || i.pathname === "", a = s ? "/" : i.pathname, l; if (a == null) l = n; else { let g = e.length - 1; if (!r && a.startsWith("..")) { let y = a.split("/"); for (; y[0] === "..";)y.shift(), g -= 1; i.pathname = y.join("/") } l = g >= 0 ? e[g] : "/" } let u = A8(i, l), f = a && a !== "/" && a.endsWith("/"), p = (s || a === ".") && n.endsWith("/"); return !u.pathname.endsWith("/") && (f || p) && (u.pathname += "/"), u } var Xs = t => t.join("/").replace(/\/\/+/g, "/"), O8 = t => t.replace(/\/+$/, "").replace(/^\/*/, "/"), M8 = t => !t || t === "?" ? "" : t.startsWith("?") ? t : "?" + t, D8 = t => !t || t === "#" ? "" : t.startsWith("#") ? t : "#" + t, Um = class { constructor(t, e, n, r = !1) { this.status = t, this.statusText = e || "", this.internal = r, n instanceof Error ? (this.data = n.toString(), this.error = n) : this.data = n } }; function Of(t) { return t != null && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.internal == "boolean" && "data" in t } var iO = ["POST", "PUT", "PATCH", "DELETE"], R8 = new Set(iO), _8 = ["GET", ...iO], L8 = new Set(_8), P8 = new Set([301, 302, 303, 307, 308]), z8 = new Set([307, 308]), nx = { state: "idle", location: void 0, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0 }, I8 = { state: "idle", data: void 0, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0 }, Pd = { state: "unblocked", proceed: void 0, reset: void 0, location: void 0 }, vw = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, F8 = t => ({ hasErrorBoundary: !!t.hasErrorBoundary }), sO = "remix-router-transitions", aO = Symbol("ResetLoaderData"); function B8(t) { const e = t.window ? t.window : typeof window < "u" ? window : void 0, n = typeof e < "u" && typeof e.document < "u" && typeof e.document.createElement < "u"; Yt(t.routes.length > 0, "You must provide a non-empty routes array to createRouter"); let r = t.hydrationRouteProperties || [], i = t.mapRouteProperties || F8, s = {}, a = Bm(t.routes, i, void 0, s), l, u = t.basename || "/", f = t.dataStrategy || q8, p = { unstable_middleware: !1, ...t.future }, g = null, y = new Set, v = null, b = null, S = null, C = t.hydrationData != null, T = To(a, t.history.location, u), A = !1, M = null, O; if (T == null && !t.patchRoutesOnNavigation) { let Z = is(404, { pathname: t.history.location.pathname }), { matches: ce, route: Se } = _j(a); O = !0, T = ce, M = { [Se.id]: Z } } else if (T && !t.hydrationData && vt(T, a, t.history.location.pathname).active && (T = null), T) if (T.some(Z => Z.route.lazy)) O = !1; else if (!T.some(Z => Z.route.loader)) O = !0; else { let Z = t.hydrationData ? t.hydrationData.loaderData : null, ce = t.hydrationData ? t.hydrationData.errors : null; if (ce) { let Se = T.findIndex(Le => ce[Le.route.id] !== void 0); O = T.slice(0, Se + 1).every(Le => !Cb(Le.route, Z, ce)) } else O = T.every(Se => !Cb(Se.route, Z, ce)) } else { O = !1, T = []; let Z = vt(null, a, t.history.location.pathname); Z.active && Z.matches && (A = !0, T = Z.matches) } let E, k = { historyAction: t.history.action, location: t.history.location, matches: T, initialized: O, navigation: nx, restoreScrollPosition: t.hydrationData != null ? !1 : null, preventScrollReset: !1, revalidation: "idle", loaderData: t.hydrationData && t.hydrationData.loaderData || {}, actionData: t.hydrationData && t.hydrationData.actionData || null, errors: t.hydrationData && t.hydrationData.errors || M, fetchers: new Map, blockers: new Map }, z = "POP", V = !1, q, ue = !1, W = new Map, ne = null, H = !1, we = !1, xe = new Set, K = new Map, te = 0, ye = -1, He = new Map, B = new Set, ie = new Map, oe = new Map, pe = new Set, Ee = new Map, fe, Oe = null; function et() { if (g = t.history.listen(({ action: Z, location: ce, delta: Se }) => { if (fe) { fe(), fe = void 0; return } rr(Ee.size === 0 || Se != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL."); let Le = st({ currentLocation: k.location, nextLocation: ce, historyAction: Z }); if (Le && Se != null) { let We = new Promise(ct => { fe = ct }); t.history.go(Se * -1), le(Le, { state: "blocked", location: ce, proceed() { le(Le, { state: "proceeding", proceed: void 0, reset: void 0, location: ce }), We.then(() => t.history.go(Se)) }, reset() { let ct = new Map(k.blockers); ct.set(Le, Pd), he({ blockers: ct }) } }); return } return $e(Z, ce) }), n) { nz(e, W); let Z = () => rz(e, W); e.addEventListener("pagehide", Z), ne = () => e.removeEventListener("pagehide", Z) } return k.initialized || $e("POP", k.location, { initialHydration: !0 }), E } function Xe() { g && g(), ne && ne(), y.clear(), q && q.abort(), k.fetchers.forEach((Z, ce) => Tt(ce)), k.blockers.forEach((Z, ce) => lt(ce)) } function De(Z) { return y.add(Z), () => y.delete(Z) } function he(Z, ce = {}) { k = { ...k, ...Z }; let Se = [], Le = []; k.fetchers.forEach((We, ct) => { We.state === "idle" && (pe.has(ct) ? Se.push(ct) : Le.push(ct)) }), pe.forEach(We => { !k.fetchers.has(We) && !K.has(We) && Se.push(We) }), [...y].forEach(We => We(k, { deletedFetchers: Se, viewTransitionOpts: ce.viewTransitionOpts, flushSync: ce.flushSync === !0 })), Se.forEach(We => Tt(We)), Le.forEach(We => k.fetchers.delete(We)) } function Be(Z, ce, { flushSync: Se } = {}) { let Le = k.actionData != null && k.navigation.formMethod != null && Pi(k.navigation.formMethod) && k.navigation.state === "loading" && Z.state?._isRedirect !== !0, We; ce.actionData ? Object.keys(ce.actionData).length > 0 ? We = ce.actionData : We = null : Le ? We = k.actionData : We = null; let ct = ce.loaderData ? Dj(k.loaderData, ce.loaderData, ce.matches || [], ce.errors) : k.loaderData, xt = k.blockers; xt.size > 0 && (xt = new Map(xt), xt.forEach((ut, jt) => xt.set(jt, Pd))); let at = V === !0 || k.navigation.formMethod != null && Pi(k.navigation.formMethod) && Z.state?._isRedirect !== !0; l && (a = l, l = void 0), H || z === "POP" || (z === "PUSH" ? t.history.push(Z, Z.state) : z === "REPLACE" && t.history.replace(Z, Z.state)); let dt; if (z === "POP") { let ut = W.get(k.location.pathname); ut && ut.has(Z.pathname) ? dt = { currentLocation: k.location, nextLocation: Z } : W.has(Z.pathname) && (dt = { currentLocation: Z, nextLocation: k.location }) } else if (ue) { let ut = W.get(k.location.pathname); ut ? ut.add(Z.pathname) : (ut = new Set([Z.pathname]), W.set(k.location.pathname, ut)), dt = { currentLocation: k.location, nextLocation: Z } } he({ ...ce, actionData: We, loaderData: ct, historyAction: z, location: Z, initialized: !0, navigation: nx, revalidation: "idle", restoreScrollPosition: gt(Z, ce.matches || k.matches), preventScrollReset: at, blockers: xt }, { viewTransitionOpts: dt, flushSync: Se === !0 }), z = "POP", V = !1, ue = !1, H = !1, we = !1, Oe?.resolve(), Oe = null } async function Y(Z, ce) { if (typeof Z == "number") { t.history.go(Z); return } let Se = Sb(k.location, k.matches, u, Z, ce?.fromRouteId, ce?.relative), { path: Le, submission: We, error: ct } = Cj(!1, Se, ce), xt = k.location, at = kf(k.location, Le, ce && ce.state); at = { ...at, ...t.history.encodeLocation(at) }; let dt = ce && ce.replace != null ? ce.replace : void 0, ut = "PUSH"; dt === !0 ? ut = "REPLACE" : dt === !1 || We != null && Pi(We.formMethod) && We.formAction === k.location.pathname + k.location.search && (ut = "REPLACE"); let jt = ce && "preventScrollReset" in ce ? ce.preventScrollReset === !0 : void 0, St = (ce && ce.flushSync) === !0, Mt = st({ currentLocation: xt, nextLocation: at, historyAction: ut }); if (Mt) { le(Mt, { state: "blocked", location: at, proceed() { le(Mt, { state: "proceeding", proceed: void 0, reset: void 0, location: at }), Y(Z, ce) }, reset() { let zt = new Map(k.blockers); zt.set(Mt, Pd), he({ blockers: zt }) } }); return } await $e(ut, at, { submission: We, pendingError: ct, preventScrollReset: jt, replace: ce && ce.replace, enableViewTransition: ce && ce.viewTransition, flushSync: St }) } function Je() { Oe || (Oe = iz()), ae(), he({ revalidation: "loading" }); let Z = Oe.promise; return k.navigation.state === "submitting" ? Z : k.navigation.state === "idle" ? ($e(k.historyAction, k.location, { startUninterruptedRevalidation: !0 }), Z) : ($e(z || k.historyAction, k.navigation.location, { overrideNavigation: k.navigation, enableViewTransition: ue === !0 }), Z) } async function $e(Z, ce, Se) { q && q.abort(), q = null, z = Z, H = (Se && Se.startUninterruptedRevalidation) === !0, Ze(k.location, k.matches), V = (Se && Se.preventScrollReset) === !0, ue = (Se && Se.enableViewTransition) === !0; let Le = l || a, We = Se && Se.overrideNavigation, ct = Se?.initialHydration && k.matches && k.matches.length > 0 && !A ? k.matches : To(Le, ce, u), xt = (Se && Se.flushSync) === !0; if (ct && k.initialized && !we && Q8(k.location, ce) && !(Se && Se.submission && Pi(Se.submission.formMethod))) { Be(ce, { matches: ct }, { flushSync: xt }); return } let at = vt(ct, Le, ce.pathname); if (at.active && at.matches && (ct = at.matches), !ct) { let { error: pn, notFoundMatches: Zt, route: Ht } = wt(ce.pathname); Be(ce, { matches: Zt, loaderData: {}, errors: { [Ht.id]: pn } }, { flushSync: xt }); return } q = new AbortController; let dt = Xc(t.history, ce, q.signal, Se && Se.submission), ut = new wj(t.unstable_getContext ? await t.unstable_getContext() : void 0), jt; if (Se && Se.pendingError) jt = [Tl(ct).route.id, { type: "error", error: Se.pendingError }]; else if (Se && Se.submission && Pi(Se.submission.formMethod)) { let pn = await $(dt, ce, Se.submission, ct, ut, at.active, Se && Se.initialHydration === !0, { replace: Se.replace, flushSync: xt }); if (pn.shortCircuited) return; if (pn.pendingActionResult) { let [Zt, Ht] = pn.pendingActionResult; if (Li(Ht) && Of(Ht.error) && Ht.error.status === 404) { q = null, Be(ce, { matches: pn.matches, loaderData: {}, errors: { [Zt]: Ht.error } }); return } } ct = pn.matches || ct, jt = pn.pendingActionResult, We = rx(ce, Se.submission), xt = !1, at.active = !1, dt = Xc(t.history, dt.url, dt.signal) } let { shortCircuited: St, matches: Mt, loaderData: zt, errors: hn } = await U(dt, ce, ct, ut, at.active, We, Se && Se.submission, Se && Se.fetcherSubmission, Se && Se.replace, Se && Se.initialHydration === !0, xt, jt); St || (q = null, Be(ce, { matches: Mt || ct, ...Rj(jt), loaderData: zt, errors: hn })) } async function $(Z, ce, Se, Le, We, ct, xt, at = {}) { ae(); let dt = ez(ce, Se); if (he({ navigation: dt }, { flushSync: at.flushSync === !0 }), ct) { let St = await Nt(Le, ce.pathname, Z.signal); if (St.type === "aborted") return { shortCircuited: !0 }; if (St.type === "error") { let Mt = Tl(St.partialMatches).route.id; return { matches: St.partialMatches, pendingActionResult: [Mt, { type: "error", error: St.error }] } } else if (St.matches) Le = St.matches; else { let { notFoundMatches: Mt, error: zt, route: hn } = wt(ce.pathname); return { matches: Mt, pendingActionResult: [hn.id, { type: "error", error: zt }] } } } let ut, jt = Xd(Le, ce); if (!jt.route.action && !jt.route.lazy) ut = { type: "error", error: is(405, { method: Z.method, pathname: ce.pathname, routeId: jt.route.id }) }; else { let St = cu(i, s, Z, Le, jt, xt ? [] : r, We), Mt = await I(Z, St, We, null); if (ut = Mt[jt.route.id], !ut) { for (let zt of Le) if (Mt[zt.route.id]) { ut = Mt[zt.route.id]; break } } if (Z.signal.aborted) return { shortCircuited: !0 } } if (El(ut)) { let St; return at && at.replace != null ? St = at.replace : St = kj(ut.response.headers.get("Location"), new URL(Z.url), u) === k.location.pathname + k.location.search, await _(Z, ut, !0, { submission: Se, replace: St }), { shortCircuited: !0 } } if (Li(ut)) { let St = Tl(Le, jt.route.id); return (at && at.replace) !== !0 && (z = "PUSH"), { matches: Le, pendingActionResult: [St.route.id, ut, jt.route.id] } } return { matches: Le, pendingActionResult: [jt.route.id, ut] } } async function U(Z, ce, Se, Le, We, ct, xt, at, dt, ut, jt, St) { let Mt = ct || rx(ce, xt), zt = xt || at || Pj(Mt), hn = !H && !ut; if (We) { if (hn) { let Vn = be(St); he({ navigation: Mt, ...Vn !== void 0 ? { actionData: Vn } : {} }, { flushSync: jt }) } let _t = await Nt(Se, ce.pathname, Z.signal); if (_t.type === "aborted") return { shortCircuited: !0 }; if (_t.type === "error") { let Vn = Tl(_t.partialMatches).route.id; return { matches: _t.partialMatches, loaderData: {}, errors: { [Vn]: _t.error } } } else if (_t.matches) Se = _t.matches; else { let { error: Vn, notFoundMatches: Jr, route: Zr } = wt(ce.pathname); return { matches: Jr, loaderData: {}, errors: { [Zr.id]: Vn } } } } let pn = l || a, { dsMatches: Zt, revalidatingFetchers: Ht } = Tj(Z, Le, i, s, t.history, k, Se, zt, ce, ut ? [] : r, ut === !0, we, xe, pe, ie, B, pn, u, t.patchRoutesOnNavigation != null, St); if (ye = ++te, !t.dataStrategy && !Zt.some(_t => _t.shouldLoad) && Ht.length === 0) { let _t = cn(); return Be(ce, { matches: Se, loaderData: {}, errors: St && Li(St[1]) ? { [St[0]]: St[1].error } : null, ...Rj(St), ..._t ? { fetchers: new Map(k.fetchers) } : {} }, { flushSync: jt }), { shortCircuited: !0 } } if (hn) { let _t = {}; if (!We) { _t.navigation = Mt; let Vn = be(St); Vn !== void 0 && (_t.actionData = Vn) } Ht.length > 0 && (_t.fetchers = Ie(Ht)), he(_t, { flushSync: jt }) } Ht.forEach(_t => { Gt(_t.key), _t.controller && K.set(_t.key, _t.controller) }); let Hi = () => Ht.forEach(_t => Gt(_t.key)); q && q.signal.addEventListener("abort", Hi); let { loaderResults: pr, fetcherResults: $r } = await se(Zt, Ht, Z, Le); if (Z.signal.aborted) return { shortCircuited: !0 }; q && q.signal.removeEventListener("abort", Hi), Ht.forEach(_t => K.delete(_t.key)); let Pn = Lp(pr); if (Pn) return await _(Z, Pn.result, !0, { replace: dt }), { shortCircuited: !0 }; if (Pn = Lp($r), Pn) return B.add(Pn.key), await _(Z, Pn.result, !0, { replace: dt }), { shortCircuited: !0 }; let { loaderData: Ur, errors: Mr } = Mj(k, Se, pr, St, Ht, $r); ut && k.errors && (Mr = { ...k.errors, ...Mr }); let Ls = cn(), Jn = je(ye), Ni = Ls || Jn || Ht.length > 0; return { matches: Se, loaderData: Ur, errors: Mr, ...Ni ? { fetchers: new Map(k.fetchers) } : {} } } function be(Z) { if (Z && !Li(Z[1])) return { [Z[0]]: Z[1].data }; if (k.actionData) return Object.keys(k.actionData).length === 0 ? null : k.actionData } function Ie(Z) { return Z.forEach(ce => { let Se = k.fetchers.get(ce.key), Le = zd(void 0, Se ? Se.data : void 0); k.fetchers.set(ce.key, Le) }), new Map(k.fetchers) } async function it(Z, ce, Se, Le) { Gt(Z); let We = (Le && Le.flushSync) === !0, ct = l || a, xt = Sb(k.location, k.matches, u, Se, ce, Le?.relative), at = To(ct, xt, u), dt = vt(at, ct, xt); if (dt.active && dt.matches && (at = dt.matches), !at) { qe(Z, ce, is(404, { pathname: xt }), { flushSync: We }); return } let { path: ut, submission: jt, error: St } = Cj(!0, xt, Le); if (St) { qe(Z, ce, St, { flushSync: We }); return } let Mt = Xd(at, ut), zt = new wj(t.unstable_getContext ? await t.unstable_getContext() : void 0), hn = (Le && Le.preventScrollReset) === !0; if (jt && Pi(jt.formMethod)) { await P(Z, ce, ut, Mt, at, zt, dt.active, We, hn, jt); return } ie.set(Z, { routeId: ce, path: ut }), await ee(Z, ce, ut, Mt, at, zt, dt.active, We, hn, jt) } async function P(Z, ce, Se, Le, We, ct, xt, at, dt, ut) { ae(), ie.delete(Z); function jt(un) { if (!un.route.action && !un.route.lazy) { let qi = is(405, { method: ut.formMethod, pathname: Se, routeId: ce }); return qe(Z, ce, qi, { flushSync: at }), !0 } return !1 } if (!xt && jt(Le)) return; let St = k.fetchers.get(Z); Ae(Z, tz(ut, St), { flushSync: at }); let Mt = new AbortController, zt = Xc(t.history, Se, Mt.signal, ut); if (xt) { let un = await Nt(We, Se, zt.signal, Z); if (un.type === "aborted") return; if (un.type === "error") { qe(Z, ce, un.error, { flushSync: at }); return } else if (un.matches) { if (We = un.matches, Le = Xd(We, Se), jt(Le)) return } else { qe(Z, ce, is(404, { pathname: Se }), { flushSync: at }); return } } K.set(Z, Mt); let hn = te, pn = cu(i, s, zt, We, Le, r, ct), Ht = (await I(zt, pn, ct, Z))[Le.route.id]; if (zt.signal.aborted) { K.get(Z) === Mt && K.delete(Z); return } if (pe.has(Z)) { if (El(Ht) || Li(Ht)) { Ae(Z, yo(void 0)); return } } else { if (El(Ht)) if (K.delete(Z), ye > hn) { Ae(Z, yo(void 0)); return } else return B.add(Z), Ae(Z, zd(ut)), _(zt, Ht, !1, { fetcherSubmission: ut, preventScrollReset: dt }); if (Li(Ht)) { qe(Z, ce, Ht.error); return } } let Hi = k.navigation.location || k.location, pr = Xc(t.history, Hi, Mt.signal), $r = l || a, Pn = k.navigation.state !== "idle" ? To($r, k.navigation.location, u) : k.matches; Yt(Pn, "Didn't find any matches after fetcher action"); let Ur = ++te; He.set(Z, Ur); let Mr = zd(ut, Ht.data); k.fetchers.set(Z, Mr); let { dsMatches: Ls, revalidatingFetchers: Jn } = Tj(pr, ct, i, s, t.history, k, Pn, ut, Hi, r, !1, we, xe, pe, ie, B, $r, u, t.patchRoutesOnNavigation != null, [Le.route.id, Ht]); Jn.filter(un => un.key !== Z).forEach(un => { let qi = un.key, L = k.fetchers.get(qi), Q = zd(void 0, L ? L.data : void 0); k.fetchers.set(qi, Q), Gt(qi), un.controller && K.set(qi, un.controller) }), he({ fetchers: new Map(k.fetchers) }); let Ni = () => Jn.forEach(un => Gt(un.key)); Mt.signal.addEventListener("abort", Ni); let { loaderResults: _t, fetcherResults: Vn } = await se(Ls, Jn, pr, ct); if (Mt.signal.aborted) return; if (Mt.signal.removeEventListener("abort", Ni), He.delete(Z), K.delete(Z), Jn.forEach(un => K.delete(un.key)), k.fetchers.has(Z)) { let un = yo(Ht.data); k.fetchers.set(Z, un) } let Jr = Lp(_t); if (Jr) return _(pr, Jr.result, !1, { preventScrollReset: dt }); if (Jr = Lp(Vn), Jr) return B.add(Jr.key), _(pr, Jr.result, !1, { preventScrollReset: dt }); let { loaderData: Zr, errors: ji } = Mj(k, Pn, _t, void 0, Jn, Vn); je(Ur), k.navigation.state === "loading" && Ur > ye ? (Yt(z, "Expected pending action"), q && q.abort(), Be(k.navigation.location, { matches: Pn, loaderData: Zr, errors: ji, fetchers: new Map(k.fetchers) })) : (he({ errors: ji, loaderData: Dj(k.loaderData, Zr, Pn, ji), fetchers: new Map(k.fetchers) }), we = !1) } async function ee(Z, ce, Se, Le, We, ct, xt, at, dt, ut) { let jt = k.fetchers.get(Z); Ae(Z, zd(ut, jt ? jt.data : void 0), { flushSync: at }); let St = new AbortController, Mt = Xc(t.history, Se, St.signal); if (xt) { let Ht = await Nt(We, Se, Mt.signal, Z); if (Ht.type === "aborted") return; if (Ht.type === "error") { qe(Z, ce, Ht.error, { flushSync: at }); return } else if (Ht.matches) We = Ht.matches, Le = Xd(We, Se); else { qe(Z, ce, is(404, { pathname: Se }), { flushSync: at }); return } } K.set(Z, St); let zt = te, hn = cu(i, s, Mt, We, Le, r, ct), Zt = (await I(Mt, hn, ct, Z))[Le.route.id]; if (K.get(Z) === St && K.delete(Z), !Mt.signal.aborted) { if (pe.has(Z)) { Ae(Z, yo(void 0)); return } if (El(Zt)) if (ye > zt) { Ae(Z, yo(void 0)); return } else { B.add(Z), await _(Mt, Zt, !1, { preventScrollReset: dt }); return } if (Li(Zt)) { qe(Z, ce, Zt.error); return } Ae(Z, yo(Zt.data)) } } async function _(Z, ce, Se, { submission: Le, fetcherSubmission: We, preventScrollReset: ct, replace: xt } = {}) { ce.response.headers.has("X-Remix-Revalidate") && (we = !0); let at = ce.response.headers.get("Location"); Yt(at, "Expected a Location header on the redirect Response"), at = kj(at, new URL(Z.url), u); let dt = kf(k.location, at, { _isRedirect: !0 }); if (n) { let hn = !1; if (ce.response.headers.has("X-Remix-Reload-Document")) hn = !0; else if (vw.test(at)) { const pn = eO(at, !0); hn = pn.origin !== e.location.origin || ds(pn.pathname, u) == null } if (hn) { xt ? e.location.replace(at) : e.location.assign(at); return } } q = null; let ut = xt === !0 || ce.response.headers.has("X-Remix-Replace") ? "REPLACE" : "PUSH", { formMethod: jt, formAction: St, formEncType: Mt } = k.navigation; !Le && !We && jt && St && Mt && (Le = Pj(k.navigation)); let zt = Le || We; if (z8.has(ce.response.status) && zt && Pi(zt.formMethod)) await $e(ut, dt, { submission: { ...zt, formAction: at }, preventScrollReset: ct || V, enableViewTransition: Se ? ue : void 0 }); else { let hn = rx(dt, Le); await $e(ut, dt, { overrideNavigation: hn, fetcherSubmission: We, preventScrollReset: ct || V, enableViewTransition: Se ? ue : void 0 }) } } async function I(Z, ce, Se, Le) { let We, ct = {}; try { We = await K8(f, Z, ce, Le, Se, !1) } catch (xt) { return ce.filter(at => at.shouldLoad).forEach(at => { ct[at.route.id] = { type: "error", error: xt } }), ct } if (Z.signal.aborted) return ct; for (let [xt, at] of Object.entries(We)) if (J8(at)) { let dt = at.result; ct[xt] = { type: "redirect", response: G8(dt, Z, xt, ce, u) } } else ct[xt] = await Y8(at); return ct } async function se(Z, ce, Se, Le) { let We = I(Se, Z, Le, null), ct = Promise.all(ce.map(async dt => { if (dt.matches && dt.match && dt.request && dt.controller) { let jt = (await I(dt.request, dt.matches, Le, dt.key))[dt.match.route.id]; return { [dt.key]: jt } } else return Promise.resolve({ [dt.key]: { type: "error", error: is(404, { pathname: dt.path }) } }) })), xt = await We, at = (await ct).reduce((dt, ut) => Object.assign(dt, ut), {}); return { loaderResults: xt, fetcherResults: at } } function ae() { we = !0, ie.forEach((Z, ce) => { K.has(ce) && xe.add(ce), Gt(ce) }) } function Ae(Z, ce, Se = {}) { k.fetchers.set(Z, ce), he({ fetchers: new Map(k.fetchers) }, { flushSync: (Se && Se.flushSync) === !0 }) } function qe(Z, ce, Se, Le = {}) { let We = Tl(k.matches, ce); Tt(Z), he({ errors: { [We.route.id]: Se }, fetchers: new Map(k.fetchers) }, { flushSync: (Le && Le.flushSync) === !0 }) } function rt(Z) { return oe.set(Z, (oe.get(Z) || 0) + 1), pe.has(Z) && pe.delete(Z), k.fetchers.get(Z) || I8 } function Tt(Z) { let ce = k.fetchers.get(Z); K.has(Z) && !(ce && ce.state === "loading" && He.has(Z)) && Gt(Z), ie.delete(Z), He.delete(Z), B.delete(Z), pe.delete(Z), xe.delete(Z), k.fetchers.delete(Z) } function yn(Z) { let ce = (oe.get(Z) || 0) - 1; ce <= 0 ? (oe.delete(Z), pe.add(Z)) : oe.set(Z, ce), he({ fetchers: new Map(k.fetchers) }) } function Gt(Z) { let ce = K.get(Z); ce && (ce.abort(), K.delete(Z)) } function $n(Z) { for (let ce of Z) { let Se = rt(ce), Le = yo(Se.data); k.fetchers.set(ce, Le) } } function cn() { let Z = [], ce = !1; for (let Se of B) { let Le = k.fetchers.get(Se); Yt(Le, `Expected fetcher: ${Se}`), Le.state === "loading" && (B.delete(Se), Z.push(Se), ce = !0) } return $n(Z), ce } function je(Z) { let ce = []; for (let [Se, Le] of He) if (Le < Z) { let We = k.fetchers.get(Se); Yt(We, `Expected fetcher: ${Se}`), We.state === "loading" && (Gt(Se), He.delete(Se), ce.push(Se)) } return $n(ce), ce.length > 0 } function tt(Z, ce) { let Se = k.blockers.get(Z) || Pd; return Ee.get(Z) !== ce && Ee.set(Z, ce), Se } function lt(Z) { k.blockers.delete(Z), Ee.delete(Z) } function le(Z, ce) { let Se = k.blockers.get(Z) || Pd; Yt(Se.state === "unblocked" && ce.state === "blocked" || Se.state === "blocked" && ce.state === "blocked" || Se.state === "blocked" && ce.state === "proceeding" || Se.state === "blocked" && ce.state === "unblocked" || Se.state === "proceeding" && ce.state === "unblocked", `Invalid blocker state transition: ${Se.state} -> ${ce.state}`); let Le = new Map(k.blockers); Le.set(Z, ce), he({ blockers: Le }) } function st({ currentLocation: Z, nextLocation: ce, historyAction: Se }) { if (Ee.size === 0) return; Ee.size > 1 && rr(!1, "A router only supports one blocker at a time"); let Le = Array.from(Ee.entries()), [We, ct] = Le[Le.length - 1], xt = k.blockers.get(We); if (!(xt && xt.state === "proceeding") && ct({ currentLocation: Z, nextLocation: ce, historyAction: Se })) return We } function wt(Z) { let ce = is(404, { pathname: Z }), Se = l || a, { matches: Le, route: We } = _j(Se); return { notFoundMatches: Le, route: We, error: ce } } function Qe(Z, ce, Se) { if (v = Z, S = ce, b = Se || null, !C && k.navigation === nx) { C = !0; let Le = gt(k.location, k.matches); Le != null && he({ restoreScrollPosition: Le }) } return () => { v = null, S = null, b = null } } function Te(Z, ce) { return b && b(Z, ce.map(Le => m8(Le, k.loaderData))) || Z.key } function Ze(Z, ce) { if (v && S) { let Se = Te(Z, ce); v[Se] = S() } } function gt(Z, ce) { if (v) { let Se = Te(Z, ce), Le = v[Se]; if (typeof Le == "number") return Le } return null } function vt(Z, ce, Se) { if (t.patchRoutesOnNavigation) if (Z) { if (Object.keys(Z[0].params).length > 0) return { active: !0, matches: gm(ce, Se, u, !0) } } else return { active: !0, matches: gm(ce, Se, u, !0) || [] }; return { active: !1, matches: null } } async function Nt(Z, ce, Se, Le) { if (!t.patchRoutesOnNavigation) return { type: "success", matches: Z }; let We = Z; for (; ;) { let ct = l == null, xt = l || a, at = s; try { await t.patchRoutesOnNavigation({ signal: Se, path: ce, matches: We, fetcherKey: Le, patch: (jt, St) => { Se.aborted || Nj(jt, St, xt, at, i) } }) } catch (jt) { return { type: "error", error: jt, partialMatches: We } } finally { ct && !Se.aborted && (a = [...a]) } if (Se.aborted) return { type: "aborted" }; let dt = To(xt, ce, u); if (dt) return { type: "success", matches: dt }; let ut = gm(xt, ce, u, !0); if (!ut || We.length === ut.length && We.every((jt, St) => jt.route.id === ut[St].route.id)) return { type: "success", matches: null }; We = ut } } function rn(Z) { s = {}, l = Bm(Z, i, void 0, s) } function Un(Z, ce) { let Se = l == null; Nj(Z, ce, l || a, s, i), Se && (a = [...a], he({})) } return E = { get basename() { return u }, get future() { return p }, get state() { return k }, get routes() { return a }, get window() { return e }, initialize: et, subscribe: De, enableScrollRestoration: Qe, navigate: Y, fetch: it, revalidate: Je, createHref: Z => t.history.createHref(Z), encodeLocation: Z => t.history.encodeLocation(Z), getFetcher: rt, deleteFetcher: yn, dispose: Xe, getBlocker: tt, deleteBlocker: lt, patchRoutes: Un, _internalFetchControllers: K, _internalSetRoutes: rn }, E } function $8(t) { return t != null && ("formData" in t && t.formData != null || "body" in t && t.body !== void 0) } function Sb(t, e, n, r, i, s) { let a, l; if (i) { a = []; for (let f of e) if (a.push(f), f.route.id === i) { l = f; break } } else a = e, l = e[e.length - 1]; let u = oy(r || ".", ay(a), ds(t.pathname, n) || t.pathname, s === "path"); if (r == null && (u.search = t.search, u.hash = t.hash), (r == null || r === "" || r === ".") && l) { let f = xw(u.search); if (l.route.index && !f) u.search = u.search ? u.search.replace(/^\?/, "?index&") : "?index"; else if (!l.route.index && f) { let p = new URLSearchParams(u.search), g = p.getAll("index"); p.delete("index"), g.filter(v => v).forEach(v => p.append("index", v)); let y = p.toString(); u.search = y ? `?${y}` : "" } } return n !== "/" && (u.pathname = u.pathname === "/" ? n : Xs([n, u.pathname])), Fo(u) } function Cj(t, e, n) {
    if (!n || !$8(n)) return { path: e }; if (n.formMethod && !Z8(n.formMethod)) return { path: e, error: is(405, { method: n.formMethod }) }; let r = () => ({ path: e, error: is(400, { type: "invalid-body" }) }), s = (n.formMethod || "get").toUpperCase(), a = fO(e); if (n.body !== void 0) {
      if (n.formEncType === "text/plain") {
        if (!Pi(s)) return r(); let g = typeof n.body == "string" ? n.body : n.body instanceof FormData || n.body instanceof URLSearchParams ? Array.from(n.body.entries()).reduce((y, [v, b]) => `${y}${v}=${b}
`, "") : String(n.body); return { path: e, submission: { formMethod: s, formAction: a, formEncType: n.formEncType, formData: void 0, json: void 0, text: g } }
      } else if (n.formEncType === "application/json") { if (!Pi(s)) return r(); try { let g = typeof n.body == "string" ? JSON.parse(n.body) : n.body; return { path: e, submission: { formMethod: s, formAction: a, formEncType: n.formEncType, formData: void 0, json: g, text: void 0 } } } catch { return r() } }
    } Yt(typeof FormData == "function", "FormData is not available in this environment"); let l, u; if (n.formData) l = Nb(n.formData), u = n.formData; else if (n.body instanceof FormData) l = Nb(n.body), u = n.body; else if (n.body instanceof URLSearchParams) l = n.body, u = Oj(l); else if (n.body == null) l = new URLSearchParams, u = new FormData; else try { l = new URLSearchParams(n.body), u = Oj(l) } catch { return r() } let f = { formMethod: s, formAction: a, formEncType: n && n.formEncType || "application/x-www-form-urlencoded", formData: u, json: void 0, text: void 0 }; if (Pi(f.formMethod)) return { path: e, submission: f }; let p = qo(e); return t && p.search && xw(p.search) && l.append("index", ""), p.search = `?${l}`, { path: Fo(p), submission: f }
  } function Tj(t, e, n, r, i, s, a, l, u, f, p, g, y, v, b, S, C, T, A, M) { let O = M ? Li(M[1]) ? M[1].error : M[1].data : void 0, E = i.createURL(s.location), k = i.createURL(u), z; if (p && s.errors) { let H = Object.keys(s.errors)[0]; z = a.findIndex(we => we.route.id === H) } else if (M && Li(M[1])) { let H = M[0]; z = a.findIndex(we => we.route.id === H) - 1 } let V = M ? M[1].statusCode : void 0, q = V && V >= 400, ue = { currentUrl: E, currentParams: s.matches[0]?.params || {}, nextUrl: k, nextParams: a[0].params, ...l, actionResult: O, actionStatus: V }, W = a.map((H, we) => { let { route: xe } = H, K = null; if (z != null && we > z ? K = !1 : xe.lazy ? K = !0 : xe.loader == null ? K = !1 : p ? K = Cb(xe, s.loaderData, s.errors) : U8(s.loaderData, s.matches[we], H) && (K = !0), K !== null) return Tb(n, r, t, H, f, e, K); let te = q ? !1 : g || E.pathname + E.search === k.pathname + k.search || E.search !== k.search || V8(s.matches[we], H), ye = { ...ue, defaultShouldRevalidate: te }, He = Vm(H, ye); return Tb(n, r, t, H, f, e, He, ye) }), ne = []; return b.forEach((H, we) => { if (p || !a.some(oe => oe.route.id === H.routeId) || v.has(we)) return; let xe = s.fetchers.get(we), K = xe && xe.state !== "idle" && xe.data === void 0, te = To(C, H.path, T); if (!te) { if (A && K) return; ne.push({ key: we, routeId: H.routeId, path: H.path, matches: null, match: null, request: null, controller: null }); return } if (S.has(we)) return; let ye = Xd(te, H.path), He = new AbortController, B = Xc(i, H.path, He.signal), ie = null; if (y.has(we)) y.delete(we), ie = cu(n, r, B, te, ye, f, e); else if (K) g && (ie = cu(n, r, B, te, ye, f, e)); else { let oe = { ...ue, defaultShouldRevalidate: q ? !1 : g }; Vm(ye, oe) && (ie = cu(n, r, B, te, ye, f, e, oe)) } ie && ne.push({ key: we, routeId: H.routeId, path: H.path, matches: ie, match: ye, request: B, controller: He }) }), { dsMatches: W, revalidatingFetchers: ne } } function Cb(t, e, n) { if (t.lazy) return !0; if (!t.loader) return !1; let r = e != null && t.id in e, i = n != null && n[t.id] !== void 0; return !r && i ? !1 : typeof t.loader == "function" && t.loader.hydrate === !0 ? !0 : !r && !i } function U8(t, e, n) { let r = !e || n.route.id !== e.route.id, i = !t.hasOwnProperty(n.route.id); return r || i } function V8(t, e) { let n = t.route.path; return t.pathname !== e.pathname || n != null && n.endsWith("*") && t.params["*"] !== e.params["*"] } function Vm(t, e) { if (t.route.shouldRevalidate) { let n = t.route.shouldRevalidate(e); if (typeof n == "boolean") return n } return e.defaultShouldRevalidate } function Nj(t, e, n, r, i) { let s; if (t) { let u = r[t]; Yt(u, `No route found to patch children into: routeId = ${t}`), u.children || (u.children = []), s = u.children } else s = n; let a = e.filter(u => !s.some(f => oO(u, f))), l = Bm(a, i, [t || "_", "patch", String(s?.length || "0")], r); s.push(...l) } function oO(t, e) { return "id" in t && "id" in e && t.id === e.id ? !0 : t.index === e.index && t.path === e.path && t.caseSensitive === e.caseSensitive ? (!t.children || t.children.length === 0) && (!e.children || e.children.length === 0) ? !0 : t.children.every((n, r) => e.children?.some(i => oO(n, i))) : !1 } var jj = new WeakMap, lO = ({ key: t, route: e, manifest: n, mapRouteProperties: r }) => { let i = n[e.id]; if (Yt(i, "No route found in manifest"), !i.lazy || typeof i.lazy != "object") return; let s = i.lazy[t]; if (!s) return; let a = jj.get(i); a || (a = {}, jj.set(i, a)); let l = a[t]; if (l) return l; let u = (async () => { let f = d8(t), g = i[t] !== void 0 && t !== "hasErrorBoundary"; if (f) rr(!f, "Route property " + t + " is not a supported lazy route property. This property will be ignored."), a[t] = Promise.resolve(); else if (g) rr(!1, `Route "${i.id}" has a static property "${t}" defined. The lazy property will be ignored.`); else { let y = await s(); y != null && (Object.assign(i, { [t]: y }), Object.assign(i, r(i))) } typeof i.lazy == "object" && (i.lazy[t] = void 0, Object.values(i.lazy).every(y => y === void 0) && (i.lazy = void 0)) })(); return a[t] = u, u }, Ej = new WeakMap; function H8(t, e, n, r, i) { let s = n[t.id]; if (Yt(s, "No route found in manifest"), !t.lazy) return { lazyRoutePromise: void 0, lazyHandlerPromise: void 0 }; if (typeof t.lazy == "function") { let p = Ej.get(s); if (p) return { lazyRoutePromise: p, lazyHandlerPromise: p }; let g = (async () => { Yt(typeof t.lazy == "function", "No lazy route function found"); let y = await t.lazy(), v = {}; for (let b in y) { let S = y[b]; if (S === void 0) continue; let C = h8(b), A = s[b] !== void 0 && b !== "hasErrorBoundary"; C ? rr(!C, "Route property " + b + " is not a supported property to be returned from a lazy route function. This property will be ignored.") : A ? rr(!A, `Route "${s.id}" has a static property "${b}" defined but its lazy function is also returning a value for this property. The lazy route property "${b}" will be ignored.`) : v[b] = S } Object.assign(s, v), Object.assign(s, { ...r(s), lazy: void 0 }) })(); return Ej.set(s, g), g.catch(() => { }), { lazyRoutePromise: g, lazyHandlerPromise: g } } let a = Object.keys(t.lazy), l = [], u; for (let p of a) { if (i && i.includes(p)) continue; let g = lO({ key: p, route: t, manifest: n, mapRouteProperties: r }); g && (l.push(g), p === e && (u = g)) } let f = l.length > 0 ? Promise.all(l).then(() => { }) : void 0; return f?.catch(() => { }), u?.catch(() => { }), { lazyRoutePromise: f, lazyHandlerPromise: u } } async function Aj(t) { let e = t.matches.filter(i => i.shouldLoad), n = {}; return (await Promise.all(e.map(i => i.resolve()))).forEach((i, s) => { n[e[s].route.id] = i }), n } async function q8(t) { return t.matches.some(e => e.route.unstable_middleware) ? cO(t, !1, () => Aj(t), (e, n) => ({ [n]: { type: "error", result: e } })) : Aj(t) } async function cO(t, e, n, r) { let { matches: i, request: s, params: a, context: l } = t, u = { handlerResult: void 0 }; try { let f = i.flatMap(g => g.route.unstable_middleware ? g.route.unstable_middleware.map(y => [g.route.id, y]) : []), p = await uO({ request: s, params: a, context: l }, f, e, u, n); return e ? p : u.handlerResult } catch (f) { if (!u.middlewareError) throw f; let p = await r(u.middlewareError.error, u.middlewareError.routeId); return u.handlerResult ? Object.assign(u.handlerResult, p) : p } } async function uO(t, e, n, r, i, s = 0) { let { request: a } = t; if (a.signal.aborted) throw a.signal.reason ? a.signal.reason : new Error(`Request aborted without an \`AbortSignal.reason\`: ${a.method} ${a.url}`); let l = e[s]; if (!l) return r.handlerResult = await i(), r.handlerResult; let [u, f] = l, p = !1, g, y = async () => { if (p) throw new Error("You may only call `next()` once per middleware"); p = !0, await uO(t, e, n, r, i, s + 1) }; try { let v = await f({ request: t.request, params: t.params, context: t.context }, y); return p ? v === void 0 ? g : v : y() } catch (v) { throw r.middlewareError ? r.middlewareError.error !== v && (r.middlewareError = { routeId: u, error: v }) : r.middlewareError = { routeId: u, error: v }, v } } function dO(t, e, n, r, i) { let s = lO({ key: "unstable_middleware", route: r.route, manifest: e, mapRouteProperties: t }), a = H8(r.route, Pi(n.method) ? "action" : "loader", e, t, i); return { middleware: s, route: a.lazyRoutePromise, handler: a.lazyHandlerPromise } } function Tb(t, e, n, r, i, s, a, l = null) { let u = !1, f = dO(t, e, n, r, i); return { ...r, _lazyPromises: f, shouldLoad: a, unstable_shouldRevalidateArgs: l, unstable_shouldCallHandler(p) { return u = !0, l ? typeof p == "boolean" ? Vm(r, { ...l, defaultShouldRevalidate: p }) : Vm(r, l) : a }, resolve(p) { return u || a || p && n.method === "GET" && (r.route.lazy || r.route.loader) ? W8({ request: n, match: r, lazyHandlerPromise: f?.handler, lazyRoutePromise: f?.route, handlerOverride: p, scopedContext: s }) : Promise.resolve({ type: "data", result: void 0 }) } } } function cu(t, e, n, r, i, s, a, l = null) { return r.map(u => u.route.id !== i.route.id ? { ...u, shouldLoad: !1, unstable_shouldRevalidateArgs: l, unstable_shouldCallHandler: () => !1, _lazyPromises: dO(t, e, n, u, s), resolve: () => Promise.resolve({ type: "data", result: void 0 }) } : Tb(t, e, n, u, s, a, !0, l)) } async function K8(t, e, n, r, i, s) { n.some(f => f._lazyPromises?.middleware) && await Promise.all(n.map(f => f._lazyPromises?.middleware)); let a = { request: e, params: n[0].params, context: i, matches: n }, u = await t({ ...a, fetcherKey: r, unstable_runClientMiddleware: f => { let p = a; return cO(p, !1, () => f({ ...p, fetcherKey: r, unstable_runClientMiddleware: () => { throw new Error("Cannot call `unstable_runClientMiddleware()` from within an `unstable_runClientMiddleware` handler") } }), (g, y) => ({ [y]: { type: "error", result: g } })) } }); try { await Promise.all(n.flatMap(f => [f._lazyPromises?.handler, f._lazyPromises?.route])) } catch { } return u } async function W8({ request: t, match: e, lazyHandlerPromise: n, lazyRoutePromise: r, handlerOverride: i, scopedContext: s }) { let a, l, u = Pi(t.method), f = u ? "action" : "loader", p = g => { let y, v = new Promise((C, T) => y = T); l = () => y(), t.signal.addEventListener("abort", l); let b = C => typeof g != "function" ? Promise.reject(new Error(`You cannot call the handler for a route which defines a boolean "${f}" [routeId: ${e.route.id}]`)) : g({ request: t, params: e.params, context: s }, ...C !== void 0 ? [C] : []), S = (async () => { try { return { type: "data", result: await (i ? i(T => b(T)) : b()) } } catch (C) { return { type: "error", result: C } } })(); return Promise.race([S, v]) }; try { let g = u ? e.route.action : e.route.loader; if (n || r) if (g) { let y, [v] = await Promise.all([p(g).catch(b => { y = b }), n, r]); if (y !== void 0) throw y; a = v } else { await n; let y = u ? e.route.action : e.route.loader; if (y) [a] = await Promise.all([p(y), r]); else if (f === "action") { let v = new URL(t.url), b = v.pathname + v.search; throw is(405, { method: t.method, pathname: b, routeId: e.route.id }) } else return { type: "data", result: void 0 } } else if (g) a = await p(g); else { let y = new URL(t.url), v = y.pathname + y.search; throw is(404, { pathname: v }) } } catch (g) { return { type: "error", result: g } } finally { l && t.signal.removeEventListener("abort", l) } return a } async function Y8(t) { let { result: e, type: n } = t; if (hO(e)) { let r; try { let i = e.headers.get("Content-Type"); i && /\bapplication\/json\b/.test(i) ? e.body == null ? r = null : r = await e.json() : r = await e.text() } catch (i) { return { type: "error", error: i } } return n === "error" ? { type: "error", error: new Um(e.status, e.statusText, r), statusCode: e.status, headers: e.headers } : { type: "data", data: r, statusCode: e.status, headers: e.headers } } return n === "error" ? Lj(e) ? e.data instanceof Error ? { type: "error", error: e.data, statusCode: e.init?.status, headers: e.init?.headers ? new Headers(e.init.headers) : void 0 } : { type: "error", error: new Um(e.init?.status || 500, void 0, e.data), statusCode: Of(e) ? e.status : void 0, headers: e.init?.headers ? new Headers(e.init.headers) : void 0 } : { type: "error", error: e, statusCode: Of(e) ? e.status : void 0 } : Lj(e) ? { type: "data", data: e.data, statusCode: e.init?.status, headers: e.init?.headers ? new Headers(e.init.headers) : void 0 } : { type: "data", data: e } } function G8(t, e, n, r, i) { let s = t.headers.get("Location"); if (Yt(s, "Redirects returned/thrown from loaders/actions must have a Location header"), !vw.test(s)) { let a = r.slice(0, r.findIndex(l => l.route.id === n) + 1); s = Sb(new URL(e.url), a, i, s), t.headers.set("Location", s) } return t } function kj(t, e, n) { if (vw.test(t)) { let r = t, i = r.startsWith("//") ? new URL(e.protocol + r) : new URL(r), s = ds(i.pathname, n) != null; if (i.origin === e.origin && s) return i.pathname + i.search + i.hash } return t } function Xc(t, e, n, r) { let i = t.createURL(fO(e)).toString(), s = { signal: n }; if (r && Pi(r.formMethod)) { let { formMethod: a, formEncType: l } = r; s.method = a.toUpperCase(), l === "application/json" ? (s.headers = new Headers({ "Content-Type": l }), s.body = JSON.stringify(r.json)) : l === "text/plain" ? s.body = r.text : l === "application/x-www-form-urlencoded" && r.formData ? s.body = Nb(r.formData) : s.body = r.formData } return new Request(i, s) } function Nb(t) { let e = new URLSearchParams; for (let [n, r] of t.entries()) e.append(n, typeof r == "string" ? r : r.name); return e } function Oj(t) { let e = new FormData; for (let [n, r] of t.entries()) e.append(n, r); return e } function X8(t, e, n, r = !1, i = !1) { let s = {}, a = null, l, u = !1, f = {}, p = n && Li(n[1]) ? n[1].error : void 0; return t.forEach(g => { if (!(g.route.id in e)) return; let y = g.route.id, v = e[y]; if (Yt(!El(v), "Cannot handle redirect results in processLoaderData"), Li(v)) { let b = v.error; if (p !== void 0 && (b = p, p = void 0), a = a || {}, i) a[y] = b; else { let S = Tl(t, y); a[S.route.id] == null && (a[S.route.id] = b) } r || (s[y] = aO), u || (u = !0, l = Of(v.error) ? v.error.status : 500), v.headers && (f[y] = v.headers) } else s[y] = v.data, v.statusCode && v.statusCode !== 200 && !u && (l = v.statusCode), v.headers && (f[y] = v.headers) }), p !== void 0 && n && (a = { [n[0]]: p }, n[2] && (s[n[2]] = void 0)), { loaderData: s, errors: a, statusCode: l || 200, loaderHeaders: f } } function Mj(t, e, n, r, i, s) { let { loaderData: a, errors: l } = X8(e, n, r); return i.filter(u => !u.matches || u.matches.some(f => f.shouldLoad)).forEach(u => { let { key: f, match: p, controller: g } = u, y = s[f]; if (Yt(y, "Did not find corresponding fetcher result"), !(g && g.signal.aborted)) if (Li(y)) { let v = Tl(t.matches, p?.route.id); l && l[v.route.id] || (l = { ...l, [v.route.id]: y.error }), t.fetchers.delete(f) } else if (El(y)) Yt(!1, "Unhandled fetcher revalidation redirect"); else { let v = yo(y.data); t.fetchers.set(f, v) } }), { loaderData: a, errors: l } } function Dj(t, e, n, r) { let i = Object.entries(e).filter(([, s]) => s !== aO).reduce((s, [a, l]) => (s[a] = l, s), {}); for (let s of n) { let a = s.route.id; if (!e.hasOwnProperty(a) && t.hasOwnProperty(a) && s.route.loader && (i[a] = t[a]), r && r.hasOwnProperty(a)) break } return i } function Rj(t) { return t ? Li(t[1]) ? { actionData: {} } : { actionData: { [t[0]]: t[1].data } } : {} } function Tl(t, e) { return (e ? t.slice(0, t.findIndex(r => r.route.id === e) + 1) : [...t]).reverse().find(r => r.route.hasErrorBoundary === !0) || t[0] } function _j(t) { let e = t.length === 1 ? t[0] : t.find(n => n.index || !n.path || n.path === "/") || { id: "__shim-error-route__" }; return { matches: [{ params: {}, pathname: "", pathnameBase: "", route: e }], route: e } } function is(t, { pathname: e, routeId: n, method: r, type: i, message: s } = {}) { let a = "Unknown Server Error", l = "Unknown @remix-run/router error"; return t === 400 ? (a = "Bad Request", r && e && n ? l = `You made a ${r} request to "${e}" but did not provide a \`loader\` for route "${n}", so there is no way to handle the request.` : i === "invalid-body" && (l = "Unable to encode submission body")) : t === 403 ? (a = "Forbidden", l = `Route "${n}" does not match URL "${e}"`) : t === 404 ? (a = "Not Found", l = `No route matches URL "${e}"`) : t === 405 && (a = "Method Not Allowed", r && e && n ? l = `You made a ${r.toUpperCase()} request to "${e}" but did not provide an \`action\` for route "${n}", so there is no way to handle the request.` : r && (l = `Invalid request method "${r.toUpperCase()}"`)), new Um(t || 500, a, new Error(l), !0) } function Lp(t) { let e = Object.entries(t); for (let n = e.length - 1; n >= 0; n--) { let [r, i] = e[n]; if (El(i)) return { key: r, result: i } } } function fO(t) { let e = typeof t == "string" ? qo(t) : t; return Fo({ ...e, hash: "" }) } function Q8(t, e) { return t.pathname !== e.pathname || t.search !== e.search ? !1 : t.hash === "" ? e.hash !== "" : t.hash === e.hash ? !0 : e.hash !== "" } function J8(t) { return hO(t.result) && P8.has(t.result.status) } function Li(t) { return t.type === "error" } function El(t) { return (t && t.type) === "redirect" } function Lj(t) { return typeof t == "object" && t != null && "type" in t && "data" in t && "init" in t && t.type === "DataWithResponseInit" } function hO(t) { return t != null && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.headers == "object" && typeof t.body < "u" } function Z8(t) { return L8.has(t.toUpperCase()) } function Pi(t) { return R8.has(t.toUpperCase()) } function xw(t) { return new URLSearchParams(t).getAll("index").some(e => e === "") } function Xd(t, e) { let n = typeof e == "string" ? qo(e).search : e.search; if (t[t.length - 1].route.index && xw(n || "")) return t[t.length - 1]; let r = rO(t); return r[r.length - 1] } function Pj(t) { let { formMethod: e, formAction: n, formEncType: r, text: i, formData: s, json: a } = t; if (!(!e || !n || !r)) { if (i != null) return { formMethod: e, formAction: n, formEncType: r, formData: void 0, json: void 0, text: i }; if (s != null) return { formMethod: e, formAction: n, formEncType: r, formData: s, json: void 0, text: void 0 }; if (a !== void 0) return { formMethod: e, formAction: n, formEncType: r, formData: void 0, json: a, text: void 0 } } } function rx(t, e) { return e ? { state: "loading", location: t, formMethod: e.formMethod, formAction: e.formAction, formEncType: e.formEncType, formData: e.formData, json: e.json, text: e.text } : { state: "loading", location: t, formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0 } } function ez(t, e) { return { state: "submitting", location: t, formMethod: e.formMethod, formAction: e.formAction, formEncType: e.formEncType, formData: e.formData, json: e.json, text: e.text } } function zd(t, e) { return t ? { state: "loading", formMethod: t.formMethod, formAction: t.formAction, formEncType: t.formEncType, formData: t.formData, json: t.json, text: t.text, data: e } : { state: "loading", formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0, data: e } } function tz(t, e) { return { state: "submitting", formMethod: t.formMethod, formAction: t.formAction, formEncType: t.formEncType, formData: t.formData, json: t.json, text: t.text, data: e ? e.data : void 0 } } function yo(t) { return { state: "idle", formMethod: void 0, formAction: void 0, formEncType: void 0, formData: void 0, json: void 0, text: void 0, data: t } } function nz(t, e) { try { let n = t.sessionStorage.getItem(sO); if (n) { let r = JSON.parse(n); for (let [i, s] of Object.entries(r || {})) s && Array.isArray(s) && e.set(i, new Set(s || [])) } } catch { } } function rz(t, e) { if (e.size > 0) { let n = {}; for (let [r, i] of e) n[r] = [...i]; try { t.sessionStorage.setItem(sO, JSON.stringify(n)) } catch (r) { rr(!1, `Failed to save applied view transitions in sessionStorage (${r}).`) } } } function iz() { let t, e, n = new Promise((r, i) => { t = async s => { r(s); try { await n } catch { } }, e = async s => { i(s); try { await n } catch { } } }); return { promise: n, resolve: t, reject: e } } var ac = N.createContext(null); ac.displayName = "DataRouter"; var ch = N.createContext(null); ch.displayName = "DataRouterState"; var bw = N.createContext({ isTransitioning: !1 }); bw.displayName = "ViewTransition"; var pO = N.createContext(new Map); pO.displayName = "Fetchers"; var sz = N.createContext(null); sz.displayName = "Await"; var ks = N.createContext(null); ks.displayName = "Navigation"; var ly = N.createContext(null); ly.displayName = "Location"; var Os = N.createContext({ outlet: null, matches: [], isDataRoute: !1 }); Os.displayName = "Route"; var ww = N.createContext(null); ww.displayName = "RouteError"; function az(t, { relative: e } = {}) { Yt(Nu(), "useHref() may be used only in the context of a <Router> component."); let { basename: n, navigator: r } = N.useContext(ks), { hash: i, pathname: s, search: a } = uh(t, { relative: e }), l = s; return n !== "/" && (l = s === "/" ? n : Xs([n, s])), r.createHref({ pathname: l, search: a, hash: i }) } function Nu() { return N.useContext(ly) != null } function Ko() { return Yt(Nu(), "useLocation() may be used only in the context of a <Router> component."), N.useContext(ly).location } var mO = "You should call navigate() in a React.useEffect(), not when your component is first rendered."; function gO(t) { N.useContext(ks).static || N.useLayoutEffect(t) } function ln() { let { isDataRoute: t } = N.useContext(Os); return t ? wz() : oz() } function oz() { Yt(Nu(), "useNavigate() may be used only in the context of a <Router> component."); let t = N.useContext(ac), { basename: e, navigator: n } = N.useContext(ks), { matches: r } = N.useContext(Os), { pathname: i } = Ko(), s = JSON.stringify(ay(r)), a = N.useRef(!1); return gO(() => { a.current = !0 }), N.useCallback((u, f = {}) => { if (rr(a.current, mO), !a.current) return; if (typeof u == "number") { n.go(u); return } let p = oy(u, JSON.parse(s), i, f.relative === "path"); t == null && e !== "/" && (p.pathname = p.pathname === "/" ? e : Xs([e, p.pathname])), (f.replace ? n.replace : n.push)(p, f.state, f) }, [e, n, s, i, t]) } var lz = N.createContext(null); function cz(t) { let e = N.useContext(Os).outlet; return e && N.createElement(lz.Provider, { value: t }, e) } function uh(t, { relative: e } = {}) { let { matches: n } = N.useContext(Os), { pathname: r } = Ko(), i = JSON.stringify(ay(n)); return N.useMemo(() => oy(t, JSON.parse(i), r, e === "path"), [t, i, r, e]) } function uz(t, e, n, r) {
    Yt(Nu(), "useRoutes() may be used only in the context of a <Router> component."); let { navigator: i } = N.useContext(ks), { matches: s } = N.useContext(Os), a = s[s.length - 1], l = a ? a.params : {}, u = a ? a.pathname : "/", f = a ? a.pathnameBase : "/", p = a && a.route; {
      let T = p && p.path || ""; yO(u, !p || T.endsWith("*") || T.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${u}" (under <Route path="${T}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${T}"> to <Route path="${T === "/" ? "*" : `${T}/*`}">.`)
    } let g = Ko(), y; y = g; let v = y.pathname || "/", b = v; if (f !== "/") { let T = f.replace(/^\//, "").split("/"); b = "/" + v.replace(/^\//, "").split("/").slice(T.length).join("/") } let S = To(t, { pathname: b }); return rr(p || S != null, `No routes matched location "${y.pathname}${y.search}${y.hash}" `), rr(S == null || S[S.length - 1].route.element !== void 0 || S[S.length - 1].route.Component !== void 0 || S[S.length - 1].route.lazy !== void 0, `Matched leaf route at location "${y.pathname}${y.search}${y.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`), mz(S && S.map(T => Object.assign({}, T, { params: Object.assign({}, l, T.params), pathname: Xs([f, i.encodeLocation ? i.encodeLocation(T.pathname).pathname : T.pathname]), pathnameBase: T.pathnameBase === "/" ? f : Xs([f, i.encodeLocation ? i.encodeLocation(T.pathnameBase).pathname : T.pathnameBase]) })), s, n, r)
  } function dz() { let t = bz(), e = Of(t) ? `${t.status} ${t.statusText}` : t instanceof Error ? t.message : JSON.stringify(t), n = t instanceof Error ? t.stack : null, r = "rgba(200,200,200, 0.5)", i = { padding: "0.5rem", backgroundColor: r }, s = { padding: "2px 4px", backgroundColor: r }, a = null; return console.error("Error handled by React Router default ErrorBoundary:", t), a = N.createElement(N.Fragment, null, N.createElement("p", null, " Hey developer "), N.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", N.createElement("code", { style: s }, "ErrorBoundary"), " or", " ", N.createElement("code", { style: s }, "errorElement"), " prop on your route.")), N.createElement(N.Fragment, null, N.createElement("h2", null, "Unexpected Application Error!"), N.createElement("h3", { style: { fontStyle: "italic" } }, e), n ? N.createElement("pre", { style: i }, n) : null, a) } var fz = N.createElement(dz, null), hz = class extends N.Component { constructor(t) { super(t), this.state = { location: t.location, revalidation: t.revalidation, error: t.error } } static getDerivedStateFromError(t) { return { error: t } } static getDerivedStateFromProps(t, e) { return e.location !== t.location || e.revalidation !== "idle" && t.revalidation === "idle" ? { error: t.error, location: t.location, revalidation: t.revalidation } : { error: t.error !== void 0 ? t.error : e.error, location: e.location, revalidation: t.revalidation || e.revalidation } } componentDidCatch(t, e) { console.error("React Router caught the following error during render", t, e) } render() { return this.state.error !== void 0 ? N.createElement(Os.Provider, { value: this.props.routeContext }, N.createElement(ww.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } }; function pz({ routeContext: t, match: e, children: n }) { let r = N.useContext(ac); return r && r.static && r.staticContext && (e.route.errorElement || e.route.ErrorBoundary) && (r.staticContext._deepestRenderedBoundaryId = e.route.id), N.createElement(Os.Provider, { value: t }, n) } function mz(t, e = [], n = null, r = null) { if (t == null) { if (!n) return null; if (n.errors) t = n.matches; else if (e.length === 0 && !n.initialized && n.matches.length > 0) t = n.matches; else return null } let i = t, s = n?.errors; if (s != null) { let u = i.findIndex(f => f.route.id && s?.[f.route.id] !== void 0); Yt(u >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(s).join(",")}`), i = i.slice(0, Math.min(i.length, u + 1)) } let a = !1, l = -1; if (n) for (let u = 0; u < i.length; u++) { let f = i[u]; if ((f.route.HydrateFallback || f.route.hydrateFallbackElement) && (l = u), f.route.id) { let { loaderData: p, errors: g } = n, y = f.route.loader && !p.hasOwnProperty(f.route.id) && (!g || g[f.route.id] === void 0); if (f.route.lazy || y) { a = !0, l >= 0 ? i = i.slice(0, l + 1) : i = [i[0]]; break } } } return i.reduceRight((u, f, p) => { let g, y = !1, v = null, b = null; n && (g = s && f.route.id ? s[f.route.id] : void 0, v = f.route.errorElement || fz, a && (l < 0 && p === 0 ? (yO("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), y = !0, b = null) : l === p && (y = !0, b = f.route.hydrateFallbackElement || null))); let S = e.concat(i.slice(0, p + 1)), C = () => { let T; return g ? T = v : y ? T = b : f.route.Component ? T = N.createElement(f.route.Component, null) : f.route.element ? T = f.route.element : T = u, N.createElement(pz, { match: f, routeContext: { outlet: u, matches: S, isDataRoute: n != null }, children: T }) }; return n && (f.route.ErrorBoundary || f.route.errorElement || p === 0) ? N.createElement(hz, { location: n.location, revalidation: n.revalidation, component: v, error: g, children: C(), routeContext: { outlet: null, matches: S, isDataRoute: !0 } }) : C() }, null) } function Sw(t) { return `${t} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.` } function gz(t) { let e = N.useContext(ac); return Yt(e, Sw(t)), e } function yz(t) { let e = N.useContext(ch); return Yt(e, Sw(t)), e } function vz(t) { let e = N.useContext(Os); return Yt(e, Sw(t)), e } function Cw(t) { let e = vz(t), n = e.matches[e.matches.length - 1]; return Yt(n.route.id, `${t} can only be used on routes that contain a unique "id"`), n.route.id } function xz() { return Cw("useRouteId") } function bz() { let t = N.useContext(ww), e = yz("useRouteError"), n = Cw("useRouteError"); return t !== void 0 ? t : e.errors?.[n] } function wz() { let { router: t } = gz("useNavigate"), e = Cw("useNavigate"), n = N.useRef(!1); return gO(() => { n.current = !0 }), N.useCallback(async (i, s = {}) => { rr(n.current, mO), n.current && (typeof i == "number" ? t.navigate(i) : await t.navigate(i, { fromRouteId: e, ...s })) }, [t, e]) } var zj = {}; function yO(t, e, n) { !e && !zj[t] && (zj[t] = !0, rr(!1, n)) } var Ij = {}; function Fj(t, e) { !t && !Ij[e] && (Ij[e] = !0, console.warn(e)) } function Sz(t) { let e = { hasErrorBoundary: t.hasErrorBoundary || t.ErrorBoundary != null || t.errorElement != null }; return t.Component && (t.element && rr(!1, "You should not include both `Component` and `element` on your route - `Component` will be used."), Object.assign(e, { element: N.createElement(t.Component), Component: void 0 })), t.HydrateFallback && (t.hydrateFallbackElement && rr(!1, "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."), Object.assign(e, { hydrateFallbackElement: N.createElement(t.HydrateFallback), HydrateFallback: void 0 })), t.ErrorBoundary && (t.errorElement && rr(!1, "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."), Object.assign(e, { errorElement: N.createElement(t.ErrorBoundary), ErrorBoundary: void 0 })), e } var Cz = ["HydrateFallback", "hydrateFallbackElement"], Tz = class { constructor() { this.status = "pending", this.promise = new Promise((t, e) => { this.resolve = n => { this.status === "pending" && (this.status = "resolved", t(n)) }, this.reject = n => { this.status === "pending" && (this.status = "rejected", e(n)) } }) } }; function Nz({ router: t, flushSync: e }) { let [n, r] = N.useState(t.state), [i, s] = N.useState(), [a, l] = N.useState({ isTransitioning: !1 }), [u, f] = N.useState(), [p, g] = N.useState(), [y, v] = N.useState(), b = N.useRef(new Map), S = N.useCallback((M, { deletedFetchers: O, flushSync: E, viewTransitionOpts: k }) => { M.fetchers.forEach((V, q) => { V.data !== void 0 && b.current.set(q, V.data) }), O.forEach(V => b.current.delete(V)), Fj(E === !1 || e != null, 'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from "react-router/dom"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.'); let z = t.window != null && t.window.document != null && typeof t.window.document.startViewTransition == "function"; if (Fj(k == null || z, "You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available."), !k || !z) { e && E ? e(() => r(M)) : N.startTransition(() => r(M)); return } if (e && E) { e(() => { p && (u && u.resolve(), p.skipTransition()), l({ isTransitioning: !0, flushSync: !0, currentLocation: k.currentLocation, nextLocation: k.nextLocation }) }); let V = t.window.document.startViewTransition(() => { e(() => r(M)) }); V.finished.finally(() => { e(() => { f(void 0), g(void 0), s(void 0), l({ isTransitioning: !1 }) }) }), e(() => g(V)); return } p ? (u && u.resolve(), p.skipTransition(), v({ state: M, currentLocation: k.currentLocation, nextLocation: k.nextLocation })) : (s(M), l({ isTransitioning: !0, flushSync: !1, currentLocation: k.currentLocation, nextLocation: k.nextLocation })) }, [t.window, e, p, u]); N.useLayoutEffect(() => t.subscribe(S), [t, S]), N.useEffect(() => { a.isTransitioning && !a.flushSync && f(new Tz) }, [a]), N.useEffect(() => { if (u && i && t.window) { let M = i, O = u.promise, E = t.window.document.startViewTransition(async () => { N.startTransition(() => r(M)), await O }); E.finished.finally(() => { f(void 0), g(void 0), s(void 0), l({ isTransitioning: !1 }) }), g(E) } }, [i, u, t.window]), N.useEffect(() => { u && i && n.location.key === i.location.key && u.resolve() }, [u, p, n.location, i]), N.useEffect(() => { !a.isTransitioning && y && (s(y.state), l({ isTransitioning: !0, flushSync: !1, currentLocation: y.currentLocation, nextLocation: y.nextLocation }), v(void 0)) }, [a.isTransitioning, y]); let C = N.useMemo(() => ({ createHref: t.createHref, encodeLocation: t.encodeLocation, go: M => t.navigate(M), push: (M, O, E) => t.navigate(M, { state: O, preventScrollReset: E?.preventScrollReset }), replace: (M, O, E) => t.navigate(M, { replace: !0, state: O, preventScrollReset: E?.preventScrollReset }) }), [t]), T = t.basename || "/", A = N.useMemo(() => ({ router: t, navigator: C, static: !1, basename: T }), [t, C, T]); return N.createElement(N.Fragment, null, N.createElement(ac.Provider, { value: A }, N.createElement(ch.Provider, { value: n }, N.createElement(pO.Provider, { value: b.current }, N.createElement(bw.Provider, { value: a }, N.createElement(Oz, { basename: T, location: n.location, navigationType: n.historyAction, navigator: C }, N.createElement(jz, { routes: t.routes, future: t.future, state: n })))))), null) } var jz = N.memo(Ez); function Ez({ routes: t, future: e, state: n }) { return uz(t, void 0, n, e) } function Az({ to: t, replace: e, state: n, relative: r }) { Yt(Nu(), "<Navigate> may be used only in the context of a <Router> component."); let { static: i } = N.useContext(ks); rr(!i, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change."); let { matches: s } = N.useContext(Os), { pathname: a } = Ko(), l = ln(), u = oy(t, ay(s), a, r === "path"), f = JSON.stringify(u); return N.useEffect(() => { l(JSON.parse(f), { replace: e, state: n, relative: r }) }, [l, f, r, e, n]), null } function kz(t) { return cz(t.context) } function Oz({ basename: t = "/", children: e = null, location: n, navigationType: r = "POP", navigator: i, static: s = !1 }) { Yt(!Nu(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app."); let a = t.replace(/^\/*/, "/"), l = N.useMemo(() => ({ basename: a, navigator: i, static: s, future: {} }), [a, i, s]); typeof n == "string" && (n = qo(n)); let { pathname: u = "/", search: f = "", hash: p = "", state: g = null, key: y = "default" } = n, v = N.useMemo(() => { let b = ds(u, a); return b == null ? null : { location: { pathname: b, search: f, hash: p, state: g, key: y }, navigationType: r } }, [a, u, f, p, g, y, r]); return rr(v != null, `<Router basename="${a}"> is not able to match the URL "${u}${f}${p}" because it does not start with the basename, so the <Router> won't render anything.`), v == null ? null : N.createElement(ks.Provider, { value: l }, N.createElement(ly.Provider, { children: e, value: v })) } var ym = "get", vm = "application/x-www-form-urlencoded"; function cy(t) { return t != null && typeof t.tagName == "string" } function Mz(t) { return cy(t) && t.tagName.toLowerCase() === "button" } function Dz(t) { return cy(t) && t.tagName.toLowerCase() === "form" } function Rz(t) { return cy(t) && t.tagName.toLowerCase() === "input" } function _z(t) { return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) } function Lz(t, e) { return t.button === 0 && (!e || e === "_self") && !_z(t) } var Pp = null; function Pz() { if (Pp === null) try { new FormData(document.createElement("form"), 0), Pp = !1 } catch { Pp = !0 } return Pp } var zz = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]); function ix(t) { return t != null && !zz.has(t) ? (rr(!1, `"${t}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${vm}"`), null) : t } function Iz(t, e) { let n, r, i, s, a; if (Dz(t)) { let l = t.getAttribute("action"); r = l ? ds(l, e) : null, n = t.getAttribute("method") || ym, i = ix(t.getAttribute("enctype")) || vm, s = new FormData(t) } else if (Mz(t) || Rz(t) && (t.type === "submit" || t.type === "image")) { let l = t.form; if (l == null) throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>'); let u = t.getAttribute("formaction") || l.getAttribute("action"); if (r = u ? ds(u, e) : null, n = t.getAttribute("formmethod") || l.getAttribute("method") || ym, i = ix(t.getAttribute("formenctype")) || ix(l.getAttribute("enctype")) || vm, s = new FormData(l, t), !Pz()) { let { name: f, type: p, value: g } = t; if (p === "image") { let y = f ? `${f}.` : ""; s.append(`${y}x`, "0"), s.append(`${y}y`, "0") } else f && s.append(f, g) } } else { if (cy(t)) throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">'); n = ym, r = null, i = vm, a = t } return s && i === "text/plain" && (a = s, s = void 0), { action: r, method: n.toLowerCase(), encType: i, formData: s, body: a } } function Tw(t, e) { if (t === !1 || t === null || typeof t > "u") throw new Error(e) } async function Fz(t, e) { if (t.id in e) return e[t.id]; try { let n = await import(t.module); return e[t.id] = n, n } catch (n) { return console.error(`Error loading route module \`${t.module}\`, reloading page...`), console.error(n), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => { }) } } function Bz(t) { return t == null ? !1 : t.href == null ? t.rel === "preload" && typeof t.imageSrcSet == "string" && typeof t.imageSizes == "string" : typeof t.rel == "string" && typeof t.href == "string" } async function $z(t, e, n) { let r = await Promise.all(t.map(async i => { let s = e.routes[i.route.id]; if (s) { let a = await Fz(s, n); return a.links ? a.links() : [] } return [] })); return qz(r.flat(1).filter(Bz).filter(i => i.rel === "stylesheet" || i.rel === "preload").map(i => i.rel === "stylesheet" ? { ...i, rel: "prefetch", as: "style" } : { ...i, rel: "prefetch" })) } function Bj(t, e, n, r, i, s) { let a = (u, f) => n[f] ? u.route.id !== n[f].route.id : !0, l = (u, f) => n[f].pathname !== u.pathname || n[f].route.path?.endsWith("*") && n[f].params["*"] !== u.params["*"]; return s === "assets" ? e.filter((u, f) => a(u, f) || l(u, f)) : s === "data" ? e.filter((u, f) => { let p = r.routes[u.route.id]; if (!p || !p.hasLoader) return !1; if (a(u, f) || l(u, f)) return !0; if (u.route.shouldRevalidate) { let g = u.route.shouldRevalidate({ currentUrl: new URL(i.pathname + i.search + i.hash, window.origin), currentParams: n[0]?.params || {}, nextUrl: new URL(t, window.origin), nextParams: u.params, defaultShouldRevalidate: !0 }); if (typeof g == "boolean") return g } return !0 }) : [] } function Uz(t, e, { includeHydrateFallback: n } = {}) { return Vz(t.map(r => { let i = e.routes[r.route.id]; if (!i) return []; let s = [i.module]; return i.clientActionModule && (s = s.concat(i.clientActionModule)), i.clientLoaderModule && (s = s.concat(i.clientLoaderModule)), n && i.hydrateFallbackModule && (s = s.concat(i.hydrateFallbackModule)), i.imports && (s = s.concat(i.imports)), s }).flat(1)) } function Vz(t) { return [...new Set(t)] } function Hz(t) { let e = {}, n = Object.keys(t).sort(); for (let r of n) e[r] = t[r]; return e } function qz(t, e) { let n = new Set; return new Set(e), t.reduce((r, i) => { let s = JSON.stringify(Hz(i)); return n.has(s) || (n.add(s), r.push({ key: s, link: i })), r }, []) } Object.getOwnPropertyNames(Object.prototype).sort().join("\0"); var Kz = new Set([100, 101, 204, 205]); function Wz(t, e) { let n = typeof t == "string" ? new URL(t, typeof window > "u" ? "server://singlefetch/" : window.location.origin) : t; return n.pathname === "/" ? n.pathname = "_root.data" : e && ds(n.pathname, e) === "/" ? n.pathname = `${e.replace(/\/$/, "")}/_root.data` : n.pathname = `${n.pathname.replace(/\/$/, "")}.data`, n } function vO() { let t = N.useContext(ac); return Tw(t, "You must render this element inside a <DataRouterContext.Provider> element"), t } function Yz() { let t = N.useContext(ch); return Tw(t, "You must render this element inside a <DataRouterStateContext.Provider> element"), t } var Nw = N.createContext(void 0); Nw.displayName = "FrameworkContext"; function xO() { let t = N.useContext(Nw); return Tw(t, "You must render this element inside a <HydratedRouter> element"), t } function Gz(t, e) { let n = N.useContext(Nw), [r, i] = N.useState(!1), [s, a] = N.useState(!1), { onFocus: l, onBlur: u, onMouseEnter: f, onMouseLeave: p, onTouchStart: g } = e, y = N.useRef(null); N.useEffect(() => { if (t === "render" && a(!0), t === "viewport") { let S = T => { T.forEach(A => { a(A.isIntersecting) }) }, C = new IntersectionObserver(S, { threshold: .5 }); return y.current && C.observe(y.current), () => { C.disconnect() } } }, [t]), N.useEffect(() => { if (r) { let S = setTimeout(() => { a(!0) }, 100); return () => { clearTimeout(S) } } }, [r]); let v = () => { i(!0) }, b = () => { i(!1), a(!1) }; return n ? t !== "intent" ? [s, y, {}] : [s, y, { onFocus: Id(l, v), onBlur: Id(u, b), onMouseEnter: Id(f, v), onMouseLeave: Id(p, b), onTouchStart: Id(g, v) }] : [!1, y, {}] } function Id(t, e) { return n => { t && t(n), n.defaultPrevented || e(n) } } function Xz({ page: t, ...e }) { let { router: n } = vO(), r = N.useMemo(() => To(n.routes, t, n.basename), [n.routes, t, n.basename]); return r ? N.createElement(Jz, { page: t, matches: r, ...e }) : null } function Qz(t) { let { manifest: e, routeModules: n } = xO(), [r, i] = N.useState([]); return N.useEffect(() => { let s = !1; return $z(t, e, n).then(a => { s || i(a) }), () => { s = !0 } }, [t, e, n]), r } function Jz({ page: t, matches: e, ...n }) { let r = Ko(), { manifest: i, routeModules: s } = xO(), { basename: a } = vO(), { loaderData: l, matches: u } = Yz(), f = N.useMemo(() => Bj(t, e, u, i, r, "data"), [t, e, u, i, r]), p = N.useMemo(() => Bj(t, e, u, i, r, "assets"), [t, e, u, i, r]), g = N.useMemo(() => { if (t === r.pathname + r.search + r.hash) return []; let b = new Set, S = !1; if (e.forEach(T => { let A = i.routes[T.route.id]; !A || !A.hasLoader || (!f.some(M => M.route.id === T.route.id) && T.route.id in l && s[T.route.id]?.shouldRevalidate || A.hasClientLoader ? S = !0 : b.add(T.route.id)) }), b.size === 0) return []; let C = Wz(t, a); return S && b.size > 0 && C.searchParams.set("_routes", e.filter(T => b.has(T.route.id)).map(T => T.route.id).join(",")), [C.pathname + C.search] }, [a, l, r, i, f, e, t, s]), y = N.useMemo(() => Uz(p, i), [p, i]), v = Qz(p); return N.createElement(N.Fragment, null, g.map(b => N.createElement("link", { key: b, rel: "prefetch", as: "fetch", href: b, ...n })), y.map(b => N.createElement("link", { key: b, rel: "modulepreload", href: b, ...n })), v.map(({ key: b, link: S }) => N.createElement("link", { key: b, ...S }))) } function Zz(...t) { return e => { t.forEach(n => { typeof n == "function" ? n(e) : n != null && (n.current = e) }) } } var bO = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"; try { bO && (window.__reactRouterVersion = "7.6.2") } catch { } function eI(t, e) { return B8({ basename: e?.basename, unstable_getContext: e?.unstable_getContext, future: e?.future, history: o8({ window: e?.window }), hydrationData: tI(), routes: t, mapRouteProperties: Sz, hydrationRouteProperties: Cz, dataStrategy: e?.dataStrategy, patchRoutesOnNavigation: e?.patchRoutesOnNavigation, window: e?.window }).initialize() } function tI() { let t = window?.__staticRouterHydrationData; return t && t.errors && (t = { ...t, errors: nI(t.errors) }), t } function nI(t) { if (!t) return null; let e = Object.entries(t), n = {}; for (let [r, i] of e) if (i && i.__type === "RouteErrorResponse") n[r] = new Um(i.status, i.statusText, i.data, i.internal === !0); else if (i && i.__type === "Error") { if (i.__subType) { let s = window[i.__subType]; if (typeof s == "function") try { let a = new s(i.message); a.stack = "", n[r] = a } catch { } } if (n[r] == null) { let s = new Error(i.message); s.stack = "", n[r] = s } } else n[r] = i; return n } var wO = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, za = N.forwardRef(function ({ onClick: e, discover: n = "render", prefetch: r = "none", relative: i, reloadDocument: s, replace: a, state: l, target: u, to: f, preventScrollReset: p, viewTransition: g, ...y }, v) { let { basename: b } = N.useContext(ks), S = typeof f == "string" && wO.test(f), C, T = !1; if (typeof f == "string" && S && (C = f, bO)) try { let q = new URL(window.location.href), ue = f.startsWith("//") ? new URL(q.protocol + f) : new URL(f), W = ds(ue.pathname, b); ue.origin === q.origin && W != null ? f = W + ue.search + ue.hash : T = !0 } catch { rr(!1, `<Link to="${f}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`) } let A = az(f, { relative: i }), [M, O, E] = Gz(r, y), k = sI(f, { replace: a, state: l, target: u, preventScrollReset: p, relative: i, viewTransition: g }); function z(q) { e && e(q), q.defaultPrevented || k(q) } let V = N.createElement("a", { ...y, ...E, href: C || A, onClick: T || s ? e : z, ref: Zz(v, O), target: u, "data-discover": !S && n === "render" ? "true" : void 0 }); return M && !S ? N.createElement(N.Fragment, null, V, N.createElement(Xz, { page: A })) : V }); za.displayName = "Link"; var SO = N.forwardRef(function ({ "aria-current": e = "page", caseSensitive: n = !1, className: r = "", end: i = !1, style: s, to: a, viewTransition: l, children: u, ...f }, p) { let g = uh(a, { relative: f.relative }), y = Ko(), v = N.useContext(ch), { navigator: b, basename: S } = N.useContext(ks), C = v != null && uI(g) && l === !0, T = b.encodeLocation ? b.encodeLocation(g).pathname : g.pathname, A = y.pathname, M = v && v.navigation && v.navigation.location ? v.navigation.location.pathname : null; n || (A = A.toLowerCase(), M = M ? M.toLowerCase() : null, T = T.toLowerCase()), M && S && (M = ds(M, S) || M); const O = T !== "/" && T.endsWith("/") ? T.length - 1 : T.length; let E = A === T || !i && A.startsWith(T) && A.charAt(O) === "/", k = M != null && (M === T || !i && M.startsWith(T) && M.charAt(T.length) === "/"), z = { isActive: E, isPending: k, isTransitioning: C }, V = E ? e : void 0, q; typeof r == "function" ? q = r(z) : q = [r, E ? "active" : null, k ? "pending" : null, C ? "transitioning" : null].filter(Boolean).join(" "); let ue = typeof s == "function" ? s(z) : s; return N.createElement(za, { ...f, "aria-current": V, className: q, ref: p, style: ue, to: a, viewTransition: l }, typeof u == "function" ? u(z) : u) }); SO.displayName = "NavLink"; var rI = N.forwardRef(({ discover: t = "render", fetcherKey: e, navigate: n, reloadDocument: r, replace: i, state: s, method: a = ym, action: l, onSubmit: u, relative: f, preventScrollReset: p, viewTransition: g, ...y }, v) => { let b = lI(), S = cI(l, { relative: f }), C = a.toLowerCase() === "get" ? "get" : "post", T = typeof l == "string" && wO.test(l), A = M => { if (u && u(M), M.defaultPrevented) return; M.preventDefault(); let O = M.nativeEvent.submitter, E = O?.getAttribute("formmethod") || a; b(O || M.currentTarget, { fetcherKey: e, method: E, navigate: n, replace: i, state: s, relative: f, preventScrollReset: p, viewTransition: g }) }; return N.createElement("form", { ref: v, method: C, action: S, onSubmit: r ? u : A, ...y, "data-discover": !T && t === "render" ? "true" : void 0 }) }); rI.displayName = "Form"; function iI(t) { return `${t} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.` } function CO(t) { let e = N.useContext(ac); return Yt(e, iI(t)), e } function sI(t, { target: e, replace: n, state: r, preventScrollReset: i, relative: s, viewTransition: a } = {}) { let l = ln(), u = Ko(), f = uh(t, { relative: s }); return N.useCallback(p => { if (Lz(p, e)) { p.preventDefault(); let g = n !== void 0 ? n : Fo(u) === Fo(f); l(t, { replace: g, state: r, preventScrollReset: i, relative: s, viewTransition: a }) } }, [u, l, f, n, r, e, t, i, s, a]) } var aI = 0, oI = () => `__${String(++aI)}__`; function lI() { let { router: t } = CO("useSubmit"), { basename: e } = N.useContext(ks), n = xz(); return N.useCallback(async (r, i = {}) => { let { action: s, method: a, encType: l, formData: u, body: f } = Iz(r, e); if (i.navigate === !1) { let p = i.fetcherKey || oI(); await t.fetch(p, n, i.action || s, { preventScrollReset: i.preventScrollReset, formData: u, body: f, formMethod: i.method || a, formEncType: i.encType || l, flushSync: i.flushSync }) } else await t.navigate(i.action || s, { preventScrollReset: i.preventScrollReset, formData: u, body: f, formMethod: i.method || a, formEncType: i.encType || l, replace: i.replace, state: i.state, fromRouteId: n, flushSync: i.flushSync, viewTransition: i.viewTransition }) }, [t, e, n]) } function cI(t, { relative: e } = {}) { let { basename: n } = N.useContext(ks), r = N.useContext(Os); Yt(r, "useFormAction must be used inside a RouteContext"); let [i] = r.matches.slice(-1), s = { ...uh(t || ".", { relative: e }) }, a = Ko(); if (t == null) { s.search = a.search; let l = new URLSearchParams(s.search), u = l.getAll("index"); if (u.some(p => p === "")) { l.delete("index"), u.filter(g => g).forEach(g => l.append("index", g)); let p = l.toString(); s.search = p ? `?${p}` : "" } } return (!t || t === ".") && i.route.index && (s.search = s.search ? s.search.replace(/^\?/, "?index&") : "?index"), n !== "/" && (s.pathname = s.pathname === "/" ? n : Xs([n, s.pathname])), Fo(s) } function uI(t, e = {}) { let n = N.useContext(bw); Yt(n != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"); let { basename: r } = CO("useViewTransitionState"), i = uh(t, { relative: e.relative }); if (!n.isTransitioning) return !1; let s = ds(n.currentLocation.pathname, r) || n.currentLocation.pathname, a = ds(n.nextLocation.pathname, r) || n.nextLocation.pathname; return $m(i.pathname, a) != null || $m(i.pathname, s) != null } [...Kz]; var jw = J3(); const TO = Ha(jw);/**
 * react-router v7.6.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function dI(t) { return N.createElement(Nz, { flushSync: jw.flushSync, ...t }) } function fI() { const t = ln(); return N.useEffect(() => { t("/user-setting") }, []), d.jsx("div", { children: "Home" }) } const NO = "/assets/Logo-QpduObwk.png"; var sx, $j; function hI() { if ($j) return sx; $j = 1; function t(T) { this._maxSize = T, this.clear() } t.prototype.clear = function () { this._size = 0, this._values = Object.create(null) }, t.prototype.get = function (T) { return this._values[T] }, t.prototype.set = function (T, A) { return this._size >= this._maxSize && this.clear(), T in this._values || this._size++, this._values[T] = A }; var e = /[^.^\]^[]+|(?=\[\]|\.\.)/g, n = /^\d+$/, r = /^\d/, i = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g, s = /^\s*(['"]?)(.*?)(\1)\s*$/, a = 512, l = new t(a), u = new t(a), f = new t(a); sx = { Cache: t, split: g, normalizePath: p, setter: function (T) { var A = p(T); return u.get(T) || u.set(T, function (O, E) { for (var k = 0, z = A.length, V = O; k < z - 1;) { var q = A[k]; if (q === "__proto__" || q === "constructor" || q === "prototype") return O; V = V[A[k++]] } V[A[k]] = E }) }, getter: function (T, A) { var M = p(T); return f.get(T) || f.set(T, function (E) { for (var k = 0, z = M.length; k < z;)if (E != null || !A) E = E[M[k++]]; else return; return E }) }, join: function (T) { return T.reduce(function (A, M) { return A + (v(M) || n.test(M) ? "[" + M + "]" : (A ? "." : "") + M) }, "") }, forEach: function (T, A, M) { y(Array.isArray(T) ? T : g(T), A, M) } }; function p(T) { return l.get(T) || l.set(T, g(T).map(function (A) { return A.replace(s, "$2") })) } function g(T) { return T.match(e) || [""] } function y(T, A, M) { var O = T.length, E, k, z, V; for (k = 0; k < O; k++)E = T[k], E && (C(E) && (E = '"' + E + '"'), V = v(E), z = !V && /^\d+$/.test(E), A.call(M, E, V, z, k, T)) } function v(T) { return typeof T == "string" && T && ["'", '"'].indexOf(T.charAt(0)) !== -1 } function b(T) { return T.match(r) && !T.match(n) } function S(T) { return i.test(T) } function C(T) { return !v(T) && (b(T) || S(T)) } return sx } var zl = hI(), ax, Uj; function pI() { if (Uj) return ax; Uj = 1; const t = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g, e = p => p.match(t) || [], n = p => p[0].toUpperCase() + p.slice(1), r = (p, g) => e(p).join(g).toLowerCase(), i = p => e(p).reduce((g, y) => `${g}${g ? y[0].toUpperCase() + y.slice(1).toLowerCase() : y.toLowerCase()}`, ""); return ax = { words: e, upperFirst: n, camelCase: i, pascalCase: p => n(i(p)), snakeCase: p => r(p, "_"), kebabCase: p => r(p, "-"), sentenceCase: p => n(r(p, " ")), titleCase: p => e(p).map(n).join(" ") }, ax } var ox = pI(), zp = { exports: {} }, Vj; function mI() { if (Vj) return zp.exports; Vj = 1, zp.exports = function (i) { return t(e(i), i) }, zp.exports.array = t; function t(i, s) { var a = i.length, l = new Array(a), u = {}, f = a, p = n(s), g = r(i); for (s.forEach(function (v) { if (!g.has(v[0]) || !g.has(v[1])) throw new Error("Unknown node. There is an unknown node in the supplied edges.") }); f--;)u[f] || y(i[f], f, new Set); return l; function y(v, b, S) { if (S.has(v)) { var C; try { C = ", node was:" + JSON.stringify(v) } catch { C = "" } throw new Error("Cyclic dependency" + C) } if (!g.has(v)) throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(v)); if (!u[b]) { u[b] = !0; var T = p.get(v) || new Set; if (T = Array.from(T), b = T.length) { S.add(v); do { var A = T[--b]; y(A, g.get(A), S) } while (b); S.delete(v) } l[--a] = v } } } function e(i) { for (var s = new Set, a = 0, l = i.length; a < l; a++) { var u = i[a]; s.add(u[0]), s.add(u[1]) } return Array.from(s) } function n(i) { for (var s = new Map, a = 0, l = i.length; a < l; a++) { var u = i[a]; s.has(u[0]) || s.set(u[0], new Set), s.has(u[1]) || s.set(u[1], new Set), s.get(u[0]).add(u[1]) } return s } function r(i) { for (var s = new Map, a = 0, l = i.length; a < l; a++)s.set(i[a], a); return s } return zp.exports } var gI = mI(); const yI = Ha(gI), vI = Object.prototype.toString, xI = Error.prototype.toString, bI = RegExp.prototype.toString, wI = typeof Symbol < "u" ? Symbol.prototype.toString : () => "", SI = /^Symbol\((.*)\)(.*)$/; function CI(t) { return t != +t ? "NaN" : t === 0 && 1 / t < 0 ? "-0" : "" + t } function Hj(t, e = !1) { if (t == null || t === !0 || t === !1) return "" + t; const n = typeof t; if (n === "number") return CI(t); if (n === "string") return e ? `"${t}"` : t; if (n === "function") return "[Function " + (t.name || "anonymous") + "]"; if (n === "symbol") return wI.call(t).replace(SI, "Symbol($1)"); const r = vI.call(t).slice(8, -1); return r === "Date" ? isNaN(t.getTime()) ? "" + t : t.toISOString(t) : r === "Error" || t instanceof Error ? "[" + xI.call(t) + "]" : r === "RegExp" ? bI.call(t) : null } function Ro(t, e) { let n = Hj(t, e); return n !== null ? n : JSON.stringify(t, function (r, i) { let s = Hj(this[r], e); return s !== null ? s : i }, 2) } function jO(t) { return t == null ? [] : [].concat(t) } let EO, AO, kO, TI = /\$\{\s*(\w+)\s*\}/g; EO = Symbol.toStringTag; class qj { constructor(e, n, r, i) { this.name = void 0, this.message = void 0, this.value = void 0, this.path = void 0, this.type = void 0, this.params = void 0, this.errors = void 0, this.inner = void 0, this[EO] = "Error", this.name = "ValidationError", this.value = n, this.path = r, this.type = i, this.errors = [], this.inner = [], jO(e).forEach(s => { if (gi.isError(s)) { this.errors.push(...s.errors); const a = s.inner.length ? s.inner : [s]; this.inner.push(...a) } else this.errors.push(s) }), this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0] } } AO = Symbol.hasInstance; kO = Symbol.toStringTag; class gi extends Error { static formatError(e, n) { const r = n.label || n.path || "this"; return n = Object.assign({}, n, { path: r, originalPath: n.path }), typeof e == "string" ? e.replace(TI, (i, s) => Ro(n[s])) : typeof e == "function" ? e(n) : e } static isError(e) { return e && e.name === "ValidationError" } constructor(e, n, r, i, s) { const a = new qj(e, n, r, i); if (s) return a; super(), this.value = void 0, this.path = void 0, this.type = void 0, this.params = void 0, this.errors = [], this.inner = [], this[kO] = "Error", this.name = a.name, this.message = a.message, this.type = a.type, this.value = a.value, this.path = a.path, this.errors = a.errors, this.inner = a.inner, Error.captureStackTrace && Error.captureStackTrace(this, gi) } static [AO](e) { return qj[Symbol.hasInstance](e) || super[Symbol.hasInstance](e) } } let qs = { default: "${path} is invalid", required: "${path} is a required field", defined: "${path} must be defined", notNull: "${path} cannot be null", oneOf: "${path} must be one of the following values: ${values}", notOneOf: "${path} must not be one of the following values: ${values}", notType: ({ path: t, type: e, value: n, originalValue: r }) => { const i = r != null && r !== n ? ` (cast from the value \`${Ro(r, !0)}\`).` : "."; return e !== "mixed" ? `${t} must be a \`${e}\` type, but the final value was: \`${Ro(n, !0)}\`` + i : `${t} must match the configured type. The validated value was: \`${Ro(n, !0)}\`` + i } }, hi = { length: "${path} must be exactly ${length} characters", min: "${path} must be at least ${min} characters", max: "${path} must be at most ${max} characters", matches: '${path} must match the following: "${regex}"', email: "${path} must be a valid email", url: "${path} must be a valid URL", uuid: "${path} must be a valid UUID", datetime: "${path} must be a valid ISO date-time", datetime_precision: "${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits", datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone', trim: "${path} must be a trimmed string", lowercase: "${path} must be a lowercase string", uppercase: "${path} must be a upper case string" }, NI = { min: "${path} must be greater than or equal to ${min}", max: "${path} must be less than or equal to ${max}", lessThan: "${path} must be less than ${less}", moreThan: "${path} must be greater than ${more}", positive: "${path} must be a positive number", negative: "${path} must be a negative number", integer: "${path} must be an integer" }, jb = { min: "${path} field must be later than ${min}", max: "${path} field must be at earlier than ${max}" }, jI = { isValue: "${path} field must be ${value}" }, xm = { noUnknown: "${path} field has unspecified keys: ${unknown}", exact: "${path} object contains unknown properties: ${properties}" }, EI = { min: "${path} field must have at least ${min} items", max: "${path} field must have less than or equal to ${max} items", length: "${path} must have ${length} items" }, AI = { notType: t => { const { path: e, value: n, spec: r } = t, i = r.types.length; if (Array.isArray(n)) { if (n.length < i) return `${e} tuple value has too few items, expected a length of ${i} but got ${n.length} for value: \`${Ro(n, !0)}\``; if (n.length > i) return `${e} tuple value has too many items, expected a length of ${i} but got ${n.length} for value: \`${Ro(n, !0)}\`` } return gi.formatError(qs.notType, t) } }; Object.assign(Object.create(null), { mixed: qs, string: hi, number: NI, date: jb, object: xm, array: EI, boolean: jI, tuple: AI }); const Ew = t => t && t.__isYupSchema__; class Hm { static fromOptions(e, n) { if (!n.then && !n.otherwise) throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions"); let { is: r, then: i, otherwise: s } = n, a = typeof r == "function" ? r : (...l) => l.every(u => u === r); return new Hm(e, (l, u) => { var f; let p = a(...l) ? i : s; return (f = p?.(u)) != null ? f : u }) } constructor(e, n) { this.fn = void 0, this.refs = e, this.refs = e, this.fn = n } resolve(e, n) { let r = this.refs.map(s => s.getValue(n?.value, n?.parent, n?.context)), i = this.fn(r, e, n); if (i === void 0 || i === e) return e; if (!Ew(i)) throw new TypeError("conditions must return a schema object"); return i.resolve(n) } } const Ip = { context: "$", value: "." }; class oc { constructor(e, n = {}) { if (this.key = void 0, this.isContext = void 0, this.isValue = void 0, this.isSibling = void 0, this.path = void 0, this.getter = void 0, this.map = void 0, typeof e != "string") throw new TypeError("ref must be a string, got: " + e); if (this.key = e.trim(), e === "") throw new TypeError("ref must be a non-empty string"); this.isContext = this.key[0] === Ip.context, this.isValue = this.key[0] === Ip.value, this.isSibling = !this.isContext && !this.isValue; let r = this.isContext ? Ip.context : this.isValue ? Ip.value : ""; this.path = this.key.slice(r.length), this.getter = this.path && zl.getter(this.path, !0), this.map = n.map } getValue(e, n, r) { let i = this.isContext ? r : this.isValue ? e : n; return this.getter && (i = this.getter(i || {})), this.map && (i = this.map(i)), i } cast(e, n) { return this.getValue(e, n?.parent, n?.context) } resolve() { return this } describe() { return { type: "ref", key: this.key } } toString() { return `Ref(${this.key})` } static isRef(e) { return e && e.__isYupRef } } oc.prototype.__isYupRef = !0; const Al = t => t == null; function Hc(t) { function e({ value: n, path: r = "", options: i, originalValue: s, schema: a }, l, u) { const { name: f, test: p, params: g, message: y, skipAbsent: v } = t; let { parent: b, context: S, abortEarly: C = a.spec.abortEarly, disableStackTrace: T = a.spec.disableStackTrace } = i; function A(W) { return oc.isRef(W) ? W.getValue(n, b, S) : W } function M(W = {}) { const ne = Object.assign({ value: n, originalValue: s, label: a.spec.label, path: W.path || r, spec: a.spec, disableStackTrace: W.disableStackTrace || T }, g, W.params); for (const we of Object.keys(ne)) ne[we] = A(ne[we]); const H = new gi(gi.formatError(W.message || y, ne), n, ne.path, W.type || f, ne.disableStackTrace); return H.params = ne, H } const O = C ? l : u; let E = { path: r, parent: b, type: f, from: i.from, createError: M, resolve: A, options: i, originalValue: s, schema: a }; const k = W => { gi.isError(W) ? O(W) : W ? u(null) : O(M()) }, z = W => { gi.isError(W) ? O(W) : l(W) }; if (v && Al(n)) return k(!0); let q; try { var ue; if (q = p.call(E, n, E), typeof ((ue = q) == null ? void 0 : ue.then) == "function") { if (i.sync) throw new Error(`Validation test of type: "${E.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`); return Promise.resolve(q).then(k, z) } } catch (W) { z(W); return } k(q) } return e.OPTIONS = t, e } function kI(t, e, n, r = n) { let i, s, a; return e ? (zl.forEach(e, (l, u, f) => { let p = u ? l.slice(1, l.length - 1) : l; t = t.resolve({ context: r, parent: i, value: n }); let g = t.type === "tuple", y = f ? parseInt(p, 10) : 0; if (t.innerType || g) { if (g && !f) throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${a}" must contain an index to the tuple element, e.g. "${a}[0]"`); if (n && y >= n.length) throw new Error(`Yup.reach cannot resolve an array item at index: ${l}, in the path: ${e}. because there is no value at that index. `); i = n, n = n && n[y], t = g ? t.spec.types[y] : t.innerType } if (!f) { if (!t.fields || !t.fields[p]) throw new Error(`The schema does not contain the path: ${e}. (failed at: ${a} which is a type: "${t.type}")`); i = n, n = n && n[p], t = t.fields[p] } s = p, a = u ? "[" + l + "]" : "." + l }), { schema: t, parent: i, parentPath: s }) : { parent: i, parentPath: e, schema: t } } class qm extends Set { describe() { const e = []; for (const n of this.values()) e.push(oc.isRef(n) ? n.describe() : n); return e } resolveAll(e) { let n = []; for (const r of this.values()) n.push(e(r)); return n } clone() { return new qm(this.values()) } merge(e, n) { const r = this.clone(); return e.forEach(i => r.add(i)), n.forEach(i => r.delete(i)), r } } function tu(t, e = new Map) { if (Ew(t) || !t || typeof t != "object") return t; if (e.has(t)) return e.get(t); let n; if (t instanceof Date) n = new Date(t.getTime()), e.set(t, n); else if (t instanceof RegExp) n = new RegExp(t), e.set(t, n); else if (Array.isArray(t)) { n = new Array(t.length), e.set(t, n); for (let r = 0; r < t.length; r++)n[r] = tu(t[r], e) } else if (t instanceof Map) { n = new Map, e.set(t, n); for (const [r, i] of t.entries()) n.set(r, tu(i, e)) } else if (t instanceof Set) { n = new Set, e.set(t, n); for (const r of t) n.add(tu(r, e)) } else if (t instanceof Object) { n = {}, e.set(t, n); for (const [r, i] of Object.entries(t)) n[r] = tu(i, e) } else throw Error(`Unable to clone ${t}`); return n } let na = class {
    constructor(e) { this.type = void 0, this.deps = [], this.tests = void 0, this.transforms = void 0, this.conditions = [], this._mutate = void 0, this.internalTests = {}, this._whitelist = new qm, this._blacklist = new qm, this.exclusiveTests = Object.create(null), this._typeCheck = void 0, this.spec = void 0, this.tests = [], this.transforms = [], this.withMutation(() => { this.typeError(qs.notType) }), this.type = e.type, this._typeCheck = e.check, this.spec = Object.assign({ strip: !1, strict: !1, abortEarly: !0, recursive: !0, disableStackTrace: !1, nullable: !1, optional: !0, coerce: !0 }, e?.spec), this.withMutation(n => { n.nonNullable() }) } get _type() { return this.type } clone(e) { if (this._mutate) return e && Object.assign(this.spec, e), this; const n = Object.create(Object.getPrototypeOf(this)); return n.type = this.type, n._typeCheck = this._typeCheck, n._whitelist = this._whitelist.clone(), n._blacklist = this._blacklist.clone(), n.internalTests = Object.assign({}, this.internalTests), n.exclusiveTests = Object.assign({}, this.exclusiveTests), n.deps = [...this.deps], n.conditions = [...this.conditions], n.tests = [...this.tests], n.transforms = [...this.transforms], n.spec = tu(Object.assign({}, this.spec, e)), n } label(e) { let n = this.clone(); return n.spec.label = e, n } meta(...e) { if (e.length === 0) return this.spec.meta; let n = this.clone(); return n.spec.meta = Object.assign(n.spec.meta || {}, e[0]), n } withMutation(e) { let n = this._mutate; this._mutate = !0; let r = e(this); return this._mutate = n, r } concat(e) { if (!e || e === this) return this; if (e.type !== this.type && this.type !== "mixed") throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${e.type}`); let n = this, r = e.clone(); const i = Object.assign({}, n.spec, r.spec); return r.spec = i, r.internalTests = Object.assign({}, n.internalTests, r.internalTests), r._whitelist = n._whitelist.merge(e._whitelist, e._blacklist), r._blacklist = n._blacklist.merge(e._blacklist, e._whitelist), r.tests = n.tests, r.exclusiveTests = n.exclusiveTests, r.withMutation(s => { e.tests.forEach(a => { s.test(a.OPTIONS) }) }), r.transforms = [...n.transforms, ...r.transforms], r } isType(e) { return e == null ? !!(this.spec.nullable && e === null || this.spec.optional && e === void 0) : this._typeCheck(e) } resolve(e) { let n = this; if (n.conditions.length) { let r = n.conditions; n = n.clone(), n.conditions = [], n = r.reduce((i, s) => s.resolve(i, e), n), n = n.resolve(e) } return n } resolveOptions(e) { var n, r, i, s; return Object.assign({}, e, { from: e.from || [], strict: (n = e.strict) != null ? n : this.spec.strict, abortEarly: (r = e.abortEarly) != null ? r : this.spec.abortEarly, recursive: (i = e.recursive) != null ? i : this.spec.recursive, disableStackTrace: (s = e.disableStackTrace) != null ? s : this.spec.disableStackTrace }) } cast(e, n = {}) {
      let r = this.resolve(Object.assign({ value: e }, n)), i = n.assert === "ignore-optionality", s = r._cast(e, n); if (n.assert !== !1 && !r.isType(s)) {
        if (i && Al(s)) return s; let a = Ro(e), l = Ro(s); throw new TypeError(`The value of ${n.path || "field"} could not be cast to a value that satisfies the schema type: "${r.type}". 

attempted value: ${a} 
`+ (l !== a ? `result of cast: ${l}` : ""))
      } return s
    } _cast(e, n) { let r = e === void 0 ? e : this.transforms.reduce((i, s) => s.call(this, i, e, this), e); return r === void 0 && (r = this.getDefault(n)), r } _validate(e, n = {}, r, i) { let { path: s, originalValue: a = e, strict: l = this.spec.strict } = n, u = e; l || (u = this._cast(u, Object.assign({ assert: !1 }, n))); let f = []; for (let p of Object.values(this.internalTests)) p && f.push(p); this.runTests({ path: s, value: u, originalValue: a, options: n, tests: f }, r, p => { if (p.length) return i(p, u); this.runTests({ path: s, value: u, originalValue: a, options: n, tests: this.tests }, r, i) }) } runTests(e, n, r) { let i = !1, { tests: s, value: a, originalValue: l, path: u, options: f } = e, p = S => { i || (i = !0, n(S, a)) }, g = S => { i || (i = !0, r(S, a)) }, y = s.length, v = []; if (!y) return g([]); let b = { value: a, originalValue: l, path: u, options: f, schema: this }; for (let S = 0; S < s.length; S++) { const C = s[S]; C(b, p, function (A) { A && (Array.isArray(A) ? v.push(...A) : v.push(A)), --y <= 0 && g(v) }) } } asNestedTest({ key: e, index: n, parent: r, parentPath: i, originalParent: s, options: a }) { const l = e ?? n; if (l == null) throw TypeError("Must include `key` or `index` for nested validations"); const u = typeof l == "number"; let f = r[l]; const p = Object.assign({}, a, { strict: !0, parent: r, value: f, originalValue: s[l], key: void 0, [u ? "index" : "key"]: l, path: u || l.includes(".") ? `${i || ""}[${u ? l : `"${l}"`}]` : (i ? `${i}.` : "") + e }); return (g, y, v) => this.resolve(p)._validate(f, p, y, v) } validate(e, n) { var r; let i = this.resolve(Object.assign({}, n, { value: e })), s = (r = n?.disableStackTrace) != null ? r : i.spec.disableStackTrace; return new Promise((a, l) => i._validate(e, n, (u, f) => { gi.isError(u) && (u.value = f), l(u) }, (u, f) => { u.length ? l(new gi(u, f, void 0, void 0, s)) : a(f) })) } validateSync(e, n) { var r; let i = this.resolve(Object.assign({}, n, { value: e })), s, a = (r = n?.disableStackTrace) != null ? r : i.spec.disableStackTrace; return i._validate(e, Object.assign({}, n, { sync: !0 }), (l, u) => { throw gi.isError(l) && (l.value = u), l }, (l, u) => { if (l.length) throw new gi(l, e, void 0, void 0, a); s = u }), s } isValid(e, n) { return this.validate(e, n).then(() => !0, r => { if (gi.isError(r)) return !1; throw r }) } isValidSync(e, n) { try { return this.validateSync(e, n), !0 } catch (r) { if (gi.isError(r)) return !1; throw r } } _getDefault(e) { let n = this.spec.default; return n == null ? n : typeof n == "function" ? n.call(this, e) : tu(n) } getDefault(e) { return this.resolve(e || {})._getDefault(e) } default(e) { return arguments.length === 0 ? this._getDefault() : this.clone({ default: e }) } strict(e = !0) { return this.clone({ strict: e }) } nullability(e, n) { const r = this.clone({ nullable: e }); return r.internalTests.nullable = Hc({ message: n, name: "nullable", test(i) { return i === null ? this.schema.spec.nullable : !0 } }), r } optionality(e, n) { const r = this.clone({ optional: e }); return r.internalTests.optionality = Hc({ message: n, name: "optionality", test(i) { return i === void 0 ? this.schema.spec.optional : !0 } }), r } optional() { return this.optionality(!0) } defined(e = qs.defined) { return this.optionality(!1, e) } nullable() { return this.nullability(!0) } nonNullable(e = qs.notNull) { return this.nullability(!1, e) } required(e = qs.required) { return this.clone().withMutation(n => n.nonNullable(e).defined(e)) } notRequired() { return this.clone().withMutation(e => e.nullable().optional()) } transform(e) { let n = this.clone(); return n.transforms.push(e), n } test(...e) { let n; if (e.length === 1 ? typeof e[0] == "function" ? n = { test: e[0] } : n = e[0] : e.length === 2 ? n = { name: e[0], test: e[1] } : n = { name: e[0], message: e[1], test: e[2] }, n.message === void 0 && (n.message = qs.default), typeof n.test != "function") throw new TypeError("`test` is a required parameters"); let r = this.clone(), i = Hc(n), s = n.exclusive || n.name && r.exclusiveTests[n.name] === !0; if (n.exclusive && !n.name) throw new TypeError("Exclusive tests must provide a unique `name` identifying the test"); return n.name && (r.exclusiveTests[n.name] = !!n.exclusive), r.tests = r.tests.filter(a => !(a.OPTIONS.name === n.name && (s || a.OPTIONS.test === i.OPTIONS.test))), r.tests.push(i), r } when(e, n) { !Array.isArray(e) && typeof e != "string" && (n = e, e = "."); let r = this.clone(), i = jO(e).map(s => new oc(s)); return i.forEach(s => { s.isSibling && r.deps.push(s.key) }), r.conditions.push(typeof n == "function" ? new Hm(i, n) : Hm.fromOptions(i, n)), r } typeError(e) { let n = this.clone(); return n.internalTests.typeError = Hc({ message: e, name: "typeError", skipAbsent: !0, test(r) { return this.schema._typeCheck(r) ? !0 : this.createError({ params: { type: this.schema.type } }) } }), n } oneOf(e, n = qs.oneOf) { let r = this.clone(); return e.forEach(i => { r._whitelist.add(i), r._blacklist.delete(i) }), r.internalTests.whiteList = Hc({ message: n, name: "oneOf", skipAbsent: !0, test(i) { let s = this.schema._whitelist, a = s.resolveAll(this.resolve); return a.includes(i) ? !0 : this.createError({ params: { values: Array.from(s).join(", "), resolved: a } }) } }), r } notOneOf(e, n = qs.notOneOf) { let r = this.clone(); return e.forEach(i => { r._blacklist.add(i), r._whitelist.delete(i) }), r.internalTests.blacklist = Hc({ message: n, name: "notOneOf", test(i) { let s = this.schema._blacklist, a = s.resolveAll(this.resolve); return a.includes(i) ? this.createError({ params: { values: Array.from(s).join(", "), resolved: a } }) : !0 } }), r } strip(e = !0) { let n = this.clone(); return n.spec.strip = e, n } describe(e) { const n = (e ? this.resolve(e) : this).clone(), { label: r, meta: i, optional: s, nullable: a } = n.spec; return { meta: i, label: r, optional: s, nullable: a, default: n.getDefault(e), type: n.type, oneOf: n._whitelist.describe(), notOneOf: n._blacklist.describe(), tests: n.tests.map(u => ({ name: u.OPTIONS.name, params: u.OPTIONS.params })).filter((u, f, p) => p.findIndex(g => g.name === u.name) === f) } }
  }; na.prototype.__isYupSchema__ = !0; for (const t of ["validate", "validateSync"]) na.prototype[`${t}At`] = function (e, n, r = {}) { const { parent: i, parentPath: s, schema: a } = kI(this, e, n, r.context); return a[t](i && i[s], Object.assign({}, r, { parent: i, path: e })) }; for (const t of ["equals", "is"]) na.prototype[t] = na.prototype.oneOf; for (const t of ["not", "nope"]) na.prototype[t] = na.prototype.notOneOf; const OI = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/; function MI(t) { const e = Eb(t); if (!e) return Date.parse ? Date.parse(t) : Number.NaN; if (e.z === void 0 && e.plusMinus === void 0) return new Date(e.year, e.month, e.day, e.hour, e.minute, e.second, e.millisecond).valueOf(); let n = 0; return e.z !== "Z" && e.plusMinus !== void 0 && (n = e.hourOffset * 60 + e.minuteOffset, e.plusMinus === "+" && (n = 0 - n)), Date.UTC(e.year, e.month, e.day, e.hour, e.minute + n, e.second, e.millisecond) } function Eb(t) { var e, n; const r = OI.exec(t); return r ? { year: Ca(r[1]), month: Ca(r[2], 1) - 1, day: Ca(r[3], 1), hour: Ca(r[4]), minute: Ca(r[5]), second: Ca(r[6]), millisecond: r[7] ? Ca(r[7].substring(0, 3)) : 0, precision: (e = (n = r[7]) == null ? void 0 : n.length) != null ? e : void 0, z: r[8] || void 0, plusMinus: r[9] || void 0, hourOffset: Ca(r[10]), minuteOffset: Ca(r[11]) } : null } function Ca(t, e = 0) { return Number(t) || e } let DI = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, RI = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i, _I = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i, LI = "^\\d{4}-\\d{2}-\\d{2}", PI = "\\d{2}:\\d{2}:\\d{2}", zI = "(([+-]\\d{2}(:?\\d{2})?)|Z)", II = new RegExp(`${LI}T${PI}(\\.\\d+)?${zI}$`), FI = t => Al(t) || t === t.trim(), BI = {}.toString(); function Ab() { return new OO } class OO extends na { constructor() { super({ type: "string", check(e) { return e instanceof String && (e = e.valueOf()), typeof e == "string" } }), this.withMutation(() => { this.transform((e, n, r) => { if (!r.spec.coerce || r.isType(e) || Array.isArray(e)) return e; const i = e != null && e.toString ? e.toString() : e; return i === BI ? e : i }) }) } required(e) { return super.required(e).withMutation(n => n.test({ message: e || qs.required, name: "required", skipAbsent: !0, test: r => !!r.length })) } notRequired() { return super.notRequired().withMutation(e => (e.tests = e.tests.filter(n => n.OPTIONS.name !== "required"), e)) } length(e, n = hi.length) { return this.test({ message: n, name: "length", exclusive: !0, params: { length: e }, skipAbsent: !0, test(r) { return r.length === this.resolve(e) } }) } min(e, n = hi.min) { return this.test({ message: n, name: "min", exclusive: !0, params: { min: e }, skipAbsent: !0, test(r) { return r.length >= this.resolve(e) } }) } max(e, n = hi.max) { return this.test({ name: "max", exclusive: !0, message: n, params: { max: e }, skipAbsent: !0, test(r) { return r.length <= this.resolve(e) } }) } matches(e, n) { let r = !1, i, s; return n && (typeof n == "object" ? { excludeEmptyString: r = !1, message: i, name: s } = n : i = n), this.test({ name: s || "matches", message: i || hi.matches, params: { regex: e }, skipAbsent: !0, test: a => a === "" && r || a.search(e) !== -1 }) } email(e = hi.email) { return this.matches(DI, { name: "email", message: e, excludeEmptyString: !0 }) } url(e = hi.url) { return this.matches(RI, { name: "url", message: e, excludeEmptyString: !0 }) } uuid(e = hi.uuid) { return this.matches(_I, { name: "uuid", message: e, excludeEmptyString: !1 }) } datetime(e) { let n = "", r, i; return e && (typeof e == "object" ? { message: n = "", allowOffset: r = !1, precision: i = void 0 } = e : n = e), this.matches(II, { name: "datetime", message: n || hi.datetime, excludeEmptyString: !0 }).test({ name: "datetime_offset", message: n || hi.datetime_offset, params: { allowOffset: r }, skipAbsent: !0, test: s => { if (!s || r) return !0; const a = Eb(s); return a ? !!a.z : !1 } }).test({ name: "datetime_precision", message: n || hi.datetime_precision, params: { precision: i }, skipAbsent: !0, test: s => { if (!s || i == null) return !0; const a = Eb(s); return a ? a.precision === i : !1 } }) } ensure() { return this.default("").transform(e => e === null ? "" : e) } trim(e = hi.trim) { return this.transform(n => n != null ? n.trim() : n).test({ message: e, name: "trim", test: FI }) } lowercase(e = hi.lowercase) { return this.transform(n => Al(n) ? n : n.toLowerCase()).test({ message: e, name: "string_case", exclusive: !0, skipAbsent: !0, test: n => Al(n) || n === n.toLowerCase() }) } uppercase(e = hi.uppercase) { return this.transform(n => Al(n) ? n : n.toUpperCase()).test({ message: e, name: "string_case", exclusive: !0, skipAbsent: !0, test: n => Al(n) || n === n.toUpperCase() }) } } Ab.prototype = OO.prototype; let $I = new Date(""), UI = t => Object.prototype.toString.call(t) === "[object Date]"; class Aw extends na { constructor() { super({ type: "date", check(e) { return UI(e) && !isNaN(e.getTime()) } }), this.withMutation(() => { this.transform((e, n, r) => !r.spec.coerce || r.isType(e) || e === null ? e : (e = MI(e), isNaN(e) ? Aw.INVALID_DATE : new Date(e))) }) } prepareParam(e, n) { let r; if (oc.isRef(e)) r = e; else { let i = this.cast(e); if (!this._typeCheck(i)) throw new TypeError(`\`${n}\` must be a Date or a value that can be \`cast()\` to a Date`); r = i } return r } min(e, n = jb.min) { let r = this.prepareParam(e, "min"); return this.test({ message: n, name: "min", exclusive: !0, params: { min: e }, skipAbsent: !0, test(i) { return i >= this.resolve(r) } }) } max(e, n = jb.max) { let r = this.prepareParam(e, "max"); return this.test({ message: n, name: "max", exclusive: !0, params: { max: e }, skipAbsent: !0, test(i) { return i <= this.resolve(r) } }) } } Aw.INVALID_DATE = $I; function VI(t, e = []) { let n = [], r = new Set, i = new Set(e.map(([a, l]) => `${a}-${l}`)); function s(a, l) { let u = zl.split(a)[0]; r.add(u), i.has(`${l}-${u}`) || n.push([l, u]) } for (const a of Object.keys(t)) { let l = t[a]; r.add(a), oc.isRef(l) && l.isSibling ? s(l.path, a) : Ew(l) && "deps" in l && l.deps.forEach(u => s(u, a)) } return yI.array(Array.from(r), n).reverse() } function Kj(t, e) { let n = 1 / 0; return t.some((r, i) => { var s; if ((s = e.path) != null && s.includes(r)) return n = i, !0 }), n } function MO(t) { return (e, n) => Kj(t, e) - Kj(t, n) } const HI = (t, e, n) => { if (typeof t != "string") return t; let r = t; try { r = JSON.parse(t) } catch { } return n.isType(r) ? r : t }; function bm(t) { if ("fields" in t) { const e = {}; for (const [n, r] of Object.entries(t.fields)) e[n] = bm(r); return t.setFields(e) } if (t.type === "array") { const e = t.optional(); return e.innerType && (e.innerType = bm(e.innerType)), e } return t.type === "tuple" ? t.optional().clone({ types: t.spec.types.map(bm) }) : "optional" in t ? t.optional() : t } const qI = (t, e) => { const n = [...zl.normalizePath(e)]; if (n.length === 1) return n[0] in t; let r = n.pop(), i = zl.getter(zl.join(n), !0)(t); return !!(i && r in i) }; let Wj = t => Object.prototype.toString.call(t) === "[object Object]"; function Yj(t, e) { let n = Object.keys(t.fields); return Object.keys(e).filter(r => n.indexOf(r) === -1) } const KI = MO([]); function DO(t) { return new RO(t) } class RO extends na { constructor(e) { super({ type: "object", check(n) { return Wj(n) || typeof n == "function" } }), this.fields = Object.create(null), this._sortErrors = KI, this._nodes = [], this._excludedEdges = [], this.withMutation(() => { e && this.shape(e) }) } _cast(e, n = {}) { var r; let i = super._cast(e, n); if (i === void 0) return this.getDefault(n); if (!this._typeCheck(i)) return i; let s = this.fields, a = (r = n.stripUnknown) != null ? r : this.spec.noUnknown, l = [].concat(this._nodes, Object.keys(i).filter(g => !this._nodes.includes(g))), u = {}, f = Object.assign({}, n, { parent: u, __validating: n.__validating || !1 }), p = !1; for (const g of l) { let y = s[g], v = g in i; if (y) { let b, S = i[g]; f.path = (n.path ? `${n.path}.` : "") + g, y = y.resolve({ value: S, context: n.context, parent: u }); let C = y instanceof na ? y.spec : void 0, T = C?.strict; if (C != null && C.strip) { p = p || g in i; continue } b = !n.__validating || !T ? y.cast(i[g], f) : i[g], b !== void 0 && (u[g] = b) } else v && !a && (u[g] = i[g]); (v !== g in u || u[g] !== i[g]) && (p = !0) } return p ? u : i } _validate(e, n = {}, r, i) { let { from: s = [], originalValue: a = e, recursive: l = this.spec.recursive } = n; n.from = [{ schema: this, value: a }, ...s], n.__validating = !0, n.originalValue = a, super._validate(e, n, r, (u, f) => { if (!l || !Wj(f)) { i(u, f); return } a = a || f; let p = []; for (let g of this._nodes) { let y = this.fields[g]; !y || oc.isRef(y) || p.push(y.asNestedTest({ options: n, key: g, parent: f, parentPath: n.path, originalParent: a })) } this.runTests({ tests: p, value: f, originalValue: a, options: n }, r, g => { i(g.sort(this._sortErrors).concat(u), f) }) }) } clone(e) { const n = super.clone(e); return n.fields = Object.assign({}, this.fields), n._nodes = this._nodes, n._excludedEdges = this._excludedEdges, n._sortErrors = this._sortErrors, n } concat(e) { let n = super.concat(e), r = n.fields; for (let [i, s] of Object.entries(this.fields)) { const a = r[i]; r[i] = a === void 0 ? s : a } return n.withMutation(i => i.setFields(r, [...this._excludedEdges, ...e._excludedEdges])) } _getDefault(e) { if ("default" in this.spec) return super._getDefault(e); if (!this._nodes.length) return; let n = {}; return this._nodes.forEach(r => { var i; const s = this.fields[r]; let a = e; (i = a) != null && i.value && (a = Object.assign({}, a, { parent: a.value, value: a.value[r] })), n[r] = s && "getDefault" in s ? s.getDefault(a) : void 0 }), n } setFields(e, n) { let r = this.clone(); return r.fields = e, r._nodes = VI(e, n), r._sortErrors = MO(Object.keys(e)), n && (r._excludedEdges = n), r } shape(e, n = []) { return this.clone().withMutation(r => { let i = r._excludedEdges; return n.length && (Array.isArray(n[0]) || (n = [n]), i = [...r._excludedEdges, ...n]), r.setFields(Object.assign(r.fields, e), i) }) } partial() { const e = {}; for (const [n, r] of Object.entries(this.fields)) e[n] = "optional" in r && r.optional instanceof Function ? r.optional() : r; return this.setFields(e) } deepPartial() { return bm(this) } pick(e) { const n = {}; for (const r of e) this.fields[r] && (n[r] = this.fields[r]); return this.setFields(n, this._excludedEdges.filter(([r, i]) => e.includes(r) && e.includes(i))) } omit(e) { const n = []; for (const r of Object.keys(this.fields)) e.includes(r) || n.push(r); return this.pick(n) } from(e, n, r) { let i = zl.getter(e, !0); return this.transform(s => { if (!s) return s; let a = s; return qI(s, e) && (a = Object.assign({}, s), r || delete a[e], a[n] = i(s)), a }) } json() { return this.transform(HI) } exact(e) { return this.test({ name: "exact", exclusive: !0, message: e || xm.exact, test(n) { if (n == null) return !0; const r = Yj(this.schema, n); return r.length === 0 || this.createError({ params: { properties: r.join(", ") } }) } }) } stripUnknown() { return this.clone({ noUnknown: !0 }) } noUnknown(e = !0, n = xm.noUnknown) { typeof e != "boolean" && (n = e, e = !0); let r = this.test({ name: "noUnknown", exclusive: !0, message: n, test(i) { if (i == null) return !0; const s = Yj(this.schema, i); return !e || s.length === 0 || this.createError({ params: { unknown: s.join(", ") } }) } }); return r.spec.noUnknown = e, r } unknown(e = !0, n = xm.noUnknown) { return this.noUnknown(!e, n) } transformKeys(e) { return this.transform(n => { if (!n) return n; const r = {}; for (const i of Object.keys(n)) r[e(i)] = n[i]; return r }) } camelCase() { return this.transformKeys(ox.camelCase) } snakeCase() { return this.transformKeys(ox.snakeCase) } constantCase() { return this.transformKeys(e => ox.snakeCase(e).toUpperCase()) } describe(e) { const n = (e ? this.resolve(e) : this).clone(), r = super.describe(e); r.fields = {}; for (const [s, a] of Object.entries(n.fields)) { var i; let l = e; (i = l) != null && i.value && (l = Object.assign({}, l, { parent: l.value, value: l.value[s] })), r.fields[s] = a.describe(l) } return r } } DO.prototype = RO.prototype; var WI = function (e) { return YI(e) && !GI(e) }; function YI(t) { return !!t && typeof t == "object" } function GI(t) { var e = Object.prototype.toString.call(t); return e === "[object RegExp]" || e === "[object Date]" || JI(t) } var XI = typeof Symbol == "function" && Symbol.for, QI = XI ? Symbol.for("react.element") : 60103; function JI(t) { return t.$$typeof === QI } function ZI(t) { return Array.isArray(t) ? [] : {} } function Km(t, e) { return e.clone !== !1 && e.isMergeableObject(t) ? Mf(ZI(t), t, e) : t } function eF(t, e, n) { return t.concat(e).map(function (r) { return Km(r, n) }) } function tF(t, e, n) { var r = {}; return n.isMergeableObject(t) && Object.keys(t).forEach(function (i) { r[i] = Km(t[i], n) }), Object.keys(e).forEach(function (i) { !n.isMergeableObject(e[i]) || !t[i] ? r[i] = Km(e[i], n) : r[i] = Mf(t[i], e[i], n) }), r } function Mf(t, e, n) { n = n || {}, n.arrayMerge = n.arrayMerge || eF, n.isMergeableObject = n.isMergeableObject || WI; var r = Array.isArray(e), i = Array.isArray(t), s = r === i; return s ? r ? n.arrayMerge(t, e, n) : tF(t, e, n) : Km(e, n) } Mf.all = function (e, n) { if (!Array.isArray(e)) throw new Error("first argument should be an array"); return e.reduce(function (r, i) { return Mf(r, i, n) }, {}) }; var kb = Mf, _O = typeof global == "object" && global && global.Object === Object && global, nF = typeof self == "object" && self && self.Object === Object && self, aa = _O || nF || Function("return this")(), Bo = aa.Symbol, LO = Object.prototype, rF = LO.hasOwnProperty, iF = LO.toString, Fd = Bo ? Bo.toStringTag : void 0; function sF(t) { var e = rF.call(t, Fd), n = t[Fd]; try { t[Fd] = void 0; var r = !0 } catch { } var i = iF.call(t); return r && (e ? t[Fd] = n : delete t[Fd]), i } var aF = Object.prototype, oF = aF.toString; function lF(t) { return oF.call(t) } var cF = "[object Null]", uF = "[object Undefined]", Gj = Bo ? Bo.toStringTag : void 0; function lc(t) { return t == null ? t === void 0 ? uF : cF : Gj && Gj in Object(t) ? sF(t) : lF(t) } function PO(t, e) { return function (n) { return t(e(n)) } } var kw = PO(Object.getPrototypeOf, Object); function cc(t) { return t != null && typeof t == "object" } var dF = "[object Object]", fF = Function.prototype, hF = Object.prototype, zO = fF.toString, pF = hF.hasOwnProperty, mF = zO.call(Object); function Xj(t) { if (!cc(t) || lc(t) != dF) return !1; var e = kw(t); if (e === null) return !0; var n = pF.call(e, "constructor") && e.constructor; return typeof n == "function" && n instanceof n && zO.call(n) == mF } function gF() { this.__data__ = [], this.size = 0 } function IO(t, e) { return t === e || t !== t && e !== e } function uy(t, e) { for (var n = t.length; n--;)if (IO(t[n][0], e)) return n; return -1 } var yF = Array.prototype, vF = yF.splice; function xF(t) { var e = this.__data__, n = uy(e, t); if (n < 0) return !1; var r = e.length - 1; return n == r ? e.pop() : vF.call(e, n, 1), --this.size, !0 } function bF(t) { var e = this.__data__, n = uy(e, t); return n < 0 ? void 0 : e[n][1] } function wF(t) { return uy(this.__data__, t) > -1 } function SF(t, e) { var n = this.__data__, r = uy(n, t); return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this } function qa(t) { var e = -1, n = t == null ? 0 : t.length; for (this.clear(); ++e < n;) { var r = t[e]; this.set(r[0], r[1]) } } qa.prototype.clear = gF; qa.prototype.delete = xF; qa.prototype.get = bF; qa.prototype.has = wF; qa.prototype.set = SF; function CF() { this.__data__ = new qa, this.size = 0 } function TF(t) { var e = this.__data__, n = e.delete(t); return this.size = e.size, n } function NF(t) { return this.__data__.get(t) } function jF(t) { return this.__data__.has(t) } function dh(t) { var e = typeof t; return t != null && (e == "object" || e == "function") } var EF = "[object AsyncFunction]", AF = "[object Function]", kF = "[object GeneratorFunction]", OF = "[object Proxy]"; function FO(t) { if (!dh(t)) return !1; var e = lc(t); return e == AF || e == kF || e == EF || e == OF } var lx = aa["__core-js_shared__"], Qj = function () { var t = /[^.]+$/.exec(lx && lx.keys && lx.keys.IE_PROTO || ""); return t ? "Symbol(src)_1." + t : "" }(); function MF(t) { return !!Qj && Qj in t } var DF = Function.prototype, RF = DF.toString; function uc(t) { if (t != null) { try { return RF.call(t) } catch { } try { return t + "" } catch { } } return "" } var _F = /[\\^$.*+?()[\]{}|]/g, LF = /^\[object .+?Constructor\]$/, PF = Function.prototype, zF = Object.prototype, IF = PF.toString, FF = zF.hasOwnProperty, BF = RegExp("^" + IF.call(FF).replace(_F, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"); function $F(t) { if (!dh(t) || MF(t)) return !1; var e = FO(t) ? BF : LF; return e.test(uc(t)) } function UF(t, e) { return t?.[e] } function dc(t, e) { var n = UF(t, e); return $F(n) ? n : void 0 } var Df = dc(aa, "Map"), Rf = dc(Object, "create"); function VF() { this.__data__ = Rf ? Rf(null) : {}, this.size = 0 } function HF(t) { var e = this.has(t) && delete this.__data__[t]; return this.size -= e ? 1 : 0, e } var qF = "__lodash_hash_undefined__", KF = Object.prototype, WF = KF.hasOwnProperty; function YF(t) { var e = this.__data__; if (Rf) { var n = e[t]; return n === qF ? void 0 : n } return WF.call(e, t) ? e[t] : void 0 } var GF = Object.prototype, XF = GF.hasOwnProperty; function QF(t) { var e = this.__data__; return Rf ? e[t] !== void 0 : XF.call(e, t) } var JF = "__lodash_hash_undefined__"; function ZF(t, e) { var n = this.__data__; return this.size += this.has(t) ? 0 : 1, n[t] = Rf && e === void 0 ? JF : e, this } function Gl(t) { var e = -1, n = t == null ? 0 : t.length; for (this.clear(); ++e < n;) { var r = t[e]; this.set(r[0], r[1]) } } Gl.prototype.clear = VF; Gl.prototype.delete = HF; Gl.prototype.get = YF; Gl.prototype.has = QF; Gl.prototype.set = ZF; function eB() { this.size = 0, this.__data__ = { hash: new Gl, map: new (Df || qa), string: new Gl } } function tB(t) { var e = typeof t; return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null } function dy(t, e) { var n = t.__data__; return tB(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map } function nB(t) { var e = dy(this, t).delete(t); return this.size -= e ? 1 : 0, e } function rB(t) { return dy(this, t).get(t) } function iB(t) { return dy(this, t).has(t) } function sB(t, e) { var n = dy(this, t), r = n.size; return n.set(t, e), this.size += n.size == r ? 0 : 1, this } function Wo(t) { var e = -1, n = t == null ? 0 : t.length; for (this.clear(); ++e < n;) { var r = t[e]; this.set(r[0], r[1]) } } Wo.prototype.clear = eB; Wo.prototype.delete = nB; Wo.prototype.get = rB; Wo.prototype.has = iB; Wo.prototype.set = sB; var aB = 200; function oB(t, e) { var n = this.__data__; if (n instanceof qa) { var r = n.__data__; if (!Df || r.length < aB - 1) return r.push([t, e]), this.size = ++n.size, this; n = this.__data__ = new Wo(r) } return n.set(t, e), this.size = n.size, this } function ju(t) { var e = this.__data__ = new qa(t); this.size = e.size } ju.prototype.clear = CF; ju.prototype.delete = TF; ju.prototype.get = NF; ju.prototype.has = jF; ju.prototype.set = oB; function lB(t, e) { for (var n = -1, r = t == null ? 0 : t.length; ++n < r && e(t[n], n, t) !== !1;); return t } var Jj = function () { try { var t = dc(Object, "defineProperty"); return t({}, "", {}), t } catch { } }(); function BO(t, e, n) { e == "__proto__" && Jj ? Jj(t, e, { configurable: !0, enumerable: !0, value: n, writable: !0 }) : t[e] = n } var cB = Object.prototype, uB = cB.hasOwnProperty; function $O(t, e, n) { var r = t[e]; (!(uB.call(t, e) && IO(r, n)) || n === void 0 && !(e in t)) && BO(t, e, n) } function fy(t, e, n, r) { var i = !n; n || (n = {}); for (var s = -1, a = e.length; ++s < a;) { var l = e[s], u = void 0; u === void 0 && (u = t[l]), i ? BO(n, l, u) : $O(n, l, u) } return n } function dB(t, e) { for (var n = -1, r = Array(t); ++n < t;)r[n] = e(n); return r } var fB = "[object Arguments]"; function Zj(t) { return cc(t) && lc(t) == fB } var UO = Object.prototype, hB = UO.hasOwnProperty, pB = UO.propertyIsEnumerable, mB = Zj(function () { return arguments }()) ? Zj : function (t) { return cc(t) && hB.call(t, "callee") && !pB.call(t, "callee") }, fh = Array.isArray; function gB() { return !1 } var VO = typeof Fi == "object" && Fi && !Fi.nodeType && Fi, eE = VO && typeof Bi == "object" && Bi && !Bi.nodeType && Bi, yB = eE && eE.exports === VO, tE = yB ? aa.Buffer : void 0, vB = tE ? tE.isBuffer : void 0, HO = vB || gB, xB = 9007199254740991, bB = /^(?:0|[1-9]\d*)$/; function wB(t, e) { var n = typeof t; return e = e ?? xB, !!e && (n == "number" || n != "symbol" && bB.test(t)) && t > -1 && t % 1 == 0 && t < e } var SB = 9007199254740991; function qO(t) { return typeof t == "number" && t > -1 && t % 1 == 0 && t <= SB } var CB = "[object Arguments]", TB = "[object Array]", NB = "[object Boolean]", jB = "[object Date]", EB = "[object Error]", AB = "[object Function]", kB = "[object Map]", OB = "[object Number]", MB = "[object Object]", DB = "[object RegExp]", RB = "[object Set]", _B = "[object String]", LB = "[object WeakMap]", PB = "[object ArrayBuffer]", zB = "[object DataView]", IB = "[object Float32Array]", FB = "[object Float64Array]", BB = "[object Int8Array]", $B = "[object Int16Array]", UB = "[object Int32Array]", VB = "[object Uint8Array]", HB = "[object Uint8ClampedArray]", qB = "[object Uint16Array]", KB = "[object Uint32Array]", kn = {}; kn[IB] = kn[FB] = kn[BB] = kn[$B] = kn[UB] = kn[VB] = kn[HB] = kn[qB] = kn[KB] = !0; kn[CB] = kn[TB] = kn[PB] = kn[NB] = kn[zB] = kn[jB] = kn[EB] = kn[AB] = kn[kB] = kn[OB] = kn[MB] = kn[DB] = kn[RB] = kn[_B] = kn[LB] = !1; function WB(t) { return cc(t) && qO(t.length) && !!kn[lc(t)] } function Ow(t) { return function (e) { return t(e) } } var KO = typeof Fi == "object" && Fi && !Fi.nodeType && Fi, rf = KO && typeof Bi == "object" && Bi && !Bi.nodeType && Bi, YB = rf && rf.exports === KO, cx = YB && _O.process, hu = function () { try { var t = rf && rf.require && rf.require("util").types; return t || cx && cx.binding && cx.binding("util") } catch { } }(), nE = hu && hu.isTypedArray, GB = nE ? Ow(nE) : WB, XB = Object.prototype, QB = XB.hasOwnProperty; function WO(t, e) { var n = fh(t), r = !n && mB(t), i = !n && !r && HO(t), s = !n && !r && !i && GB(t), a = n || r || i || s, l = a ? dB(t.length, String) : [], u = l.length; for (var f in t) (e || QB.call(t, f)) && !(a && (f == "length" || i && (f == "offset" || f == "parent") || s && (f == "buffer" || f == "byteLength" || f == "byteOffset") || wB(f, u))) && l.push(f); return l } var JB = Object.prototype; function Mw(t) { var e = t && t.constructor, n = typeof e == "function" && e.prototype || JB; return t === n } var ZB = PO(Object.keys, Object), e7 = Object.prototype, t7 = e7.hasOwnProperty; function n7(t) { if (!Mw(t)) return ZB(t); var e = []; for (var n in Object(t)) t7.call(t, n) && n != "constructor" && e.push(n); return e } function YO(t) { return t != null && qO(t.length) && !FO(t) } function Dw(t) { return YO(t) ? WO(t) : n7(t) } function r7(t, e) { return t && fy(e, Dw(e), t) } function i7(t) { var e = []; if (t != null) for (var n in Object(t)) e.push(n); return e } var s7 = Object.prototype, a7 = s7.hasOwnProperty; function o7(t) { if (!dh(t)) return i7(t); var e = Mw(t), n = []; for (var r in t) r == "constructor" && (e || !a7.call(t, r)) || n.push(r); return n } function Rw(t) { return YO(t) ? WO(t, !0) : o7(t) } function l7(t, e) { return t && fy(e, Rw(e), t) } var GO = typeof Fi == "object" && Fi && !Fi.nodeType && Fi, rE = GO && typeof Bi == "object" && Bi && !Bi.nodeType && Bi, c7 = rE && rE.exports === GO, iE = c7 ? aa.Buffer : void 0, sE = iE ? iE.allocUnsafe : void 0; function u7(t, e) { if (e) return t.slice(); var n = t.length, r = sE ? sE(n) : new t.constructor(n); return t.copy(r), r } function XO(t, e) { var n = -1, r = t.length; for (e || (e = Array(r)); ++n < r;)e[n] = t[n]; return e } function d7(t, e) { for (var n = -1, r = t == null ? 0 : t.length, i = 0, s = []; ++n < r;) { var a = t[n]; e(a, n, t) && (s[i++] = a) } return s } function QO() { return [] } var f7 = Object.prototype, h7 = f7.propertyIsEnumerable, aE = Object.getOwnPropertySymbols, _w = aE ? function (t) { return t == null ? [] : (t = Object(t), d7(aE(t), function (e) { return h7.call(t, e) })) } : QO; function p7(t, e) { return fy(t, _w(t), e) } function JO(t, e) { for (var n = -1, r = e.length, i = t.length; ++n < r;)t[i + n] = e[n]; return t } var m7 = Object.getOwnPropertySymbols, ZO = m7 ? function (t) { for (var e = []; t;)JO(e, _w(t)), t = kw(t); return e } : QO; function g7(t, e) { return fy(t, ZO(t), e) } function eM(t, e, n) { var r = e(t); return fh(t) ? r : JO(r, n(t)) } function y7(t) { return eM(t, Dw, _w) } function v7(t) { return eM(t, Rw, ZO) } var Ob = dc(aa, "DataView"), Mb = dc(aa, "Promise"), Db = dc(aa, "Set"), Rb = dc(aa, "WeakMap"), oE = "[object Map]", x7 = "[object Object]", lE = "[object Promise]", cE = "[object Set]", uE = "[object WeakMap]", dE = "[object DataView]", b7 = uc(Ob), w7 = uc(Df), S7 = uc(Mb), C7 = uc(Db), T7 = uc(Rb), Ra = lc; (Ob && Ra(new Ob(new ArrayBuffer(1))) != dE || Df && Ra(new Df) != oE || Mb && Ra(Mb.resolve()) != lE || Db && Ra(new Db) != cE || Rb && Ra(new Rb) != uE) && (Ra = function (t) { var e = lc(t), n = e == x7 ? t.constructor : void 0, r = n ? uc(n) : ""; if (r) switch (r) { case b7: return dE; case w7: return oE; case S7: return lE; case C7: return cE; case T7: return uE }return e }); var N7 = Object.prototype, j7 = N7.hasOwnProperty; function E7(t) { var e = t.length, n = new t.constructor(e); return e && typeof t[0] == "string" && j7.call(t, "index") && (n.index = t.index, n.input = t.input), n } var fE = aa.Uint8Array; function Lw(t) { var e = new t.constructor(t.byteLength); return new fE(e).set(new fE(t)), e } function A7(t, e) { var n = e ? Lw(t.buffer) : t.buffer; return new t.constructor(n, t.byteOffset, t.byteLength) } var k7 = /\w*$/; function O7(t) { var e = new t.constructor(t.source, k7.exec(t)); return e.lastIndex = t.lastIndex, e } var hE = Bo ? Bo.prototype : void 0, pE = hE ? hE.valueOf : void 0; function M7(t) { return pE ? Object(pE.call(t)) : {} } function D7(t, e) { var n = e ? Lw(t.buffer) : t.buffer; return new t.constructor(n, t.byteOffset, t.length) } var R7 = "[object Boolean]", _7 = "[object Date]", L7 = "[object Map]", P7 = "[object Number]", z7 = "[object RegExp]", I7 = "[object Set]", F7 = "[object String]", B7 = "[object Symbol]", $7 = "[object ArrayBuffer]", U7 = "[object DataView]", V7 = "[object Float32Array]", H7 = "[object Float64Array]", q7 = "[object Int8Array]", K7 = "[object Int16Array]", W7 = "[object Int32Array]", Y7 = "[object Uint8Array]", G7 = "[object Uint8ClampedArray]", X7 = "[object Uint16Array]", Q7 = "[object Uint32Array]"; function J7(t, e, n) { var r = t.constructor; switch (e) { case $7: return Lw(t); case R7: case _7: return new r(+t); case U7: return A7(t, n); case V7: case H7: case q7: case K7: case W7: case Y7: case G7: case X7: case Q7: return D7(t, n); case L7: return new r; case P7: case F7: return new r(t); case z7: return O7(t); case I7: return new r; case B7: return M7(t) } } var mE = Object.create, Z7 = function () { function t() { } return function (e) { if (!dh(e)) return {}; if (mE) return mE(e); t.prototype = e; var n = new t; return t.prototype = void 0, n } }(); function e9(t) { return typeof t.constructor == "function" && !Mw(t) ? Z7(kw(t)) : {} } var t9 = "[object Map]"; function n9(t) { return cc(t) && Ra(t) == t9 } var gE = hu && hu.isMap, r9 = gE ? Ow(gE) : n9, i9 = "[object Set]"; function s9(t) { return cc(t) && Ra(t) == i9 } var yE = hu && hu.isSet, a9 = yE ? Ow(yE) : s9, o9 = 1, l9 = 2, c9 = 4, tM = "[object Arguments]", u9 = "[object Array]", d9 = "[object Boolean]", f9 = "[object Date]", h9 = "[object Error]", nM = "[object Function]", p9 = "[object GeneratorFunction]", m9 = "[object Map]", g9 = "[object Number]", rM = "[object Object]", y9 = "[object RegExp]", v9 = "[object Set]", x9 = "[object String]", b9 = "[object Symbol]", w9 = "[object WeakMap]", S9 = "[object ArrayBuffer]", C9 = "[object DataView]", T9 = "[object Float32Array]", N9 = "[object Float64Array]", j9 = "[object Int8Array]", E9 = "[object Int16Array]", A9 = "[object Int32Array]", k9 = "[object Uint8Array]", O9 = "[object Uint8ClampedArray]", M9 = "[object Uint16Array]", D9 = "[object Uint32Array]", jn = {}; jn[tM] = jn[u9] = jn[S9] = jn[C9] = jn[d9] = jn[f9] = jn[T9] = jn[N9] = jn[j9] = jn[E9] = jn[A9] = jn[m9] = jn[g9] = jn[rM] = jn[y9] = jn[v9] = jn[x9] = jn[b9] = jn[k9] = jn[O9] = jn[M9] = jn[D9] = !0; jn[h9] = jn[nM] = jn[w9] = !1; function sf(t, e, n, r, i, s) { var a, l = e & o9, u = e & l9, f = e & c9; if (a !== void 0) return a; if (!dh(t)) return t; var p = fh(t); if (p) { if (a = E7(t), !l) return XO(t, a) } else { var g = Ra(t), y = g == nM || g == p9; if (HO(t)) return u7(t, l); if (g == rM || g == tM || y && !i) { if (a = u || y ? {} : e9(t), !l) return u ? g7(t, l7(a, t)) : p7(t, r7(a, t)) } else { if (!jn[g]) return i ? t : {}; a = J7(t, g, l) } } s || (s = new ju); var v = s.get(t); if (v) return v; s.set(t, a), a9(t) ? t.forEach(function (C) { a.add(sf(C, e, n, C, t, s)) }) : r9(t) && t.forEach(function (C, T) { a.set(T, sf(C, e, n, T, t, s)) }); var b = f ? u ? v7 : y7 : u ? Rw : Dw, S = p ? void 0 : b(t); return lB(S || t, function (C, T) { S && (T = C, C = t[T]), $O(a, T, sf(C, e, n, T, t, s)) }), a } var R9 = 1, _9 = 4; function Fp(t) { return sf(t, R9 | _9) } var ux, vE; function L9() { if (vE) return ux; vE = 1; var t = Array.isArray, e = Object.keys, n = Object.prototype.hasOwnProperty, r = typeof Element < "u"; function i(s, a) { if (s === a) return !0; if (s && a && typeof s == "object" && typeof a == "object") { var l = t(s), u = t(a), f, p, g; if (l && u) { if (p = s.length, p != a.length) return !1; for (f = p; f-- !== 0;)if (!i(s[f], a[f])) return !1; return !0 } if (l != u) return !1; var y = s instanceof Date, v = a instanceof Date; if (y != v) return !1; if (y && v) return s.getTime() == a.getTime(); var b = s instanceof RegExp, S = a instanceof RegExp; if (b != S) return !1; if (b && S) return s.toString() == a.toString(); var C = e(s); if (p = C.length, p !== e(a).length) return !1; for (f = p; f-- !== 0;)if (!n.call(a, C[f])) return !1; if (r && s instanceof Element && a instanceof Element) return s === a; for (f = p; f-- !== 0;)if (g = C[f], !(g === "_owner" && s.$$typeof) && !i(s[g], a[g])) return !1; return !0 } return s !== s && a !== a } return ux = function (a, l) { try { return i(a, l) } catch (u) { if (u.message && u.message.match(/stack|recursion/i) || u.number === -2146828260) return console.warn("Warning: react-fast-compare does not handle circular references.", u.name, u.message), !1; throw u } }, ux } var P9 = L9(); const wl = Ha(P9); var z9 = 4; function xE(t) { return sf(t, z9) } function iM(t, e) { for (var n = -1, r = t == null ? 0 : t.length, i = Array(r); ++n < r;)i[n] = e(t[n], n, t); return i } var I9 = "[object Symbol]"; function Pw(t) { return typeof t == "symbol" || cc(t) && lc(t) == I9 } var F9 = "Expected a function"; function zw(t, e) { if (typeof t != "function" || e != null && typeof e != "function") throw new TypeError(F9); var n = function () { var r = arguments, i = e ? e.apply(this, r) : r[0], s = n.cache; if (s.has(i)) return s.get(i); var a = t.apply(this, r); return n.cache = s.set(i, a) || s, a }; return n.cache = new (zw.Cache || Wo), n } zw.Cache = Wo; var B9 = 500; function $9(t) { var e = zw(t, function (r) { return n.size === B9 && n.clear(), r }), n = e.cache; return e } var U9 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, V9 = /\\(\\)?/g, H9 = $9(function (t) { var e = []; return t.charCodeAt(0) === 46 && e.push(""), t.replace(U9, function (n, r, i, s) { e.push(i ? s.replace(V9, "$1") : r || n) }), e }); function q9(t) { if (typeof t == "string" || Pw(t)) return t; var e = t + ""; return e == "0" && 1 / t == -1 / 0 ? "-0" : e } var bE = Bo ? Bo.prototype : void 0, wE = bE ? bE.toString : void 0; function sM(t) { if (typeof t == "string") return t; if (fh(t)) return iM(t, sM) + ""; if (Pw(t)) return wE ? wE.call(t) : ""; var e = t + ""; return e == "0" && 1 / t == -1 / 0 ? "-0" : e } function K9(t) { return t == null ? "" : sM(t) } function aM(t) { return fh(t) ? iM(t, q9) : Pw(t) ? [t] : XO(H9(K9(t))) } var dx = { exports: {} }, fn = {};/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var SE; function W9() { if (SE) return fn; SE = 1; var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, r = t ? Symbol.for("react.fragment") : 60107, i = t ? Symbol.for("react.strict_mode") : 60108, s = t ? Symbol.for("react.profiler") : 60114, a = t ? Symbol.for("react.provider") : 60109, l = t ? Symbol.for("react.context") : 60110, u = t ? Symbol.for("react.async_mode") : 60111, f = t ? Symbol.for("react.concurrent_mode") : 60111, p = t ? Symbol.for("react.forward_ref") : 60112, g = t ? Symbol.for("react.suspense") : 60113, y = t ? Symbol.for("react.suspense_list") : 60120, v = t ? Symbol.for("react.memo") : 60115, b = t ? Symbol.for("react.lazy") : 60116, S = t ? Symbol.for("react.block") : 60121, C = t ? Symbol.for("react.fundamental") : 60117, T = t ? Symbol.for("react.responder") : 60118, A = t ? Symbol.for("react.scope") : 60119; function M(E) { if (typeof E == "object" && E !== null) { var k = E.$$typeof; switch (k) { case e: switch (E = E.type, E) { case u: case f: case r: case s: case i: case g: return E; default: switch (E = E && E.$$typeof, E) { case l: case p: case b: case v: case a: return E; default: return k } }case n: return k } } } function O(E) { return M(E) === f } return fn.AsyncMode = u, fn.ConcurrentMode = f, fn.ContextConsumer = l, fn.ContextProvider = a, fn.Element = e, fn.ForwardRef = p, fn.Fragment = r, fn.Lazy = b, fn.Memo = v, fn.Portal = n, fn.Profiler = s, fn.StrictMode = i, fn.Suspense = g, fn.isAsyncMode = function (E) { return O(E) || M(E) === u }, fn.isConcurrentMode = O, fn.isContextConsumer = function (E) { return M(E) === l }, fn.isContextProvider = function (E) { return M(E) === a }, fn.isElement = function (E) { return typeof E == "object" && E !== null && E.$$typeof === e }, fn.isForwardRef = function (E) { return M(E) === p }, fn.isFragment = function (E) { return M(E) === r }, fn.isLazy = function (E) { return M(E) === b }, fn.isMemo = function (E) { return M(E) === v }, fn.isPortal = function (E) { return M(E) === n }, fn.isProfiler = function (E) { return M(E) === s }, fn.isStrictMode = function (E) { return M(E) === i }, fn.isSuspense = function (E) { return M(E) === g }, fn.isValidElementType = function (E) { return typeof E == "string" || typeof E == "function" || E === r || E === f || E === s || E === i || E === g || E === y || typeof E == "object" && E !== null && (E.$$typeof === b || E.$$typeof === v || E.$$typeof === a || E.$$typeof === l || E.$$typeof === p || E.$$typeof === C || E.$$typeof === T || E.$$typeof === A || E.$$typeof === S) }, fn.typeOf = M, fn } var CE; function Y9() { return CE || (CE = 1, dx.exports = W9()), dx.exports } var fx, TE; function G9() { if (TE) return fx; TE = 1; var t = Y9(), e = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, n = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, r = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, i = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, s = {}; s[t.ForwardRef] = r, s[t.Memo] = i; function a(b) { return t.isMemo(b) ? i : s[b.$$typeof] || e } var l = Object.defineProperty, u = Object.getOwnPropertyNames, f = Object.getOwnPropertySymbols, p = Object.getOwnPropertyDescriptor, g = Object.getPrototypeOf, y = Object.prototype; function v(b, S, C) { if (typeof S != "string") { if (y) { var T = g(S); T && T !== y && v(b, T, C) } var A = u(S); f && (A = A.concat(f(S))); for (var M = a(b), O = a(S), E = 0; E < A.length; ++E) { var k = A[E]; if (!n[k] && !(C && C[k]) && !(O && O[k]) && !(M && M[k])) { var z = p(S, k); try { l(b, k, z) } catch { } } } } return b } return fx = v, fx } G9(); function jr() { return jr = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, jr.apply(this, arguments) } function oM(t, e) { if (t == null) return {}; var n = {}, r = Object.keys(t), i, s; for (s = 0; s < r.length; s++)i = r[s], !(e.indexOf(i) >= 0) && (n[i] = t[i]); return n } var hy = N.createContext(void 0); hy.displayName = "FormikContext"; hy.Provider; hy.Consumer; function X9() { var t = N.useContext(hy); return t } var ys = function (e) { return typeof e == "function" }, py = function (e) { return e !== null && typeof e == "object" }, Q9 = function (e) { return String(Math.floor(Number(e))) === e }, hx = function (e) { return Object.prototype.toString.call(e) === "[object String]" }, px = function (e) { return py(e) && ys(e.then) }; function _i(t, e, n, r) { r === void 0 && (r = 0); for (var i = aM(e); t && r < i.length;)t = t[i[r++]]; return r !== i.length && !t || t === void 0 ? n : t } function Il(t, e, n) { for (var r = xE(t), i = r, s = 0, a = aM(e); s < a.length - 1; s++) { var l = a[s], u = _i(t, a.slice(0, s + 1)); if (u && (py(u) || Array.isArray(u))) i = i[l] = xE(u); else { var f = a[s + 1]; i = i[l] = Q9(f) && Number(f) >= 0 ? [] : {} } } return (s === 0 ? t : i)[a[s]] === n ? t : (n === void 0 ? delete i[a[s]] : i[a[s]] = n, s === 0 && n === void 0 && delete r[a[s]], r) } function lM(t, e, n, r) { n === void 0 && (n = new WeakMap), r === void 0 && (r = {}); for (var i = 0, s = Object.keys(t); i < s.length; i++) { var a = s[i], l = t[a]; py(l) ? n.get(l) || (n.set(l, !0), r[a] = Array.isArray(l) ? [] : {}, lM(l, e, n, r[a])) : r[a] = e } return r } function J9(t, e) { switch (e.type) { case "SET_VALUES": return jr({}, t, { values: e.payload }); case "SET_TOUCHED": return jr({}, t, { touched: e.payload }); case "SET_ERRORS": return wl(t.errors, e.payload) ? t : jr({}, t, { errors: e.payload }); case "SET_STATUS": return jr({}, t, { status: e.payload }); case "SET_ISSUBMITTING": return jr({}, t, { isSubmitting: e.payload }); case "SET_ISVALIDATING": return jr({}, t, { isValidating: e.payload }); case "SET_FIELD_VALUE": return jr({}, t, { values: Il(t.values, e.payload.field, e.payload.value) }); case "SET_FIELD_TOUCHED": return jr({}, t, { touched: Il(t.touched, e.payload.field, e.payload.value) }); case "SET_FIELD_ERROR": return jr({}, t, { errors: Il(t.errors, e.payload.field, e.payload.value) }); case "RESET_FORM": return jr({}, t, e.payload); case "SET_FORMIK_STATE": return e.payload(t); case "SUBMIT_ATTEMPT": return jr({}, t, { touched: lM(t.values, !0), isSubmitting: !0, submitCount: t.submitCount + 1 }); case "SUBMIT_FAILURE": return jr({}, t, { isSubmitting: !1 }); case "SUBMIT_SUCCESS": return jr({}, t, { isSubmitting: !1 }); default: return t } } var yl = {}, Bp = {}; function Z9(t) { var e = t.validateOnChange, n = e === void 0 ? !0 : e, r = t.validateOnBlur, i = r === void 0 ? !0 : r, s = t.validateOnMount, a = s === void 0 ? !1 : s, l = t.isInitialValid, u = t.enableReinitialize, f = u === void 0 ? !1 : u, p = t.onSubmit, g = oM(t, ["validateOnChange", "validateOnBlur", "validateOnMount", "isInitialValid", "enableReinitialize", "onSubmit"]), y = jr({ validateOnChange: n, validateOnBlur: i, validateOnMount: a, onSubmit: p }, g), v = N.useRef(y.initialValues), b = N.useRef(y.initialErrors || yl), S = N.useRef(y.initialTouched || Bp), C = N.useRef(y.initialStatus), T = N.useRef(!1), A = N.useRef({}); N.useEffect(function () { return T.current = !0, function () { T.current = !1 } }, []); var M = N.useState(0), O = M[1], E = N.useRef({ values: Fp(y.initialValues), errors: Fp(y.initialErrors) || yl, touched: Fp(y.initialTouched) || Bp, status: Fp(y.initialStatus), isSubmitting: !1, isValidating: !1, submitCount: 0 }), k = E.current, z = N.useCallback(function (_) { var I = E.current; E.current = J9(I, _), I !== E.current && O(function (se) { return se + 1 }) }, []), V = N.useCallback(function (_, I) { return new Promise(function (se, ae) { var Ae = y.validate(_, I); Ae == null ? se(yl) : px(Ae) ? Ae.then(function (qe) { se(qe || yl) }, function (qe) { ae(qe) }) : se(Ae) }) }, [y.validate]), q = N.useCallback(function (_, I) { var se = y.validationSchema, ae = ys(se) ? se(I) : se, Ae = I && ae.validateAt ? ae.validateAt(I, _) : t$(_, ae); return new Promise(function (qe, rt) { Ae.then(function () { qe(yl) }, function (Tt) { Tt.name === "ValidationError" ? qe(e$(Tt)) : rt(Tt) }) }) }, [y.validationSchema]), ue = N.useCallback(function (_, I) { return new Promise(function (se) { return se(A.current[_].validate(I)) }) }, []), W = N.useCallback(function (_) { var I = Object.keys(A.current).filter(function (ae) { return ys(A.current[ae].validate) }), se = I.length > 0 ? I.map(function (ae) { return ue(ae, _i(_, ae)) }) : [Promise.resolve("DO_NOT_DELETE_YOU_WILL_BE_FIRED")]; return Promise.all(se).then(function (ae) { return ae.reduce(function (Ae, qe, rt) { return qe === "DO_NOT_DELETE_YOU_WILL_BE_FIRED" || qe && (Ae = Il(Ae, I[rt], qe)), Ae }, {}) }) }, [ue]), ne = N.useCallback(function (_) { return Promise.all([W(_), y.validationSchema ? q(_) : {}, y.validate ? V(_) : {}]).then(function (I) { var se = I[0], ae = I[1], Ae = I[2], qe = kb.all([se, ae, Ae], { arrayMerge: n$ }); return qe }) }, [y.validate, y.validationSchema, W, V, q]), H = Zi(function (_) { return _ === void 0 && (_ = k.values), z({ type: "SET_ISVALIDATING", payload: !0 }), ne(_).then(function (I) { return T.current && (z({ type: "SET_ISVALIDATING", payload: !1 }), z({ type: "SET_ERRORS", payload: I })), I }) }); N.useEffect(function () { a && T.current === !0 && wl(v.current, y.initialValues) && H(v.current) }, [a, H]); var we = N.useCallback(function (_) { var I = _ && _.values ? _.values : v.current, se = _ && _.errors ? _.errors : b.current ? b.current : y.initialErrors || {}, ae = _ && _.touched ? _.touched : S.current ? S.current : y.initialTouched || {}, Ae = _ && _.status ? _.status : C.current ? C.current : y.initialStatus; v.current = I, b.current = se, S.current = ae, C.current = Ae; var qe = function () { z({ type: "RESET_FORM", payload: { isSubmitting: !!_ && !!_.isSubmitting, errors: se, touched: ae, status: Ae, values: I, isValidating: !!_ && !!_.isValidating, submitCount: _ && _.submitCount && typeof _.submitCount == "number" ? _.submitCount : 0 } }) }; if (y.onReset) { var rt = y.onReset(k.values, Je); px(rt) ? rt.then(qe) : qe() } else qe() }, [y.initialErrors, y.initialStatus, y.initialTouched, y.onReset]); N.useEffect(function () { T.current === !0 && !wl(v.current, y.initialValues) && f && (v.current = y.initialValues, we(), a && H(v.current)) }, [f, y.initialValues, we, a, H]), N.useEffect(function () { f && T.current === !0 && !wl(b.current, y.initialErrors) && (b.current = y.initialErrors || yl, z({ type: "SET_ERRORS", payload: y.initialErrors || yl })) }, [f, y.initialErrors]), N.useEffect(function () { f && T.current === !0 && !wl(S.current, y.initialTouched) && (S.current = y.initialTouched || Bp, z({ type: "SET_TOUCHED", payload: y.initialTouched || Bp })) }, [f, y.initialTouched]), N.useEffect(function () { f && T.current === !0 && !wl(C.current, y.initialStatus) && (C.current = y.initialStatus, z({ type: "SET_STATUS", payload: y.initialStatus })) }, [f, y.initialStatus, y.initialTouched]); var xe = Zi(function (_) { if (A.current[_] && ys(A.current[_].validate)) { var I = _i(k.values, _), se = A.current[_].validate(I); return px(se) ? (z({ type: "SET_ISVALIDATING", payload: !0 }), se.then(function (ae) { return ae }).then(function (ae) { z({ type: "SET_FIELD_ERROR", payload: { field: _, value: ae } }), z({ type: "SET_ISVALIDATING", payload: !1 }) })) : (z({ type: "SET_FIELD_ERROR", payload: { field: _, value: se } }), Promise.resolve(se)) } else if (y.validationSchema) return z({ type: "SET_ISVALIDATING", payload: !0 }), q(k.values, _).then(function (ae) { return ae }).then(function (ae) { z({ type: "SET_FIELD_ERROR", payload: { field: _, value: _i(ae, _) } }), z({ type: "SET_ISVALIDATING", payload: !1 }) }); return Promise.resolve() }), K = N.useCallback(function (_, I) { var se = I.validate; A.current[_] = { validate: se } }, []), te = N.useCallback(function (_) { delete A.current[_] }, []), ye = Zi(function (_, I) { z({ type: "SET_TOUCHED", payload: _ }); var se = I === void 0 ? i : I; return se ? H(k.values) : Promise.resolve() }), He = N.useCallback(function (_) { z({ type: "SET_ERRORS", payload: _ }) }, []), B = Zi(function (_, I) { var se = ys(_) ? _(k.values) : _; z({ type: "SET_VALUES", payload: se }); var ae = I === void 0 ? n : I; return ae ? H(se) : Promise.resolve() }), ie = N.useCallback(function (_, I) { z({ type: "SET_FIELD_ERROR", payload: { field: _, value: I } }) }, []), oe = Zi(function (_, I, se) { z({ type: "SET_FIELD_VALUE", payload: { field: _, value: I } }); var ae = se === void 0 ? n : se; return ae ? H(Il(k.values, _, I)) : Promise.resolve() }), pe = N.useCallback(function (_, I) { var se = I, ae = _, Ae; if (!hx(_)) { _.persist && _.persist(); var qe = _.target ? _.target : _.currentTarget, rt = qe.type, Tt = qe.name, yn = qe.id, Gt = qe.value, $n = qe.checked; qe.outerHTML; var cn = qe.options, je = qe.multiple; se = I || Tt || yn, ae = /number|range/.test(rt) ? (Ae = parseFloat(Gt), isNaN(Ae) ? "" : Ae) : /checkbox/.test(rt) ? i$(_i(k.values, se), $n, Gt) : cn && je ? r$(cn) : Gt } se && oe(se, ae) }, [oe, k.values]), Ee = Zi(function (_) { if (hx(_)) return function (I) { return pe(I, _) }; pe(_) }), fe = Zi(function (_, I, se) { I === void 0 && (I = !0), z({ type: "SET_FIELD_TOUCHED", payload: { field: _, value: I } }); var ae = se === void 0 ? i : se; return ae ? H(k.values) : Promise.resolve() }), Oe = N.useCallback(function (_, I) { _.persist && _.persist(); var se = _.target, ae = se.name, Ae = se.id; se.outerHTML; var qe = I || ae || Ae; fe(qe, !0) }, [fe]), et = Zi(function (_) { if (hx(_)) return function (I) { return Oe(I, _) }; Oe(_) }), Xe = N.useCallback(function (_) { ys(_) ? z({ type: "SET_FORMIK_STATE", payload: _ }) : z({ type: "SET_FORMIK_STATE", payload: function () { return _ } }) }, []), De = N.useCallback(function (_) { z({ type: "SET_STATUS", payload: _ }) }, []), he = N.useCallback(function (_) { z({ type: "SET_ISSUBMITTING", payload: _ }) }, []), Be = Zi(function () { return z({ type: "SUBMIT_ATTEMPT" }), H().then(function (_) { var I = _ instanceof Error, se = !I && Object.keys(_).length === 0; if (se) { var ae; try { if (ae = $e(), ae === void 0) return } catch (Ae) { throw Ae } return Promise.resolve(ae).then(function (Ae) { return T.current && z({ type: "SUBMIT_SUCCESS" }), Ae }).catch(function (Ae) { if (T.current) throw z({ type: "SUBMIT_FAILURE" }), Ae }) } else if (T.current && (z({ type: "SUBMIT_FAILURE" }), I)) throw _ }) }), Y = Zi(function (_) { _ && _.preventDefault && ys(_.preventDefault) && _.preventDefault(), _ && _.stopPropagation && ys(_.stopPropagation) && _.stopPropagation(), Be().catch(function (I) { console.warn("Warning: An unhandled error was caught from submitForm()", I) }) }), Je = { resetForm: we, validateForm: H, validateField: xe, setErrors: He, setFieldError: ie, setFieldTouched: fe, setFieldValue: oe, setStatus: De, setSubmitting: he, setTouched: ye, setValues: B, setFormikState: Xe, submitForm: Be }, $e = Zi(function () { return p(k.values, Je) }), $ = Zi(function (_) { _ && _.preventDefault && ys(_.preventDefault) && _.preventDefault(), _ && _.stopPropagation && ys(_.stopPropagation) && _.stopPropagation(), we() }), U = N.useCallback(function (_) { return { value: _i(k.values, _), error: _i(k.errors, _), touched: !!_i(k.touched, _), initialValue: _i(v.current, _), initialTouched: !!_i(S.current, _), initialError: _i(b.current, _) } }, [k.errors, k.touched, k.values]), be = N.useCallback(function (_) { return { setValue: function (se, ae) { return oe(_, se, ae) }, setTouched: function (se, ae) { return fe(_, se, ae) }, setError: function (se) { return ie(_, se) } } }, [oe, fe, ie]), Ie = N.useCallback(function (_) { var I = py(_), se = I ? _.name : _, ae = _i(k.values, se), Ae = { name: se, value: ae, onChange: Ee, onBlur: et }; if (I) { var qe = _.type, rt = _.value, Tt = _.as, yn = _.multiple; qe === "checkbox" ? rt === void 0 ? Ae.checked = !!ae : (Ae.checked = !!(Array.isArray(ae) && ~ae.indexOf(rt)), Ae.value = rt) : qe === "radio" ? (Ae.checked = ae === rt, Ae.value = rt) : Tt === "select" && yn && (Ae.value = Ae.value || [], Ae.multiple = !0) } return Ae }, [et, Ee, k.values]), it = N.useMemo(function () { return !wl(v.current, k.values) }, [v.current, k.values]), P = N.useMemo(function () { return typeof l < "u" ? it ? k.errors && Object.keys(k.errors).length === 0 : l !== !1 && ys(l) ? l(y) : l : k.errors && Object.keys(k.errors).length === 0 }, [l, it, k.errors, y]), ee = jr({}, k, { initialValues: v.current, initialErrors: b.current, initialTouched: S.current, initialStatus: C.current, handleBlur: et, handleChange: Ee, handleReset: $, handleSubmit: Y, resetForm: we, setErrors: He, setFormikState: Xe, setFieldTouched: fe, setFieldValue: oe, setFieldError: ie, setStatus: De, setSubmitting: he, setTouched: ye, setValues: B, submitForm: Be, validateForm: H, validateField: xe, isValid: P, dirty: it, unregisterField: te, registerField: K, getFieldProps: Ie, getFieldMeta: U, getFieldHelpers: be, validateOnBlur: i, validateOnChange: n, validateOnMount: a }); return ee } function e$(t) { var e = {}; if (t.inner) { if (t.inner.length === 0) return Il(e, t.path, t.message); for (var i = t.inner, n = Array.isArray(i), r = 0, i = n ? i : i[Symbol.iterator](); ;) { var s; if (n) { if (r >= i.length) break; s = i[r++] } else { if (r = i.next(), r.done) break; s = r.value } var a = s; _i(e, a.path) || (e = Il(e, a.path, a.message)) } } return e } function t$(t, e, n, r) { n === void 0 && (n = !1); var i = _b(t); return e[n ? "validateSync" : "validate"](i, { abortEarly: !1, context: i }) } function _b(t) { var e = Array.isArray(t) ? [] : {}; for (var n in t) if (Object.prototype.hasOwnProperty.call(t, n)) { var r = String(n); Array.isArray(t[r]) === !0 ? e[r] = t[r].map(function (i) { return Array.isArray(i) === !0 || Xj(i) ? _b(i) : i !== "" ? i : void 0 }) : Xj(t[r]) ? e[r] = _b(t[r]) : e[r] = t[r] !== "" ? t[r] : void 0 } return e } function n$(t, e, n) { var r = t.slice(); return e.forEach(function (s, a) { if (typeof r[a] > "u") { var l = n.clone !== !1, u = l && n.isMergeableObject(s); r[a] = u ? kb(Array.isArray(s) ? [] : {}, s, n) : s } else n.isMergeableObject(s) ? r[a] = kb(t[a], s, n) : t.indexOf(s) === -1 && r.push(s) }), r } function r$(t) { return Array.from(t).filter(function (e) { return e.selected }).map(function (e) { return e.value }) } function i$(t, e, n) { if (typeof t == "boolean") return !!e; var r = [], i = !1, s = -1; if (Array.isArray(t)) r = t, s = t.indexOf(n), i = s >= 0; else if (!n || n == "true" || n == "false") return !!e; return e && n && !i ? r.concat(n) : i ? r.slice(0, s).concat(r.slice(s + 1)) : r } var s$ = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? N.useLayoutEffect : N.useEffect; function Zi(t) { var e = N.useRef(t); return s$(function () { e.current = t }), N.useCallback(function () { for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)r[i] = arguments[i]; return e.current.apply(void 0, r) }, []) } var a$ = N.forwardRef(function (t, e) { var n = t.action, r = oM(t, ["action"]), i = n ?? "#", s = X9(), a = s.handleReset, l = s.handleSubmit; return N.createElement("form", jr({ onSubmit: l, ref: e, onReset: a, action: i }, r)) }); a$.displayName = "Form"; let o$ = { data: "" }, l$ = t => typeof window == "object" ? ((t ? t.querySelector("#_goober") : window._goober) || Object.assign((t || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : t || o$, c$ = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, u$ = /\/\*[^]*?\*\/|  +/g, NE = /\n+/g, No = (t, e) => { let n = "", r = "", i = ""; for (let s in t) { let a = t[s]; s[0] == "@" ? s[1] == "i" ? n = s + " " + a + ";" : r += s[1] == "f" ? No(a, s) : s + "{" + No(a, s[1] == "k" ? "" : e) + "}" : typeof a == "object" ? r += No(a, e ? e.replace(/([^,])+/g, l => s.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, u => /&/.test(u) ? u.replace(/&/g, l) : l ? l + " " + u : u)) : s) : a != null && (s = /^--/.test(s) ? s : s.replace(/[A-Z]/g, "-$&").toLowerCase(), i += No.p ? No.p(s, a) : s + ":" + a + ";") } return n + (e && i ? e + "{" + i + "}" : i) + r }, Ta = {}, cM = t => { if (typeof t == "object") { let e = ""; for (let n in t) e += n + cM(t[n]); return e } return t }, d$ = (t, e, n, r, i) => { let s = cM(t), a = Ta[s] || (Ta[s] = (u => { let f = 0, p = 11; for (; f < u.length;)p = 101 * p + u.charCodeAt(f++) >>> 0; return "go" + p })(s)); if (!Ta[a]) { let u = s !== t ? t : (f => { let p, g, y = [{}]; for (; p = c$.exec(f.replace(u$, ""));)p[4] ? y.shift() : p[3] ? (g = p[3].replace(NE, " ").trim(), y.unshift(y[0][g] = y[0][g] || {})) : y[0][p[1]] = p[2].replace(NE, " ").trim(); return y[0] })(t); Ta[a] = No(i ? { ["@keyframes " + a]: u } : u, n ? "" : "." + a) } let l = n && Ta.g ? Ta.g : null; return n && (Ta.g = Ta[a]), ((u, f, p, g) => { g ? f.data = f.data.replace(g, u) : f.data.indexOf(u) === -1 && (f.data = p ? u + f.data : f.data + u) })(Ta[a], e, r, l), a }, f$ = (t, e, n) => t.reduce((r, i, s) => { let a = e[s]; if (a && a.call) { let l = a(n), u = l && l.props && l.props.className || /^go/.test(l) && l; a = u ? "." + u : l && typeof l == "object" ? l.props ? "" : No(l, "") : l === !1 ? "" : l } return r + i + (a ?? "") }, ""); function my(t) { let e = this || {}, n = t.call ? t(e.p) : t; return d$(n.unshift ? n.raw ? f$(n, [].slice.call(arguments, 1), e.p) : n.reduce((r, i) => Object.assign(r, i && i.call ? i(e.p) : i), {}) : n, l$(e.target), e.g, e.o, e.k) } let uM, Lb, Pb; my.bind({ g: 1 }); let Ba = my.bind({ k: 1 }); function h$(t, e, n, r) { No.p = e, uM = t, Lb = n, Pb = r } function Yo(t, e) { let n = this || {}; return function () { let r = arguments; function i(s, a) { let l = Object.assign({}, s), u = l.className || i.className; n.p = Object.assign({ theme: Lb && Lb() }, l), n.o = / *go\d+/.test(u), l.className = my.apply(n, r) + (u ? " " + u : ""); let f = t; return t[0] && (f = l.as || t, delete l.as), Pb && f[0] && Pb(l), uM(f, l) } return i } } var p$ = t => typeof t == "function", Wm = (t, e) => p$(t) ? t(e) : t, m$ = (() => { let t = 0; return () => (++t).toString() })(), dM = (() => { let t; return () => { if (t === void 0 && typeof window < "u") { let e = matchMedia("(prefers-reduced-motion: reduce)"); t = !e || e.matches } return t } })(), g$ = 20, fM = (t, e) => { switch (e.type) { case 0: return { ...t, toasts: [e.toast, ...t.toasts].slice(0, g$) }; case 1: return { ...t, toasts: t.toasts.map(s => s.id === e.toast.id ? { ...s, ...e.toast } : s) }; case 2: let { toast: n } = e; return fM(t, { type: t.toasts.find(s => s.id === n.id) ? 1 : 0, toast: n }); case 3: let { toastId: r } = e; return { ...t, toasts: t.toasts.map(s => s.id === r || r === void 0 ? { ...s, dismissed: !0, visible: !1 } : s) }; case 4: return e.toastId === void 0 ? { ...t, toasts: [] } : { ...t, toasts: t.toasts.filter(s => s.id !== e.toastId) }; case 5: return { ...t, pausedAt: e.time }; case 6: let i = e.time - (t.pausedAt || 0); return { ...t, pausedAt: void 0, toasts: t.toasts.map(s => ({ ...s, pauseDuration: s.pauseDuration + i })) } } }, wm = [], kl = { toasts: [], pausedAt: void 0 }, fc = t => { kl = fM(kl, t), wm.forEach(e => { e(kl) }) }, y$ = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, v$ = (t = {}) => { let [e, n] = N.useState(kl), r = N.useRef(kl); N.useEffect(() => (r.current !== kl && n(kl), wm.push(n), () => { let s = wm.indexOf(n); s > -1 && wm.splice(s, 1) }), []); let i = e.toasts.map(s => { var a, l, u; return { ...t, ...t[s.type], ...s, removeDelay: s.removeDelay || ((a = t[s.type]) == null ? void 0 : a.removeDelay) || t?.removeDelay, duration: s.duration || ((l = t[s.type]) == null ? void 0 : l.duration) || t?.duration || y$[s.type], style: { ...t.style, ...(u = t[s.type]) == null ? void 0 : u.style, ...s.style } } }); return { ...e, toasts: i } }, x$ = (t, e = "blank", n) => ({ createdAt: Date.now(), visible: !0, dismissed: !1, type: e, ariaProps: { role: "status", "aria-live": "polite" }, message: t, pauseDuration: 0, ...n, id: n?.id || m$() }), hh = t => (e, n) => { let r = x$(e, t, n); return fc({ type: 2, toast: r }), r.id }, ur = (t, e) => hh("blank")(t, e); ur.error = hh("error"); ur.success = hh("success"); ur.loading = hh("loading"); ur.custom = hh("custom"); ur.dismiss = t => { fc({ type: 3, toastId: t }) }; ur.remove = t => fc({ type: 4, toastId: t }); ur.promise = (t, e, n) => { let r = ur.loading(e.loading, { ...n, ...n?.loading }); return typeof t == "function" && (t = t()), t.then(i => { let s = e.success ? Wm(e.success, i) : void 0; return s ? ur.success(s, { id: r, ...n, ...n?.success }) : ur.dismiss(r), i }).catch(i => { let s = e.error ? Wm(e.error, i) : void 0; s ? ur.error(s, { id: r, ...n, ...n?.error }) : ur.dismiss(r) }), t }; var b$ = (t, e) => { fc({ type: 1, toast: { id: t, height: e } }) }, w$ = () => { fc({ type: 5, time: Date.now() }) }, af = new Map, S$ = 1e3, C$ = (t, e = S$) => { if (af.has(t)) return; let n = setTimeout(() => { af.delete(t), fc({ type: 4, toastId: t }) }, e); af.set(t, n) }, T$ = t => { let { toasts: e, pausedAt: n } = v$(t); N.useEffect(() => { if (n) return; let s = Date.now(), a = e.map(l => { if (l.duration === 1 / 0) return; let u = (l.duration || 0) + l.pauseDuration - (s - l.createdAt); if (u < 0) { l.visible && ur.dismiss(l.id); return } return setTimeout(() => ur.dismiss(l.id), u) }); return () => { a.forEach(l => l && clearTimeout(l)) } }, [e, n]); let r = N.useCallback(() => { n && fc({ type: 6, time: Date.now() }) }, [n]), i = N.useCallback((s, a) => { let { reverseOrder: l = !1, gutter: u = 8, defaultPosition: f } = a || {}, p = e.filter(v => (v.position || f) === (s.position || f) && v.height), g = p.findIndex(v => v.id === s.id), y = p.filter((v, b) => b < g && v.visible).length; return p.filter(v => v.visible).slice(...l ? [y + 1] : [0, y]).reduce((v, b) => v + (b.height || 0) + u, 0) }, [e]); return N.useEffect(() => { e.forEach(s => { if (s.dismissed) C$(s.id, s.removeDelay); else { let a = af.get(s.id); a && (clearTimeout(a), af.delete(s.id)) } }) }, [e]), { toasts: e, handlers: { updateHeight: b$, startPause: w$, endPause: r, calculateOffset: i } } }, N$ = Ba`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, j$ = Ba`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, E$ = Ba`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, A$ = Yo("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${t => t.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${N$} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${j$} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${t => t.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${E$} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, k$ = Ba`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, O$ = Yo("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${t => t.secondary || "#e0e0e0"};
  border-right-color: ${t => t.primary || "#616161"};
  animation: ${k$} 1s linear infinite;
`, M$ = Ba`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, D$ = Ba`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, R$ = Yo("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${t => t.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${M$} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${D$} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${t => t.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, _$ = Yo("div")`
  position: absolute;
`, L$ = Yo("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, P$ = Ba`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, z$ = Yo("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${P$} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, I$ = ({ toast: t }) => { let { icon: e, type: n, iconTheme: r } = t; return e !== void 0 ? typeof e == "string" ? N.createElement(z$, null, e) : e : n === "blank" ? null : N.createElement(L$, null, N.createElement(O$, { ...r }), n !== "loading" && N.createElement(_$, null, n === "error" ? N.createElement(A$, { ...r }) : N.createElement(R$, { ...r }))) }, F$ = t => `
0% {transform: translate3d(0,${t * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, B$ = t => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${t * -150}%,-1px) scale(.6); opacity:0;}
`, $$ = "0%{opacity:0;} 100%{opacity:1;}", U$ = "0%{opacity:1;} 100%{opacity:0;}", V$ = Yo("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, H$ = Yo("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, q$ = (t, e) => { let n = t.includes("top") ? 1 : -1, [r, i] = dM() ? [$$, U$] : [F$(n), B$(n)]; return { animation: e ? `${Ba(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Ba(i)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` } }, K$ = N.memo(({ toast: t, position: e, style: n, children: r }) => { let i = t.height ? q$(t.position || e || "top-center", t.visible) : { opacity: 0 }, s = N.createElement(I$, { toast: t }), a = N.createElement(H$, { ...t.ariaProps }, Wm(t.message, t)); return N.createElement(V$, { className: t.className, style: { ...i, ...n, ...t.style } }, typeof r == "function" ? r({ icon: s, message: a }) : N.createElement(N.Fragment, null, s, a)) }); h$(N.createElement); var W$ = ({ id: t, className: e, style: n, onHeightUpdate: r, children: i }) => { let s = N.useCallback(a => { if (a) { let l = () => { let u = a.getBoundingClientRect().height; r(t, u) }; l(), new MutationObserver(l).observe(a, { subtree: !0, childList: !0, characterData: !0 }) } }, [t, r]); return N.createElement("div", { ref: s, className: e, style: n }, i) }, Y$ = (t, e) => { let n = t.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, i = t.includes("center") ? { justifyContent: "center" } : t.includes("right") ? { justifyContent: "flex-end" } : {}; return { left: 0, right: 0, display: "flex", position: "absolute", transition: dM() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${e * (n ? 1 : -1)}px)`, ...r, ...i } }, G$ = my`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, $p = 16, X$ = ({ reverseOrder: t, position: e = "top-center", toastOptions: n, gutter: r, children: i, containerStyle: s, containerClassName: a }) => { let { toasts: l, handlers: u } = T$(n); return N.createElement("div", { id: "_rht_toaster", style: { position: "fixed", zIndex: 9999, top: $p, left: $p, right: $p, bottom: $p, pointerEvents: "none", ...s }, className: a, onMouseEnter: u.startPause, onMouseLeave: u.endPause }, l.map(f => { let p = f.position || e, g = u.calculateOffset(f, { reverseOrder: t, gutter: r, defaultPosition: e }), y = Y$(p, g); return N.createElement(W$, { id: f.id, key: f.id, onHeightUpdate: u.updateHeight, className: f.visible ? G$ : "", style: y }, f.type === "custom" ? Wm(f.message, f) : i ? i(f) : N.createElement(K$, { toast: f, position: p })) })) }, me = ur; function hM(t, e) { return function () { return t.apply(e, arguments) } } const { toString: Q$ } = Object.prototype, { getPrototypeOf: Iw } = Object, { iterator: gy, toStringTag: pM } = Symbol, yy = (t => e => { const n = Q$.call(e); return t[n] || (t[n] = n.slice(8, -1).toLowerCase()) })(Object.create(null)), Ms = t => (t = t.toLowerCase(), e => yy(e) === t), vy = t => e => typeof e === t, { isArray: Eu } = Array, _f = vy("undefined"); function J$(t) { return t !== null && !_f(t) && t.constructor !== null && !_f(t.constructor) && xi(t.constructor.isBuffer) && t.constructor.isBuffer(t) } const mM = Ms("ArrayBuffer"); function Z$(t) { let e; return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && mM(t.buffer), e } const eU = vy("string"), xi = vy("function"), gM = vy("number"), xy = t => t !== null && typeof t == "object", tU = t => t === !0 || t === !1, Sm = t => { if (yy(t) !== "object") return !1; const e = Iw(t); return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(pM in t) && !(gy in t) }, nU = Ms("Date"), rU = Ms("File"), iU = Ms("Blob"), sU = Ms("FileList"), aU = t => xy(t) && xi(t.pipe), oU = t => { let e; return t && (typeof FormData == "function" && t instanceof FormData || xi(t.append) && ((e = yy(t)) === "formdata" || e === "object" && xi(t.toString) && t.toString() === "[object FormData]")) }, lU = Ms("URLSearchParams"), [cU, uU, dU, fU] = ["ReadableStream", "Request", "Response", "Headers"].map(Ms), hU = t => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""); function ph(t, e, { allOwnKeys: n = !1 } = {}) { if (t === null || typeof t > "u") return; let r, i; if (typeof t != "object" && (t = [t]), Eu(t)) for (r = 0, i = t.length; r < i; r++)e.call(null, t[r], r, t); else { const s = n ? Object.getOwnPropertyNames(t) : Object.keys(t), a = s.length; let l; for (r = 0; r < a; r++)l = s[r], e.call(null, t[l], l, t) } } function yM(t, e) { e = e.toLowerCase(); const n = Object.keys(t); let r = n.length, i; for (; r-- > 0;)if (i = n[r], e === i.toLowerCase()) return i; return null } const Ol = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, vM = t => !_f(t) && t !== Ol; function zb() { const { caseless: t } = vM(this) && this || {}, e = {}, n = (r, i) => { const s = t && yM(e, i) || i; Sm(e[s]) && Sm(r) ? e[s] = zb(e[s], r) : Sm(r) ? e[s] = zb({}, r) : Eu(r) ? e[s] = r.slice() : e[s] = r }; for (let r = 0, i = arguments.length; r < i; r++)arguments[r] && ph(arguments[r], n); return e } const pU = (t, e, n, { allOwnKeys: r } = {}) => (ph(e, (i, s) => { n && xi(i) ? t[s] = hM(i, n) : t[s] = i }, { allOwnKeys: r }), t), mU = t => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), gU = (t, e, n, r) => { t.prototype = Object.create(e.prototype, r), t.prototype.constructor = t, Object.defineProperty(t, "super", { value: e.prototype }), n && Object.assign(t.prototype, n) }, yU = (t, e, n, r) => { let i, s, a; const l = {}; if (e = e || {}, t == null) return e; do { for (i = Object.getOwnPropertyNames(t), s = i.length; s-- > 0;)a = i[s], (!r || r(a, t, e)) && !l[a] && (e[a] = t[a], l[a] = !0); t = n !== !1 && Iw(t) } while (t && (!n || n(t, e)) && t !== Object.prototype); return e }, vU = (t, e, n) => { t = String(t), (n === void 0 || n > t.length) && (n = t.length), n -= e.length; const r = t.indexOf(e, n); return r !== -1 && r === n }, xU = t => { if (!t) return null; if (Eu(t)) return t; let e = t.length; if (!gM(e)) return null; const n = new Array(e); for (; e-- > 0;)n[e] = t[e]; return n }, bU = (t => e => t && e instanceof t)(typeof Uint8Array < "u" && Iw(Uint8Array)), wU = (t, e) => { const r = (t && t[gy]).call(t); let i; for (; (i = r.next()) && !i.done;) { const s = i.value; e.call(t, s[0], s[1]) } }, SU = (t, e) => { let n; const r = []; for (; (n = t.exec(e)) !== null;)r.push(n); return r }, CU = Ms("HTMLFormElement"), TU = t => t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (n, r, i) { return r.toUpperCase() + i }), jE = (({ hasOwnProperty: t }) => (e, n) => t.call(e, n))(Object.prototype), NU = Ms("RegExp"), xM = (t, e) => { const n = Object.getOwnPropertyDescriptors(t), r = {}; ph(n, (i, s) => { let a; (a = e(i, s, t)) !== !1 && (r[s] = a || i) }), Object.defineProperties(t, r) }, jU = t => { xM(t, (e, n) => { if (xi(t) && ["arguments", "caller", "callee"].indexOf(n) !== -1) return !1; const r = t[n]; if (xi(r)) { if (e.enumerable = !1, "writable" in e) { e.writable = !1; return } e.set || (e.set = () => { throw Error("Can not rewrite read-only method '" + n + "'") }) } }) }, EU = (t, e) => { const n = {}, r = i => { i.forEach(s => { n[s] = !0 }) }; return Eu(t) ? r(t) : r(String(t).split(e)), n }, AU = () => { }, kU = (t, e) => t != null && Number.isFinite(t = +t) ? t : e; function OU(t) { return !!(t && xi(t.append) && t[pM] === "FormData" && t[gy]) } const MU = t => { const e = new Array(10), n = (r, i) => { if (xy(r)) { if (e.indexOf(r) >= 0) return; if (!("toJSON" in r)) { e[i] = r; const s = Eu(r) ? [] : {}; return ph(r, (a, l) => { const u = n(a, i + 1); !_f(u) && (s[l] = u) }), e[i] = void 0, s } } return r }; return n(t, 0) }, DU = Ms("AsyncFunction"), RU = t => t && (xy(t) || xi(t)) && xi(t.then) && xi(t.catch), bM = ((t, e) => t ? setImmediate : e ? ((n, r) => (Ol.addEventListener("message", ({ source: i, data: s }) => { i === Ol && s === n && r.length && r.shift()() }, !1), i => { r.push(i), Ol.postMessage(n, "*") }))(`axios@${Math.random()}`, []) : n => setTimeout(n))(typeof setImmediate == "function", xi(Ol.postMessage)), _U = typeof queueMicrotask < "u" ? queueMicrotask.bind(Ol) : typeof process < "u" && process.nextTick || bM, LU = t => t != null && xi(t[gy]), ke = { isArray: Eu, isArrayBuffer: mM, isBuffer: J$, isFormData: oU, isArrayBufferView: Z$, isString: eU, isNumber: gM, isBoolean: tU, isObject: xy, isPlainObject: Sm, isReadableStream: cU, isRequest: uU, isResponse: dU, isHeaders: fU, isUndefined: _f, isDate: nU, isFile: rU, isBlob: iU, isRegExp: NU, isFunction: xi, isStream: aU, isURLSearchParams: lU, isTypedArray: bU, isFileList: sU, forEach: ph, merge: zb, extend: pU, trim: hU, stripBOM: mU, inherits: gU, toFlatObject: yU, kindOf: yy, kindOfTest: Ms, endsWith: vU, toArray: xU, forEachEntry: wU, matchAll: SU, isHTMLForm: CU, hasOwnProperty: jE, hasOwnProp: jE, reduceDescriptors: xM, freezeMethods: jU, toObjectSet: EU, toCamelCase: TU, noop: AU, toFiniteNumber: kU, findKey: yM, global: Ol, isContextDefined: vM, isSpecCompliantForm: OU, toJSONObject: MU, isAsyncFn: DU, isThenable: RU, setImmediate: bM, asap: _U, isIterable: LU }; function Ft(t, e, n, r, i) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), n && (this.config = n), r && (this.request = r), i && (this.response = i, this.status = i.status ? i.status : null) } ke.inherits(Ft, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: ke.toJSONObject(this.config), code: this.code, status: this.status } } }); const wM = Ft.prototype, SM = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(t => { SM[t] = { value: t } }); Object.defineProperties(Ft, SM); Object.defineProperty(wM, "isAxiosError", { value: !0 }); Ft.from = (t, e, n, r, i, s) => { const a = Object.create(wM); return ke.toFlatObject(t, a, function (u) { return u !== Error.prototype }, l => l !== "isAxiosError"), Ft.call(a, t.message, e, n, r, i), a.cause = t, a.name = t.name, s && Object.assign(a, s), a }; const PU = null; function Ib(t) { return ke.isPlainObject(t) || ke.isArray(t) } function CM(t) { return ke.endsWith(t, "[]") ? t.slice(0, -2) : t } function EE(t, e, n) { return t ? t.concat(e).map(function (i, s) { return i = CM(i), !n && s ? "[" + i + "]" : i }).join(n ? "." : "") : e } function zU(t) { return ke.isArray(t) && !t.some(Ib) } const IU = ke.toFlatObject(ke, {}, null, function (e) { return /^is[A-Z]/.test(e) }); function by(t, e, n) { if (!ke.isObject(t)) throw new TypeError("target must be an object"); e = e || new FormData, n = ke.toFlatObject(n, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (S, C) { return !ke.isUndefined(C[S]) }); const r = n.metaTokens, i = n.visitor || p, s = n.dots, a = n.indexes, u = (n.Blob || typeof Blob < "u" && Blob) && ke.isSpecCompliantForm(e); if (!ke.isFunction(i)) throw new TypeError("visitor must be a function"); function f(b) { if (b === null) return ""; if (ke.isDate(b)) return b.toISOString(); if (ke.isBoolean(b)) return b.toString(); if (!u && ke.isBlob(b)) throw new Ft("Blob is not supported. Use a Buffer instead."); return ke.isArrayBuffer(b) || ke.isTypedArray(b) ? u && typeof Blob == "function" ? new Blob([b]) : Buffer.from(b) : b } function p(b, S, C) { let T = b; if (b && !C && typeof b == "object") { if (ke.endsWith(S, "{}")) S = r ? S : S.slice(0, -2), b = JSON.stringify(b); else if (ke.isArray(b) && zU(b) || (ke.isFileList(b) || ke.endsWith(S, "[]")) && (T = ke.toArray(b))) return S = CM(S), T.forEach(function (M, O) { !(ke.isUndefined(M) || M === null) && e.append(a === !0 ? EE([S], O, s) : a === null ? S : S + "[]", f(M)) }), !1 } return Ib(b) ? !0 : (e.append(EE(C, S, s), f(b)), !1) } const g = [], y = Object.assign(IU, { defaultVisitor: p, convertValue: f, isVisitable: Ib }); function v(b, S) { if (!ke.isUndefined(b)) { if (g.indexOf(b) !== -1) throw Error("Circular reference detected in " + S.join(".")); g.push(b), ke.forEach(b, function (T, A) { (!(ke.isUndefined(T) || T === null) && i.call(e, T, ke.isString(A) ? A.trim() : A, S, y)) === !0 && v(T, S ? S.concat(A) : [A]) }), g.pop() } } if (!ke.isObject(t)) throw new TypeError("data must be an object"); return v(t), e } function AE(t) { const e = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function (r) { return e[r] }) } function Fw(t, e) { this._pairs = [], t && by(t, this, e) } const TM = Fw.prototype; TM.append = function (e, n) { this._pairs.push([e, n]) }; TM.toString = function (e) { const n = e ? function (r) { return e.call(this, r, AE) } : AE; return this._pairs.map(function (i) { return n(i[0]) + "=" + n(i[1]) }, "").join("&") }; function FU(t) { return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } function NM(t, e, n) { if (!e) return t; const r = n && n.encode || FU; ke.isFunction(n) && (n = { serialize: n }); const i = n && n.serialize; let s; if (i ? s = i(e, n) : s = ke.isURLSearchParams(e) ? e.toString() : new Fw(e, n).toString(r), s) { const a = t.indexOf("#"); a !== -1 && (t = t.slice(0, a)), t += (t.indexOf("?") === -1 ? "?" : "&") + s } return t } class kE { constructor() { this.handlers = [] } use(e, n, r) { return this.handlers.push({ fulfilled: e, rejected: n, synchronous: r ? r.synchronous : !1, runWhen: r ? r.runWhen : null }), this.handlers.length - 1 } eject(e) { this.handlers[e] && (this.handlers[e] = null) } clear() { this.handlers && (this.handlers = []) } forEach(e) { ke.forEach(this.handlers, function (r) { r !== null && e(r) }) } } const jM = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, BU = typeof URLSearchParams < "u" ? URLSearchParams : Fw, $U = typeof FormData < "u" ? FormData : null, UU = typeof Blob < "u" ? Blob : null, VU = { isBrowser: !0, classes: { URLSearchParams: BU, FormData: $U, Blob: UU }, protocols: ["http", "https", "file", "blob", "url", "data"] }, Bw = typeof window < "u" && typeof document < "u", Fb = typeof navigator == "object" && navigator || void 0, HU = Bw && (!Fb || ["ReactNative", "NativeScript", "NS"].indexOf(Fb.product) < 0), qU = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function", KU = Bw && window.location.href || "http://localhost", WU = Object.freeze(Object.defineProperty({ __proto__: null, hasBrowserEnv: Bw, hasStandardBrowserEnv: HU, hasStandardBrowserWebWorkerEnv: qU, navigator: Fb, origin: KU }, Symbol.toStringTag, { value: "Module" })), Wr = { ...WU, ...VU }; function YU(t, e) { return by(t, new Wr.classes.URLSearchParams, Object.assign({ visitor: function (n, r, i, s) { return Wr.isNode && ke.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments) } }, e)) } function GU(t) { return ke.matchAll(/\w+|\[(\w*)]/g, t).map(e => e[0] === "[]" ? "" : e[1] || e[0]) } function XU(t) { const e = {}, n = Object.keys(t); let r; const i = n.length; let s; for (r = 0; r < i; r++)s = n[r], e[s] = t[s]; return e } function EM(t) { function e(n, r, i, s) { let a = n[s++]; if (a === "__proto__") return !0; const l = Number.isFinite(+a), u = s >= n.length; return a = !a && ke.isArray(i) ? i.length : a, u ? (ke.hasOwnProp(i, a) ? i[a] = [i[a], r] : i[a] = r, !l) : ((!i[a] || !ke.isObject(i[a])) && (i[a] = []), e(n, r, i[a], s) && ke.isArray(i[a]) && (i[a] = XU(i[a])), !l) } if (ke.isFormData(t) && ke.isFunction(t.entries)) { const n = {}; return ke.forEachEntry(t, (r, i) => { e(GU(r), i, n, 0) }), n } return null } function QU(t, e, n) { if (ke.isString(t)) try { return (e || JSON.parse)(t), ke.trim(t) } catch (r) { if (r.name !== "SyntaxError") throw r } return (n || JSON.stringify)(t) } const mh = { transitional: jM, adapter: ["xhr", "http", "fetch"], transformRequest: [function (e, n) { const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, s = ke.isObject(e); if (s && ke.isHTMLForm(e) && (e = new FormData(e)), ke.isFormData(e)) return i ? JSON.stringify(EM(e)) : e; if (ke.isArrayBuffer(e) || ke.isBuffer(e) || ke.isStream(e) || ke.isFile(e) || ke.isBlob(e) || ke.isReadableStream(e)) return e; if (ke.isArrayBufferView(e)) return e.buffer; if (ke.isURLSearchParams(e)) return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString(); let l; if (s) { if (r.indexOf("application/x-www-form-urlencoded") > -1) return YU(e, this.formSerializer).toString(); if ((l = ke.isFileList(e)) || r.indexOf("multipart/form-data") > -1) { const u = this.env && this.env.FormData; return by(l ? { "files[]": e } : e, u && new u, this.formSerializer) } } return s || i ? (n.setContentType("application/json", !1), QU(e)) : e }], transformResponse: [function (e) { const n = this.transitional || mh.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json"; if (ke.isResponse(e) || ke.isReadableStream(e)) return e; if (e && ke.isString(e) && (r && !this.responseType || i)) { const a = !(n && n.silentJSONParsing) && i; try { return JSON.parse(e) } catch (l) { if (a) throw l.name === "SyntaxError" ? Ft.from(l, Ft.ERR_BAD_RESPONSE, this, null, this.response) : l } } return e }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: Wr.classes.FormData, Blob: Wr.classes.Blob }, validateStatus: function (e) { return e >= 200 && e < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; ke.forEach(["delete", "get", "head", "post", "put", "patch"], t => { mh.headers[t] = {} }); const JU = ke.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), ZU = t => {
    const e = {}; let n, r, i; return t && t.split(`
`).forEach(function (a) { i = a.indexOf(":"), n = a.substring(0, i).trim().toLowerCase(), r = a.substring(i + 1).trim(), !(!n || e[n] && JU[n]) && (n === "set-cookie" ? e[n] ? e[n].push(r) : e[n] = [r] : e[n] = e[n] ? e[n] + ", " + r : r) }), e
  }, OE = Symbol("internals"); function Bd(t) { return t && String(t).trim().toLowerCase() } function Cm(t) { return t === !1 || t == null ? t : ke.isArray(t) ? t.map(Cm) : String(t) } function eV(t) { const e = Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let r; for (; r = n.exec(t);)e[r[1]] = r[2]; return e } const tV = t => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim()); function mx(t, e, n, r, i) { if (ke.isFunction(r)) return r.call(this, e, n); if (i && (e = n), !!ke.isString(e)) { if (ke.isString(r)) return e.indexOf(r) !== -1; if (ke.isRegExp(r)) return r.test(e) } } function nV(t) { return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, n, r) => n.toUpperCase() + r) } function rV(t, e) { const n = ke.toCamelCase(" " + e);["get", "set", "has"].forEach(r => { Object.defineProperty(t, r + n, { value: function (i, s, a) { return this[r].call(this, e, i, s, a) }, configurable: !0 }) }) } let bi = class {
    constructor(e) { e && this.set(e) } set(e, n, r) { const i = this; function s(l, u, f) { const p = Bd(u); if (!p) throw new Error("header name must be a non-empty string"); const g = ke.findKey(i, p); (!g || i[g] === void 0 || f === !0 || f === void 0 && i[g] !== !1) && (i[g || u] = Cm(l)) } const a = (l, u) => ke.forEach(l, (f, p) => s(f, p, u)); if (ke.isPlainObject(e) || e instanceof this.constructor) a(e, n); else if (ke.isString(e) && (e = e.trim()) && !tV(e)) a(ZU(e), n); else if (ke.isObject(e) && ke.isIterable(e)) { let l = {}, u, f; for (const p of e) { if (!ke.isArray(p)) throw TypeError("Object iterator must return a key-value pair"); l[f = p[0]] = (u = l[f]) ? ke.isArray(u) ? [...u, p[1]] : [u, p[1]] : p[1] } a(l, n) } else e != null && s(n, e, r); return this } get(e, n) { if (e = Bd(e), e) { const r = ke.findKey(this, e); if (r) { const i = this[r]; if (!n) return i; if (n === !0) return eV(i); if (ke.isFunction(n)) return n.call(this, i, r); if (ke.isRegExp(n)) return n.exec(i); throw new TypeError("parser must be boolean|regexp|function") } } } has(e, n) { if (e = Bd(e), e) { const r = ke.findKey(this, e); return !!(r && this[r] !== void 0 && (!n || mx(this, this[r], r, n))) } return !1 } delete(e, n) { const r = this; let i = !1; function s(a) { if (a = Bd(a), a) { const l = ke.findKey(r, a); l && (!n || mx(r, r[l], l, n)) && (delete r[l], i = !0) } } return ke.isArray(e) ? e.forEach(s) : s(e), i } clear(e) { const n = Object.keys(this); let r = n.length, i = !1; for (; r--;) { const s = n[r]; (!e || mx(this, this[s], s, e, !0)) && (delete this[s], i = !0) } return i } normalize(e) { const n = this, r = {}; return ke.forEach(this, (i, s) => { const a = ke.findKey(r, s); if (a) { n[a] = Cm(i), delete n[s]; return } const l = e ? nV(s) : String(s).trim(); l !== s && delete n[s], n[l] = Cm(i), r[l] = !0 }), this } concat(...e) { return this.constructor.concat(this, ...e) } toJSON(e) { const n = Object.create(null); return ke.forEach(this, (r, i) => { r != null && r !== !1 && (n[i] = e && ke.isArray(r) ? r.join(", ") : r) }), n } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() {
      return Object.entries(this.toJSON()).map(([e, n]) => e + ": " + n).join(`
`)
    } getSetCookie() { return this.get("set-cookie") || [] } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(e) { return e instanceof this ? e : new this(e) } static concat(e, ...n) { const r = new this(e); return n.forEach(i => r.set(i)), r } static accessor(e) { const r = (this[OE] = this[OE] = { accessors: {} }).accessors, i = this.prototype; function s(a) { const l = Bd(a); r[l] || (rV(i, a), r[l] = !0) } return ke.isArray(e) ? e.forEach(s) : s(e), this }
  }; bi.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]); ke.reduceDescriptors(bi.prototype, ({ value: t }, e) => { let n = e[0].toUpperCase() + e.slice(1); return { get: () => t, set(r) { this[n] = r } } }); ke.freezeMethods(bi); function gx(t, e) { const n = this || mh, r = e || n, i = bi.from(r.headers); let s = r.data; return ke.forEach(t, function (l) { s = l.call(n, s, i.normalize(), e ? e.status : void 0) }), i.normalize(), s } function AM(t) { return !!(t && t.__CANCEL__) } function Au(t, e, n) { Ft.call(this, t ?? "canceled", Ft.ERR_CANCELED, e, n), this.name = "CanceledError" } ke.inherits(Au, Ft, { __CANCEL__: !0 }); function kM(t, e, n) { const r = n.config.validateStatus; !n.status || !r || r(n.status) ? t(n) : e(new Ft("Request failed with status code " + n.status, [Ft.ERR_BAD_REQUEST, Ft.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n)) } function iV(t) { const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t); return e && e[1] || "" } function sV(t, e) { t = t || 10; const n = new Array(t), r = new Array(t); let i = 0, s = 0, a; return e = e !== void 0 ? e : 1e3, function (u) { const f = Date.now(), p = r[s]; a || (a = f), n[i] = u, r[i] = f; let g = s, y = 0; for (; g !== i;)y += n[g++], g = g % t; if (i = (i + 1) % t, i === s && (s = (s + 1) % t), f - a < e) return; const v = p && f - p; return v ? Math.round(y * 1e3 / v) : void 0 } } function aV(t, e) { let n = 0, r = 1e3 / e, i, s; const a = (f, p = Date.now()) => { n = p, i = null, s && (clearTimeout(s), s = null), t.apply(null, f) }; return [(...f) => { const p = Date.now(), g = p - n; g >= r ? a(f, p) : (i = f, s || (s = setTimeout(() => { s = null, a(i) }, r - g))) }, () => i && a(i)] } const Ym = (t, e, n = 3) => { let r = 0; const i = sV(50, 250); return aV(s => { const a = s.loaded, l = s.lengthComputable ? s.total : void 0, u = a - r, f = i(u), p = a <= l; r = a; const g = { loaded: a, total: l, progress: l ? a / l : void 0, bytes: u, rate: f || void 0, estimated: f && l && p ? (l - a) / f : void 0, event: s, lengthComputable: l != null, [e ? "download" : "upload"]: !0 }; t(g) }, n) }, ME = (t, e) => { const n = t != null; return [r => e[0]({ lengthComputable: n, total: t, loaded: r }), e[1]] }, DE = t => (...e) => ke.asap(() => t(...e)), oV = Wr.hasStandardBrowserEnv ? ((t, e) => n => (n = new URL(n, Wr.origin), t.protocol === n.protocol && t.host === n.host && (e || t.port === n.port)))(new URL(Wr.origin), Wr.navigator && /(msie|trident)/i.test(Wr.navigator.userAgent)) : () => !0, lV = Wr.hasStandardBrowserEnv ? { write(t, e, n, r, i, s) { const a = [t + "=" + encodeURIComponent(e)]; ke.isNumber(n) && a.push("expires=" + new Date(n).toGMTString()), ke.isString(r) && a.push("path=" + r), ke.isString(i) && a.push("domain=" + i), s === !0 && a.push("secure"), document.cookie = a.join("; ") }, read(t) { const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)")); return e ? decodeURIComponent(e[3]) : null }, remove(t) { this.write(t, "", Date.now() - 864e5) } } : { write() { }, read() { return null }, remove() { } }; function cV(t) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t) } function uV(t, e) { return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t } function OM(t, e, n) { let r = !cV(e); return t && (r || n == !1) ? uV(t, e) : e } const RE = t => t instanceof bi ? { ...t } : t; function Xl(t, e) { e = e || {}; const n = {}; function r(f, p, g, y) { return ke.isPlainObject(f) && ke.isPlainObject(p) ? ke.merge.call({ caseless: y }, f, p) : ke.isPlainObject(p) ? ke.merge({}, p) : ke.isArray(p) ? p.slice() : p } function i(f, p, g, y) { if (ke.isUndefined(p)) { if (!ke.isUndefined(f)) return r(void 0, f, g, y) } else return r(f, p, g, y) } function s(f, p) { if (!ke.isUndefined(p)) return r(void 0, p) } function a(f, p) { if (ke.isUndefined(p)) { if (!ke.isUndefined(f)) return r(void 0, f) } else return r(void 0, p) } function l(f, p, g) { if (g in e) return r(f, p); if (g in t) return r(void 0, f) } const u = { url: s, method: s, data: s, baseURL: a, transformRequest: a, transformResponse: a, paramsSerializer: a, timeout: a, timeoutMessage: a, withCredentials: a, withXSRFToken: a, adapter: a, responseType: a, xsrfCookieName: a, xsrfHeaderName: a, onUploadProgress: a, onDownloadProgress: a, decompress: a, maxContentLength: a, maxBodyLength: a, beforeRedirect: a, transport: a, httpAgent: a, httpsAgent: a, cancelToken: a, socketPath: a, responseEncoding: a, validateStatus: l, headers: (f, p, g) => i(RE(f), RE(p), g, !0) }; return ke.forEach(Object.keys(Object.assign({}, t, e)), function (p) { const g = u[p] || i, y = g(t[p], e[p], p); ke.isUndefined(y) && g !== l || (n[p] = y) }), n } const MM = t => { const e = Xl({}, t); let { data: n, withXSRFToken: r, xsrfHeaderName: i, xsrfCookieName: s, headers: a, auth: l } = e; e.headers = a = bi.from(a), e.url = NM(OM(e.baseURL, e.url, e.allowAbsoluteUrls), t.params, t.paramsSerializer), l && a.set("Authorization", "Basic " + btoa((l.username || "") + ":" + (l.password ? unescape(encodeURIComponent(l.password)) : ""))); let u; if (ke.isFormData(n)) { if (Wr.hasStandardBrowserEnv || Wr.hasStandardBrowserWebWorkerEnv) a.setContentType(void 0); else if ((u = a.getContentType()) !== !1) { const [f, ...p] = u ? u.split(";").map(g => g.trim()).filter(Boolean) : []; a.setContentType([f || "multipart/form-data", ...p].join("; ")) } } if (Wr.hasStandardBrowserEnv && (r && ke.isFunction(r) && (r = r(e)), r || r !== !1 && oV(e.url))) { const f = i && s && lV.read(s); f && a.set(i, f) } return e }, dV = typeof XMLHttpRequest < "u", fV = dV && function (t) { return new Promise(function (n, r) { const i = MM(t); let s = i.data; const a = bi.from(i.headers).normalize(); let { responseType: l, onUploadProgress: u, onDownloadProgress: f } = i, p, g, y, v, b; function S() { v && v(), b && b(), i.cancelToken && i.cancelToken.unsubscribe(p), i.signal && i.signal.removeEventListener("abort", p) } let C = new XMLHttpRequest; C.open(i.method.toUpperCase(), i.url, !0), C.timeout = i.timeout; function T() { if (!C) return; const M = bi.from("getAllResponseHeaders" in C && C.getAllResponseHeaders()), E = { data: !l || l === "text" || l === "json" ? C.responseText : C.response, status: C.status, statusText: C.statusText, headers: M, config: t, request: C }; kM(function (z) { n(z), S() }, function (z) { r(z), S() }, E), C = null } "onloadend" in C ? C.onloadend = T : C.onreadystatechange = function () { !C || C.readyState !== 4 || C.status === 0 && !(C.responseURL && C.responseURL.indexOf("file:") === 0) || setTimeout(T) }, C.onabort = function () { C && (r(new Ft("Request aborted", Ft.ECONNABORTED, t, C)), C = null) }, C.onerror = function () { r(new Ft("Network Error", Ft.ERR_NETWORK, t, C)), C = null }, C.ontimeout = function () { let O = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded"; const E = i.transitional || jM; i.timeoutErrorMessage && (O = i.timeoutErrorMessage), r(new Ft(O, E.clarifyTimeoutError ? Ft.ETIMEDOUT : Ft.ECONNABORTED, t, C)), C = null }, s === void 0 && a.setContentType(null), "setRequestHeader" in C && ke.forEach(a.toJSON(), function (O, E) { C.setRequestHeader(E, O) }), ke.isUndefined(i.withCredentials) || (C.withCredentials = !!i.withCredentials), l && l !== "json" && (C.responseType = i.responseType), f && ([y, b] = Ym(f, !0), C.addEventListener("progress", y)), u && C.upload && ([g, v] = Ym(u), C.upload.addEventListener("progress", g), C.upload.addEventListener("loadend", v)), (i.cancelToken || i.signal) && (p = M => { C && (r(!M || M.type ? new Au(null, t, C) : M), C.abort(), C = null) }, i.cancelToken && i.cancelToken.subscribe(p), i.signal && (i.signal.aborted ? p() : i.signal.addEventListener("abort", p))); const A = iV(i.url); if (A && Wr.protocols.indexOf(A) === -1) { r(new Ft("Unsupported protocol " + A + ":", Ft.ERR_BAD_REQUEST, t)); return } C.send(s || null) }) }, hV = (t, e) => { const { length: n } = t = t ? t.filter(Boolean) : []; if (e || n) { let r = new AbortController, i; const s = function (f) { if (!i) { i = !0, l(); const p = f instanceof Error ? f : this.reason; r.abort(p instanceof Ft ? p : new Au(p instanceof Error ? p.message : p)) } }; let a = e && setTimeout(() => { a = null, s(new Ft(`timeout ${e} of ms exceeded`, Ft.ETIMEDOUT)) }, e); const l = () => { t && (a && clearTimeout(a), a = null, t.forEach(f => { f.unsubscribe ? f.unsubscribe(s) : f.removeEventListener("abort", s) }), t = null) }; t.forEach(f => f.addEventListener("abort", s)); const { signal: u } = r; return u.unsubscribe = () => ke.asap(l), u } }, pV = function* (t, e) { let n = t.byteLength; if (n < e) { yield t; return } let r = 0, i; for (; r < n;)i = r + e, yield t.slice(r, i), r = i }, mV = async function* (t, e) { for await (const n of gV(t)) yield* pV(n, e) }, gV = async function* (t) { if (t[Symbol.asyncIterator]) { yield* t; return } const e = t.getReader(); try { for (; ;) { const { done: n, value: r } = await e.read(); if (n) break; yield r } } finally { await e.cancel() } }, _E = (t, e, n, r) => { const i = mV(t, e); let s = 0, a, l = u => { a || (a = !0, r && r(u)) }; return new ReadableStream({ async pull(u) { try { const { done: f, value: p } = await i.next(); if (f) { l(), u.close(); return } let g = p.byteLength; if (n) { let y = s += g; n(y) } u.enqueue(new Uint8Array(p)) } catch (f) { throw l(f), f } }, cancel(u) { return l(u), i.return() } }, { highWaterMark: 2 }) }, wy = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", DM = wy && typeof ReadableStream == "function", yV = wy && (typeof TextEncoder == "function" ? (t => e => t.encode(e))(new TextEncoder) : async t => new Uint8Array(await new Response(t).arrayBuffer())), RM = (t, ...e) => { try { return !!t(...e) } catch { return !1 } }, vV = DM && RM(() => { let t = !1; const e = new Request(Wr.origin, { body: new ReadableStream, method: "POST", get duplex() { return t = !0, "half" } }).headers.has("Content-Type"); return t && !e }), LE = 64 * 1024, Bb = DM && RM(() => ke.isReadableStream(new Response("").body)), Gm = { stream: Bb && (t => t.body) }; wy && (t => { ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(e => { !Gm[e] && (Gm[e] = ke.isFunction(t[e]) ? n => n[e]() : (n, r) => { throw new Ft(`Response type '${e}' is not supported`, Ft.ERR_NOT_SUPPORT, r) }) }) })(new Response); const xV = async t => { if (t == null) return 0; if (ke.isBlob(t)) return t.size; if (ke.isSpecCompliantForm(t)) return (await new Request(Wr.origin, { method: "POST", body: t }).arrayBuffer()).byteLength; if (ke.isArrayBufferView(t) || ke.isArrayBuffer(t)) return t.byteLength; if (ke.isURLSearchParams(t) && (t = t + ""), ke.isString(t)) return (await yV(t)).byteLength }, bV = async (t, e) => { const n = ke.toFiniteNumber(t.getContentLength()); return n ?? xV(e) }, wV = wy && (async t => { let { url: e, method: n, data: r, signal: i, cancelToken: s, timeout: a, onDownloadProgress: l, onUploadProgress: u, responseType: f, headers: p, withCredentials: g = "same-origin", fetchOptions: y } = MM(t); f = f ? (f + "").toLowerCase() : "text"; let v = hV([i, s && s.toAbortSignal()], a), b; const S = v && v.unsubscribe && (() => { v.unsubscribe() }); let C; try { if (u && vV && n !== "get" && n !== "head" && (C = await bV(p, r)) !== 0) { let E = new Request(e, { method: "POST", body: r, duplex: "half" }), k; if (ke.isFormData(r) && (k = E.headers.get("content-type")) && p.setContentType(k), E.body) { const [z, V] = ME(C, Ym(DE(u))); r = _E(E.body, LE, z, V) } } ke.isString(g) || (g = g ? "include" : "omit"); const T = "credentials" in Request.prototype; b = new Request(e, { ...y, signal: v, method: n.toUpperCase(), headers: p.normalize().toJSON(), body: r, duplex: "half", credentials: T ? g : void 0 }); let A = await fetch(b, y); const M = Bb && (f === "stream" || f === "response"); if (Bb && (l || M && S)) { const E = {};["status", "statusText", "headers"].forEach(q => { E[q] = A[q] }); const k = ke.toFiniteNumber(A.headers.get("content-length")), [z, V] = l && ME(k, Ym(DE(l), !0)) || []; A = new Response(_E(A.body, LE, z, () => { V && V(), S && S() }), E) } f = f || "text"; let O = await Gm[ke.findKey(Gm, f) || "text"](A, t); return !M && S && S(), await new Promise((E, k) => { kM(E, k, { data: O, headers: bi.from(A.headers), status: A.status, statusText: A.statusText, config: t, request: b }) }) } catch (T) { throw S && S(), T && T.name === "TypeError" && /Load failed|fetch/i.test(T.message) ? Object.assign(new Ft("Network Error", Ft.ERR_NETWORK, t, b), { cause: T.cause || T }) : Ft.from(T, T && T.code, t, b) } }), $b = { http: PU, xhr: fV, fetch: wV }; ke.forEach($b, (t, e) => { if (t) { try { Object.defineProperty(t, "name", { value: e }) } catch { } Object.defineProperty(t, "adapterName", { value: e }) } }); const PE = t => `- ${t}`, SV = t => ke.isFunction(t) || t === null || t === !1, _M = {
    getAdapter: t => {
      t = ke.isArray(t) ? t : [t]; const { length: e } = t; let n, r; const i = {}; for (let s = 0; s < e; s++) { n = t[s]; let a; if (r = n, !SV(n) && (r = $b[(a = String(n)).toLowerCase()], r === void 0)) throw new Ft(`Unknown adapter '${a}'`); if (r) break; i[a || "#" + s] = r } if (!r) {
        const s = Object.entries(i).map(([l, u]) => `adapter ${l} ` + (u === !1 ? "is not supported by the environment" : "is not available in the build")); let a = e ? s.length > 1 ? `since :
`+ s.map(PE).join(`
`) : " " + PE(s[0]) : "as no adapter specified"; throw new Ft("There is no suitable adapter to dispatch the request " + a, "ERR_NOT_SUPPORT")
      } return r
    }, adapters: $b
  }; function yx(t) { if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted) throw new Au(null, t) } function zE(t) { return yx(t), t.headers = bi.from(t.headers), t.data = gx.call(t, t.transformRequest), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), _M.getAdapter(t.adapter || mh.adapter)(t).then(function (r) { return yx(t), r.data = gx.call(t, t.transformResponse, r), r.headers = bi.from(r.headers), r }, function (r) { return AM(r) || (yx(t), r && r.response && (r.response.data = gx.call(t, t.transformResponse, r.response), r.response.headers = bi.from(r.response.headers))), Promise.reject(r) }) } const LM = "1.10.0", Sy = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => { Sy[t] = function (r) { return typeof r === t || "a" + (e < 1 ? "n " : " ") + t } }); const IE = {}; Sy.transitional = function (e, n, r) { function i(s, a) { return "[Axios v" + LM + "] Transitional option '" + s + "'" + a + (r ? ". " + r : "") } return (s, a, l) => { if (e === !1) throw new Ft(i(a, " has been removed" + (n ? " in " + n : "")), Ft.ERR_DEPRECATED); return n && !IE[a] && (IE[a] = !0, console.warn(i(a, " has been deprecated since v" + n + " and will be removed in the near future"))), e ? e(s, a, l) : !0 } }; Sy.spelling = function (e) { return (n, r) => (console.warn(`${r} is likely a misspelling of ${e}`), !0) }; function CV(t, e, n) { if (typeof t != "object") throw new Ft("options must be an object", Ft.ERR_BAD_OPTION_VALUE); const r = Object.keys(t); let i = r.length; for (; i-- > 0;) { const s = r[i], a = e[s]; if (a) { const l = t[s], u = l === void 0 || a(l, s, t); if (u !== !0) throw new Ft("option " + s + " must be " + u, Ft.ERR_BAD_OPTION_VALUE); continue } if (n !== !0) throw new Ft("Unknown option " + s, Ft.ERR_BAD_OPTION) } } const Tm = { assertOptions: CV, validators: Sy }, $s = Tm.validators; let Fl = class {
    constructor(e) { this.defaults = e || {}, this.interceptors = { request: new kE, response: new kE } } async request(e, n) {
      try { return await this._request(e, n) } catch (r) {
        if (r instanceof Error) {
          let i = {}; Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error; const s = i.stack ? i.stack.replace(/^.+\n/, "") : ""; try {
            r.stack ? s && !String(r.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (r.stack += `
`+ s) : r.stack = s
          } catch { }
        } throw r
      }
    } _request(e, n) { typeof e == "string" ? (n = n || {}, n.url = e) : n = e || {}, n = Xl(this.defaults, n); const { transitional: r, paramsSerializer: i, headers: s } = n; r !== void 0 && Tm.assertOptions(r, { silentJSONParsing: $s.transitional($s.boolean), forcedJSONParsing: $s.transitional($s.boolean), clarifyTimeoutError: $s.transitional($s.boolean) }, !1), i != null && (ke.isFunction(i) ? n.paramsSerializer = { serialize: i } : Tm.assertOptions(i, { encode: $s.function, serialize: $s.function }, !0)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0), Tm.assertOptions(n, { baseUrl: $s.spelling("baseURL"), withXsrfToken: $s.spelling("withXSRFToken") }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase(); let a = s && ke.merge(s.common, s[n.method]); s && ke.forEach(["delete", "get", "head", "post", "put", "patch", "common"], b => { delete s[b] }), n.headers = bi.concat(a, s); const l = []; let u = !0; this.interceptors.request.forEach(function (S) { typeof S.runWhen == "function" && S.runWhen(n) === !1 || (u = u && S.synchronous, l.unshift(S.fulfilled, S.rejected)) }); const f = []; this.interceptors.response.forEach(function (S) { f.push(S.fulfilled, S.rejected) }); let p, g = 0, y; if (!u) { const b = [zE.bind(this), void 0]; for (b.unshift.apply(b, l), b.push.apply(b, f), y = b.length, p = Promise.resolve(n); g < y;)p = p.then(b[g++], b[g++]); return p } y = l.length; let v = n; for (g = 0; g < y;) { const b = l[g++], S = l[g++]; try { v = b(v) } catch (C) { S.call(this, C); break } } try { p = zE.call(this, v) } catch (b) { return Promise.reject(b) } for (g = 0, y = f.length; g < y;)p = p.then(f[g++], f[g++]); return p } getUri(e) { e = Xl(this.defaults, e); const n = OM(e.baseURL, e.url, e.allowAbsoluteUrls); return NM(n, e.params, e.paramsSerializer) }
  }; ke.forEach(["delete", "get", "head", "options"], function (e) { Fl.prototype[e] = function (n, r) { return this.request(Xl(r || {}, { method: e, url: n, data: (r || {}).data })) } }); ke.forEach(["post", "put", "patch"], function (e) { function n(r) { return function (s, a, l) { return this.request(Xl(l || {}, { method: e, headers: r ? { "Content-Type": "multipart/form-data" } : {}, url: s, data: a })) } } Fl.prototype[e] = n(), Fl.prototype[e + "Form"] = n(!0) }); let TV = class PM { constructor(e) { if (typeof e != "function") throw new TypeError("executor must be a function."); let n; this.promise = new Promise(function (s) { n = s }); const r = this; this.promise.then(i => { if (!r._listeners) return; let s = r._listeners.length; for (; s-- > 0;)r._listeners[s](i); r._listeners = null }), this.promise.then = i => { let s; const a = new Promise(l => { r.subscribe(l), s = l }).then(i); return a.cancel = function () { r.unsubscribe(s) }, a }, e(function (s, a, l) { r.reason || (r.reason = new Au(s, a, l), n(r.reason)) }) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(e) { if (this.reason) { e(this.reason); return } this._listeners ? this._listeners.push(e) : this._listeners = [e] } unsubscribe(e) { if (!this._listeners) return; const n = this._listeners.indexOf(e); n !== -1 && this._listeners.splice(n, 1) } toAbortSignal() { const e = new AbortController, n = r => { e.abort(r) }; return this.subscribe(n), e.signal.unsubscribe = () => this.unsubscribe(n), e.signal } static source() { let e; return { token: new PM(function (i) { e = i }), cancel: e } } }; function NV(t) { return function (n) { return t.apply(null, n) } } function jV(t) { return ke.isObject(t) && t.isAxiosError === !0 } const Ub = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 }; Object.entries(Ub).forEach(([t, e]) => { Ub[e] = t }); function zM(t) { const e = new Fl(t), n = hM(Fl.prototype.request, e); return ke.extend(n, Fl.prototype, e, { allOwnKeys: !0 }), ke.extend(n, e, null, { allOwnKeys: !0 }), n.create = function (i) { return zM(Xl(t, i)) }, n } const Ve = zM(mh); Ve.Axios = Fl; Ve.CanceledError = Au; Ve.CancelToken = TV; Ve.isCancel = AM; Ve.VERSION = LM; Ve.toFormData = by; Ve.AxiosError = Ft; Ve.Cancel = Ve.CanceledError; Ve.all = function (e) { return Promise.all(e) }; Ve.spread = NV; Ve.isAxiosError = jV; Ve.mergeConfig = Xl; Ve.AxiosHeaders = bi; Ve.formToJSON = t => EM(ke.isHTMLForm(t) ? new FormData(t) : t); Ve.getAdapter = _M.getAdapter; Ve.HttpStatusCode = Ub; Ve.default = Ve; const { Axios: jce, AxiosError: Ece, CanceledError: Ace, isCancel: kce, CancelToken: Oce, VERSION: Mce, all: Dce, Cancel: Rce, isAxiosError: _ce, spread: Lce, toFormData: Pce, AxiosHeaders: zce, HttpStatusCode: Ice, formToJSON: Fce, getAdapter: Bce, mergeConfig: $ce } = Ve; function EV() {
    const t = ln(), [e, n] = N.useState(!1); async function r(a) { n(!0); try { let { data: l } = await Ve.post("https://api.nexus.com/api/auth/login", a); n(!1), console.log(l), me.success("logged in successfully", { duration: 2e3 }), localStorage.setItem("userToken", l.data.access_token), t("/") } catch (l) { me.error(l?.response?.data?.message, { duration: 5e3 }), n(!1), console.log(l?.response?.data?.message) } } let i = DO({ email: Ab().email("invalid mail").required("email is required"), password: Ab().min(9, "password must be at least 9 length").required("password is required") }), s = Z9({ initialValues: { email: "", password: "" }, validationSchema: i, onSubmit: r }); return d.jsx(d.Fragment, {
      children: d.jsxs("div", {
        className: "h-screen w-screen bg-white flex flex-col justify-center items-center", children: [d.jsx("img", { className: "lg:w-1/6 w-1/3", src: NO, alt: "logo" }), d.jsxs("div", {
          className: `lg:w-1/3 w-full bg-white text-[#283859] rounded-xl shadow-xl p-8 space-y-5\r
            `, children: [d.jsx("h1", { className: "text-3xl font-bold text-center", children: "Login" }), d.jsxs("form", { className: "flex flex-col gap-5", onSubmit: s.handleSubmit, children: [d.jsxs("div", { className: "relative z-0 w-full group mb-4", children: [d.jsx("input", { type: "email", name: "email", id: "email", onBlur: s.handleBlur, onChange: s.handleChange, className: "block py-2.5 px-0 w-full text-sm text-primary bg-transparent border-0 border-b-2 border-gray-300 appearance-none focus:outline-none focus:ring-0 focus:border-darkTeal peer", placeholder: " " }), d.jsx("label", { htmlFor: "email", className: "peer-focus:font-medium absolute text-sm text-gray-500 dark:text-gray-400 duration-300 transform -translate-y-6 scale-75 top-3 -z-10 origin-[0] peer-focus:start-0 rtl:peer-focus:translate-x-1/4 rtl:peer-focus:left-auto peer-focus:text-darkTeal peer-focus:dark:text-darkTeal peer-placeholder-shown:scale-100 peer-placeholder-shown:translate-y-0 peer-focus:scale-75 peer-focus:-translate-y-6", children: "Email" }), s.errors.email && s.touched.email && d.jsx("div", { className: " text-sm text-red-800 rounded-lg bg-transparent dark:text-red-600 ", role: "alert", children: s.errors.email })] }), d.jsxs("div", { className: "relative z-0 w-full group", children: [d.jsx("input", { type: "password", name: "password", id: "password", onBlur: s.handleBlur, onChange: s.handleChange, className: "block py-2.5 px-0 w-full text-sm text-primary bg-transparent border-0 border-b-2 border-gray-300 appearance-none focus:outline-none focus:ring-0 focus:border-darkTeal peer", placeholder: " " }), d.jsx("label", { htmlFor: "password", className: "peer-focus:font-medium absolute text-sm text-gray-500 dark:text-gray-400 duration-300 transform -translate-y-6 scale-75 top-3 -z-10 origin-[0] peer-focus:start-0 rtl:peer-focus:translate-x-1/4 rtl:peer-focus:left-auto peer-focus:text-darkTeal peer-focus:dark:text-darkTeal peer-placeholder-shown:scale-100 peer-placeholder-shown:translate-y-0 peer-focus:scale-75 peer-focus:-translate-y-6", children: "Password" }), s.errors.password && s.touched.password && d.jsx("div", { className: " text-sm text-red-800 rounded-lg bg-transparent dark:text-red-600", role: "alert", children: s.errors.password })] }), d.jsx("button", { type: "submit", disabled: e, className: "w-full h-12 rounded-xl bg-gradient-to-r from-[#283859] via-[#283859] to-[#a4c2ff] text-white text-xl font-bold hover:shadow-md", style: { transition: "background-position 0.4s ease", backgroundSize: "110%" }, onMouseEnter: a => a.target.style.backgroundPosition = "right", onMouseLeave: a => a.target.style.backgroundPosition = "left", children: e ? d.jsx("div", { className: "animate-spin rounded-full h-5 w-5 border-b-2 border-gray-100 m-auto" }) : "login" })] })]
        })]
      })
    })
  } function yr({ children: t }) { return localStorage.getItem("userToken") ? t : d.jsx(Az, { to: "/login" }) } let $w = N.createContext(!0); function AV(t) { const [e, n] = N.useState(!0); return d.jsx($w.Provider, { value: { sidebarOpen: e, setSidebarOpen: n }, children: t.children }) } var IM = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 }, FE = Pt.createContext && Pt.createContext(IM), kV = ["attr", "size", "title"]; function OV(t, e) { if (t == null) return {}; var n = MV(t, e), r, i; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(t); for (i = 0; i < s.length; i++)r = s[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]) } return n } function MV(t, e) { if (t == null) return {}; var n = {}; for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) { if (e.indexOf(r) >= 0) continue; n[r] = t[r] } return n } function Xm() { return Xm = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, Xm.apply(this, arguments) } function BE(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Qm(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? BE(Object(n), !0).forEach(function (r) { DV(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : BE(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function DV(t, e, n) { return e = RV(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function RV(t) { var e = _V(t, "string"); return typeof e == "symbol" ? e : e + "" } function _V(t, e) { if (typeof t != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (typeof r != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function FM(t) { return t && t.map((e, n) => Pt.createElement(e.tag, Qm({ key: n }, e.attr), FM(e.child))) } function Vt(t) { return e => Pt.createElement(LV, Xm({ attr: Qm({}, t.attr) }, e), FM(t.child)) } function LV(t) { var e = n => { var { attr: r, size: i, title: s } = t, a = OV(t, kV), l = i || n.size || "1em", u; return n.className && (u = n.className), t.className && (u = (u ? u + " " : "") + t.className), Pt.createElement("svg", Xm({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, n.attr, r, a, { className: u, style: Qm(Qm({ color: t.color || n.color }, n.style), t.style), height: l, width: l, xmlns: "http://www.w3.org/2000/svg" }), s && Pt.createElement("title", null, s), t.children) }; return FE !== void 0 ? Pt.createElement(FE.Consumer, null, n => e(n)) : e(IM) } function PV(t) { return Vt({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "M11.28 9.53 8.81 12l2.47 2.47a.749.749 0 0 1-.326 1.275.749.749 0 0 1-.734-.215l-3-3a.75.75 0 0 1 0-1.06l3-3a.749.749 0 0 1 1.275.326.749.749 0 0 1-.215.734Z" }, child: [] }, { tag: "path", attr: { d: "M3.75 2h16.5c.966 0 1.75.784 1.75 1.75v16.5A1.75 1.75 0 0 1 20.25 22H3.75A1.75 1.75 0 0 1 2 20.25V3.75C2 2.784 2.784 2 3.75 2ZM3.5 3.75v16.5c0 .138.112.25.25.25H15v-17H3.75a.25.25 0 0 0-.25.25Zm13 16.75h3.75a.25.25 0 0 0 .25-.25V3.75a.25.25 0 0 0-.25-.25H16.5Z" }, child: [] }] })(t) } function zV(t) { return Vt({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "g", attr: { id: "Logout" }, child: [{ tag: "g", attr: {}, child: [{ tag: "path", attr: { d: "M20.968,18.448a2.577,2.577,0,0,1-2.73,2.5c-2.153.012-4.306,0-6.459,0a.5.5,0,0,1,0-1c2.2,0,4.4.032,6.6,0,1.107-.016,1.589-.848,1.589-1.838V5.647A1.546,1.546,0,0,0,19,4.175a3.023,3.023,0,0,0-1.061-.095H11.779a.5.5,0,0,1,0-1c2.224,0,4.465-.085,6.687,0a2.567,2.567,0,0,1,2.5,2.67Z" }, child: [] }, { tag: "path", attr: { d: "M3.176,11.663a.455.455,0,0,0-.138.311c0,.015,0,.028-.006.043s0,.027.006.041a.457.457,0,0,0,.138.312l3.669,3.669a.5.5,0,0,0,.707-.707L4.737,12.516H15.479a.5.5,0,0,0,0-1H4.737L7.552,8.7a.5.5,0,0,0-.707-.707Z" }, child: [] }] }] }] })(t) } var ku = class { constructor() { this.listeners = new Set, this.subscribe = this.subscribe.bind(this) } subscribe(t) { return this.listeners.add(t), this.onSubscribe(), () => { this.listeners.delete(t), this.onUnsubscribe() } } hasListeners() { return this.listeners.size > 0 } onSubscribe() { } onUnsubscribe() { } }, Ql = typeof window > "u" || "Deno" in globalThis; function ni() { } function IV(t, e) { return typeof t == "function" ? t(e) : t } function Vb(t) { return typeof t == "number" && t >= 0 && t !== 1 / 0 } function BM(t, e) { return Math.max(t + (e || 0) - Date.now(), 0) } function _o(t, e) { return typeof t == "function" ? t(e) : t } function xs(t, e) { return typeof t == "function" ? t(e) : t } function $E(t, e) { const { type: n = "all", exact: r, fetchStatus: i, predicate: s, queryKey: a, stale: l } = t; if (a) { if (r) { if (e.queryHash !== Uw(a, e.options)) return !1 } else if (!Lf(e.queryKey, a)) return !1 } if (n !== "all") { const u = e.isActive(); if (n === "active" && !u || n === "inactive" && u) return !1 } return !(typeof l == "boolean" && e.isStale() !== l || i && i !== e.state.fetchStatus || s && !s(e)) } function UE(t, e) { const { exact: n, status: r, predicate: i, mutationKey: s } = t; if (s) { if (!e.options.mutationKey) return !1; if (n) { if (Jl(e.options.mutationKey) !== Jl(s)) return !1 } else if (!Lf(e.options.mutationKey, s)) return !1 } return !(r && e.state.status !== r || i && !i(e)) } function Uw(t, e) { return (e?.queryKeyHashFn || Jl)(t) } function Jl(t) { return JSON.stringify(t, (e, n) => Hb(n) ? Object.keys(n).sort().reduce((r, i) => (r[i] = n[i], r), {}) : n) } function Lf(t, e) { return t === e ? !0 : typeof t != typeof e ? !1 : t && e && typeof t == "object" && typeof e == "object" ? Object.keys(e).every(n => Lf(t[n], e[n])) : !1 } function $M(t, e) { if (t === e) return t; const n = VE(t) && VE(e); if (n || Hb(t) && Hb(e)) { const r = n ? t : Object.keys(t), i = r.length, s = n ? e : Object.keys(e), a = s.length, l = n ? [] : {}, u = new Set(r); let f = 0; for (let p = 0; p < a; p++) { const g = n ? p : s[p]; (!n && u.has(g) || n) && t[g] === void 0 && e[g] === void 0 ? (l[g] = void 0, f++) : (l[g] = $M(t[g], e[g]), l[g] === t[g] && t[g] !== void 0 && f++) } return i === a && f === i ? t : l } return e } function Jm(t, e) { if (!e || Object.keys(t).length !== Object.keys(e).length) return !1; for (const n in t) if (t[n] !== e[n]) return !1; return !0 } function VE(t) { return Array.isArray(t) && t.length === Object.keys(t).length } function Hb(t) { if (!HE(t)) return !1; const e = t.constructor; if (e === void 0) return !0; const n = e.prototype; return !(!HE(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(t) !== Object.prototype) } function HE(t) { return Object.prototype.toString.call(t) === "[object Object]" } function FV(t) { return new Promise(e => { setTimeout(e, t) }) } function qb(t, e, n) { return typeof n.structuralSharing == "function" ? n.structuralSharing(t, e) : n.structuralSharing !== !1 ? $M(t, e) : e } function BV(t, e, n = 0) { const r = [...t, e]; return n && r.length > n ? r.slice(1) : r } function $V(t, e, n = 0) { const r = [e, ...t]; return n && r.length > n ? r.slice(0, -1) : r } var Vw = Symbol(); function UM(t, e) { return !t.queryFn && e?.initialPromise ? () => e.initialPromise : !t.queryFn || t.queryFn === Vw ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`)) : t.queryFn } function VM(t, e) { return typeof t == "function" ? t(...e) : !!t } var UV = class extends ku { #t; #e; #n; constructor() { super(), this.#n = t => { if (!Ql && window.addEventListener) { const e = () => t(); return window.addEventListener("visibilitychange", e, !1), () => { window.removeEventListener("visibilitychange", e) } } } } onSubscribe() { this.#e || this.setEventListener(this.#n) } onUnsubscribe() { this.hasListeners() || (this.#e?.(), this.#e = void 0) } setEventListener(t) { this.#n = t, this.#e?.(), this.#e = t(e => { typeof e == "boolean" ? this.setFocused(e) : this.onFocus() }) } setFocused(t) { this.#t !== t && (this.#t = t, this.onFocus()) } onFocus() { const t = this.isFocused(); this.listeners.forEach(e => { e(t) }) } isFocused() { return typeof this.#t == "boolean" ? this.#t : globalThis.document?.visibilityState !== "hidden" } }, Hw = new UV, VV = class extends ku { #t = !0; #e; #n; constructor() { super(), this.#n = t => { if (!Ql && window.addEventListener) { const e = () => t(!0), n = () => t(!1); return window.addEventListener("online", e, !1), window.addEventListener("offline", n, !1), () => { window.removeEventListener("online", e), window.removeEventListener("offline", n) } } } } onSubscribe() { this.#e || this.setEventListener(this.#n) } onUnsubscribe() { this.hasListeners() || (this.#e?.(), this.#e = void 0) } setEventListener(t) { this.#n = t, this.#e?.(), this.#e = t(this.setOnline.bind(this)) } setOnline(t) { this.#t !== t && (this.#t = t, this.listeners.forEach(n => { n(t) })) } isOnline() { return this.#t } }, Zm = new VV; function Kb() { let t, e; const n = new Promise((i, s) => { t = i, e = s }); n.status = "pending", n.catch(() => { }); function r(i) { Object.assign(n, i), delete n.resolve, delete n.reject } return n.resolve = i => { r({ status: "fulfilled", value: i }), t(i) }, n.reject = i => { r({ status: "rejected", reason: i }), e(i) }, n } function HV(t) { return Math.min(1e3 * 2 ** t, 3e4) } function HM(t) { return (t ?? "online") === "online" ? Zm.isOnline() : !0 } var qM = class extends Error { constructor(t) { super("CancelledError"), this.revert = t?.revert, this.silent = t?.silent } }; function vx(t) { return t instanceof qM } function KM(t) { let e = !1, n = 0, r = !1, i; const s = Kb(), a = S => { r || (y(new qM(S)), t.abort?.()) }, l = () => { e = !0 }, u = () => { e = !1 }, f = () => Hw.isFocused() && (t.networkMode === "always" || Zm.isOnline()) && t.canRun(), p = () => HM(t.networkMode) && t.canRun(), g = S => { r || (r = !0, t.onSuccess?.(S), i?.(), s.resolve(S)) }, y = S => { r || (r = !0, t.onError?.(S), i?.(), s.reject(S)) }, v = () => new Promise(S => { i = C => { (r || f()) && S(C) }, t.onPause?.() }).then(() => { i = void 0, r || t.onContinue?.() }), b = () => { if (r) return; let S; const C = n === 0 ? t.initialPromise : void 0; try { S = C ?? t.fn() } catch (T) { S = Promise.reject(T) } Promise.resolve(S).then(g).catch(T => { if (r) return; const A = t.retry ?? (Ql ? 0 : 3), M = t.retryDelay ?? HV, O = typeof M == "function" ? M(n, T) : M, E = A === !0 || typeof A == "number" && n < A || typeof A == "function" && A(n, T); if (e || !E) { y(T); return } n++, t.onFail?.(n, T), FV(O).then(() => f() ? void 0 : v()).then(() => { e ? y(T) : b() }) }) }; return { promise: s, cancel: a, continue: () => (i?.(), s), cancelRetry: l, continueRetry: u, canStart: p, start: () => (p() ? b() : v().then(b), s) } } var qV = t => setTimeout(t, 0); function KV() { let t = [], e = 0, n = l => { l() }, r = l => { l() }, i = qV; const s = l => { e ? t.push(l) : i(() => { n(l) }) }, a = () => { const l = t; t = [], l.length && i(() => { r(() => { l.forEach(u => { n(u) }) }) }) }; return { batch: l => { let u; e++; try { u = l() } finally { e--, e || a() } return u }, batchCalls: l => (...u) => { s(() => { l(...u) }) }, schedule: s, setNotifyFunction: l => { n = l }, setBatchNotifyFunction: l => { r = l }, setScheduler: l => { i = l } } } var xr = KV(), WM = class { #t; destroy() { this.clearGcTimeout() } scheduleGc() { this.clearGcTimeout(), Vb(this.gcTime) && (this.#t = setTimeout(() => { this.optionalRemove() }, this.gcTime)) } updateGcTime(t) { this.gcTime = Math.max(this.gcTime || 0, t ?? (Ql ? 1 / 0 : 5 * 60 * 1e3)) } clearGcTimeout() { this.#t && (clearTimeout(this.#t), this.#t = void 0) } }, WV = class extends WM { #t; #e; #n; #r; #i; #a; #o; constructor(t) { super(), this.#o = !1, this.#a = t.defaultOptions, this.setOptions(t.options), this.observers = [], this.#r = t.client, this.#n = this.#r.getQueryCache(), this.queryKey = t.queryKey, this.queryHash = t.queryHash, this.#t = YV(this.options), this.state = t.state ?? this.#t, this.scheduleGc() } get meta() { return this.options.meta } get promise() { return this.#i?.promise } setOptions(t) { this.options = { ...this.#a, ...t }, this.updateGcTime(this.options.gcTime) } optionalRemove() { !this.observers.length && this.state.fetchStatus === "idle" && this.#n.remove(this) } setData(t, e) { const n = qb(this.state.data, t, this.options); return this.#s({ data: n, type: "success", dataUpdatedAt: e?.updatedAt, manual: e?.manual }), n } setState(t, e) { this.#s({ type: "setState", state: t, setStateOptions: e }) } cancel(t) { const e = this.#i?.promise; return this.#i?.cancel(t), e ? e.then(ni).catch(ni) : Promise.resolve() } destroy() { super.destroy(), this.cancel({ silent: !0 }) } reset() { this.destroy(), this.setState(this.#t) } isActive() { return this.observers.some(t => xs(t.options.enabled, this) !== !1) } isDisabled() { return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === Vw || this.state.dataUpdateCount + this.state.errorUpdateCount === 0 } isStatic() { return this.getObserversCount() > 0 ? this.observers.some(t => _o(t.options.staleTime, this) === "static") : !1 } isStale() { return this.getObserversCount() > 0 ? this.observers.some(t => t.getCurrentResult().isStale) : this.state.data === void 0 || this.state.isInvalidated } isStaleByTime(t = 0) { return this.state.data === void 0 ? !0 : t === "static" ? !1 : this.state.isInvalidated ? !0 : !BM(this.state.dataUpdatedAt, t) } onFocus() { this.observers.find(e => e.shouldFetchOnWindowFocus())?.refetch({ cancelRefetch: !1 }), this.#i?.continue() } onOnline() { this.observers.find(e => e.shouldFetchOnReconnect())?.refetch({ cancelRefetch: !1 }), this.#i?.continue() } addObserver(t) { this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), this.#n.notify({ type: "observerAdded", query: this, observer: t })) } removeObserver(t) { this.observers.includes(t) && (this.observers = this.observers.filter(e => e !== t), this.observers.length || (this.#i && (this.#o ? this.#i.cancel({ revert: !0 }) : this.#i.cancelRetry()), this.scheduleGc()), this.#n.notify({ type: "observerRemoved", query: this, observer: t })) } getObserversCount() { return this.observers.length } invalidate() { this.state.isInvalidated || this.#s({ type: "invalidate" }) } fetch(t, e) { if (this.state.fetchStatus !== "idle") { if (this.state.data !== void 0 && e?.cancelRefetch) this.cancel({ silent: !0 }); else if (this.#i) return this.#i.continueRetry(), this.#i.promise } if (t && this.setOptions(t), !this.options.queryFn) { const u = this.observers.find(f => f.options.queryFn); u && this.setOptions(u.options) } const n = new AbortController, r = u => { Object.defineProperty(u, "signal", { enumerable: !0, get: () => (this.#o = !0, n.signal) }) }, i = () => { const u = UM(this.options, e), p = (() => { const g = { client: this.#r, queryKey: this.queryKey, meta: this.meta }; return r(g), g })(); return this.#o = !1, this.options.persister ? this.options.persister(u, p, this) : u(p) }, a = (() => { const u = { fetchOptions: e, options: this.options, queryKey: this.queryKey, client: this.#r, state: this.state, fetchFn: i }; return r(u), u })(); this.options.behavior?.onFetch(a, this), this.#e = this.state, (this.state.fetchStatus === "idle" || this.state.fetchMeta !== a.fetchOptions?.meta) && this.#s({ type: "fetch", meta: a.fetchOptions?.meta }); const l = u => { vx(u) && u.silent || this.#s({ type: "error", error: u }), vx(u) || (this.#n.config.onError?.(u, this), this.#n.config.onSettled?.(this.state.data, u, this)), this.scheduleGc() }; return this.#i = KM({ initialPromise: e?.initialPromise, fn: a.fetchFn, abort: n.abort.bind(n), onSuccess: u => { if (u === void 0) { l(new Error(`${this.queryHash} data is undefined`)); return } try { this.setData(u) } catch (f) { l(f); return } this.#n.config.onSuccess?.(u, this), this.#n.config.onSettled?.(u, this.state.error, this), this.scheduleGc() }, onError: l, onFail: (u, f) => { this.#s({ type: "failed", failureCount: u, error: f }) }, onPause: () => { this.#s({ type: "pause" }) }, onContinue: () => { this.#s({ type: "continue" }) }, retry: a.options.retry, retryDelay: a.options.retryDelay, networkMode: a.options.networkMode, canRun: () => !0 }), this.#i.start() } #s(t) { const e = n => { switch (t.type) { case "failed": return { ...n, fetchFailureCount: t.failureCount, fetchFailureReason: t.error }; case "pause": return { ...n, fetchStatus: "paused" }; case "continue": return { ...n, fetchStatus: "fetching" }; case "fetch": return { ...n, ...YM(n.data, this.options), fetchMeta: t.meta ?? null }; case "success": return this.#e = void 0, { ...n, data: t.data, dataUpdateCount: n.dataUpdateCount + 1, dataUpdatedAt: t.dataUpdatedAt ?? Date.now(), error: null, isInvalidated: !1, status: "success", ...!t.manual && { fetchStatus: "idle", fetchFailureCount: 0, fetchFailureReason: null } }; case "error": const r = t.error; return vx(r) && r.revert && this.#e ? { ...this.#e, fetchStatus: "idle" } : { ...n, error: r, errorUpdateCount: n.errorUpdateCount + 1, errorUpdatedAt: Date.now(), fetchFailureCount: n.fetchFailureCount + 1, fetchFailureReason: r, fetchStatus: "idle", status: "error" }; case "invalidate": return { ...n, isInvalidated: !0 }; case "setState": return { ...n, ...t.state } } }; this.state = e(this.state), xr.batch(() => { this.observers.forEach(n => { n.onQueryUpdate() }), this.#n.notify({ query: this, type: "updated", action: t }) }) } }; function YM(t, e) { return { fetchFailureCount: 0, fetchFailureReason: null, fetchStatus: HM(e.networkMode) ? "fetching" : "paused", ...t === void 0 && { error: null, status: "pending" } } } function YV(t) { const e = typeof t.initialData == "function" ? t.initialData() : t.initialData, n = e !== void 0, r = n ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0; return { data: e, dataUpdateCount: 0, dataUpdatedAt: n ? r ?? Date.now() : 0, error: null, errorUpdateCount: 0, errorUpdatedAt: 0, fetchFailureCount: 0, fetchFailureReason: null, fetchMeta: null, isInvalidated: !1, status: n ? "success" : "pending", fetchStatus: "idle" } } var GV = class extends ku { constructor(t = {}) { super(), this.config = t, this.#t = new Map } #t; build(t, e, n) { const r = e.queryKey, i = e.queryHash ?? Uw(r, e); let s = this.get(i); return s || (s = new WV({ client: t, queryKey: r, queryHash: i, options: t.defaultQueryOptions(e), state: n, defaultOptions: t.getQueryDefaults(r) }), this.add(s)), s } add(t) { this.#t.has(t.queryHash) || (this.#t.set(t.queryHash, t), this.notify({ type: "added", query: t })) } remove(t) { const e = this.#t.get(t.queryHash); e && (t.destroy(), e === t && this.#t.delete(t.queryHash), this.notify({ type: "removed", query: t })) } clear() { xr.batch(() => { this.getAll().forEach(t => { this.remove(t) }) }) } get(t) { return this.#t.get(t) } getAll() { return [...this.#t.values()] } find(t) { const e = { exact: !0, ...t }; return this.getAll().find(n => $E(e, n)) } findAll(t = {}) { const e = this.getAll(); return Object.keys(t).length > 0 ? e.filter(n => $E(t, n)) : e } notify(t) { xr.batch(() => { this.listeners.forEach(e => { e(t) }) }) } onFocus() { xr.batch(() => { this.getAll().forEach(t => { t.onFocus() }) }) } onOnline() { xr.batch(() => { this.getAll().forEach(t => { t.onOnline() }) }) } }, XV = class extends WM { #t; #e; #n; constructor(t) { super(), this.mutationId = t.mutationId, this.#e = t.mutationCache, this.#t = [], this.state = t.state || GM(), this.setOptions(t.options), this.scheduleGc() } setOptions(t) { this.options = t, this.updateGcTime(this.options.gcTime) } get meta() { return this.options.meta } addObserver(t) { this.#t.includes(t) || (this.#t.push(t), this.clearGcTimeout(), this.#e.notify({ type: "observerAdded", mutation: this, observer: t })) } removeObserver(t) { this.#t = this.#t.filter(e => e !== t), this.scheduleGc(), this.#e.notify({ type: "observerRemoved", mutation: this, observer: t }) } optionalRemove() { this.#t.length || (this.state.status === "pending" ? this.scheduleGc() : this.#e.remove(this)) } continue() { return this.#n?.continue() ?? this.execute(this.state.variables) } async execute(t) { const e = () => { this.#r({ type: "continue" }) }; this.#n = KM({ fn: () => this.options.mutationFn ? this.options.mutationFn(t) : Promise.reject(new Error("No mutationFn found")), onFail: (i, s) => { this.#r({ type: "failed", failureCount: i, error: s }) }, onPause: () => { this.#r({ type: "pause" }) }, onContinue: e, retry: this.options.retry ?? 0, retryDelay: this.options.retryDelay, networkMode: this.options.networkMode, canRun: () => this.#e.canRun(this) }); const n = this.state.status === "pending", r = !this.#n.canStart(); try { if (n) e(); else { this.#r({ type: "pending", variables: t, isPaused: r }), await this.#e.config.onMutate?.(t, this); const s = await this.options.onMutate?.(t); s !== this.state.context && this.#r({ type: "pending", context: s, variables: t, isPaused: r }) } const i = await this.#n.start(); return await this.#e.config.onSuccess?.(i, t, this.state.context, this), await this.options.onSuccess?.(i, t, this.state.context), await this.#e.config.onSettled?.(i, null, this.state.variables, this.state.context, this), await this.options.onSettled?.(i, null, t, this.state.context), this.#r({ type: "success", data: i }), i } catch (i) { try { throw await this.#e.config.onError?.(i, t, this.state.context, this), await this.options.onError?.(i, t, this.state.context), await this.#e.config.onSettled?.(void 0, i, this.state.variables, this.state.context, this), await this.options.onSettled?.(void 0, i, t, this.state.context), i } finally { this.#r({ type: "error", error: i }) } } finally { this.#e.runNext(this) } } #r(t) { const e = n => { switch (t.type) { case "failed": return { ...n, failureCount: t.failureCount, failureReason: t.error }; case "pause": return { ...n, isPaused: !0 }; case "continue": return { ...n, isPaused: !1 }; case "pending": return { ...n, context: t.context, data: void 0, failureCount: 0, failureReason: null, error: null, isPaused: t.isPaused, status: "pending", variables: t.variables, submittedAt: Date.now() }; case "success": return { ...n, data: t.data, failureCount: 0, failureReason: null, error: null, status: "success", isPaused: !1 }; case "error": return { ...n, data: void 0, error: t.error, failureCount: n.failureCount + 1, failureReason: t.error, isPaused: !1, status: "error" } } }; this.state = e(this.state), xr.batch(() => { this.#t.forEach(n => { n.onMutationUpdate(t) }), this.#e.notify({ mutation: this, type: "updated", action: t }) }) } }; function GM() { return { context: void 0, data: void 0, error: null, failureCount: 0, failureReason: null, isPaused: !1, status: "idle", variables: void 0, submittedAt: 0 } } var QV = class extends ku { constructor(t = {}) { super(), this.config = t, this.#t = new Set, this.#e = new Map, this.#n = 0 } #t; #e; #n; build(t, e, n) { const r = new XV({ mutationCache: this, mutationId: ++this.#n, options: t.defaultMutationOptions(e), state: n }); return this.add(r), r } add(t) { this.#t.add(t); const e = Up(t); if (typeof e == "string") { const n = this.#e.get(e); n ? n.push(t) : this.#e.set(e, [t]) } this.notify({ type: "added", mutation: t }) } remove(t) { if (this.#t.delete(t)) { const e = Up(t); if (typeof e == "string") { const n = this.#e.get(e); if (n) if (n.length > 1) { const r = n.indexOf(t); r !== -1 && n.splice(r, 1) } else n[0] === t && this.#e.delete(e) } } this.notify({ type: "removed", mutation: t }) } canRun(t) { const e = Up(t); if (typeof e == "string") { const r = this.#e.get(e)?.find(i => i.state.status === "pending"); return !r || r === t } else return !0 } runNext(t) { const e = Up(t); return typeof e == "string" ? this.#e.get(e)?.find(r => r !== t && r.state.isPaused)?.continue() ?? Promise.resolve() : Promise.resolve() } clear() { xr.batch(() => { this.#t.forEach(t => { this.notify({ type: "removed", mutation: t }) }), this.#t.clear(), this.#e.clear() }) } getAll() { return Array.from(this.#t) } find(t) { const e = { exact: !0, ...t }; return this.getAll().find(n => UE(e, n)) } findAll(t = {}) { return this.getAll().filter(e => UE(t, e)) } notify(t) { xr.batch(() => { this.listeners.forEach(e => { e(t) }) }) } resumePausedMutations() { const t = this.getAll().filter(e => e.state.isPaused); return xr.batch(() => Promise.all(t.map(e => e.continue().catch(ni)))) } }; function Up(t) { return t.options.scope?.id } function qE(t) { return { onFetch: (e, n) => { const r = e.options, i = e.fetchOptions?.meta?.fetchMore?.direction, s = e.state.data?.pages || [], a = e.state.data?.pageParams || []; let l = { pages: [], pageParams: [] }, u = 0; const f = async () => { let p = !1; const g = b => { Object.defineProperty(b, "signal", { enumerable: !0, get: () => (e.signal.aborted ? p = !0 : e.signal.addEventListener("abort", () => { p = !0 }), e.signal) }) }, y = UM(e.options, e.fetchOptions), v = async (b, S, C) => { if (p) return Promise.reject(); if (S == null && b.pages.length) return Promise.resolve(b); const A = (() => { const k = { client: e.client, queryKey: e.queryKey, pageParam: S, direction: C ? "backward" : "forward", meta: e.options.meta }; return g(k), k })(), M = await y(A), { maxPages: O } = e.options, E = C ? $V : BV; return { pages: E(b.pages, M, O), pageParams: E(b.pageParams, S, O) } }; if (i && s.length) { const b = i === "backward", S = b ? JV : KE, C = { pages: s, pageParams: a }, T = S(r, C); l = await v(C, T, b) } else { const b = t ?? s.length; do { const S = u === 0 ? a[0] ?? r.initialPageParam : KE(r, l); if (u > 0 && S == null) break; l = await v(l, S), u++ } while (u < b) } return l }; e.options.persister ? e.fetchFn = () => e.options.persister?.(f, { client: e.client, queryKey: e.queryKey, meta: e.options.meta, signal: e.signal }, n) : e.fetchFn = f } } } function KE(t, { pages: e, pageParams: n }) { const r = e.length - 1; return e.length > 0 ? t.getNextPageParam(e[r], e, n[r], n) : void 0 } function JV(t, { pages: e, pageParams: n }) { return e.length > 0 ? t.getPreviousPageParam?.(e[0], e, n[0], n) : void 0 } var ZV = class { #t; #e; #n; #r; #i; #a; #o; #s; constructor(t = {}) { this.#t = t.queryCache || new GV, this.#e = t.mutationCache || new QV, this.#n = t.defaultOptions || {}, this.#r = new Map, this.#i = new Map, this.#a = 0 } mount() { this.#a++, this.#a === 1 && (this.#o = Hw.subscribe(async t => { t && (await this.resumePausedMutations(), this.#t.onFocus()) }), this.#s = Zm.subscribe(async t => { t && (await this.resumePausedMutations(), this.#t.onOnline()) })) } unmount() { this.#a--, this.#a === 0 && (this.#o?.(), this.#o = void 0, this.#s?.(), this.#s = void 0) } isFetching(t) { return this.#t.findAll({ ...t, fetchStatus: "fetching" }).length } isMutating(t) { return this.#e.findAll({ ...t, status: "pending" }).length } getQueryData(t) { const e = this.defaultQueryOptions({ queryKey: t }); return this.#t.get(e.queryHash)?.state.data } ensureQueryData(t) { const e = this.defaultQueryOptions(t), n = this.#t.build(this, e), r = n.state.data; return r === void 0 ? this.fetchQuery(t) : (t.revalidateIfStale && n.isStaleByTime(_o(e.staleTime, n)) && this.prefetchQuery(e), Promise.resolve(r)) } getQueriesData(t) { return this.#t.findAll(t).map(({ queryKey: e, state: n }) => { const r = n.data; return [e, r] }) } setQueryData(t, e, n) { const r = this.defaultQueryOptions({ queryKey: t }), s = this.#t.get(r.queryHash)?.state.data, a = IV(e, s); if (a !== void 0) return this.#t.build(this, r).setData(a, { ...n, manual: !0 }) } setQueriesData(t, e, n) { return xr.batch(() => this.#t.findAll(t).map(({ queryKey: r }) => [r, this.setQueryData(r, e, n)])) } getQueryState(t) { const e = this.defaultQueryOptions({ queryKey: t }); return this.#t.get(e.queryHash)?.state } removeQueries(t) { const e = this.#t; xr.batch(() => { e.findAll(t).forEach(n => { e.remove(n) }) }) } resetQueries(t, e) { const n = this.#t; return xr.batch(() => (n.findAll(t).forEach(r => { r.reset() }), this.refetchQueries({ type: "active", ...t }, e))) } cancelQueries(t, e = {}) { const n = { revert: !0, ...e }, r = xr.batch(() => this.#t.findAll(t).map(i => i.cancel(n))); return Promise.all(r).then(ni).catch(ni) } invalidateQueries(t, e = {}) { return xr.batch(() => (this.#t.findAll(t).forEach(n => { n.invalidate() }), t?.refetchType === "none" ? Promise.resolve() : this.refetchQueries({ ...t, type: t?.refetchType ?? t?.type ?? "active" }, e))) } refetchQueries(t, e = {}) { const n = { ...e, cancelRefetch: e.cancelRefetch ?? !0 }, r = xr.batch(() => this.#t.findAll(t).filter(i => !i.isDisabled() && !i.isStatic()).map(i => { let s = i.fetch(void 0, n); return n.throwOnError || (s = s.catch(ni)), i.state.fetchStatus === "paused" ? Promise.resolve() : s })); return Promise.all(r).then(ni) } fetchQuery(t) { const e = this.defaultQueryOptions(t); e.retry === void 0 && (e.retry = !1); const n = this.#t.build(this, e); return n.isStaleByTime(_o(e.staleTime, n)) ? n.fetch(e) : Promise.resolve(n.state.data) } prefetchQuery(t) { return this.fetchQuery(t).then(ni).catch(ni) } fetchInfiniteQuery(t) { return t.behavior = qE(t.pages), this.fetchQuery(t) } prefetchInfiniteQuery(t) { return this.fetchInfiniteQuery(t).then(ni).catch(ni) } ensureInfiniteQueryData(t) { return t.behavior = qE(t.pages), this.ensureQueryData(t) } resumePausedMutations() { return Zm.isOnline() ? this.#e.resumePausedMutations() : Promise.resolve() } getQueryCache() { return this.#t } getMutationCache() { return this.#e } getDefaultOptions() { return this.#n } setDefaultOptions(t) { this.#n = t } setQueryDefaults(t, e) { this.#r.set(Jl(t), { queryKey: t, defaultOptions: e }) } getQueryDefaults(t) { const e = [...this.#r.values()], n = {}; return e.forEach(r => { Lf(t, r.queryKey) && Object.assign(n, r.defaultOptions) }), n } setMutationDefaults(t, e) { this.#i.set(Jl(t), { mutationKey: t, defaultOptions: e }) } getMutationDefaults(t) { const e = [...this.#i.values()], n = {}; return e.forEach(r => { Lf(t, r.mutationKey) && Object.assign(n, r.defaultOptions) }), n } defaultQueryOptions(t) { if (t._defaulted) return t; const e = { ...this.#n.queries, ...this.getQueryDefaults(t.queryKey), ...t, _defaulted: !0 }; return e.queryHash || (e.queryHash = Uw(e.queryKey, e)), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.queryFn === Vw && (e.enabled = !1), e } defaultMutationOptions(t) { return t?._defaulted ? t : { ...this.#n.mutations, ...t?.mutationKey && this.getMutationDefaults(t.mutationKey), ...t, _defaulted: !0 } } clear() { this.#t.clear(), this.#e.clear() } }, eH = class extends ku { constructor(t, e) { super(), this.options = e, this.#t = t, this.#s = null, this.#o = Kb(), this.options.experimental_prefetchInRender || this.#o.reject(new Error("experimental_prefetchInRender feature flag is not enabled")), this.bindMethods(), this.setOptions(e) } #t; #e = void 0; #n = void 0; #r = void 0; #i; #a; #o; #s; #m; #f; #h; #c; #u; #l; #p = new Set; bindMethods() { this.refetch = this.refetch.bind(this) } onSubscribe() { this.listeners.size === 1 && (this.#e.addObserver(this), WE(this.#e, this.options) ? this.#d() : this.updateResult(), this.#x()) } onUnsubscribe() { this.hasListeners() || this.destroy() } shouldFetchOnReconnect() { return Wb(this.#e, this.options, this.options.refetchOnReconnect) } shouldFetchOnWindowFocus() { return Wb(this.#e, this.options, this.options.refetchOnWindowFocus) } destroy() { this.listeners = new Set, this.#b(), this.#w(), this.#e.removeObserver(this) } setOptions(t) { const e = this.options, n = this.#e; if (this.options = this.#t.defaultQueryOptions(t), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof xs(this.options.enabled, this.#e) != "boolean") throw new Error("Expected enabled to be a boolean or a callback that returns a boolean"); this.#S(), this.#e.setOptions(this.options), e._defaulted && !Jm(this.options, e) && this.#t.getQueryCache().notify({ type: "observerOptionsUpdated", query: this.#e, observer: this }); const r = this.hasListeners(); r && YE(this.#e, n, this.options, e) && this.#d(), this.updateResult(), r && (this.#e !== n || xs(this.options.enabled, this.#e) !== xs(e.enabled, this.#e) || _o(this.options.staleTime, this.#e) !== _o(e.staleTime, this.#e)) && this.#g(); const i = this.#y(); r && (this.#e !== n || xs(this.options.enabled, this.#e) !== xs(e.enabled, this.#e) || i !== this.#l) && this.#v(i) } getOptimisticResult(t) { const e = this.#t.getQueryCache().build(this.#t, t), n = this.createResult(e, t); return nH(this, n) && (this.#r = n, this.#a = this.options, this.#i = this.#e.state), n } getCurrentResult() { return this.#r } trackResult(t, e) { return new Proxy(t, { get: (n, r) => (this.trackProp(r), e?.(r), Reflect.get(n, r)) }) } trackProp(t) { this.#p.add(t) } getCurrentQuery() { return this.#e } refetch({ ...t } = {}) { return this.fetch({ ...t }) } fetchOptimistic(t) { const e = this.#t.defaultQueryOptions(t), n = this.#t.getQueryCache().build(this.#t, e); return n.fetch().then(() => this.createResult(n, e)) } fetch(t) { return this.#d({ ...t, cancelRefetch: t.cancelRefetch ?? !0 }).then(() => (this.updateResult(), this.#r)) } #d(t) { this.#S(); let e = this.#e.fetch(this.options, t); return t?.throwOnError || (e = e.catch(ni)), e } #g() { this.#b(); const t = _o(this.options.staleTime, this.#e); if (Ql || this.#r.isStale || !Vb(t)) return; const n = BM(this.#r.dataUpdatedAt, t) + 1; this.#c = setTimeout(() => { this.#r.isStale || this.updateResult() }, n) } #y() { return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(this.#e) : this.options.refetchInterval) ?? !1 } #v(t) { this.#w(), this.#l = t, !(Ql || xs(this.options.enabled, this.#e) === !1 || !Vb(this.#l) || this.#l === 0) && (this.#u = setInterval(() => { (this.options.refetchIntervalInBackground || Hw.isFocused()) && this.#d() }, this.#l)) } #x() { this.#g(), this.#v(this.#y()) } #b() { this.#c && (clearTimeout(this.#c), this.#c = void 0) } #w() { this.#u && (clearInterval(this.#u), this.#u = void 0) } createResult(t, e) { const n = this.#e, r = this.options, i = this.#r, s = this.#i, a = this.#a, u = t !== n ? t.state : this.#n, { state: f } = t; let p = { ...f }, g = !1, y; if (e._optimisticResults) { const V = this.hasListeners(), q = !V && WE(t, e), ue = V && YE(t, n, e, r); (q || ue) && (p = { ...p, ...YM(f.data, t.options) }), e._optimisticResults === "isRestoring" && (p.fetchStatus = "idle") } let { error: v, errorUpdatedAt: b, status: S } = p; y = p.data; let C = !1; if (e.placeholderData !== void 0 && y === void 0 && S === "pending") { let V; i?.isPlaceholderData && e.placeholderData === a?.placeholderData ? (V = i.data, C = !0) : V = typeof e.placeholderData == "function" ? e.placeholderData(this.#h?.state.data, this.#h) : e.placeholderData, V !== void 0 && (S = "success", y = qb(i?.data, V, e), g = !0) } if (e.select && y !== void 0 && !C) if (i && y === s?.data && e.select === this.#m) y = this.#f; else try { this.#m = e.select, y = e.select(y), y = qb(i?.data, y, e), this.#f = y, this.#s = null } catch (V) { this.#s = V } this.#s && (v = this.#s, y = this.#f, b = Date.now(), S = "error"); const T = p.fetchStatus === "fetching", A = S === "pending", M = S === "error", O = A && T, E = y !== void 0, z = { status: S, fetchStatus: p.fetchStatus, isPending: A, isSuccess: S === "success", isError: M, isInitialLoading: O, isLoading: O, data: y, dataUpdatedAt: p.dataUpdatedAt, error: v, errorUpdatedAt: b, failureCount: p.fetchFailureCount, failureReason: p.fetchFailureReason, errorUpdateCount: p.errorUpdateCount, isFetched: p.dataUpdateCount > 0 || p.errorUpdateCount > 0, isFetchedAfterMount: p.dataUpdateCount > u.dataUpdateCount || p.errorUpdateCount > u.errorUpdateCount, isFetching: T, isRefetching: T && !A, isLoadingError: M && !E, isPaused: p.fetchStatus === "paused", isPlaceholderData: g, isRefetchError: M && E, isStale: qw(t, e), refetch: this.refetch, promise: this.#o }; if (this.options.experimental_prefetchInRender) { const V = W => { z.status === "error" ? W.reject(z.error) : z.data !== void 0 && W.resolve(z.data) }, q = () => { const W = this.#o = z.promise = Kb(); V(W) }, ue = this.#o; switch (ue.status) { case "pending": t.queryHash === n.queryHash && V(ue); break; case "fulfilled": (z.status === "error" || z.data !== ue.value) && q(); break; case "rejected": (z.status !== "error" || z.error !== ue.reason) && q(); break } } return z } updateResult() { const t = this.#r, e = this.createResult(this.#e, this.options); if (this.#i = this.#e.state, this.#a = this.options, this.#i.data !== void 0 && (this.#h = this.#e), Jm(e, t)) return; this.#r = e; const n = () => { if (!t) return !0; const { notifyOnChangeProps: r } = this.options, i = typeof r == "function" ? r() : r; if (i === "all" || !i && !this.#p.size) return !0; const s = new Set(i ?? this.#p); return this.options.throwOnError && s.add("error"), Object.keys(this.#r).some(a => { const l = a; return this.#r[l] !== t[l] && s.has(l) }) }; this.#C({ listeners: n() }) } #S() { const t = this.#t.getQueryCache().build(this.#t, this.options); if (t === this.#e) return; const e = this.#e; this.#e = t, this.#n = t.state, this.hasListeners() && (e?.removeObserver(this), t.addObserver(this)) } onQueryUpdate() { this.updateResult(), this.hasListeners() && this.#x() } #C(t) { xr.batch(() => { t.listeners && this.listeners.forEach(e => { e(this.#r) }), this.#t.getQueryCache().notify({ query: this.#e, type: "observerResultsUpdated" }) }) } }; function tH(t, e) { return xs(e.enabled, t) !== !1 && t.state.data === void 0 && !(t.state.status === "error" && e.retryOnMount === !1) } function WE(t, e) { return tH(t, e) || t.state.data !== void 0 && Wb(t, e, e.refetchOnMount) } function Wb(t, e, n) { if (xs(e.enabled, t) !== !1 && _o(e.staleTime, t) !== "static") { const r = typeof n == "function" ? n(t) : n; return r === "always" || r !== !1 && qw(t, e) } return !1 } function YE(t, e, n, r) { return (t !== e || xs(r.enabled, t) === !1) && (!n.suspense || t.state.status !== "error") && qw(t, n) } function qw(t, e) { return xs(e.enabled, t) !== !1 && t.isStaleByTime(_o(e.staleTime, t)) } function nH(t, e) { return !Jm(t.getCurrentResult(), e) } var rH = class extends ku { #t; #e = void 0; #n; #r; constructor(e, n) { super(), this.#t = e, this.setOptions(n), this.bindMethods(), this.#i() } bindMethods() { this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this) } setOptions(e) { const n = this.options; this.options = this.#t.defaultMutationOptions(e), Jm(this.options, n) || this.#t.getMutationCache().notify({ type: "observerOptionsUpdated", mutation: this.#n, observer: this }), n?.mutationKey && this.options.mutationKey && Jl(n.mutationKey) !== Jl(this.options.mutationKey) ? this.reset() : this.#n?.state.status === "pending" && this.#n.setOptions(this.options) } onUnsubscribe() { this.hasListeners() || this.#n?.removeObserver(this) } onMutationUpdate(e) { this.#i(), this.#a(e) } getCurrentResult() { return this.#e } reset() { this.#n?.removeObserver(this), this.#n = void 0, this.#i(), this.#a() } mutate(e, n) { return this.#r = n, this.#n?.removeObserver(this), this.#n = this.#t.getMutationCache().build(this.#t, this.options), this.#n.addObserver(this), this.#n.execute(e) } #i() { const e = this.#n?.state ?? GM(); this.#e = { ...e, isPending: e.status === "pending", isSuccess: e.status === "success", isError: e.status === "error", isIdle: e.status === "idle", mutate: this.mutate, reset: this.reset } } #a(e) { xr.batch(() => { if (this.#r && this.hasListeners()) { const n = this.#e.variables, r = this.#e.context; e?.type === "success" ? (this.#r.onSuccess?.(e.data, n, r), this.#r.onSettled?.(e.data, null, n, r)) : e?.type === "error" && (this.#r.onError?.(e.error, n, r), this.#r.onSettled?.(void 0, e.error, n, r)) } this.listeners.forEach(n => { n(this.#e) }) }) } }, XM = N.createContext(void 0), Ou = t => { const e = N.useContext(XM); if (!e) throw new Error("No QueryClient set, use QueryClientProvider to set one"); return e }, iH = ({ client: t, children: e }) => (N.useEffect(() => (t.mount(), () => { t.unmount() }), [t]), d.jsx(XM.Provider, { value: t, children: e })), QM = N.createContext(!1), sH = () => N.useContext(QM); QM.Provider; function aH() { let t = !1; return { clearReset: () => { t = !1 }, reset: () => { t = !0 }, isReset: () => t } } var oH = N.createContext(aH()), lH = () => N.useContext(oH), cH = (t, e) => { (t.suspense || t.throwOnError || t.experimental_prefetchInRender) && (e.isReset() || (t.retryOnMount = !1)) }, uH = t => { N.useEffect(() => { t.clearReset() }, [t]) }, dH = ({ result: t, errorResetBoundary: e, throwOnError: n, query: r, suspense: i }) => t.isError && !e.isReset() && !t.isFetching && r && (i && t.data === void 0 || VM(n, [t.error, r])), fH = t => { if (t.suspense) { const e = r => r === "static" ? r : Math.max(r ?? 1e3, 1e3), n = t.staleTime; t.staleTime = typeof n == "function" ? (...r) => e(n(...r)) : e(n), typeof t.gcTime == "number" && (t.gcTime = Math.max(t.gcTime, 1e3)) } }, hH = (t, e) => t.isLoading && t.isFetching && !e, pH = (t, e) => t?.suspense && e.isPending, GE = (t, e, n) => e.fetchOptimistic(t).catch(() => { n.clearReset() }); function mH(t, e, n) { const r = sH(), i = lH(), s = Ou(), a = s.defaultQueryOptions(t); s.getDefaultOptions().queries?._experimental_beforeQuery?.(a), a._optimisticResults = r ? "isRestoring" : "optimistic", fH(a), cH(a, i), uH(i); const l = !s.getQueryCache().get(a.queryHash), [u] = N.useState(() => new e(s, a)), f = u.getOptimisticResult(a), p = !r && t.subscribed !== !1; if (N.useSyncExternalStore(N.useCallback(g => { const y = p ? u.subscribe(xr.batchCalls(g)) : ni; return u.updateResult(), y }, [u, p]), () => u.getCurrentResult(), () => u.getCurrentResult()), N.useEffect(() => { u.setOptions(a) }, [a, u]), pH(a, f)) throw GE(a, u, i); if (dH({ result: f, errorResetBoundary: i, throwOnError: a.throwOnError, query: s.getQueryCache().get(a.queryHash), suspense: a.suspense })) throw f.error; return s.getDefaultOptions().queries?._experimental_afterQuery?.(a, f), a.experimental_prefetchInRender && !Ql && hH(f, r) && (l ? GE(a, u, i) : s.getQueryCache().get(a.queryHash)?.promise)?.catch(ni).finally(() => { u.updateResult() }), a.notifyOnChangeProps ? f : u.trackResult(f) } function Jt(t, e) { return mH(t, eH) } function js(t, e) { const n = Ou(), [r] = N.useState(() => new rH(n, t)); N.useEffect(() => { r.setOptions(t) }, [r, t]); const i = N.useSyncExternalStore(N.useCallback(a => r.subscribe(xr.batchCalls(a)), [r]), () => r.getCurrentResult(), () => r.getCurrentResult()), s = N.useCallback((a, l) => { r.mutate(a, l).catch(ni) }, [r]); if (i.error && VM(r.options.throwOnError, [i.error])) throw i.error; return { ...i, mutate: s, mutateAsync: i.mutate } } function gH(t) { return Vt({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "rect", attr: { width: "416", height: "384", x: "48", y: "80", fill: "none", strokeLinejoin: "round", strokeWidth: "32", rx: "48" }, child: [] }, { tag: "circle", attr: { cx: "296", cy: "232", r: "24" }, child: [] }, { tag: "circle", attr: { cx: "376", cy: "232", r: "24" }, child: [] }, { tag: "circle", attr: { cx: "296", cy: "312", r: "24" }, child: [] }, { tag: "circle", attr: { cx: "376", cy: "312", r: "24" }, child: [] }, { tag: "circle", attr: { cx: "136", cy: "312", r: "24" }, child: [] }, { tag: "circle", attr: { cx: "216", cy: "312", r: "24" }, child: [] }, { tag: "circle", attr: { cx: "136", cy: "392", r: "24" }, child: [] }, { tag: "circle", attr: { cx: "216", cy: "392", r: "24" }, child: [] }, { tag: "circle", attr: { cx: "296", cy: "392", r: "24" }, child: [] }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M128 48v32m256-32v32" }, child: [] }, { tag: "path", attr: { fill: "none", strokeLinejoin: "round", strokeWidth: "32", d: "M464 160H48" }, child: [] }] })(t) } function yH(t) { return Vt({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "rect", attr: { width: "416", height: "320", x: "48", y: "96", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", rx: "56", ry: "56" }, child: [] }, { tag: "path", attr: { fill: "none", strokeLinejoin: "round", strokeWidth: "60", d: "M48 192h416M128 300h48v20h-48z" }, child: [] }] })(t) } function vH(t) { return Vt({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinejoin: "round", strokeWidth: "32", d: "M416 221.25V416a48 48 0 0 1-48 48H144a48 48 0 0 1-48-48V96a48 48 0 0 1 48-48h98.75a32 32 0 0 1 22.62 9.37l141.26 141.26a32 32 0 0 1 9.37 22.62z" }, child: [] }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M256 56v120a32 32 0 0 0 32 32h120m-232 80h160m-160 80h160" }, child: [] }] })(t) } function xH(t) { return Vt({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M277.42 247a24.68 24.68 0 0 0-4.08-5.47L255 223.44a21.63 21.63 0 0 0-6.56-4.57 20.93 20.93 0 0 0-23.28 4.27c-6.36 6.26-18 17.68-39 38.43C146 301.3 71.43 367.89 37.71 396.29a16 16 0 0 0-1.09 23.54l39 39.43a16.13 16.13 0 0 0 23.67-.89c29.24-34.37 96.3-109 136-148.23 20.39-20.06 31.82-31.58 38.29-37.94a21.76 21.76 0 0 0 3.84-25.2zm201.01-46-34.31-34a5.44 5.44 0 0 0-4-1.59 5.59 5.59 0 0 0-4 1.59h0a11.41 11.41 0 0 1-9.55 3.27c-4.48-.49-9.25-1.88-12.33-4.86-7-6.86 1.09-20.36-5.07-29a242.88 242.88 0 0 0-23.08-26.72c-7.06-7-34.81-33.47-81.55-52.53a123.79 123.79 0 0 0-47-9.24c-26.35 0-46.61 11.76-54 18.51-5.88 5.32-12 13.77-12 13.77a91.29 91.29 0 0 1 10.81-3.2 79.53 79.53 0 0 1 23.28-1.49C241.19 76.8 259.94 84.1 270 92c16.21 13 23.18 30.39 24.27 52.83.8 16.69-15.23 37.76-30.44 54.94a7.85 7.85 0 0 0 .4 10.83l21.24 21.23a8 8 0 0 0 11.14.1c13.93-13.51 31.09-28.47 40.82-34.46s17.58-7.68 21.35-8.09a35.71 35.71 0 0 1 21.3 4.62 13.65 13.65 0 0 1 3.08 2.38c6.46 6.56 6.07 17.28-.5 23.74l-2 1.89a5.5 5.5 0 0 0 0 7.84l34.31 34a5.5 5.5 0 0 0 4 1.58 5.65 5.65 0 0 0 4-1.58L478.43 209a5.82 5.82 0 0 0 0-8z" }, child: [] }] })(t) } function bH(t) { return Vt({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "circle", attr: { cx: "256", cy: "256", r: "208", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32" }, child: [] }, { tag: "circle", attr: { cx: "256", cy: "256", r: "80", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32" }, child: [] }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "m208 54 8 132m80 0 8-132m-96 404 8-132m80 0 8 132m154-250-132 8m0 80 132 8M54 208l132 8m0 80-132 8" }, child: [] }] })(t) } function wH(t) { return Vt({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "36", d: "M208 352h-64a96 96 0 0 1 0-192h64m96 0h64a96 96 0 0 1 0 192h-64m-140.71-96h187.42" }, child: [] }] })(t) } function SH(t) { return Vt({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinejoin: "round", strokeWidth: "32", d: "M368 415.86V72a24.07 24.07 0 0 0-24-24H72a24.07 24.07 0 0 0-24 24v352a40.12 40.12 0 0 0 40 40h328" }, child: [] }, { tag: "path", attr: { fill: "none", strokeLinejoin: "round", strokeWidth: "32", d: "M416 464a48 48 0 0 1-48-48V128h72a24 24 0 0 1 24 24v264a48 48 0 0 1-48 48z" }, child: [] }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M240 128h64m-64 64h64m-192 64h192m-192 64h192m-192 64h192" }, child: [] }, { tag: "path", attr: { d: "M176 208h-64a16 16 0 0 1-16-16v-64a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v64a16 16 0 0 1-16 16z" }, child: [] }] })(t) } function XE(t) { return Vt({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M402 168c-2.93 40.67-33.1 72-66 72s-63.12-31.32-66-72c-3-42.31 26.37-72 66-72s69 30.46 66 72z" }, child: [] }, { tag: "path", attr: { fill: "none", strokeMiterlimit: "10", strokeWidth: "32", d: "M336 304c-65.17 0-127.84 32.37-143.54 95.41-2.08 8.34 3.15 16.59 11.72 16.59h263.65c8.57 0 13.77-8.25 11.72-16.59C463.85 335.36 401.18 304 336 304z" }, child: [] }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "32", d: "M200 185.94c-2.34 32.48-26.72 58.06-53 58.06s-50.7-25.57-53-58.06C91.61 152.15 115.34 128 147 128s55.39 24.77 53 57.94z" }, child: [] }, { tag: "path", attr: { fill: "none", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "32", d: "M206 306c-18.05-8.27-37.93-11.45-59-11.45-52 0-102.1 25.85-114.65 76.2-1.65 6.66 2.53 13.25 9.37 13.25H154" }, child: [] }] })(t) } function CH() { const { sidebarOpen: t, setSidebarOpen: e } = N.useContext($w), [n, r] = N.useState(!1), i = ln(); async function s() { r(!0); try { let y = await Ve.post("https://api.nexus.com/api/auth/logout", {}, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }); localStorage.removeItem("userToken"), i("/login"), me.success("logged Out Successfully", { duration: 2e3 }), r(!1) } catch (y) { y.status == 401 && (localStorage.removeItem("userToken"), i("/login"), console.log("error to out")), console.log(y.status), r(!1), me.error(y.response?.data?.message || "something went wrong", { duration: 3e3 }), localStorage.removeItem("userToken"), i("/login") } } const a = () => e(!t), { data: l, isLoading: u, error: f, isError: p } = Jt({ queryKey: ["currentUser"], queryFn: () => Ve.get("https://api.nexus.com/api/auth/me", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }), g = [{ title: "Integrations", path: "/integrations", icon: d.jsx(wH, {}), permission: "view_integrations" }, { title: "Admins", path: "/admins", icon: d.jsx(XE, {}), permission: "view_admins" }, { title: "Plans", path: "/plans", icon: d.jsx(yH, {}), permission: "view_plans" }, { title: "Privacy Policy", path: "/privacy-Policy", icon: d.jsx(vH, {}), permission: "" }, { title: "Terms of Services", path: "/terms-of-Services", icon: d.jsx(xH, {}), permission: "" }, { title: "Blogs", path: "/blogs", icon: d.jsx(SH, {}), permission: "view_blogs" }, { title: "Requested demos", path: "/requested-demos", icon: d.jsx(gH, {}), permission: "view_request_demos" }, { title: "Help center", path: "/help-center", icon: d.jsx(bH, {}), permission: "" }, { title: "Webinars", path: "/webinars", icon: d.jsx(XE, {}), permission: "manage_webinars" }]; return d.jsx(d.Fragment, { children: d.jsxs("div", { className: `h-full bg-tramsparent p-5 fixed w-56 left-0 ${t ? "translate-x-0" : "-translate-x-full"} transition-all duration-500 z-50`, children: [d.jsx("div", { className: `absolute z-50 ${t ? "top-5 right-5 -translate-x-1/2 translate-y-1/2 text-gray-400" : "top-2 -right-2 translate-x-full p-1.5 flex justify-center items-center bg-white text-gray-700 bg-opacity-90 aspect-square rounded-full cursor-pointer"} transition-all duration-500`, children: d.jsx("button", { onClick: a, children: d.jsx(PV, { className: "text-2xl" }) }) }), d.jsxs("div", { className: "h-full bg-white rounded-2xl p-5 pt-10 flex flex-col justify-between overflow-y-auto shadow-xl", children: [d.jsxs("div", { className: "", children: [d.jsx("div", { className: "flex justify-center items-center overflow-hidden mb-2", children: d.jsx("img", { src: NO, alt: "Logo", className: "w-4/5" }) }), d.jsx("div", { className: "flex flex-col gap-1 text-gray-400 text-base", children: g.map((y, v) => d.jsx(d.Fragment, { children: (l?.data?.data?.permissions.includes(y.permission) || y.permission == "") && d.jsxs(SO, { className: "px-4 py-2 rounded-xl flex items-center gap-2", to: y.path, children: [d.jsxs("div", { className: "", children: [y.icon, " "] }), y.title] }, v) })) })] }), d.jsx("div", { className: "flex flex-col", children: d.jsxs("button", { onClick: s, disabled: n, className: "bg-gray-400 flex justify-center items-center text-white p-2 rounded-xl mb-2 gap-2 disabled:cursor-not-allowed disabled:opacity-50 capitalize", children: ["Logout ", d.jsx(zV, { className: "text-2xl font-extrabold" })] }) })] })] }) }) }/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const TH = t => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), NH = t => t.replace(/^([A-Z])|[\s-_]+(\w)/g, (e, n, r) => r ? r.toUpperCase() : n.toLowerCase()), QE = t => { const e = NH(t); return e.charAt(0).toUpperCase() + e.slice(1) }, JM = (...t) => t.filter((e, n, r) => !!e && e.trim() !== "" && r.indexOf(e) === n).join(" ").trim(), jH = t => { for (const e in t) if (e.startsWith("aria-") || e === "role" || e === "title") return !0 };/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var EH = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const AH = N.forwardRef(({ color: t = "currentColor", size: e = 24, strokeWidth: n = 2, absoluteStrokeWidth: r, className: i = "", children: s, iconNode: a, ...l }, u) => N.createElement("svg", { ref: u, ...EH, width: e, height: e, stroke: t, strokeWidth: r ? Number(n) * 24 / Number(e) : n, className: JM("lucide", i), ...!s && !jH(l) && { "aria-hidden": "true" }, ...l }, [...a.map(([f, p]) => N.createElement(f, p)), ...Array.isArray(s) ? s : [s]]));/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const en = (t, e) => { const n = N.forwardRef(({ className: r, ...i }, s) => N.createElement(AH, { ref: s, iconNode: e, className: JM(`lucide-${TH(QE(t))}`, `lucide-${t}`, r), ...i })); return n.displayName = QE(t), n };/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const kH = [["path", { d: "M17 12H7", key: "16if0g" }], ["path", { d: "M19 18H5", key: "18s9l3" }], ["path", { d: "M21 6H3", key: "1jwq7v" }]], Yb = en("align-center", kH);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const OH = [["path", { d: "M3 12h18", key: "1i2n21" }], ["path", { d: "M3 18h18", key: "1h113x" }], ["path", { d: "M3 6h18", key: "d0wm0j" }]], MH = en("align-justify", OH);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const DH = [["path", { d: "M15 12H3", key: "6jk70r" }], ["path", { d: "M17 18H3", key: "1amg6g" }], ["path", { d: "M21 6H3", key: "1jwq7v" }]], Gb = en("align-left", DH);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const RH = [["path", { d: "M21 12H9", key: "dn1m92" }], ["path", { d: "M21 18H7", key: "1ygte8" }], ["path", { d: "M21 6H3", key: "1jwq7v" }]], Xb = en("align-right", RH);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const _H = [["path", { d: "M6 12h9a4 4 0 0 1 0 8H7a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h7a4 4 0 0 1 0 8", key: "mg9rjx" }]], Kw = en("bold", _H);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const LH = [["path", { d: "M8 2v4", key: "1cmpym" }], ["path", { d: "M16 2v4", key: "4m81vk" }], ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }], ["path", { d: "M3 10h18", key: "8toen8" }]], PH = en("calendar", LH);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const zH = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], JE = en("check", zH);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const IH = [["path", { d: "M18 20a6 6 0 0 0-12 0", key: "1qehca" }], ["circle", { cx: "12", cy: "10", r: "4", key: "1h16sb" }], ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]], FH = en("circle-user-round", IH);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const BH = [["path", { d: "m18 16 4-4-4-4", key: "1inbqp" }], ["path", { d: "m6 8-4 4 4 4", key: "15zrgr" }], ["path", { d: "m14.5 4-5 16", key: "e7oirm" }]], ZM = en("code-xml", BH);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const $H = [["path", { d: "M4 12h8", key: "17cfdx" }], ["path", { d: "M4 18V6", key: "1rz3zl" }], ["path", { d: "M12 18V6", key: "zqpxq5" }], ["path", { d: "m17 12 3-2v8", key: "1hhhft" }]], eD = en("heading-1", $H);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const UH = [["path", { d: "M4 12h8", key: "17cfdx" }], ["path", { d: "M4 18V6", key: "1rz3zl" }], ["path", { d: "M12 18V6", key: "zqpxq5" }], ["path", { d: "M21 18h-4c0-4 4-3 4-6 0-1.5-2-2.5-4-1", key: "9jr5yi" }]], Ww = en("heading-2", UH);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const VH = [["path", { d: "M4 12h8", key: "17cfdx" }], ["path", { d: "M4 18V6", key: "1rz3zl" }], ["path", { d: "M12 18V6", key: "zqpxq5" }], ["path", { d: "M17.5 10.5c1.7-1 3.5 0 3.5 1.5a2 2 0 0 1-2 2", key: "68ncm8" }], ["path", { d: "M17 17.5c2 1.5 4 .3 4-1.5a2 2 0 0 0-2-2", key: "1ejuhz" }]], Yw = en("heading-3", VH);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const HH = [["path", { d: "M12 18V6", key: "zqpxq5" }], ["path", { d: "M17 10v3a1 1 0 0 0 1 1h3", key: "tj5zdr" }], ["path", { d: "M21 10v8", key: "1kdml4" }], ["path", { d: "M4 12h8", key: "17cfdx" }], ["path", { d: "M4 18V6", key: "1rz3zl" }]], qH = en("heading-4", HH);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const KH = [["path", { d: "M4 12h8", key: "17cfdx" }], ["path", { d: "M4 18V6", key: "1rz3zl" }], ["path", { d: "M12 18V6", key: "zqpxq5" }], ["path", { d: "M17 13v-3h4", key: "1nvgqp" }], ["path", { d: "M17 17.7c.4.2.8.3 1.3.3 1.5 0 2.7-1.1 2.7-2.5S19.8 13 18.3 13H17", key: "2nebdn" }]], WH = en("heading-5", KH);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const YH = [["path", { d: "M4 12h8", key: "17cfdx" }], ["path", { d: "M4 18V6", key: "1rz3zl" }], ["path", { d: "M12 18V6", key: "zqpxq5" }], ["circle", { cx: "19", cy: "16", r: "2", key: "15mx69" }], ["path", { d: "M20 10c-2 2-3 3.5-3 6", key: "f35dl0" }]], GH = en("heading-6", YH);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const XH = [["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2", key: "1m3agn" }], ["circle", { cx: "9", cy: "9", r: "2", key: "af1f0g" }], ["path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21", key: "1xmnt7" }]], tD = en("image", XH);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const QH = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "M12 16v-4", key: "1dtifu" }], ["path", { d: "M12 8h.01", key: "e9boi3" }]], JH = en("info", QH);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ZH = [["line", { x1: "19", x2: "10", y1: "4", y2: "4", key: "15jd3p" }], ["line", { x1: "14", x2: "5", y1: "20", y2: "20", key: "bu0au3" }], ["line", { x1: "15", x2: "9", y1: "4", y2: "20", key: "uljnxc" }]], Gw = en("italic", ZH);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const eq = [["path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71", key: "1cjeqo" }], ["path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71", key: "19qd67" }]], nD = en("link", eq);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const tq = [["path", { d: "M10 12h11", key: "6m4ad9" }], ["path", { d: "M10 18h11", key: "11hvi2" }], ["path", { d: "M10 6h11", key: "c7qv1k" }], ["path", { d: "M4 10h2", key: "16xx2s" }], ["path", { d: "M4 6h1v4", key: "cnovpq" }], ["path", { d: "M6 18H4c0-1 2-2 2-3s-1-1.5-2-1", key: "m9a95d" }]], Xw = en("list-ordered", tq);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const nq = [["path", { d: "M3 12h.01", key: "nlz23k" }], ["path", { d: "M3 18h.01", key: "1tta3j" }], ["path", { d: "M3 6h.01", key: "1rqtza" }], ["path", { d: "M8 12h13", key: "1za7za" }], ["path", { d: "M8 18h13", key: "1lx6n3" }], ["path", { d: "M8 6h13", key: "ik3vkj" }]], Qw = en("list", nq);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const rq = [["path", { d: "m8 6 4-4 4 4", key: "ybng9g" }], ["path", { d: "M12 2v10.3a4 4 0 0 1-1.172 2.872L4 22", key: "1hyw0i" }], ["path", { d: "m20 22-5-5", key: "1m27yz" }]], iq = en("merge", rq);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const sq = [["path", { d: "M5 12h14", key: "1ays0h" }]], rD = en("minus", sq);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const aq = [["path", { d: "M5 12h14", key: "1ays0h" }], ["path", { d: "M12 5v14", key: "s699le" }]], ZE = en("plus", aq);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const oq = [["path", { d: "M16 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z", key: "rib7q0" }], ["path", { d: "M5 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z", key: "1ymkrd" }]], iD = en("quote", oq);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const lq = [["path", { d: "M21 7v6h-6", key: "3ptur4" }], ["path", { d: "M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7", key: "1kgawr" }]], sD = en("redo", lq);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const cq = [["path", { d: "M16 3h5v5", key: "1806ms" }], ["path", { d: "M8 3H3v5", key: "15dfkv" }], ["path", { d: "M12 22v-8.3a4 4 0 0 0-1.172-2.872L3 3", key: "1qrqzj" }], ["path", { d: "m15 9 6-6", key: "ko1vev" }]], uq = en("split", cq);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const dq = [["path", { d: "M16 4H9a3 3 0 0 0-2.83 4", key: "43sutm" }], ["path", { d: "M14 12a4 4 0 0 1 0 8H6", key: "nlfj13" }], ["line", { x1: "4", x2: "20", y1: "12", y2: "12", key: "1e0a9i" }]], aD = en("strikethrough", dq);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const fq = [["path", { d: "M12 3v18", key: "108xh3" }], ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }], ["path", { d: "M3 9h18", key: "1pudct" }], ["path", { d: "M3 15h18", key: "5xshup" }]], hq = en("table", fq);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const pq = [["path", { d: "M3 6h18", key: "d0wm0j" }], ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }], ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }], ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }], ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]], xx = en("trash-2", pq);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const mq = [["path", { d: "M6 4v6a6 6 0 0 0 12 0V4", key: "9kb039" }], ["line", { x1: "4", x2: "20", y1: "20", y2: "20", key: "nun2al" }]], gq = en("underline", mq);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const yq = [["path", { d: "M3 7v6h6", key: "1v2h90" }], ["path", { d: "M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13", key: "1r6uu6" }]], oD = en("undo", yq);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const vq = [["path", { d: "m18.84 12.25 1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07 5.006 5.006 0 0 0-6.95 0l-1.72 1.71", key: "yqzxt4" }], ["path", { d: "m5.17 11.75-1.71 1.71a5.004 5.004 0 0 0 .12 7.07 5.006 5.006 0 0 0 6.95 0l1.71-1.71", key: "4qinb0" }], ["line", { x1: "8", x2: "8", y1: "2", y2: "5", key: "1041cp" }], ["line", { x1: "2", x2: "5", y1: "8", y2: "8", key: "14m1p5" }], ["line", { x1: "16", x2: "16", y1: "19", y2: "22", key: "rzdirn" }], ["line", { x1: "19", x2: "22", y1: "16", y2: "16", key: "ox905f" }]], lD = en("unlink", vq);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const xq = [["path", { d: "m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5", key: "ftymec" }], ["rect", { x: "2", y: "6", width: "14", height: "12", rx: "2", key: "158x01" }]], cD = en("video", xq);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const bq = [["path", { d: "M18 6 6 18", key: "1bl5f8" }], ["path", { d: "m6 6 12 12", key: "d8bk6v" }]], eA = en("x", bq);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const wq = [["path", { d: "M2.5 17a24.12 24.12 0 0 1 0-10 2 2 0 0 1 1.4-1.4 49.56 49.56 0 0 1 16.2 0A2 2 0 0 1 21.5 7a24.12 24.12 0 0 1 0 10 2 2 0 0 1-1.4 1.4 49.55 49.55 0 0 1-16.2 0A2 2 0 0 1 2.5 17", key: "1q2vi4" }], ["path", { d: "m10 15 5-3-5-3z", key: "1jp15x" }]], Sq = en("youtube", wq); function Cq() { const t = ln(), { data: e, isLoading: n } = Jt({ queryKey: ["currentUser"], queryFn: () => Ve.get("https://api.nexus.com/api/auth/me", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }); return d.jsx(d.Fragment, { children: d.jsx("div", { onClick: () => t("/user-setting"), className: "absolute top-5 right-5 h-11 w-11 flex justify-center items-center rounded-full bg-white cursor-pointer shadow-lg", children: e?.data?.data?.user?.profile_image ? d.jsx("img", { src: e?.data?.data?.user?.profile_image, alt: "Profile", className: "w-10 h-10 rounded-full object-cover border-gray-200" }) : d.jsx(FH, { className: "hover:scale-[1.04] transition-all" }) }) }) } function Tq() { const { sidebarOpen: t, setSidebarOpen: e } = N.useContext($w); return d.jsxs(d.Fragment, { children: [d.jsx(Cq, {}), d.jsxs("div", { className: "flex bg-base min-h-screen", children: [d.jsx("div", { className: `${t ? "md:w-56" : "w-0"} transition-all duration-500`, children: d.jsx(CH, {}) }), d.jsx("div", { className: `${t ? "w-full md:w-[calc(100%-224px)] ps-0" : "w-full"} md:p-5  text-black transition-all duration-500 bg-background`, children: d.jsx(kz, {}) })] })] }) } const Jw = N.createContext({}); function Zw(t) { const e = N.useRef(null); return e.current === null && (e.current = t()), e.current } const eS = typeof window < "u", uD = eS ? N.useLayoutEffect : N.useEffect, Cy = N.createContext(null); function tS(t, e) { t.indexOf(e) === -1 && t.push(e) } function nS(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } const $a = (t, e, n) => n > e ? e : n < t ? t : n; let rS = () => { }; const Ua = {}, dD = t => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t); function fD(t) { return typeof t == "object" && t !== null } const hD = t => /^0[^.\s]+$/u.test(t); function iS(t) { let e; return () => (e === void 0 && (e = t()), e) } const ls = t => t, Nq = (t, e) => n => e(t(n)), gh = (...t) => t.reduce(Nq), Pf = (t, e, n) => { const r = e - t; return r === 0 ? 1 : (n - t) / r }; class sS { constructor() { this.subscriptions = [] } add(e) { return tS(this.subscriptions, e), () => nS(this.subscriptions, e) } notify(e, n, r) { const i = this.subscriptions.length; if (i) if (i === 1) this.subscriptions[0](e, n, r); else for (let s = 0; s < i; s++) { const a = this.subscriptions[s]; a && a(e, n, r) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const Qs = t => t * 1e3, Js = t => t / 1e3; function pD(t, e) { return e ? t * (1e3 / e) : 0 } const mD = (t, e, n) => (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t, jq = 1e-7, Eq = 12; function Aq(t, e, n, r, i) { let s, a, l = 0; do a = e + (n - e) / 2, s = mD(a, r, i) - t, s > 0 ? n = a : e = a; while (Math.abs(s) > jq && ++l < Eq); return a } function yh(t, e, n, r) { if (t === e && n === r) return ls; const i = s => Aq(s, 0, 1, t, n); return s => s === 0 || s === 1 ? s : mD(i(s), e, r) } const gD = t => e => e <= .5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, yD = t => e => 1 - t(1 - e), vD = yh(.33, 1.53, .69, .99), aS = yD(vD), xD = gD(aS), bD = t => (t *= 2) < 1 ? .5 * aS(t) : .5 * (2 - Math.pow(2, -10 * (t - 1))), oS = t => 1 - Math.sin(Math.acos(t)), wD = yD(oS), SD = gD(oS), kq = yh(.42, 0, 1, 1), Oq = yh(0, 0, .58, 1), CD = yh(.42, 0, .58, 1), Mq = t => Array.isArray(t) && typeof t[0] != "number", TD = t => Array.isArray(t) && typeof t[0] == "number", Dq = { linear: ls, easeIn: kq, easeInOut: CD, easeOut: Oq, circIn: oS, circInOut: SD, circOut: wD, backIn: aS, backInOut: xD, backOut: vD, anticipate: bD }, Rq = t => typeof t == "string", tA = t => { if (TD(t)) { rS(t.length === 4); const [e, n, r, i] = t; return yh(e, n, r, i) } else if (Rq(t)) return Dq[t]; return t }, Vp = ["setup", "read", "resolveKeyframes", "preUpdate", "update", "preRender", "render", "postRender"], nA = { value: null }; function _q(t, e) { let n = new Set, r = new Set, i = !1, s = !1; const a = new WeakSet; let l = { delta: 0, timestamp: 0, isProcessing: !1 }, u = 0; function f(g) { a.has(g) && (p.schedule(g), t()), u++, g(l) } const p = { schedule: (g, y = !1, v = !1) => { const S = v && i ? n : r; return y && a.add(g), S.has(g) || S.add(g), g }, cancel: g => { r.delete(g), a.delete(g) }, process: g => { if (l = g, i) { s = !0; return } i = !0, [n, r] = [r, n], n.forEach(f), e && nA.value && nA.value.frameloop[e].push(u), u = 0, n.clear(), i = !1, s && (s = !1, p.process(g)) } }; return p } const Lq = 40; function ND(t, e) { let n = !1, r = !0; const i = { delta: 0, timestamp: 0, isProcessing: !1 }, s = () => n = !0, a = Vp.reduce((M, O) => (M[O] = _q(s, e ? O : void 0), M), {}), { setup: l, read: u, resolveKeyframes: f, preUpdate: p, update: g, preRender: y, render: v, postRender: b } = a, S = () => { const M = Ua.useManualTiming ? i.timestamp : performance.now(); n = !1, Ua.useManualTiming || (i.delta = r ? 1e3 / 60 : Math.max(Math.min(M - i.timestamp, Lq), 1)), i.timestamp = M, i.isProcessing = !0, l.process(i), u.process(i), f.process(i), p.process(i), g.process(i), y.process(i), v.process(i), b.process(i), i.isProcessing = !1, n && e && (r = !1, t(S)) }, C = () => { n = !0, r = !0, i.isProcessing || t(S) }; return { schedule: Vp.reduce((M, O) => { const E = a[O]; return M[O] = (k, z = !1, V = !1) => (n || C(), E.schedule(k, z, V)), M }, {}), cancel: M => { for (let O = 0; O < Vp.length; O++)a[Vp[O]].cancel(M) }, state: i, steps: a } } const { schedule: Bn, cancel: $o, state: Pr, steps: bx } = ND(typeof requestAnimationFrame < "u" ? requestAnimationFrame : ls, !0); let Nm; function Pq() { Nm = void 0 } const vi = { now: () => (Nm === void 0 && vi.set(Pr.isProcessing || Ua.useManualTiming ? Pr.timestamp : performance.now()), Nm), set: t => { Nm = t, queueMicrotask(Pq) } }, jD = t => e => typeof e == "string" && e.startsWith(t), lS = jD("--"), zq = jD("var(--"), cS = t => zq(t) ? Iq.test(t.split("/*")[0].trim()) : !1, Iq = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, Mu = { test: t => typeof t == "number", parse: parseFloat, transform: t => t }, zf = { ...Mu, transform: t => $a(0, 1, t) }, Hp = { ...Mu, default: 1 }, of = t => Math.round(t * 1e5) / 1e5, uS = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu; function Fq(t) { return t == null } const Bq = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, dS = (t, e) => n => !!(typeof n == "string" && Bq.test(n) && n.startsWith(t) || e && !Fq(n) && Object.prototype.hasOwnProperty.call(n, e)), ED = (t, e, n) => r => { if (typeof r != "string") return r; const [i, s, a, l] = r.match(uS); return { [t]: parseFloat(i), [e]: parseFloat(s), [n]: parseFloat(a), alpha: l !== void 0 ? parseFloat(l) : 1 } }, $q = t => $a(0, 255, t), wx = { ...Mu, transform: t => Math.round($q(t)) }, Ml = { test: dS("rgb", "red"), parse: ED("red", "green", "blue"), transform: ({ red: t, green: e, blue: n, alpha: r = 1 }) => "rgba(" + wx.transform(t) + ", " + wx.transform(e) + ", " + wx.transform(n) + ", " + of(zf.transform(r)) + ")" }; function Uq(t) { let e = "", n = "", r = "", i = ""; return t.length > 5 ? (e = t.substring(1, 3), n = t.substring(3, 5), r = t.substring(5, 7), i = t.substring(7, 9)) : (e = t.substring(1, 2), n = t.substring(2, 3), r = t.substring(3, 4), i = t.substring(4, 5), e += e, n += n, r += r, i += i), { red: parseInt(e, 16), green: parseInt(n, 16), blue: parseInt(r, 16), alpha: i ? parseInt(i, 16) / 255 : 1 } } const Qb = { test: dS("#"), parse: Uq, transform: Ml.transform }, vh = t => ({ test: e => typeof e == "string" && e.endsWith(t) && e.split(" ").length === 1, parse: parseFloat, transform: e => `${e}${t}` }), vo = vh("deg"), Zs = vh("%"), Rt = vh("px"), Vq = vh("vh"), Hq = vh("vw"), rA = { ...Zs, parse: t => Zs.parse(t) / 100, transform: t => Zs.transform(t * 100) }, nu = { test: dS("hsl", "hue"), parse: ED("hue", "saturation", "lightness"), transform: ({ hue: t, saturation: e, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(t) + ", " + Zs.transform(of(e)) + ", " + Zs.transform(of(n)) + ", " + of(zf.transform(r)) + ")" }, lr = { test: t => Ml.test(t) || Qb.test(t) || nu.test(t), parse: t => Ml.test(t) ? Ml.parse(t) : nu.test(t) ? nu.parse(t) : Qb.parse(t), transform: t => typeof t == "string" ? t : t.hasOwnProperty("red") ? Ml.transform(t) : nu.transform(t), getAnimatableNone: t => { const e = lr.parse(t); return e.alpha = 0, lr.transform(e) } }, qq = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; function Kq(t) { return isNaN(t) && typeof t == "string" && (t.match(uS)?.length || 0) + (t.match(qq)?.length || 0) > 0 } const AD = "number", kD = "color", Wq = "var", Yq = "var(", iA = "${}", Gq = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function If(t) { const e = t.toString(), n = [], r = { color: [], number: [], var: [] }, i = []; let s = 0; const l = e.replace(Gq, u => (lr.test(u) ? (r.color.push(s), i.push(kD), n.push(lr.parse(u))) : u.startsWith(Yq) ? (r.var.push(s), i.push(Wq), n.push(u)) : (r.number.push(s), i.push(AD), n.push(parseFloat(u))), ++s, iA)).split(iA); return { values: n, split: l, indexes: r, types: i } } function OD(t) { return If(t).values } function MD(t) { const { split: e, types: n } = If(t), r = e.length; return i => { let s = ""; for (let a = 0; a < r; a++)if (s += e[a], i[a] !== void 0) { const l = n[a]; l === AD ? s += of(i[a]) : l === kD ? s += lr.transform(i[a]) : s += i[a] } return s } } const Xq = t => typeof t == "number" ? 0 : lr.test(t) ? lr.getAnimatableNone(t) : t; function Qq(t) { const e = OD(t); return MD(t)(e.map(Xq)) } const Uo = { test: Kq, parse: OD, createTransformer: MD, getAnimatableNone: Qq }; function Sx(t, e, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t } function Jq({ hue: t, saturation: e, lightness: n, alpha: r }) { t /= 360, e /= 100, n /= 100; let i = 0, s = 0, a = 0; if (!e) i = s = a = n; else { const l = n < .5 ? n * (1 + e) : n + e - n * e, u = 2 * n - l; i = Sx(u, l, t + 1 / 3), s = Sx(u, l, t), a = Sx(u, l, t - 1 / 3) } return { red: Math.round(i * 255), green: Math.round(s * 255), blue: Math.round(a * 255), alpha: r } } function eg(t, e) { return n => n > 0 ? e : t } const Fn = (t, e, n) => t + (e - t) * n, Cx = (t, e, n) => { const r = t * t, i = n * (e * e - r) + r; return i < 0 ? 0 : Math.sqrt(i) }, Zq = [Qb, Ml, nu], eK = t => Zq.find(e => e.test(t)); function sA(t) { const e = eK(t); if (!e) return !1; let n = e.parse(t); return e === nu && (n = Jq(n)), n } const aA = (t, e) => { const n = sA(t), r = sA(e); if (!n || !r) return eg(t, e); const i = { ...n }; return s => (i.red = Cx(n.red, r.red, s), i.green = Cx(n.green, r.green, s), i.blue = Cx(n.blue, r.blue, s), i.alpha = Fn(n.alpha, r.alpha, s), Ml.transform(i)) }, Jb = new Set(["none", "hidden"]); function tK(t, e) { return Jb.has(t) ? n => n <= 0 ? t : e : n => n >= 1 ? e : t } function nK(t, e) { return n => Fn(t, e, n) } function fS(t) { return typeof t == "number" ? nK : typeof t == "string" ? cS(t) ? eg : lr.test(t) ? aA : sK : Array.isArray(t) ? DD : typeof t == "object" ? lr.test(t) ? aA : rK : eg } function DD(t, e) { const n = [...t], r = n.length, i = t.map((s, a) => fS(s)(s, e[a])); return s => { for (let a = 0; a < r; a++)n[a] = i[a](s); return n } } function rK(t, e) { const n = { ...t, ...e }, r = {}; for (const i in n) t[i] !== void 0 && e[i] !== void 0 && (r[i] = fS(t[i])(t[i], e[i])); return i => { for (const s in r) n[s] = r[s](i); return n } } function iK(t, e) { const n = [], r = { color: 0, var: 0, number: 0 }; for (let i = 0; i < e.values.length; i++) { const s = e.types[i], a = t.indexes[s][r[s]], l = t.values[a] ?? 0; n[i] = l, r[s]++ } return n } const sK = (t, e) => { const n = Uo.createTransformer(e), r = If(t), i = If(e); return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? Jb.has(t) && !i.values.length || Jb.has(e) && !r.values.length ? tK(t, e) : gh(DD(iK(r, i), i.values), n) : eg(t, e) }; function RD(t, e, n) { return typeof t == "number" && typeof e == "number" && typeof n == "number" ? Fn(t, e, n) : fS(t)(t, e) } const aK = t => { const e = ({ timestamp: n }) => t(n); return { start: (n = !0) => Bn.update(e, n), stop: () => $o(e), now: () => Pr.isProcessing ? Pr.timestamp : vi.now() } }, _D = (t, e, n = 10) => { let r = ""; const i = Math.max(Math.round(e / n), 2); for (let s = 0; s < i; s++)r += Math.round(t(s / (i - 1)) * 1e4) / 1e4 + ", "; return `linear(${r.substring(0, r.length - 2)})` }, tg = 2e4; function hS(t) { let e = 0; const n = 50; let r = t.next(e); for (; !r.done && e < tg;)e += n, r = t.next(e); return e >= tg ? 1 / 0 : e } function oK(t, e = 100, n) { const r = n({ ...t, keyframes: [0, e] }), i = Math.min(hS(r), tg); return { type: "keyframes", ease: s => r.next(i * s).value / e, duration: Js(i) } } const lK = 5; function LD(t, e, n) { const r = Math.max(e - lK, 0); return pD(n - t(r), e - r) } const Wn = { stiffness: 100, damping: 10, mass: 1, velocity: 0, duration: 800, bounce: .3, visualDuration: .3, restSpeed: { granular: .01, default: 2 }, restDelta: { granular: .005, default: .5 }, minDuration: .01, maxDuration: 10, minDamping: .05, maxDamping: 1 }, Tx = .001; function cK({ duration: t = Wn.duration, bounce: e = Wn.bounce, velocity: n = Wn.velocity, mass: r = Wn.mass }) { let i, s, a = 1 - e; a = $a(Wn.minDamping, Wn.maxDamping, a), t = $a(Wn.minDuration, Wn.maxDuration, Js(t)), a < 1 ? (i = f => { const p = f * a, g = p * t, y = p - n, v = Zb(f, a), b = Math.exp(-g); return Tx - y / v * b }, s = f => { const g = f * a * t, y = g * n + n, v = Math.pow(a, 2) * Math.pow(f, 2) * t, b = Math.exp(-g), S = Zb(Math.pow(f, 2), a); return (-i(f) + Tx > 0 ? -1 : 1) * ((y - v) * b) / S }) : (i = f => { const p = Math.exp(-f * t), g = (f - n) * t + 1; return -Tx + p * g }, s = f => { const p = Math.exp(-f * t), g = (n - f) * (t * t); return p * g }); const l = 5 / t, u = dK(i, s, l); if (t = Qs(t), isNaN(u)) return { stiffness: Wn.stiffness, damping: Wn.damping, duration: t }; { const f = Math.pow(u, 2) * r; return { stiffness: f, damping: a * 2 * Math.sqrt(r * f), duration: t } } } const uK = 12; function dK(t, e, n) { let r = n; for (let i = 1; i < uK; i++)r = r - t(r) / e(r); return r } function Zb(t, e) { return t * Math.sqrt(1 - e * e) } const fK = ["duration", "bounce"], hK = ["stiffness", "damping", "mass"]; function oA(t, e) { return e.some(n => t[n] !== void 0) } function pK(t) { let e = { velocity: Wn.velocity, stiffness: Wn.stiffness, damping: Wn.damping, mass: Wn.mass, isResolvedFromDuration: !1, ...t }; if (!oA(t, hK) && oA(t, fK)) if (t.visualDuration) { const n = t.visualDuration, r = 2 * Math.PI / (n * 1.2), i = r * r, s = 2 * $a(.05, 1, 1 - (t.bounce || 0)) * Math.sqrt(i); e = { ...e, mass: Wn.mass, stiffness: i, damping: s } } else { const n = cK(t); e = { ...e, ...n, mass: Wn.mass }, e.isResolvedFromDuration = !0 } return e } function ng(t = Wn.visualDuration, e = Wn.bounce) { const n = typeof t != "object" ? { visualDuration: t, keyframes: [0, 1], bounce: e } : t; let { restSpeed: r, restDelta: i } = n; const s = n.keyframes[0], a = n.keyframes[n.keyframes.length - 1], l = { done: !1, value: s }, { stiffness: u, damping: f, mass: p, duration: g, velocity: y, isResolvedFromDuration: v } = pK({ ...n, velocity: -Js(n.velocity || 0) }), b = y || 0, S = f / (2 * Math.sqrt(u * p)), C = a - s, T = Js(Math.sqrt(u / p)), A = Math.abs(C) < 5; r || (r = A ? Wn.restSpeed.granular : Wn.restSpeed.default), i || (i = A ? Wn.restDelta.granular : Wn.restDelta.default); let M; if (S < 1) { const E = Zb(T, S); M = k => { const z = Math.exp(-S * T * k); return a - z * ((b + S * T * C) / E * Math.sin(E * k) + C * Math.cos(E * k)) } } else if (S === 1) M = E => a - Math.exp(-T * E) * (C + (b + T * C) * E); else { const E = T * Math.sqrt(S * S - 1); M = k => { const z = Math.exp(-S * T * k), V = Math.min(E * k, 300); return a - z * ((b + S * T * C) * Math.sinh(V) + E * C * Math.cosh(V)) / E } } const O = { calculatedDuration: v && g || null, next: E => { const k = M(E); if (v) l.done = E >= g; else { let z = E === 0 ? b : 0; S < 1 && (z = E === 0 ? Qs(b) : LD(M, E, k)); const V = Math.abs(z) <= r, q = Math.abs(a - k) <= i; l.done = V && q } return l.value = l.done ? a : k, l }, toString: () => { const E = Math.min(hS(O), tg), k = _D(z => O.next(E * z).value, E, 30); return E + "ms " + k }, toTransition: () => { } }; return O } ng.applyToOptions = t => { const e = oK(t, 100, ng); return t.ease = e.ease, t.duration = Qs(e.duration), t.type = "keyframes", t }; function e1({ keyframes: t, velocity: e = 0, power: n = .8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: s = 500, modifyTarget: a, min: l, max: u, restDelta: f = .5, restSpeed: p }) { const g = t[0], y = { done: !1, value: g }, v = V => l !== void 0 && V < l || u !== void 0 && V > u, b = V => l === void 0 ? u : u === void 0 || Math.abs(l - V) < Math.abs(u - V) ? l : u; let S = n * e; const C = g + S, T = a === void 0 ? C : a(C); T !== C && (S = T - g); const A = V => -S * Math.exp(-V / r), M = V => T + A(V), O = V => { const q = A(V), ue = M(V); y.done = Math.abs(q) <= f, y.value = y.done ? T : ue }; let E, k; const z = V => { v(y.value) && (E = V, k = ng({ keyframes: [y.value, b(y.value)], velocity: LD(M, V, y.value), damping: i, stiffness: s, restDelta: f, restSpeed: p })) }; return z(0), { calculatedDuration: null, next: V => { let q = !1; return !k && E === void 0 && (q = !0, O(V), z(V)), E !== void 0 && V >= E ? k.next(V - E) : (!q && O(V), y) } } } function mK(t, e, n) { const r = [], i = n || Ua.mix || RD, s = t.length - 1; for (let a = 0; a < s; a++) { let l = i(t[a], t[a + 1]); if (e) { const u = Array.isArray(e) ? e[a] || ls : e; l = gh(u, l) } r.push(l) } return r } function gK(t, e, { clamp: n = !0, ease: r, mixer: i } = {}) { const s = t.length; if (rS(s === e.length), s === 1) return () => e[0]; if (s === 2 && e[0] === e[1]) return () => e[1]; const a = t[0] === t[1]; t[0] > t[s - 1] && (t = [...t].reverse(), e = [...e].reverse()); const l = mK(e, r, i), u = l.length, f = p => { if (a && p < t[0]) return e[0]; let g = 0; if (u > 1) for (; g < t.length - 2 && !(p < t[g + 1]); g++); const y = Pf(t[g], t[g + 1], p); return l[g](y) }; return n ? p => f($a(t[0], t[s - 1], p)) : f } function yK(t, e) { const n = t[t.length - 1]; for (let r = 1; r <= e; r++) { const i = Pf(0, e, r); t.push(Fn(n, 1, i)) } } function vK(t) { const e = [0]; return yK(e, t.length - 1), e } function xK(t, e) { return t.map(n => n * e) } function bK(t, e) { return t.map(() => e || CD).splice(0, t.length - 1) } function lf({ duration: t = 300, keyframes: e, times: n, ease: r = "easeInOut" }) { const i = Mq(r) ? r.map(tA) : tA(r), s = { done: !1, value: e[0] }, a = xK(n && n.length === e.length ? n : vK(e), t), l = gK(a, e, { ease: Array.isArray(i) ? i : bK(e, i) }); return { calculatedDuration: t, next: u => (s.value = l(u), s.done = u >= t, s) } } const wK = t => t !== null; function pS(t, { repeat: e, repeatType: n = "loop" }, r, i = 1) { const s = t.filter(wK), l = i < 0 || e && n !== "loop" && e % 2 === 1 ? 0 : s.length - 1; return !l || r === void 0 ? s[l] : r } const SK = { decay: e1, inertia: e1, tween: lf, keyframes: lf, spring: ng }; function PD(t) { typeof t.type == "string" && (t.type = SK[t.type]) } class mS { constructor() { this.updateFinished() } get finished() { return this._finished } updateFinished() { this._finished = new Promise(e => { this.resolve = e }) } notifyFinished() { this.resolve() } then(e, n) { return this.finished.then(e, n) } } const CK = t => t / 100; class gS extends mS { constructor(e) { super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => { const { motionValue: n } = this.options; n && n.updatedAt !== vi.now() && this.tick(vi.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), this.options.onStop?.()) }, this.options = e, this.initAnimation(), this.play(), e.autoplay === !1 && this.pause() } initAnimation() { const { options: e } = this; PD(e); const { type: n = lf, repeat: r = 0, repeatDelay: i = 0, repeatType: s, velocity: a = 0 } = e; let { keyframes: l } = e; const u = n || lf; u !== lf && typeof l[0] != "number" && (this.mixKeyframes = gh(CK, RD(l[0], l[1])), l = [0, 100]); const f = u({ ...e, keyframes: l }); s === "mirror" && (this.mirroredGenerator = u({ ...e, keyframes: [...l].reverse(), velocity: -a })), f.calculatedDuration === null && (f.calculatedDuration = hS(f)); const { calculatedDuration: p } = f; this.calculatedDuration = p, this.resolvedDuration = p + i, this.totalDuration = this.resolvedDuration * (r + 1) - i, this.generator = f } updateTime(e) { const n = Math.round(e - this.startTime) * this.playbackSpeed; this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n } tick(e, n = !1) { const { generator: r, totalDuration: i, mixKeyframes: s, mirroredGenerator: a, resolvedDuration: l, calculatedDuration: u } = this; if (this.startTime === null) return r.next(0); const { delay: f = 0, keyframes: p, repeat: g, repeatType: y, repeatDelay: v, type: b, onUpdate: S, finalKeyframe: C } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - i / this.speed, this.startTime)), n ? this.currentTime = e : this.updateTime(e); const T = this.currentTime - f * (this.playbackSpeed >= 0 ? 1 : -1), A = this.playbackSpeed >= 0 ? T < 0 : T > i; this.currentTime = Math.max(T, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = i); let M = this.currentTime, O = r; if (g) { const V = Math.min(this.currentTime, i) / l; let q = Math.floor(V), ue = V % 1; !ue && V >= 1 && (ue = 1), ue === 1 && q--, q = Math.min(q, g + 1), !!(q % 2) && (y === "reverse" ? (ue = 1 - ue, v && (ue -= v / l)) : y === "mirror" && (O = a)), M = $a(0, 1, ue) * l } const E = A ? { done: !1, value: p[0] } : O.next(M); s && (E.value = s(E.value)); let { done: k } = E; !A && u !== null && (k = this.playbackSpeed >= 0 ? this.currentTime >= i : this.currentTime <= 0); const z = this.holdTime === null && (this.state === "finished" || this.state === "running" && k); return z && b !== e1 && (E.value = pS(p, this.options, C, this.speed)), S && S(E.value), z && this.finish(), E } then(e, n) { return this.finished.then(e, n) } get duration() { return Js(this.calculatedDuration) } get time() { return Js(this.currentTime) } set time(e) { e = Qs(e), this.currentTime = e, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.playbackSpeed), this.driver?.start(!1) } get speed() { return this.playbackSpeed } set speed(e) { this.updateTime(vi.now()); const n = this.playbackSpeed !== e; this.playbackSpeed = e, n && (this.time = Js(this.currentTime)) } play() { if (this.isStopped) return; const { driver: e = aK, startTime: n } = this.options; this.driver || (this.driver = e(i => this.tick(i))), this.options.onPlay?.(); const r = this.driver.now(); this.state === "finished" ? (this.updateFinished(), this.startTime = r) : this.holdTime !== null ? this.startTime = r - this.holdTime : this.startTime || (this.startTime = n ?? r), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start() } pause() { this.state = "paused", this.updateTime(vi.now()), this.holdTime = this.currentTime } complete() { this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null } finish() { this.notifyFinished(), this.teardown(), this.state = "finished", this.options.onComplete?.() } cancel() { this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), this.options.onCancel?.() } teardown() { this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(e) { return this.startTime = 0, this.tick(e, !0) } attachTimeline(e) { return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), this.driver?.stop(), e.observe(this) } } function TK(t) { for (let e = 1; e < t.length; e++)t[e] ?? (t[e] = t[e - 1]) } const Dl = t => t * 180 / Math.PI, t1 = t => { const e = Dl(Math.atan2(t[1], t[0])); return n1(e) }, NK = { x: 4, y: 5, translateX: 4, translateY: 5, scaleX: 0, scaleY: 3, scale: t => (Math.abs(t[0]) + Math.abs(t[3])) / 2, rotate: t1, rotateZ: t1, skewX: t => Dl(Math.atan(t[1])), skewY: t => Dl(Math.atan(t[2])), skew: t => (Math.abs(t[1]) + Math.abs(t[2])) / 2 }, n1 = t => (t = t % 360, t < 0 && (t += 360), t), lA = t1, cA = t => Math.sqrt(t[0] * t[0] + t[1] * t[1]), uA = t => Math.sqrt(t[4] * t[4] + t[5] * t[5]), jK = { x: 12, y: 13, z: 14, translateX: 12, translateY: 13, translateZ: 14, scaleX: cA, scaleY: uA, scale: t => (cA(t) + uA(t)) / 2, rotateX: t => n1(Dl(Math.atan2(t[6], t[5]))), rotateY: t => n1(Dl(Math.atan2(-t[2], t[0]))), rotateZ: lA, rotate: lA, skewX: t => Dl(Math.atan(t[4])), skewY: t => Dl(Math.atan(t[1])), skew: t => (Math.abs(t[1]) + Math.abs(t[4])) / 2 }; function r1(t) { return t.includes("scale") ? 1 : 0 } function i1(t, e) { if (!t || t === "none") return r1(e); const n = t.match(/^matrix3d\(([-\d.e\s,]+)\)$/u); let r, i; if (n) r = jK, i = n; else { const l = t.match(/^matrix\(([-\d.e\s,]+)\)$/u); r = NK, i = l } if (!i) return r1(e); const s = r[e], a = i[1].split(",").map(AK); return typeof s == "function" ? s(a) : a[s] } const EK = (t, e) => { const { transform: n = "none" } = getComputedStyle(t); return i1(n, e) }; function AK(t) { return parseFloat(t.trim()) } const Du = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], Ru = new Set(Du), dA = t => t === Mu || t === Rt, kK = new Set(["x", "y", "z"]), OK = Du.filter(t => !kK.has(t)); function MK(t) { const e = []; return OK.forEach(n => { const r = t.getValue(n); r !== void 0 && (e.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0)) }), e } const Bl = { width: ({ x: t }, { paddingLeft: e = "0", paddingRight: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n), height: ({ y: t }, { paddingTop: e = "0", paddingBottom: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n), top: (t, { top: e }) => parseFloat(e), left: (t, { left: e }) => parseFloat(e), bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min), right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min), x: (t, { transform: e }) => i1(e, "x"), y: (t, { transform: e }) => i1(e, "y") }; Bl.translateX = Bl.x; Bl.translateY = Bl.y; const $l = new Set; let s1 = !1, a1 = !1, o1 = !1; function zD() { if (a1) { const t = Array.from($l).filter(r => r.needsMeasurement), e = new Set(t.map(r => r.element)), n = new Map; e.forEach(r => { const i = MK(r); i.length && (n.set(r, i), r.render()) }), t.forEach(r => r.measureInitialState()), e.forEach(r => { r.render(); const i = n.get(r); i && i.forEach(([s, a]) => { r.getValue(s)?.set(a) }) }), t.forEach(r => r.measureEndState()), t.forEach(r => { r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY) }) } a1 = !1, s1 = !1, $l.forEach(t => t.complete(o1)), $l.clear() } function ID() { $l.forEach(t => { t.readKeyframes(), t.needsMeasurement && (a1 = !0) }) } function DK() { o1 = !0, ID(), zD(), o1 = !1 } class yS { constructor(e, n, r, i, s, a = !1) { this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...e], this.onComplete = n, this.name = r, this.motionValue = i, this.element = s, this.isAsync = a } scheduleResolve() { this.state = "scheduled", this.isAsync ? ($l.add(this), s1 || (s1 = !0, Bn.read(ID), Bn.resolveKeyframes(zD))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: e, name: n, element: r, motionValue: i } = this; if (e[0] === null) { const s = i?.get(), a = e[e.length - 1]; if (s !== void 0) e[0] = s; else if (r && n) { const l = r.readValue(n, a); l != null && (e[0] = l) } e[0] === void 0 && (e[0] = a), i && s === void 0 && i.set(e[0]) } TK(e) } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete(e = !1) { this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, e), $l.delete(this) } cancel() { this.state === "scheduled" && ($l.delete(this), this.state = "pending") } resume() { this.state === "pending" && this.scheduleResolve() } } const RK = t => t.startsWith("--"); function _K(t, e, n) { RK(e) ? t.style.setProperty(e, n) : t.style[e] = n } const LK = iS(() => window.ScrollTimeline !== void 0), PK = {}; function zK(t, e) { const n = iS(t); return () => PK[e] ?? n() } const FD = zK(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch { return !1 } return !0 }, "linearEasing"), Qd = ([t, e, n, r]) => `cubic-bezier(${t}, ${e}, ${n}, ${r})`, fA = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: Qd([0, .65, .55, 1]), circOut: Qd([.55, 0, 1, .45]), backIn: Qd([.31, .01, .66, -.59]), backOut: Qd([.33, 1.53, .69, .99]) }; function BD(t, e) { if (t) return typeof t == "function" ? FD() ? _D(t, e) : "ease-out" : TD(t) ? Qd(t) : Array.isArray(t) ? t.map(n => BD(n, e) || fA.easeOut) : fA[t] } function IK(t, e, n, { delay: r = 0, duration: i = 300, repeat: s = 0, repeatType: a = "loop", ease: l = "easeOut", times: u } = {}, f = void 0) { const p = { [e]: n }; u && (p.offset = u); const g = BD(l, i); Array.isArray(g) && (p.easing = g); const y = { delay: r, duration: i, easing: Array.isArray(g) ? "linear" : g, fill: "both", iterations: s + 1, direction: a === "reverse" ? "alternate" : "normal" }; return f && (y.pseudoElement = f), t.animate(p, y) } function $D(t) { return typeof t == "function" && "applyToOptions" in t } function FK({ type: t, ...e }) { return $D(t) && FD() ? t.applyToOptions(e) : (e.duration ?? (e.duration = 300), e.ease ?? (e.ease = "easeOut"), e) } class BK extends mS { constructor(e) { if (super(), this.finishedTime = null, this.isStopped = !1, !e) return; const { element: n, name: r, keyframes: i, pseudoElement: s, allowFlatten: a = !1, finalKeyframe: l, onComplete: u } = e; this.isPseudoElement = !!s, this.allowFlatten = a, this.options = e, rS(typeof e.type != "string"); const f = FK(e); this.animation = IK(n, r, i, f, s), f.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => { if (this.finishedTime = this.time, !s) { const p = pS(i, this.options, l, this.speed); this.updateMotionValue ? this.updateMotionValue(p) : _K(n, r, p), this.animation.cancel() } u?.(), this.notifyFinished() } } play() { this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished()) } pause() { this.animation.pause() } complete() { this.animation.finish?.() } cancel() { try { this.animation.cancel() } catch { } } stop() { if (this.isStopped) return; this.isStopped = !0; const { state: e } = this; e === "idle" || e === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel()) } commitStyles() { this.isPseudoElement || this.animation.commitStyles?.() } get duration() { const e = this.animation.effect?.getComputedTiming?.().duration || 0; return Js(Number(e)) } get time() { return Js(Number(this.animation.currentTime) || 0) } set time(e) { this.finishedTime = null, this.animation.currentTime = Qs(e) } get speed() { return this.animation.playbackRate } set speed(e) { e < 0 && (this.finishedTime = null), this.animation.playbackRate = e } get state() { return this.finishedTime !== null ? "finished" : this.animation.playState } get startTime() { return Number(this.animation.startTime) } set startTime(e) { this.animation.startTime = e } attachTimeline({ timeline: e, observe: n }) { return this.allowFlatten && this.animation.effect?.updateTiming({ easing: "linear" }), this.animation.onfinish = null, e && LK() ? (this.animation.timeline = e, ls) : n(this) } } const UD = { anticipate: bD, backInOut: xD, circInOut: SD }; function $K(t) { return t in UD } function UK(t) { typeof t.ease == "string" && $K(t.ease) && (t.ease = UD[t.ease]) } const hA = 10; class VK extends BK { constructor(e) { UK(e), PD(e), super(e), e.startTime && (this.startTime = e.startTime), this.options = e } updateMotionValue(e) { const { motionValue: n, onUpdate: r, onComplete: i, element: s, ...a } = this.options; if (!n) return; if (e !== void 0) { n.set(e); return } const l = new gS({ ...a, autoplay: !1 }), u = Qs(this.finishedTime ?? this.time); n.setWithVelocity(l.sample(u - hA).value, l.sample(u).value, hA), l.stop() } } const pA = (t, e) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && (Uo.test(t) || t === "0") && !t.startsWith("url(")); function HK(t) { const e = t[0]; if (t.length === 1) return !0; for (let n = 0; n < t.length; n++)if (t[n] !== e) return !0 } function qK(t, e, n, r) { const i = t[0]; if (i === null) return !1; if (e === "display" || e === "visibility") return !0; const s = t[t.length - 1], a = pA(i, e), l = pA(s, e); return !a || !l ? !1 : HK(t) || (n === "spring" || $D(n)) && r } function vS(t) { return fD(t) && "offsetHeight" in t } const KK = new Set(["opacity", "clipPath", "filter", "transform"]), WK = iS(() => Object.hasOwnProperty.call(Element.prototype, "animate")); function YK(t) { const { motionValue: e, name: n, repeatDelay: r, repeatType: i, damping: s, type: a } = t; if (!vS(e?.owner?.current)) return !1; const { onUpdate: l, transformTemplate: u } = e.owner.getProps(); return WK() && n && KK.has(n) && (n !== "transform" || !u) && !l && !r && i !== "mirror" && s !== 0 && a !== "inertia" } const GK = 40; class XK extends mS { constructor({ autoplay: e = !0, delay: n = 0, type: r = "keyframes", repeat: i = 0, repeatDelay: s = 0, repeatType: a = "loop", keyframes: l, name: u, motionValue: f, element: p, ...g }) { super(), this.stop = () => { this._animation && (this._animation.stop(), this.stopTimeline?.()), this.keyframeResolver?.cancel() }, this.createdAt = vi.now(); const y = { autoplay: e, delay: n, type: r, repeat: i, repeatDelay: s, repeatType: a, name: u, motionValue: f, element: p, ...g }, v = p?.KeyframeResolver || yS; this.keyframeResolver = new v(l, (b, S, C) => this.onKeyframesResolved(b, S, y, !C), u, f, p), this.keyframeResolver?.scheduleResolve() } onKeyframesResolved(e, n, r, i) { this.keyframeResolver = void 0; const { name: s, type: a, velocity: l, delay: u, isHandoff: f, onUpdate: p } = r; this.resolvedAt = vi.now(), qK(e, s, a, l) || ((Ua.instantAnimations || !u) && p?.(pS(e, r, n)), e[0] = e[e.length - 1], r.duration = 0, r.repeat = 0); const y = { startTime: i ? this.resolvedAt ? this.resolvedAt - this.createdAt > GK ? this.resolvedAt : this.createdAt : this.createdAt : void 0, finalKeyframe: n, ...r, keyframes: e }, v = !f && YK(y) ? new VK({ ...y, element: y.motionValue.owner.current }) : new gS(y); v.finished.then(() => this.notifyFinished()).catch(ls), this.pendingTimeline && (this.stopTimeline = v.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = v } get finished() { return this._animation ? this.animation.finished : this._finished } then(e, n) { return this.finished.finally(e).then(() => { }) } get animation() { return this._animation || (this.keyframeResolver?.resume(), DK()), this._animation } get duration() { return this.animation.duration } get time() { return this.animation.time } set time(e) { this.animation.time = e } get speed() { return this.animation.speed } get state() { return this.animation.state } set speed(e) { this.animation.speed = e } get startTime() { return this.animation.startTime } attachTimeline(e) { return this._animation ? this.stopTimeline = this.animation.attachTimeline(e) : this.pendingTimeline = e, () => this.stop() } play() { this.animation.play() } pause() { this.animation.pause() } complete() { this.animation.complete() } cancel() { this._animation && this.animation.cancel(), this.keyframeResolver?.cancel() } } const QK = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function JK(t) { const e = QK.exec(t); if (!e) return [,]; const [, n, r, i] = e; return [`--${n ?? r}`, i] } function VD(t, e, n = 1) { const [r, i] = JK(t); if (!r) return; const s = window.getComputedStyle(e).getPropertyValue(r); if (s) { const a = s.trim(); return dD(a) ? parseFloat(a) : a } return cS(i) ? VD(i, e, n + 1) : i } function xS(t, e) { return t?.[e] ?? t?.default ?? t } const HD = new Set(["width", "height", "top", "left", "right", "bottom", ...Du]), ZK = { test: t => t === "auto", parse: t => t }, qD = t => e => e.test(t), KD = [Mu, Rt, Zs, vo, Hq, Vq, ZK], mA = t => KD.find(qD(t)); function eW(t) { return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || hD(t) : !0 } const tW = new Set(["brightness", "contrast", "saturate", "opacity"]); function nW(t) { const [e, n] = t.slice(0, -1).split("("); if (e === "drop-shadow") return t; const [r] = n.match(uS) || []; if (!r) return t; const i = n.replace(r, ""); let s = tW.has(e) ? 1 : 0; return r !== n && (s *= 100), e + "(" + s + i + ")" } const rW = /\b([a-z-]*)\(.*?\)/gu, l1 = { ...Uo, getAnimatableNone: t => { const e = t.match(rW); return e ? e.map(nW).join(" ") : t } }, gA = { ...Mu, transform: Math.round }, iW = { rotate: vo, rotateX: vo, rotateY: vo, rotateZ: vo, scale: Hp, scaleX: Hp, scaleY: Hp, scaleZ: Hp, skew: vo, skewX: vo, skewY: vo, distance: Rt, translateX: Rt, translateY: Rt, translateZ: Rt, x: Rt, y: Rt, z: Rt, perspective: Rt, transformPerspective: Rt, opacity: zf, originX: rA, originY: rA, originZ: Rt }, bS = { borderWidth: Rt, borderTopWidth: Rt, borderRightWidth: Rt, borderBottomWidth: Rt, borderLeftWidth: Rt, borderRadius: Rt, radius: Rt, borderTopLeftRadius: Rt, borderTopRightRadius: Rt, borderBottomRightRadius: Rt, borderBottomLeftRadius: Rt, width: Rt, maxWidth: Rt, height: Rt, maxHeight: Rt, top: Rt, right: Rt, bottom: Rt, left: Rt, padding: Rt, paddingTop: Rt, paddingRight: Rt, paddingBottom: Rt, paddingLeft: Rt, margin: Rt, marginTop: Rt, marginRight: Rt, marginBottom: Rt, marginLeft: Rt, backgroundPositionX: Rt, backgroundPositionY: Rt, ...iW, zIndex: gA, fillOpacity: zf, strokeOpacity: zf, numOctaves: gA }, sW = { ...bS, color: lr, backgroundColor: lr, outlineColor: lr, fill: lr, stroke: lr, borderColor: lr, borderTopColor: lr, borderRightColor: lr, borderBottomColor: lr, borderLeftColor: lr, filter: l1, WebkitFilter: l1 }, WD = t => sW[t]; function YD(t, e) { let n = WD(t); return n !== l1 && (n = Uo), n.getAnimatableNone ? n.getAnimatableNone(e) : void 0 } const aW = new Set(["auto", "none", "0"]); function oW(t, e, n) { let r = 0, i; for (; r < t.length && !i;) { const s = t[r]; typeof s == "string" && !aW.has(s) && If(s).values.length && (i = t[r]), r++ } if (i && n) for (const s of e) t[s] = YD(n, i) } class lW extends yS { constructor(e, n, r, i, s) { super(e, n, r, i, s, !0) } readKeyframes() { const { unresolvedKeyframes: e, element: n, name: r } = this; if (!n || !n.current) return; super.readKeyframes(); for (let u = 0; u < e.length; u++) { let f = e[u]; if (typeof f == "string" && (f = f.trim(), cS(f))) { const p = VD(f, n.current); p !== void 0 && (e[u] = p), u === e.length - 1 && (this.finalKeyframe = f) } } if (this.resolveNoneKeyframes(), !HD.has(r) || e.length !== 2) return; const [i, s] = e, a = mA(i), l = mA(s); if (a !== l) if (dA(a) && dA(l)) for (let u = 0; u < e.length; u++) { const f = e[u]; typeof f == "string" && (e[u] = parseFloat(f)) } else Bl[r] && (this.needsMeasurement = !0) } resolveNoneKeyframes() { const { unresolvedKeyframes: e, name: n } = this, r = []; for (let i = 0; i < e.length; i++)(e[i] === null || eW(e[i])) && r.push(i); r.length && oW(e, r, n) } measureInitialState() { const { element: e, unresolvedKeyframes: n, name: r } = this; if (!e || !e.current) return; r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Bl[r](e.measureViewportBox(), window.getComputedStyle(e.current)), n[0] = this.measuredOrigin; const i = n[n.length - 1]; i !== void 0 && e.getValue(r, i).jump(i, !1) } measureEndState() { const { element: e, name: n, unresolvedKeyframes: r } = this; if (!e || !e.current) return; const i = e.getValue(n); i && i.jump(this.measuredOrigin, !1); const s = r.length - 1, a = r[s]; r[s] = Bl[n](e.measureViewportBox(), window.getComputedStyle(e.current)), a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a), this.removedTransforms?.length && this.removedTransforms.forEach(([l, u]) => { e.getValue(l).set(u) }), this.resolveNoneKeyframes() } } function cW(t, e, n) { if (t instanceof EventTarget) return [t]; if (typeof t == "string") { let r = document; const i = n?.[t] ?? r.querySelectorAll(t); return i ? Array.from(i) : [] } return Array.from(t) } const GD = (t, e) => e && typeof t == "number" ? e.transform(t) : t, yA = 30, uW = t => !isNaN(parseFloat(t)); class dW { constructor(e, n = {}) { this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r, i = !0) => { const s = vi.now(); if (this.updatedAt !== s && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && (this.events.change?.notify(this.current), this.dependents)) for (const a of this.dependents) a.dirty(); i && this.events.renderRequest?.notify(this.current) }, this.hasAnimated = !1, this.setCurrent(e), this.owner = n.owner } setCurrent(e) { this.current = e, this.updatedAt = vi.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = uW(this.current)) } setPrevFrameValue(e = this.current) { this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt } onChange(e) { return this.on("change", e) } on(e, n) { this.events[e] || (this.events[e] = new sS); const r = this.events[e].add(n); return e === "change" ? () => { r(), Bn.read(() => { this.events.change.getSize() || this.stop() }) } : r } clearListeners() { for (const e in this.events) this.events[e].clear() } attach(e, n) { this.passiveEffect = e, this.stopPassiveEffect = n } set(e, n = !0) { !n || !this.passiveEffect ? this.updateAndNotify(e, n) : this.passiveEffect(e, this.updateAndNotify) } setWithVelocity(e, n, r) { this.set(n), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - r } jump(e, n = !0) { this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } dirty() { this.events.change?.notify(this.current) } addDependent(e) { this.dependents || (this.dependents = new Set), this.dependents.add(e) } removeDependent(e) { this.dependents && this.dependents.delete(e) } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const e = vi.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > yA) return 0; const n = Math.min(this.updatedAt - this.prevUpdatedAt, yA); return pD(parseFloat(this.current) - parseFloat(this.prevFrameValue), n) } start(e) { return this.stop(), new Promise(n => { this.hasAnimated = !0, this.animation = e(n), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.dependents?.clear(), this.events.destroy?.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function pu(t, e) { return new dW(t, e) } const { schedule: wS } = ND(queueMicrotask, !1), vs = { x: !1, y: !1 }; function XD() { return vs.x || vs.y } function fW(t) { return t === "x" || t === "y" ? vs[t] ? null : (vs[t] = !0, () => { vs[t] = !1 }) : vs.x || vs.y ? null : (vs.x = vs.y = !0, () => { vs.x = vs.y = !1 }) } function QD(t, e) { const n = cW(t), r = new AbortController, i = { passive: !0, ...e, signal: r.signal }; return [n, i, () => r.abort()] } function vA(t) { return !(t.pointerType === "touch" || XD()) } function hW(t, e, n = {}) { const [r, i, s] = QD(t, n), a = l => { if (!vA(l)) return; const { target: u } = l, f = e(u, l); if (typeof f != "function" || !u) return; const p = g => { vA(g) && (f(g), u.removeEventListener("pointerleave", p)) }; u.addEventListener("pointerleave", p, i) }; return r.forEach(l => { l.addEventListener("pointerenter", a, i) }), s } const JD = (t, e) => e ? t === e ? !0 : JD(t, e.parentElement) : !1, SS = t => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1, pW = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]); function mW(t) { return pW.has(t.tagName) || t.tabIndex !== -1 } const jm = new WeakSet; function xA(t) { return e => { e.key === "Enter" && t(e) } } function Nx(t, e) { t.dispatchEvent(new PointerEvent("pointer" + e, { isPrimary: !0, bubbles: !0 })) } const gW = (t, e) => { const n = t.currentTarget; if (!n) return; const r = xA(() => { if (jm.has(n)) return; Nx(n, "down"); const i = xA(() => { Nx(n, "up") }), s = () => Nx(n, "cancel"); n.addEventListener("keyup", i, e), n.addEventListener("blur", s, e) }); n.addEventListener("keydown", r, e), n.addEventListener("blur", () => n.removeEventListener("keydown", r), e) }; function bA(t) { return SS(t) && !XD() } function yW(t, e, n = {}) { const [r, i, s] = QD(t, n), a = l => { const u = l.currentTarget; if (!bA(l)) return; jm.add(u); const f = e(u, l), p = (v, b) => { window.removeEventListener("pointerup", g), window.removeEventListener("pointercancel", y), jm.has(u) && jm.delete(u), bA(v) && typeof f == "function" && f(v, { success: b }) }, g = v => { p(v, u === window || u === document || n.useGlobalTarget || JD(u, v.target)) }, y = v => { p(v, !1) }; window.addEventListener("pointerup", g, i), window.addEventListener("pointercancel", y, i) }; return r.forEach(l => { (n.useGlobalTarget ? window : l).addEventListener("pointerdown", a, i), vS(l) && (l.addEventListener("focus", f => gW(f, i)), !mW(l) && !l.hasAttribute("tabindex") && (l.tabIndex = 0)) }), s } function ZD(t) { return fD(t) && "ownerSVGElement" in t } function vW(t) { return ZD(t) && t.tagName === "svg" } const Yr = t => !!(t && t.getVelocity), xW = [...KD, lr, Uo], bW = t => xW.find(qD(t)), CS = N.createContext({ transformPagePoint: t => t, isStatic: !1, reducedMotion: "never" }); class wW extends N.Component { getSnapshotBeforeUpdate(e) { const n = this.props.childRef.current; if (n && e.isPresent && !this.props.isPresent) { const r = n.offsetParent, i = vS(r) && r.offsetWidth || 0, s = this.props.sizeRef.current; s.height = n.offsetHeight || 0, s.width = n.offsetWidth || 0, s.top = n.offsetTop, s.left = n.offsetLeft, s.right = i - s.width - s.left } return null } componentDidUpdate() { } render() { return this.props.children } } function SW({ children: t, isPresent: e, anchorX: n }) {
    const r = N.useId(), i = N.useRef(null), s = N.useRef({ width: 0, height: 0, top: 0, left: 0, right: 0 }), { nonce: a } = N.useContext(CS); return N.useInsertionEffect(() => {
      const { width: l, height: u, top: f, left: p, right: g } = s.current; if (e || !i.current || !l || !u) return; const y = n === "left" ? `left: ${p}` : `right: ${g}`; i.current.dataset.motionPopId = r; const v = document.createElement("style"); return a && (v.nonce = a), document.head.appendChild(v), v.sheet && v.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${l}px !important;
            height: ${u}px !important;
            ${y}px !important;
            top: ${f}px !important;
          }
        `), () => { document.head.contains(v) && document.head.removeChild(v) }
    }, [e]), d.jsx(wW, { isPresent: e, childRef: i, sizeRef: s, children: N.cloneElement(t, { ref: i }) })
  } const CW = ({ children: t, initial: e, isPresent: n, onExitComplete: r, custom: i, presenceAffectsLayout: s, mode: a, anchorX: l }) => { const u = Zw(TW), f = N.useId(); let p = !0, g = N.useMemo(() => (p = !1, { id: f, initial: e, isPresent: n, custom: i, onExitComplete: y => { u.set(y, !0); for (const v of u.values()) if (!v) return; r && r() }, register: y => (u.set(y, !1), () => u.delete(y)) }), [n, u, r]); return s && p && (g = { ...g }), N.useMemo(() => { u.forEach((y, v) => u.set(v, !1)) }, [n]), N.useEffect(() => { !n && !u.size && r && r() }, [n]), a === "popLayout" && (t = d.jsx(SW, { isPresent: n, anchorX: l, children: t })), d.jsx(Cy.Provider, { value: g, children: t }) }; function TW() { return new Map } function eR(t = !0) { const e = N.useContext(Cy); if (e === null) return [!0, null]; const { isPresent: n, onExitComplete: r, register: i } = e, s = N.useId(); N.useEffect(() => { if (t) return i(s) }, [t]); const a = N.useCallback(() => t && r && r(s), [s, r, t]); return !n && r ? [!1, a] : [!0] } const qp = t => t.key || ""; function wA(t) { const e = []; return N.Children.forEach(t, n => { N.isValidElement(n) && e.push(n) }), e } const NW = ({ children: t, custom: e, initial: n = !0, onExitComplete: r, presenceAffectsLayout: i = !0, mode: s = "sync", propagate: a = !1, anchorX: l = "left" }) => { const [u, f] = eR(a), p = N.useMemo(() => wA(t), [t]), g = a && !u ? [] : p.map(qp), y = N.useRef(!0), v = N.useRef(p), b = Zw(() => new Map), [S, C] = N.useState(p), [T, A] = N.useState(p); uD(() => { y.current = !1, v.current = p; for (let E = 0; E < T.length; E++) { const k = qp(T[E]); g.includes(k) ? b.delete(k) : b.get(k) !== !0 && b.set(k, !1) } }, [T, g.length, g.join("-")]); const M = []; if (p !== S) { let E = [...p]; for (let k = 0; k < T.length; k++) { const z = T[k], V = qp(z); g.includes(V) || (E.splice(k, 0, z), M.push(z)) } return s === "wait" && M.length && (E = M), A(wA(E)), C(p), null } const { forceRender: O } = N.useContext(Jw); return d.jsx(d.Fragment, { children: T.map(E => { const k = qp(E), z = a && !u ? !1 : p === T || g.includes(k), V = () => { if (b.has(k)) b.set(k, !0); else return; let q = !0; b.forEach(ue => { ue || (q = !1) }), q && (O?.(), A(v.current), a && f?.(), r && r()) }; return d.jsx(CW, { isPresent: z, initial: !y.current || n ? void 0 : !1, custom: e, presenceAffectsLayout: i, mode: s, onExitComplete: z ? void 0 : V, anchorX: l, children: E }, k) }) }) }, tR = N.createContext({ strict: !1 }), SA = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, mu = {}; for (const t in SA) mu[t] = { isEnabled: e => SA[t].some(n => !!e[n]) }; function jW(t) { for (const e in t) mu[e] = { ...mu[e], ...t[e] } } const EW = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function rg(t) { return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || EW.has(t) } let nR = t => !rg(t); function AW(t) { typeof t == "function" && (nR = e => e.startsWith("on") ? !rg(e) : t(e)) } try { AW(require("@emotion/is-prop-valid").default) } catch { } function kW(t, e, n) { const r = {}; for (const i in t) i === "values" && typeof t.values == "object" || (nR(i) || n === !0 && rg(i) || !e && !rg(i) || t.draggable && i.startsWith("onDrag")) && (r[i] = t[i]); return r } function OW(t) { if (typeof Proxy > "u") return t; const e = new Map, n = (...r) => t(...r); return new Proxy(n, { get: (r, i) => i === "create" ? t : (e.has(i) || e.set(i, t(i)), e.get(i)) }) } const Ty = N.createContext({}); function Ny(t) { return t !== null && typeof t == "object" && typeof t.start == "function" } function Ff(t) { return typeof t == "string" || Array.isArray(t) } const TS = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], NS = ["initial", ...TS]; function jy(t) { return Ny(t.animate) || NS.some(e => Ff(t[e])) } function rR(t) { return !!(jy(t) || t.variants) } function MW(t, e) { if (jy(t)) { const { initial: n, animate: r } = t; return { initial: n === !1 || Ff(n) ? n : void 0, animate: Ff(r) ? r : void 0 } } return t.inherit !== !1 ? e : {} } function DW(t) { const { initial: e, animate: n } = MW(t, N.useContext(Ty)); return N.useMemo(() => ({ initial: e, animate: n }), [CA(e), CA(n)]) } function CA(t) { return Array.isArray(t) ? t.join(" ") : t } const RW = Symbol.for("motionComponentSymbol"); function ru(t) { return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current") } function _W(t, e, n) { return N.useCallback(r => { r && t.onMount && t.onMount(r), e && (r ? e.mount(r) : e.unmount()), n && (typeof n == "function" ? n(r) : ru(n) && (n.current = r)) }, [e]) } const jS = t => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), LW = "framerAppearId", iR = "data-" + jS(LW), sR = N.createContext({}); function PW(t, e, n, r, i) { const { visualElement: s } = N.useContext(Ty), a = N.useContext(tR), l = N.useContext(Cy), u = N.useContext(CS).reducedMotion, f = N.useRef(null); r = r || a.renderer, !f.current && r && (f.current = r(t, { visualState: e, parent: s, props: n, presenceContext: l, blockInitialAnimation: l ? l.initial === !1 : !1, reducedMotionConfig: u })); const p = f.current, g = N.useContext(sR); p && !p.projection && i && (p.type === "html" || p.type === "svg") && zW(f.current, n, i, g); const y = N.useRef(!1); N.useInsertionEffect(() => { p && y.current && p.update(n, l) }); const v = n[iR], b = N.useRef(!!v && !window.MotionHandoffIsComplete?.(v) && window.MotionHasOptimisedAnimation?.(v)); return uD(() => { p && (y.current = !0, window.MotionIsMounted = !0, p.updateFeatures(), wS.render(p.render), b.current && p.animationState && p.animationState.animateChanges()) }), N.useEffect(() => { p && (!b.current && p.animationState && p.animationState.animateChanges(), b.current && (queueMicrotask(() => { window.MotionHandoffMarkAsComplete?.(v) }), b.current = !1)) }), p } function zW(t, e, n, r) { const { layoutId: i, layout: s, drag: a, dragConstraints: l, layoutScroll: u, layoutRoot: f, layoutCrossfade: p } = e; t.projection = new n(t.latestValues, e["data-framer-portal-id"] ? void 0 : aR(t.parent)), t.projection.setOptions({ layoutId: i, layout: s, alwaysMeasureLayout: !!a || l && ru(l), visualElement: t, animationType: typeof s == "string" ? s : "both", initialPromotionConfig: r, crossfade: p, layoutScroll: u, layoutRoot: f }) } function aR(t) { if (t) return t.options.allowProjection !== !1 ? t.projection : aR(t.parent) } function IW({ preloadedFeatures: t, createVisualElement: e, useRender: n, useVisualState: r, Component: i }) { t && jW(t); function s(l, u) { let f; const p = { ...N.useContext(CS), ...l, layoutId: FW(l) }, { isStatic: g } = p, y = DW(l), v = r(l, g); if (!g && eS) { BW(); const b = $W(p); f = b.MeasureLayout, y.visualElement = PW(i, v, p, e, b.ProjectionNode) } return d.jsxs(Ty.Provider, { value: y, children: [f && y.visualElement ? d.jsx(f, { visualElement: y.visualElement, ...p }) : null, n(i, l, _W(v, y.visualElement, u), v, g, y.visualElement)] }) } s.displayName = `motion.${typeof i == "string" ? i : `create(${i.displayName ?? i.name ?? ""})`}`; const a = N.forwardRef(s); return a[RW] = i, a } function FW({ layoutId: t }) { const e = N.useContext(Jw).id; return e && t !== void 0 ? e + "-" + t : t } function BW(t, e) { N.useContext(tR).strict } function $W(t) { const { drag: e, layout: n } = mu; if (!e && !n) return {}; const r = { ...e, ...n }; return { MeasureLayout: e?.isEnabled(t) || n?.isEnabled(t) ? r.MeasureLayout : void 0, ProjectionNode: r.ProjectionNode } } const Bf = {}; function UW(t) { for (const e in t) Bf[e] = t[e], lS(e) && (Bf[e].isCSSVariable = !0) } function oR(t, { layout: e, layoutId: n }) { return Ru.has(t) || t.startsWith("origin") || (e || n !== void 0) && (!!Bf[t] || t === "opacity") } const VW = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, HW = Du.length; function qW(t, e, n) { let r = "", i = !0; for (let s = 0; s < HW; s++) { const a = Du[s], l = t[a]; if (l === void 0) continue; let u = !0; if (typeof l == "number" ? u = l === (a.startsWith("scale") ? 1 : 0) : u = parseFloat(l) === 0, !u || n) { const f = GD(l, bS[a]); if (!u) { i = !1; const p = VW[a] || a; r += `${p}(${f}) ` } n && (e[a] = f) } } return r = r.trim(), n ? r = n(e, i ? "" : r) : i && (r = "none"), r } function ES(t, e, n) { const { style: r, vars: i, transformOrigin: s } = t; let a = !1, l = !1; for (const u in e) { const f = e[u]; if (Ru.has(u)) { a = !0; continue } else if (lS(u)) { i[u] = f; continue } else { const p = GD(f, bS[u]); u.startsWith("origin") ? (l = !0, s[u] = p) : r[u] = p } } if (e.transform || (a || n ? r.transform = qW(e, t.transform, n) : r.transform && (r.transform = "none")), l) { const { originX: u = "50%", originY: f = "50%", originZ: p = 0 } = s; r.transformOrigin = `${u} ${f} ${p}` } } const AS = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function lR(t, e, n) { for (const r in e) !Yr(e[r]) && !oR(r, n) && (t[r] = e[r]) } function KW({ transformTemplate: t }, e) { return N.useMemo(() => { const n = AS(); return ES(n, e, t), Object.assign({}, n.vars, n.style) }, [e]) } function WW(t, e) { const n = t.style || {}, r = {}; return lR(r, n, t), Object.assign(r, KW(t, e)), r } function YW(t, e) { const n = {}, r = WW(t, e); return t.drag && t.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (n.tabIndex = 0), n.style = r, n } const GW = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, XW = { offset: "strokeDashoffset", array: "strokeDasharray" }; function QW(t, e, n = 1, r = 0, i = !0) { t.pathLength = 1; const s = i ? GW : XW; t[s.offset] = Rt.transform(-r); const a = Rt.transform(e), l = Rt.transform(n); t[s.array] = `${a} ${l}` } function cR(t, { attrX: e, attrY: n, attrScale: r, pathLength: i, pathSpacing: s = 1, pathOffset: a = 0, ...l }, u, f, p) { if (ES(t, l, f), u) { t.style.viewBox && (t.attrs.viewBox = t.style.viewBox); return } t.attrs = t.style, t.style = {}; const { attrs: g, style: y } = t; g.transform && (y.transform = g.transform, delete g.transform), (y.transform || g.transformOrigin) && (y.transformOrigin = g.transformOrigin ?? "50% 50%", delete g.transformOrigin), y.transform && (y.transformBox = p?.transformBox ?? "fill-box", delete g.transformBox), e !== void 0 && (g.x = e), n !== void 0 && (g.y = n), r !== void 0 && (g.scale = r), i !== void 0 && QW(g, i, s, a, !1) } const uR = () => ({ ...AS(), attrs: {} }), dR = t => typeof t == "string" && t.toLowerCase() === "svg"; function JW(t, e, n, r) { const i = N.useMemo(() => { const s = uR(); return cR(s, e, dR(r), t.transformTemplate, t.style), { ...s.attrs, style: { ...s.style } } }, [e]); if (t.style) { const s = {}; lR(s, t.style, t), i.style = { ...s, ...i.style } } return i } const ZW = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function kS(t) { return typeof t != "string" || t.includes("-") ? !1 : !!(ZW.indexOf(t) > -1 || /[A-Z]/u.test(t)) } function eY(t = !1) { return (n, r, i, { latestValues: s }, a) => { const u = (kS(n) ? JW : YW)(r, s, a, n), f = kW(r, typeof n == "string", t), p = n !== N.Fragment ? { ...f, ...u, ref: i } : {}, { children: g } = r, y = N.useMemo(() => Yr(g) ? g.get() : g, [g]); return N.createElement(n, { ...p, children: y }) } } function TA(t) { const e = [{}, {}]; return t?.values.forEach((n, r) => { e[0][r] = n.get(), e[1][r] = n.getVelocity() }), e } function OS(t, e, n, r) { if (typeof e == "function") { const [i, s] = TA(r); e = e(n !== void 0 ? n : t.custom, i, s) } if (typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function") { const [i, s] = TA(r); e = e(n !== void 0 ? n : t.custom, i, s) } return e } function Em(t) { return Yr(t) ? t.get() : t } function tY({ scrapeMotionValuesFromProps: t, createRenderState: e }, n, r, i) { return { latestValues: nY(n, r, i, t), renderState: e() } } const fR = t => (e, n) => { const r = N.useContext(Ty), i = N.useContext(Cy), s = () => tY(t, e, r, i); return n ? s() : Zw(s) }; function nY(t, e, n, r) { const i = {}, s = r(t, {}); for (const y in s) i[y] = Em(s[y]); let { initial: a, animate: l } = t; const u = jy(t), f = rR(t); e && f && !u && t.inherit !== !1 && (a === void 0 && (a = e.initial), l === void 0 && (l = e.animate)); let p = n ? n.initial === !1 : !1; p = p || a === !1; const g = p ? l : a; if (g && typeof g != "boolean" && !Ny(g)) { const y = Array.isArray(g) ? g : [g]; for (let v = 0; v < y.length; v++) { const b = OS(t, y[v]); if (b) { const { transitionEnd: S, transition: C, ...T } = b; for (const A in T) { let M = T[A]; if (Array.isArray(M)) { const O = p ? M.length - 1 : 0; M = M[O] } M !== null && (i[A] = M) } for (const A in S) i[A] = S[A] } } } return i } function MS(t, e, n) { const { style: r } = t, i = {}; for (const s in r) (Yr(r[s]) || e.style && Yr(e.style[s]) || oR(s, t) || n?.getValue(s)?.liveStyle !== void 0) && (i[s] = r[s]); return i } const rY = { useVisualState: fR({ scrapeMotionValuesFromProps: MS, createRenderState: AS }) }; function hR(t, e, n) { const r = MS(t, e, n); for (const i in t) if (Yr(t[i]) || Yr(e[i])) { const s = Du.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i; r[s] = t[i] } return r } const iY = { useVisualState: fR({ scrapeMotionValuesFromProps: hR, createRenderState: uR }) }; function sY(t, e) { return function (r, { forwardMotionProps: i } = { forwardMotionProps: !1 }) { const a = { ...kS(r) ? iY : rY, preloadedFeatures: t, useRender: eY(i), createVisualElement: e, Component: r }; return IW(a) } } function $f(t, e, n) { const r = t.getProps(); return OS(r, e, n !== void 0 ? n : r.custom, t) } const c1 = t => Array.isArray(t); function aY(t, e, n) { t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, pu(n)) } function oY(t) { return c1(t) ? t[t.length - 1] || 0 : t } function lY(t, e) { const n = $f(t, e); let { transitionEnd: r = {}, transition: i = {}, ...s } = n || {}; s = { ...s, ...r }; for (const a in s) { const l = oY(s[a]); aY(t, a, l) } } function cY(t) { return !!(Yr(t) && t.add) } function u1(t, e) { const n = t.getValue("willChange"); if (cY(n)) return n.add(e); if (!n && Ua.WillChange) { const r = new Ua.WillChange("auto"); t.addValue("willChange", r), r.add(e) } } function pR(t) { return t.props[iR] } const uY = t => t !== null; function dY(t, { repeat: e, repeatType: n = "loop" }, r) { const i = t.filter(uY), s = e && n !== "loop" && e % 2 === 1 ? 0 : i.length - 1; return i[s] } const fY = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, hY = t => ({ type: "spring", stiffness: 550, damping: t === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), pY = { type: "keyframes", duration: .8 }, mY = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, gY = (t, { keyframes: e }) => e.length > 2 ? pY : Ru.has(t) ? t.startsWith("scale") ? hY(e[1]) : fY : mY; function yY({ when: t, delay: e, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: s, repeatType: a, repeatDelay: l, from: u, elapsed: f, ...p }) { return !!Object.keys(p).length } const DS = (t, e, n, r = {}, i, s) => a => { const l = xS(r, t) || {}, u = l.delay || r.delay || 0; let { elapsed: f = 0 } = r; f = f - Qs(u); const p = { keyframes: Array.isArray(n) ? n : [null, n], ease: "easeOut", velocity: e.getVelocity(), ...l, delay: -f, onUpdate: y => { e.set(y), l.onUpdate && l.onUpdate(y) }, onComplete: () => { a(), l.onComplete && l.onComplete() }, name: t, motionValue: e, element: s ? void 0 : i }; yY(l) || Object.assign(p, gY(t, p)), p.duration && (p.duration = Qs(p.duration)), p.repeatDelay && (p.repeatDelay = Qs(p.repeatDelay)), p.from !== void 0 && (p.keyframes[0] = p.from); let g = !1; if ((p.type === !1 || p.duration === 0 && !p.repeatDelay) && (p.duration = 0, p.delay === 0 && (g = !0)), (Ua.instantAnimations || Ua.skipAnimations) && (g = !0, p.duration = 0, p.delay = 0), p.allowFlatten = !l.type && !l.ease, g && !s && e.get() !== void 0) { const y = dY(p.keyframes, l); if (y !== void 0) { Bn.update(() => { p.onUpdate(y), p.onComplete() }); return } } return l.isSync ? new gS(p) : new XK(p) }; function vY({ protectedKeys: t, needsAnimating: e }, n) { const r = t.hasOwnProperty(n) && e[n] !== !0; return e[n] = !1, r } function mR(t, e, { delay: n = 0, transitionOverride: r, type: i } = {}) { let { transition: s = t.getDefaultTransition(), transitionEnd: a, ...l } = e; r && (s = r); const u = [], f = i && t.animationState && t.animationState.getState()[i]; for (const p in l) { const g = t.getValue(p, t.latestValues[p] ?? null), y = l[p]; if (y === void 0 || f && vY(f, p)) continue; const v = { delay: n, ...xS(s || {}, p) }, b = g.get(); if (b !== void 0 && !g.isAnimating && !Array.isArray(y) && y === b && !v.velocity) continue; let S = !1; if (window.MotionHandoffAnimation) { const T = pR(t); if (T) { const A = window.MotionHandoffAnimation(T, p, Bn); A !== null && (v.startTime = A, S = !0) } } u1(t, p), g.start(DS(p, g, y, t.shouldReduceMotion && HD.has(p) ? { type: !1 } : v, t, S)); const C = g.animation; C && u.push(C) } return a && Promise.all(u).then(() => { Bn.update(() => { a && lY(t, a) }) }), u } function d1(t, e, n = {}) { const r = $f(t, e, n.type === "exit" ? t.presenceContext?.custom : void 0); let { transition: i = t.getDefaultTransition() || {} } = r || {}; n.transitionOverride && (i = n.transitionOverride); const s = r ? () => Promise.all(mR(t, r, n)) : () => Promise.resolve(), a = t.variantChildren && t.variantChildren.size ? (u = 0) => { const { delayChildren: f = 0, staggerChildren: p, staggerDirection: g } = i; return xY(t, e, f + u, p, g, n) } : () => Promise.resolve(), { when: l } = i; if (l) { const [u, f] = l === "beforeChildren" ? [s, a] : [a, s]; return u().then(() => f()) } else return Promise.all([s(), a(n.delay)]) } function xY(t, e, n = 0, r = 0, i = 1, s) { const a = [], l = (t.variantChildren.size - 1) * r, u = i === 1 ? (f = 0) => f * r : (f = 0) => l - f * r; return Array.from(t.variantChildren).sort(bY).forEach((f, p) => { f.notify("AnimationStart", e), a.push(d1(f, e, { ...s, delay: n + u(p) }).then(() => f.notify("AnimationComplete", e))) }), Promise.all(a) } function bY(t, e) { return t.sortNodePosition(e) } function wY(t, e, n = {}) { t.notify("AnimationStart", e); let r; if (Array.isArray(e)) { const i = e.map(s => d1(t, s, n)); r = Promise.all(i) } else if (typeof e == "string") r = d1(t, e, n); else { const i = typeof e == "function" ? $f(t, e, n.custom) : e; r = Promise.all(mR(t, i, n)) } return r.then(() => { t.notify("AnimationComplete", e) }) } function gR(t, e) { if (!Array.isArray(e)) return !1; const n = e.length; if (n !== t.length) return !1; for (let r = 0; r < n; r++)if (e[r] !== t[r]) return !1; return !0 } const SY = NS.length; function yR(t) { if (!t) return; if (!t.isControllingVariants) { const n = t.parent ? yR(t.parent) || {} : {}; return t.props.initial !== void 0 && (n.initial = t.props.initial), n } const e = {}; for (let n = 0; n < SY; n++) { const r = NS[n], i = t.props[r]; (Ff(i) || i === !1) && (e[r] = i) } return e } const CY = [...TS].reverse(), TY = TS.length; function NY(t) { return e => Promise.all(e.map(({ animation: n, options: r }) => wY(t, n, r))) } function jY(t) { let e = NY(t), n = NA(), r = !0; const i = u => (f, p) => { const g = $f(t, p, u === "exit" ? t.presenceContext?.custom : void 0); if (g) { const { transition: y, transitionEnd: v, ...b } = g; f = { ...f, ...b, ...v } } return f }; function s(u) { e = u(t) } function a(u) { const { props: f } = t, p = yR(t.parent) || {}, g = [], y = new Set; let v = {}, b = 1 / 0; for (let C = 0; C < TY; C++) { const T = CY[C], A = n[T], M = f[T] !== void 0 ? f[T] : p[T], O = Ff(M), E = T === u ? A.isActive : null; E === !1 && (b = C); let k = M === p[T] && M !== f[T] && O; if (k && r && t.manuallyAnimateOnMount && (k = !1), A.protectedKeys = { ...v }, !A.isActive && E === null || !M && !A.prevProp || Ny(M) || typeof M == "boolean") continue; const z = EY(A.prevProp, M); let V = z || T === u && A.isActive && !k && O || C > b && O, q = !1; const ue = Array.isArray(M) ? M : [M]; let W = ue.reduce(i(T), {}); E === !1 && (W = {}); const { prevResolvedValues: ne = {} } = A, H = { ...ne, ...W }, we = te => { V = !0, y.has(te) && (q = !0, y.delete(te)), A.needsAnimating[te] = !0; const ye = t.getValue(te); ye && (ye.liveStyle = !1) }; for (const te in H) { const ye = W[te], He = ne[te]; if (v.hasOwnProperty(te)) continue; let B = !1; c1(ye) && c1(He) ? B = !gR(ye, He) : B = ye !== He, B ? ye != null ? we(te) : y.add(te) : ye !== void 0 && y.has(te) ? we(te) : A.protectedKeys[te] = !0 } A.prevProp = M, A.prevResolvedValues = W, A.isActive && (v = { ...v, ...W }), r && t.blockInitialAnimation && (V = !1), V && (!(k && z) || q) && g.push(...ue.map(te => ({ animation: te, options: { type: T } }))) } if (y.size) { const C = {}; if (typeof f.initial != "boolean") { const T = $f(t, Array.isArray(f.initial) ? f.initial[0] : f.initial); T && T.transition && (C.transition = T.transition) } y.forEach(T => { const A = t.getBaseTarget(T), M = t.getValue(T); M && (M.liveStyle = !0), C[T] = A ?? null }), g.push({ animation: C }) } let S = !!g.length; return r && (f.initial === !1 || f.initial === f.animate) && !t.manuallyAnimateOnMount && (S = !1), r = !1, S ? e(g) : Promise.resolve() } function l(u, f) { if (n[u].isActive === f) return Promise.resolve(); t.variantChildren?.forEach(g => g.animationState?.setActive(u, f)), n[u].isActive = f; const p = a(u); for (const g in n) n[g].protectedKeys = {}; return p } return { animateChanges: a, setActive: l, setAnimateFunction: s, getState: () => n, reset: () => { n = NA(), r = !0 } } } function EY(t, e) { return typeof e == "string" ? e !== t : Array.isArray(e) ? !gR(e, t) : !1 } function vl(t = !1) { return { isActive: t, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function NA() { return { animate: vl(!0), whileInView: vl(), whileHover: vl(), whileTap: vl(), whileDrag: vl(), whileFocus: vl(), exit: vl() } } class Go { constructor(e) { this.isMounted = !1, this.node = e } update() { } } class AY extends Go { constructor(e) { super(e), e.animationState || (e.animationState = jY(e)) } updateAnimationControlsSubscription() { const { animate: e } = this.node.getProps(); Ny(e) && (this.unmountControls = e.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: e } = this.node.getProps(), { animate: n } = this.node.prevProps || {}; e !== n && this.updateAnimationControlsSubscription() } unmount() { this.node.animationState.reset(), this.unmountControls?.() } } let kY = 0; class OY extends Go { constructor() { super(...arguments), this.id = kY++ } update() { if (!this.node.presenceContext) return; const { isPresent: e, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {}; if (!this.node.animationState || e === r) return; const i = this.node.animationState.setActive("exit", !e); n && !e && i.then(() => { n(this.id) }) } mount() { const { register: e, onExitComplete: n } = this.node.presenceContext || {}; n && n(this.id), e && (this.unmount = e(this.id)) } unmount() { } } const MY = { animation: { Feature: AY }, exit: { Feature: OY } }; function Uf(t, e, n, r = { passive: !0 }) { return t.addEventListener(e, n, r), () => t.removeEventListener(e, n) } function xh(t) { return { point: { x: t.pageX, y: t.pageY } } } const DY = t => e => SS(e) && t(e, xh(e)); function cf(t, e, n, r) { return Uf(t, e, DY(n), r) } function vR({ top: t, left: e, right: n, bottom: r }) { return { x: { min: e, max: n }, y: { min: t, max: r } } } function RY({ x: t, y: e }) { return { top: e.min, right: t.max, bottom: e.max, left: t.min } } function _Y(t, e) { if (!e) return t; const n = e({ x: t.left, y: t.top }), r = e({ x: t.right, y: t.bottom }); return { top: n.y, left: n.x, bottom: r.y, right: r.x } } const xR = 1e-4, LY = 1 - xR, PY = 1 + xR, bR = .01, zY = 0 - bR, IY = 0 + bR; function ii(t) { return t.max - t.min } function FY(t, e, n) { return Math.abs(t - e) <= n } function jA(t, e, n, r = .5) { t.origin = r, t.originPoint = Fn(e.min, e.max, t.origin), t.scale = ii(n) / ii(e), t.translate = Fn(n.min, n.max, t.origin) - t.originPoint, (t.scale >= LY && t.scale <= PY || isNaN(t.scale)) && (t.scale = 1), (t.translate >= zY && t.translate <= IY || isNaN(t.translate)) && (t.translate = 0) } function uf(t, e, n, r) { jA(t.x, e.x, n.x, r ? r.originX : void 0), jA(t.y, e.y, n.y, r ? r.originY : void 0) } function EA(t, e, n) { t.min = n.min + e.min, t.max = t.min + ii(e) } function BY(t, e, n) { EA(t.x, e.x, n.x), EA(t.y, e.y, n.y) } function AA(t, e, n) { t.min = e.min - n.min, t.max = t.min + ii(e) } function df(t, e, n) { AA(t.x, e.x, n.x), AA(t.y, e.y, n.y) } const kA = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), iu = () => ({ x: kA(), y: kA() }), OA = () => ({ min: 0, max: 0 }), tr = () => ({ x: OA(), y: OA() }); function ns(t) { return [t("x"), t("y")] } function jx(t) { return t === void 0 || t === 1 } function f1({ scale: t, scaleX: e, scaleY: n }) { return !jx(t) || !jx(e) || !jx(n) } function Sl(t) { return f1(t) || wR(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY } function wR(t) { return MA(t.x) || MA(t.y) } function MA(t) { return t && t !== "0%" } function ig(t, e, n) { const r = t - n, i = e * r; return n + i } function DA(t, e, n, r, i) { return i !== void 0 && (t = ig(t, i, r)), ig(t, n, r) + e } function h1(t, e = 0, n = 1, r, i) { t.min = DA(t.min, e, n, r, i), t.max = DA(t.max, e, n, r, i) } function SR(t, { x: e, y: n }) { h1(t.x, e.translate, e.scale, e.originPoint), h1(t.y, n.translate, n.scale, n.originPoint) } const RA = .999999999999, _A = 1.0000000000001; function $Y(t, e, n, r = !1) { const i = n.length; if (!i) return; e.x = e.y = 1; let s, a; for (let l = 0; l < i; l++) { s = n[l], a = s.projectionDelta; const { visualElement: u } = s.options; u && u.props.style && u.props.style.display === "contents" || (r && s.options.layoutScroll && s.scroll && s !== s.root && au(t, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }), a && (e.x *= a.x.scale, e.y *= a.y.scale, SR(t, a)), r && Sl(s.latestValues) && au(t, s.latestValues)) } e.x < _A && e.x > RA && (e.x = 1), e.y < _A && e.y > RA && (e.y = 1) } function su(t, e) { t.min = t.min + e, t.max = t.max + e } function LA(t, e, n, r, i = .5) { const s = Fn(t.min, t.max, i); h1(t, e, n, s, r) } function au(t, e) { LA(t.x, e.x, e.scaleX, e.scale, e.originX), LA(t.y, e.y, e.scaleY, e.scale, e.originY) } function CR(t, e) { return vR(_Y(t.getBoundingClientRect(), e)) } function UY(t, e, n) { const r = CR(t, n), { scroll: i } = e; return i && (su(r.x, i.offset.x), su(r.y, i.offset.y)), r } const TR = ({ current: t }) => t ? t.ownerDocument.defaultView : null, PA = (t, e) => Math.abs(t - e); function VY(t, e) { const n = PA(t.x, e.x), r = PA(t.y, e.y); return Math.sqrt(n ** 2 + r ** 2) } class NR { constructor(e, n, { transformPagePoint: r, contextWindow: i, dragSnapToOrigin: s = !1 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const g = Ax(this.lastMoveEventInfo, this.history), y = this.startEvent !== null, v = VY(g.offset, { x: 0, y: 0 }) >= 3; if (!y && !v) return; const { point: b } = g, { timestamp: S } = Pr; this.history.push({ ...b, timestamp: S }); const { onStart: C, onMove: T } = this.handlers; y || (C && C(this.lastMoveEvent, g), this.startEvent = this.lastMoveEvent), T && T(this.lastMoveEvent, g) }, this.handlePointerMove = (g, y) => { this.lastMoveEvent = g, this.lastMoveEventInfo = Ex(y, this.transformPagePoint), Bn.update(this.updatePoint, !0) }, this.handlePointerUp = (g, y) => { this.end(); const { onEnd: v, onSessionEnd: b, resumeAnimation: S } = this.handlers; if (this.dragSnapToOrigin && S && S(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const C = Ax(g.type === "pointercancel" ? this.lastMoveEventInfo : Ex(y, this.transformPagePoint), this.history); this.startEvent && v && v(g, C), b && b(g, C) }, !SS(e)) return; this.dragSnapToOrigin = s, this.handlers = n, this.transformPagePoint = r, this.contextWindow = i || window; const a = xh(e), l = Ex(a, this.transformPagePoint), { point: u } = l, { timestamp: f } = Pr; this.history = [{ ...u, timestamp: f }]; const { onSessionStart: p } = n; p && p(e, Ax(l, this.history)), this.removeListeners = gh(cf(this.contextWindow, "pointermove", this.handlePointerMove), cf(this.contextWindow, "pointerup", this.handlePointerUp), cf(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(e) { this.handlers = e } end() { this.removeListeners && this.removeListeners(), $o(this.updatePoint) } } function Ex(t, e) { return e ? { point: e(t.point) } : t } function zA(t, e) { return { x: t.x - e.x, y: t.y - e.y } } function Ax({ point: t }, e) { return { point: t, delta: zA(t, jR(e)), offset: zA(t, HY(e)), velocity: qY(e, .1) } } function HY(t) { return t[0] } function jR(t) { return t[t.length - 1] } function qY(t, e) { if (t.length < 2) return { x: 0, y: 0 }; let n = t.length - 1, r = null; const i = jR(t); for (; n >= 0 && (r = t[n], !(i.timestamp - r.timestamp > Qs(e)));)n--; if (!r) return { x: 0, y: 0 }; const s = Js(i.timestamp - r.timestamp); if (s === 0) return { x: 0, y: 0 }; const a = { x: (i.x - r.x) / s, y: (i.y - r.y) / s }; return a.x === 1 / 0 && (a.x = 0), a.y === 1 / 0 && (a.y = 0), a } function KY(t, { min: e, max: n }, r) { return e !== void 0 && t < e ? t = r ? Fn(e, t, r.min) : Math.max(t, e) : n !== void 0 && t > n && (t = r ? Fn(n, t, r.max) : Math.min(t, n)), t } function IA(t, e, n) { return { min: e !== void 0 ? t.min + e : void 0, max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0 } } function WY(t, { top: e, left: n, bottom: r, right: i }) { return { x: IA(t.x, n, i), y: IA(t.y, e, r) } } function FA(t, e) { let n = e.min - t.min, r = e.max - t.max; return e.max - e.min < t.max - t.min && ([n, r] = [r, n]), { min: n, max: r } } function YY(t, e) { return { x: FA(t.x, e.x), y: FA(t.y, e.y) } } function GY(t, e) { let n = .5; const r = ii(t), i = ii(e); return i > r ? n = Pf(e.min, e.max - r, t.min) : r > i && (n = Pf(t.min, t.max - i, e.min)), $a(0, 1, n) } function XY(t, e) { const n = {}; return e.min !== void 0 && (n.min = e.min - t.min), e.max !== void 0 && (n.max = e.max - t.min), n } const p1 = .35; function QY(t = p1) { return t === !1 ? t = 0 : t === !0 && (t = p1), { x: BA(t, "left", "right"), y: BA(t, "top", "bottom") } } function BA(t, e, n) { return { min: $A(t, e), max: $A(t, n) } } function $A(t, e) { return typeof t == "number" ? t : t[e] || 0 } const JY = new WeakMap; class ZY { constructor(e) { this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = tr(), this.visualElement = e } start(e, { snapToCursor: n = !1 } = {}) { const { presenceContext: r } = this.visualElement; if (r && r.isPresent === !1) return; const i = p => { const { dragSnapToOrigin: g } = this.getProps(); g ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(xh(p).point) }, s = (p, g) => { const { drag: y, dragPropagation: v, onDragStart: b } = this.getProps(); if (y && !v && (this.openDragLock && this.openDragLock(), this.openDragLock = fW(y), !this.openDragLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), ns(C => { let T = this.getAxisMotionValue(C).get() || 0; if (Zs.test(T)) { const { projection: A } = this.visualElement; if (A && A.layout) { const M = A.layout.layoutBox[C]; M && (T = ii(M) * (parseFloat(T) / 100)) } } this.originPoint[C] = T }), b && Bn.postRender(() => b(p, g)), u1(this.visualElement, "transform"); const { animationState: S } = this.visualElement; S && S.setActive("whileDrag", !0) }, a = (p, g) => { const { dragPropagation: y, dragDirectionLock: v, onDirectionLock: b, onDrag: S } = this.getProps(); if (!y && !this.openDragLock) return; const { offset: C } = g; if (v && this.currentDirection === null) { this.currentDirection = eG(C), this.currentDirection !== null && b && b(this.currentDirection); return } this.updateAxis("x", g.point, C), this.updateAxis("y", g.point, C), this.visualElement.render(), S && S(p, g) }, l = (p, g) => this.stop(p, g), u = () => ns(p => this.getAnimationState(p) === "paused" && this.getAxisMotionValue(p).animation?.play()), { dragSnapToOrigin: f } = this.getProps(); this.panSession = new NR(e, { onSessionStart: i, onStart: s, onMove: a, onSessionEnd: l, resumeAnimation: u }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: f, contextWindow: TR(this.visualElement) }) } stop(e, n) { const r = this.isDragging; if (this.cancel(), !r) return; const { velocity: i } = n; this.startAnimation(i); const { onDragEnd: s } = this.getProps(); s && Bn.postRender(() => s(e, n)) } cancel() { this.isDragging = !1; const { projection: e, animationState: n } = this.visualElement; e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: r } = this.getProps(); !r && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1) } updateAxis(e, n, r) { const { drag: i } = this.getProps(); if (!r || !Kp(e, i, this.currentDirection)) return; const s = this.getAxisMotionValue(e); let a = this.originPoint[e] + r[e]; this.constraints && this.constraints[e] && (a = KY(a, this.constraints[e], this.elastic[e])), s.set(a) } resolveConstraints() { const { dragConstraints: e, dragElastic: n } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, i = this.constraints; e && ru(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && r ? this.constraints = WY(r.layoutBox, e) : this.constraints = !1, this.elastic = QY(n), i !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && ns(s => { this.constraints !== !1 && this.getAxisMotionValue(s) && (this.constraints[s] = XY(r.layoutBox[s], this.constraints[s])) }) } resolveRefConstraints() { const { dragConstraints: e, onMeasureDragConstraints: n } = this.getProps(); if (!e || !ru(e)) return !1; const r = e.current, { projection: i } = this.visualElement; if (!i || !i.layout) return !1; const s = UY(r, i.root, this.visualElement.getTransformPagePoint()); let a = YY(i.layout.layoutBox, s); if (n) { const l = n(RY(a)); this.hasMutatedConstraints = !!l, l && (a = vR(l)) } return a } startAnimation(e) { const { drag: n, dragMomentum: r, dragElastic: i, dragTransition: s, dragSnapToOrigin: a, onDragTransitionEnd: l } = this.getProps(), u = this.constraints || {}, f = ns(p => { if (!Kp(p, n, this.currentDirection)) return; let g = u && u[p] || {}; a && (g = { min: 0, max: 0 }); const y = i ? 200 : 1e6, v = i ? 40 : 1e7, b = { type: "inertia", velocity: r ? e[p] : 0, bounceStiffness: y, bounceDamping: v, timeConstant: 750, restDelta: 1, restSpeed: 10, ...s, ...g }; return this.startAxisValueAnimation(p, b) }); return Promise.all(f).then(l) } startAxisValueAnimation(e, n) { const r = this.getAxisMotionValue(e); return u1(this.visualElement, e), r.start(DS(e, r, 0, n, this.visualElement, !1)) } stopAnimation() { ns(e => this.getAxisMotionValue(e).stop()) } pauseAnimation() { ns(e => this.getAxisMotionValue(e).animation?.pause()) } getAnimationState(e) { return this.getAxisMotionValue(e).animation?.state } getAxisMotionValue(e) { const n = `_drag${e.toUpperCase()}`, r = this.visualElement.getProps(), i = r[n]; return i || this.visualElement.getValue(e, (r.initial ? r.initial[e] : void 0) || 0) } snapToCursor(e) { ns(n => { const { drag: r } = this.getProps(); if (!Kp(n, r, this.currentDirection)) return; const { projection: i } = this.visualElement, s = this.getAxisMotionValue(n); if (i && i.layout) { const { min: a, max: l } = i.layout.layoutBox[n]; s.set(e[n] - Fn(a, l, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: e, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement; if (!ru(n) || !r || !this.constraints) return; this.stopAnimation(); const i = { x: 0, y: 0 }; ns(a => { const l = this.getAxisMotionValue(a); if (l && this.constraints !== !1) { const u = l.get(); i[a] = GY({ min: u, max: u }, this.constraints[a]) } }); const { transformTemplate: s } = this.visualElement.getProps(); this.visualElement.current.style.transform = s ? s({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), ns(a => { if (!Kp(a, e, null)) return; const l = this.getAxisMotionValue(a), { min: u, max: f } = this.constraints[a]; l.set(Fn(u, f, i[a])) }) } addListeners() { if (!this.visualElement.current) return; JY.set(this.visualElement, this); const e = this.visualElement.current, n = cf(e, "pointerdown", u => { const { drag: f, dragListener: p = !0 } = this.getProps(); f && p && this.start(u) }), r = () => { const { dragConstraints: u } = this.getProps(); ru(u) && u.current && (this.constraints = this.resolveRefConstraints()) }, { projection: i } = this.visualElement, s = i.addEventListener("measure", r); i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), Bn.read(r); const a = Uf(window, "resize", () => this.scalePositionWithinConstraints()), l = i.addEventListener("didUpdate", ({ delta: u, hasLayoutChanged: f }) => { this.isDragging && f && (ns(p => { const g = this.getAxisMotionValue(p); g && (this.originPoint[p] += u[p].translate, g.set(g.get() + u[p].translate)) }), this.visualElement.render()) }); return () => { a(), n(), s(), l && l() } } getProps() { const e = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: i = !1, dragConstraints: s = !1, dragElastic: a = p1, dragMomentum: l = !0 } = e; return { ...e, drag: n, dragDirectionLock: r, dragPropagation: i, dragConstraints: s, dragElastic: a, dragMomentum: l } } } function Kp(t, e, n) { return (e === !0 || e === t) && (n === null || n === t) } function eG(t, e = 10) { let n = null; return Math.abs(t.y) > e ? n = "y" : Math.abs(t.x) > e && (n = "x"), n } class tG extends Go { constructor(e) { super(e), this.removeGroupControls = ls, this.removeListeners = ls, this.controls = new ZY(e) } mount() { const { dragControls: e } = this.node.getProps(); e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || ls } unmount() { this.removeGroupControls(), this.removeListeners() } } const UA = t => (e, n) => { t && Bn.postRender(() => t(e, n)) }; class nG extends Go { constructor() { super(...arguments), this.removePointerDownListener = ls } onPointerDown(e) { this.session = new NR(e, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: TR(this.node) }) } createPanHandlers() { const { onPanSessionStart: e, onPanStart: n, onPan: r, onPanEnd: i } = this.node.getProps(); return { onSessionStart: UA(e), onStart: UA(n), onMove: r, onEnd: (s, a) => { delete this.session, i && Bn.postRender(() => i(s, a)) } } } mount() { this.removePointerDownListener = cf(this.node.current, "pointerdown", e => this.onPointerDown(e)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } const Am = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function VA(t, e) { return e.max === e.min ? 0 : t / (e.max - e.min) * 100 } const $d = { correct: (t, e) => { if (!e.target) return t; if (typeof t == "string") if (Rt.test(t)) t = parseFloat(t); else return t; const n = VA(t, e.target.x), r = VA(t, e.target.y); return `${n}% ${r}%` } }, rG = { correct: (t, { treeScale: e, projectionDelta: n }) => { const r = t, i = Uo.parse(t); if (i.length > 5) return r; const s = Uo.createTransformer(t), a = typeof i[0] != "number" ? 1 : 0, l = n.x.scale * e.x, u = n.y.scale * e.y; i[0 + a] /= l, i[1 + a] /= u; const f = Fn(l, u, .5); return typeof i[2 + a] == "number" && (i[2 + a] /= f), typeof i[3 + a] == "number" && (i[3 + a] /= f), s(i) } }; class iG extends N.Component { componentDidMount() { const { visualElement: e, layoutGroup: n, switchLayoutGroup: r, layoutId: i } = this.props, { projection: s } = e; UW(sG), s && (n.group && n.group.add(s), r && r.register && i && r.register(s), s.root.didUpdate(), s.addEventListener("animationComplete", () => { this.safeToRemove() }), s.setOptions({ ...s.options, onExitComplete: () => this.safeToRemove() })), Am.hasEverUpdated = !0 } getSnapshotBeforeUpdate(e) { const { layoutDependency: n, visualElement: r, drag: i, isPresent: s } = this.props, { projection: a } = r; return a && (a.isPresent = s, i || e.layoutDependency !== n || n === void 0 || e.isPresent !== s ? a.willUpdate() : this.safeToRemove(), e.isPresent !== s && (s ? a.promote() : a.relegate() || Bn.postRender(() => { const l = a.getStack(); (!l || !l.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: e } = this.props.visualElement; e && (e.root.didUpdate(), wS.postRender(() => { !e.currentAnimation && e.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: e, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: i } = e; i && (i.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(i), r && r.deregister && r.deregister(i)) } safeToRemove() { const { safeToRemove: e } = this.props; e && e() } render() { return null } } function ER(t) { const [e, n] = eR(), r = N.useContext(Jw); return d.jsx(iG, { ...t, layoutGroup: r, switchLayoutGroup: N.useContext(sR), isPresent: e, safeToRemove: n }) } const sG = { borderRadius: { ...$d, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: $d, borderTopRightRadius: $d, borderBottomLeftRadius: $d, borderBottomRightRadius: $d, boxShadow: rG }; function aG(t, e, n) { const r = Yr(t) ? t : pu(t); return r.start(DS("", r, e, n)), r.animation } const oG = (t, e) => t.depth - e.depth; class lG { constructor() { this.children = [], this.isDirty = !1 } add(e) { tS(this.children, e), this.isDirty = !0 } remove(e) { nS(this.children, e), this.isDirty = !0 } forEach(e) { this.isDirty && this.children.sort(oG), this.isDirty = !1, this.children.forEach(e) } } function cG(t, e) { const n = vi.now(), r = ({ timestamp: i }) => { const s = i - n; s >= e && ($o(r), t(s - e)) }; return Bn.setup(r, !0), () => $o(r) } const AR = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], uG = AR.length, HA = t => typeof t == "string" ? parseFloat(t) : t, qA = t => typeof t == "number" || Rt.test(t); function dG(t, e, n, r, i, s) { i ? (t.opacity = Fn(0, n.opacity ?? 1, fG(r)), t.opacityExit = Fn(e.opacity ?? 1, 0, hG(r))) : s && (t.opacity = Fn(e.opacity ?? 1, n.opacity ?? 1, r)); for (let a = 0; a < uG; a++) { const l = `border${AR[a]}Radius`; let u = KA(e, l), f = KA(n, l); if (u === void 0 && f === void 0) continue; u || (u = 0), f || (f = 0), u === 0 || f === 0 || qA(u) === qA(f) ? (t[l] = Math.max(Fn(HA(u), HA(f), r), 0), (Zs.test(f) || Zs.test(u)) && (t[l] += "%")) : t[l] = f } (e.rotate || n.rotate) && (t.rotate = Fn(e.rotate || 0, n.rotate || 0, r)) } function KA(t, e) { return t[e] !== void 0 ? t[e] : t.borderRadius } const fG = kR(0, .5, wD), hG = kR(.5, .95, ls); function kR(t, e, n) { return r => r < t ? 0 : r > e ? 1 : n(Pf(t, e, r)) } function WA(t, e) { t.min = e.min, t.max = e.max } function es(t, e) { WA(t.x, e.x), WA(t.y, e.y) } function YA(t, e) { t.translate = e.translate, t.scale = e.scale, t.originPoint = e.originPoint, t.origin = e.origin } function GA(t, e, n, r, i) { return t -= e, t = ig(t, 1 / n, r), i !== void 0 && (t = ig(t, 1 / i, r)), t } function pG(t, e = 0, n = 1, r = .5, i, s = t, a = t) { if (Zs.test(e) && (e = parseFloat(e), e = Fn(a.min, a.max, e / 100) - a.min), typeof e != "number") return; let l = Fn(s.min, s.max, r); t === s && (l -= e), t.min = GA(t.min, e, n, l, i), t.max = GA(t.max, e, n, l, i) } function XA(t, e, [n, r, i], s, a) { pG(t, e[n], e[r], e[i], e.scale, s, a) } const mG = ["x", "scaleX", "originX"], gG = ["y", "scaleY", "originY"]; function QA(t, e, n, r) { XA(t.x, e, mG, n ? n.x : void 0, r ? r.x : void 0), XA(t.y, e, gG, n ? n.y : void 0, r ? r.y : void 0) } function JA(t) { return t.translate === 0 && t.scale === 1 } function OR(t) { return JA(t.x) && JA(t.y) } function ZA(t, e) { return t.min === e.min && t.max === e.max } function yG(t, e) { return ZA(t.x, e.x) && ZA(t.y, e.y) } function ek(t, e) { return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max) } function MR(t, e) { return ek(t.x, e.x) && ek(t.y, e.y) } function tk(t) { return ii(t.x) / ii(t.y) } function nk(t, e) { return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint } class vG { constructor() { this.members = [] } add(e) { tS(this.members, e), e.scheduleRender() } remove(e) { if (nS(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) { const n = this.members[this.members.length - 1]; n && this.promote(n) } } relegate(e) { const n = this.members.findIndex(i => e === i); if (n === 0) return !1; let r; for (let i = n; i >= 0; i--) { const s = this.members[i]; if (s.isPresent !== !1) { r = s; break } } return r ? (this.promote(r), !0) : !1 } promote(e, n) { const r = this.lead; if (e !== r && (this.prevLead = r, this.lead = e, e.show(), r)) { r.instance && r.scheduleRender(), e.scheduleRender(), e.resumeFrom = r, n && (e.resumeFrom.preserveOpacity = !0), r.snapshot && (e.snapshot = r.snapshot, e.snapshot.latestValues = r.animationValues || r.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0); const { crossfade: i } = e.options; i === !1 && r.hide() } } exitAnimationComplete() { this.members.forEach(e => { const { options: n, resumingFrom: r } = e; n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete() }) } scheduleRender() { this.members.forEach(e => { e.instance && e.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function xG(t, e, n) { let r = ""; const i = t.x.translate / e.x, s = t.y.translate / e.y, a = n?.z || 0; if ((i || s || a) && (r = `translate3d(${i}px, ${s}px, ${a}px) `), (e.x !== 1 || e.y !== 1) && (r += `scale(${1 / e.x}, ${1 / e.y}) `), n) { const { transformPerspective: f, rotate: p, rotateX: g, rotateY: y, skewX: v, skewY: b } = n; f && (r = `perspective(${f}px) ${r}`), p && (r += `rotate(${p}deg) `), g && (r += `rotateX(${g}deg) `), y && (r += `rotateY(${y}deg) `), v && (r += `skewX(${v}deg) `), b && (r += `skewY(${b}deg) `) } const l = t.x.scale * e.x, u = t.y.scale * e.y; return (l !== 1 || u !== 1) && (r += `scale(${l}, ${u})`), r || "none" } const kx = ["", "X", "Y", "Z"], bG = { visibility: "hidden" }, wG = 1e3; let SG = 0; function Ox(t, e, n, r) { const { latestValues: i } = e; i[t] && (n[t] = i[t], e.setStaticValue(t, 0), r && (r[t] = 0)) } function DR(t) { if (t.hasCheckedOptimisedAppear = !0, t.root === t) return; const { visualElement: e } = t.options; if (!e) return; const n = pR(e); if (window.MotionHasOptimisedAnimation(n, "transform")) { const { layout: i, layoutId: s } = t.options; window.MotionCancelOptimisedAnimation(n, "transform", Bn, !(i || s)) } const { parent: r } = t; r && !r.hasCheckedOptimisedAppear && DR(r) } function RR({ attachResizeListener: t, defaultParent: e, measureScroll: n, checkIsScrollRoot: r, resetTransform: i }) { return class { constructor(a = {}, l = e?.()) { this.id = SG++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, this.nodes.forEach(NG), this.nodes.forEach(OG), this.nodes.forEach(MG), this.nodes.forEach(jG) }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = a, this.root = l ? l.root || l : this, this.path = l ? [...l.path, l] : [], this.parent = l, this.depth = l ? l.depth + 1 : 0; for (let u = 0; u < this.path.length; u++)this.path[u].shouldResetTransform = !0; this.root === this && (this.nodes = new lG) } addEventListener(a, l) { return this.eventHandlers.has(a) || this.eventHandlers.set(a, new sS), this.eventHandlers.get(a).add(l) } notifyListeners(a, ...l) { const u = this.eventHandlers.get(a); u && u.notify(...l) } hasListeners(a) { return this.eventHandlers.has(a) } mount(a) { if (this.instance) return; this.isSVG = ZD(a) && !vW(a), this.instance = a; const { layoutId: l, layout: u, visualElement: f } = this.options; if (f && !f.current && f.mount(a), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (u || l) && (this.isLayoutDirty = !0), t) { let p; const g = () => this.root.updateBlockedByResize = !1; t(a, () => { this.root.updateBlockedByResize = !0, p && p(), p = cG(g, 250), Am.hasAnimatedSinceResize && (Am.hasAnimatedSinceResize = !1, this.nodes.forEach(ik)) }) } l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && f && (l || u) && this.addEventListener("didUpdate", ({ delta: p, hasLayoutChanged: g, hasRelativeLayoutChanged: y, layout: v }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const b = this.options.transition || f.getDefaultTransition() || PG, { onLayoutAnimationStart: S, onLayoutAnimationComplete: C } = f.getProps(), T = !this.targetLayout || !MR(this.targetLayout, v), A = !g && y; if (this.options.layoutRoot || this.resumeFrom || A || g && (T || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0); const M = { ...xS(b, "layout"), onPlay: S, onComplete: C }; (f.shouldReduceMotion || this.options.layoutRoot) && (M.delay = 0, M.type = !1), this.startAnimation(M), this.setAnimationOrigin(p, A) } else g || ik(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = v }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const a = this.getStack(); a && a.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), $o(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(DG), this.animationId++) } getTransformTemplate() { const { visualElement: a } = this.options; return a && a.getProps().transformTemplate } willUpdate(a = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && DR(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let p = 0; p < this.path.length; p++) { const g = this.path[p]; g.shouldResetTransform = !0, g.updateScroll("snapshot"), g.options.layoutRoot && g.willUpdate(!1) } const { layoutId: l, layout: u } = this.options; if (l === void 0 && !u) return; const f = this.getTransformTemplate(); this.prevTransformTemplateValue = f ? f(this.latestValues, "") : void 0, this.updateSnapshot(), a && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(rk); return } this.isUpdating || this.nodes.forEach(AG), this.isUpdating = !1, this.nodes.forEach(kG), this.nodes.forEach(CG), this.nodes.forEach(TG), this.clearAllSnapshots(); const l = vi.now(); Pr.delta = $a(0, 1e3 / 60, l - Pr.timestamp), Pr.timestamp = l, Pr.isProcessing = !0, bx.update.process(Pr), bx.preRender.process(Pr), bx.render.process(Pr), Pr.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, wS.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(EG), this.sharedNodes.forEach(RG) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Bn.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { Bn.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !ii(this.snapshot.measuredBox.x) && !ii(this.snapshot.measuredBox.y) && (this.snapshot = void 0)) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let u = 0; u < this.path.length; u++)this.path[u].updateScroll(); const a = this.layout; this.layout = this.measure(!1), this.layoutCorrected = tr(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: l } = this.options; l && l.notify("LayoutMeasure", this.layout.layoutBox, a ? a.layoutBox : void 0) } updateScroll(a = "measure") { let l = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === a && (l = !1), l && this.instance) { const u = r(this.instance); this.scroll = { animationId: this.root.animationId, phase: a, isRoot: u, offset: n(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : u } } } resetTransform() { if (!i) return; const a = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, l = this.projectionDelta && !OR(this.projectionDelta), u = this.getTransformTemplate(), f = u ? u(this.latestValues, "") : void 0, p = f !== this.prevTransformTemplateValue; a && this.instance && (l || Sl(this.latestValues) || p) && (i(this.instance, f), this.shouldResetTransform = !1, this.scheduleRender()) } measure(a = !0) { const l = this.measurePageBox(); let u = this.removeElementScroll(l); return a && (u = this.removeTransform(u)), zG(u), { animationId: this.root.animationId, measuredBox: l, layoutBox: u, latestValues: {}, source: this.id } } measurePageBox() { const { visualElement: a } = this.options; if (!a) return tr(); const l = a.measureViewportBox(); if (!(this.scroll?.wasRoot || this.path.some(IG))) { const { scroll: f } = this.root; f && (su(l.x, f.offset.x), su(l.y, f.offset.y)) } return l } removeElementScroll(a) { const l = tr(); if (es(l, a), this.scroll?.wasRoot) return l; for (let u = 0; u < this.path.length; u++) { const f = this.path[u], { scroll: p, options: g } = f; f !== this.root && p && g.layoutScroll && (p.wasRoot && es(l, a), su(l.x, p.offset.x), su(l.y, p.offset.y)) } return l } applyTransform(a, l = !1) { const u = tr(); es(u, a); for (let f = 0; f < this.path.length; f++) { const p = this.path[f]; !l && p.options.layoutScroll && p.scroll && p !== p.root && au(u, { x: -p.scroll.offset.x, y: -p.scroll.offset.y }), Sl(p.latestValues) && au(u, p.latestValues) } return Sl(this.latestValues) && au(u, this.latestValues), u } removeTransform(a) { const l = tr(); es(l, a); for (let u = 0; u < this.path.length; u++) { const f = this.path[u]; if (!f.instance || !Sl(f.latestValues)) continue; f1(f.latestValues) && f.updateSnapshot(); const p = tr(), g = f.measurePageBox(); es(p, g), QA(l, f.latestValues, f.snapshot ? f.snapshot.layoutBox : void 0, p) } return Sl(this.latestValues) && QA(l, this.latestValues), l } setTargetDelta(a) { this.targetDelta = a, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(a) { this.options = { ...this.options, ...a, crossfade: a.crossfade !== void 0 ? a.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Pr.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(a = !1) { const l = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty); const u = !!this.resumingFrom || this !== l; if (!(a || u && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: p, layoutId: g } = this.options; if (!(!this.layout || !(p || g))) { if (this.resolvedRelativeTargetAt = Pr.timestamp, !this.targetDelta && !this.relativeTarget) { const y = this.getClosestProjectingParent(); y && y.layout && this.animationProgress !== 1 ? (this.relativeParent = y, this.forceRelativeParentToResolveTarget(), this.relativeTarget = tr(), this.relativeTargetOrigin = tr(), df(this.relativeTargetOrigin, this.layout.layoutBox, y.layout.layoutBox), es(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = tr(), this.targetWithTransforms = tr()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), BY(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : es(this.target, this.layout.layoutBox), SR(this.target, this.targetDelta)) : es(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget)) { this.attemptToResolveRelativeTarget = !1; const y = this.getClosestProjectingParent(); y && !!y.resumingFrom == !!this.resumingFrom && !y.options.layoutScroll && y.target && this.animationProgress !== 1 ? (this.relativeParent = y, this.forceRelativeParentToResolveTarget(), this.relativeTarget = tr(), this.relativeTargetOrigin = tr(), df(this.relativeTargetOrigin, this.target, y.target), es(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } } } getClosestProjectingParent() { if (!(!this.parent || f1(this.parent.latestValues) || wR(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { const a = this.getLead(), l = !!this.resumingFrom || this !== a; let u = !0; if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (u = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (u = !1), this.resolvedRelativeTargetAt === Pr.timestamp && (u = !1), u) return; const { layout: f, layoutId: p } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(f || p)) return; es(this.layoutCorrected, this.layout.layoutBox); const g = this.treeScale.x, y = this.treeScale.y; $Y(this.layoutCorrected, this.treeScale, this.path, l), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = tr()); const { target: v } = a; if (!v) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (YA(this.prevProjectionDelta.x, this.projectionDelta.x), YA(this.prevProjectionDelta.y, this.projectionDelta.y)), uf(this.projectionDelta, this.layoutCorrected, v, this.latestValues), (this.treeScale.x !== g || this.treeScale.y !== y || !nk(this.projectionDelta.x, this.prevProjectionDelta.x) || !nk(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", v)) } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(a = !0) { if (this.options.visualElement?.scheduleRender(), a) { const l = this.getStack(); l && l.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = iu(), this.projectionDelta = iu(), this.projectionDeltaWithTransform = iu() } setAnimationOrigin(a, l = !1) { const u = this.snapshot, f = u ? u.latestValues : {}, p = { ...this.latestValues }, g = iu(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !l; const y = tr(), v = u ? u.source : void 0, b = this.layout ? this.layout.source : void 0, S = v !== b, C = this.getStack(), T = !C || C.members.length <= 1, A = !!(S && !T && this.options.crossfade === !0 && !this.path.some(LG)); this.animationProgress = 0; let M; this.mixTargetDelta = O => { const E = O / 1e3; sk(g.x, a.x, E), sk(g.y, a.y, E), this.setTargetDelta(g), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (df(y, this.layout.layoutBox, this.relativeParent.layout.layoutBox), _G(this.relativeTarget, this.relativeTargetOrigin, y, E), M && yG(this.relativeTarget, M) && (this.isProjectionDirty = !1), M || (M = tr()), es(M, this.relativeTarget)), S && (this.animationValues = p, dG(p, f, this.latestValues, E, A, T)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = E }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(a) { this.notifyListeners("animationStart"), this.currentAnimation?.stop(), this.resumingFrom?.currentAnimation?.stop(), this.pendingAnimation && ($o(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Bn.update(() => { Am.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = pu(0)), this.currentAnimation = aG(this.motionValue, [0, 1e3], { ...a, velocity: 0, isSync: !0, onUpdate: l => { this.mixTargetDelta(l), a.onUpdate && a.onUpdate(l) }, onStop: () => { }, onComplete: () => { a.onComplete && a.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const a = this.getStack(); a && a.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(wG), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const a = this.getLead(); let { targetWithTransforms: l, target: u, layout: f, latestValues: p } = a; if (!(!l || !u || !f)) { if (this !== a && this.layout && f && _R(this.options.animationType, this.layout.layoutBox, f.layoutBox)) { u = this.target || tr(); const g = ii(this.layout.layoutBox.x); u.x.min = a.target.x.min, u.x.max = u.x.min + g; const y = ii(this.layout.layoutBox.y); u.y.min = a.target.y.min, u.y.max = u.y.min + y } es(l, u), au(l, p), uf(this.projectionDeltaWithTransform, this.layoutCorrected, l, p) } } registerSharedNode(a, l) { this.sharedNodes.has(a) || this.sharedNodes.set(a, new vG), this.sharedNodes.get(a).add(l); const f = l.options.initialPromotionConfig; l.promote({ transition: f ? f.transition : void 0, preserveFollowOpacity: f && f.shouldPreserveFollowOpacity ? f.shouldPreserveFollowOpacity(l) : void 0 }) } isLead() { const a = this.getStack(); return a ? a.lead === this : !0 } getLead() { const { layoutId: a } = this.options; return a ? this.getStack()?.lead || this : this } getPrevLead() { const { layoutId: a } = this.options; return a ? this.getStack()?.prevLead : void 0 } getStack() { const { layoutId: a } = this.options; if (a) return this.root.sharedNodes.get(a) } promote({ needsReset: a, transition: l, preserveFollowOpacity: u } = {}) { const f = this.getStack(); f && f.promote(this, u), a && (this.projectionDelta = void 0, this.needsReset = !0), l && this.setOptions({ transition: l }) } relegate() { const a = this.getStack(); return a ? a.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: a } = this.options; if (!a) return; let l = !1; const { latestValues: u } = a; if ((u.z || u.rotate || u.rotateX || u.rotateY || u.rotateZ || u.skewX || u.skewY) && (l = !0), !l) return; const f = {}; u.z && Ox("z", a, f, this.animationValues); for (let p = 0; p < kx.length; p++)Ox(`rotate${kx[p]}`, a, f, this.animationValues), Ox(`skew${kx[p]}`, a, f, this.animationValues); a.render(); for (const p in f) a.setStaticValue(p, f[p]), this.animationValues && (this.animationValues[p] = f[p]); a.scheduleRender() } getProjectionStyles(a) { if (!this.instance || this.isSVG) return; if (!this.isVisible) return bG; const l = { visibility: "" }, u = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, l.opacity = "", l.pointerEvents = Em(a?.pointerEvents) || "", l.transform = u ? u(this.latestValues, "") : "none", l; const f = this.getLead(); if (!this.projectionDelta || !this.layout || !f.target) { const v = {}; return this.options.layoutId && (v.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, v.pointerEvents = Em(a?.pointerEvents) || ""), this.hasProjected && !Sl(this.latestValues) && (v.transform = u ? u({}, "") : "none", this.hasProjected = !1), v } const p = f.animationValues || f.latestValues; this.applyTransformsToTarget(), l.transform = xG(this.projectionDeltaWithTransform, this.treeScale, p), u && (l.transform = u(p, l.transform)); const { x: g, y } = this.projectionDelta; l.transformOrigin = `${g.origin * 100}% ${y.origin * 100}% 0`, f.animationValues ? l.opacity = f === this ? p.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : p.opacityExit : l.opacity = f === this ? p.opacity !== void 0 ? p.opacity : "" : p.opacityExit !== void 0 ? p.opacityExit : 0; for (const v in Bf) { if (p[v] === void 0) continue; const { correct: b, applyTo: S, isCSSVariable: C } = Bf[v], T = l.transform === "none" ? p[v] : b(p[v], f); if (S) { const A = S.length; for (let M = 0; M < A; M++)l[S[M]] = T } else C ? this.options.visualElement.renderState.vars[v] = T : l[v] = T } return this.options.layoutId && (l.pointerEvents = f === this ? Em(a?.pointerEvents) || "" : "none"), l } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(a => a.currentAnimation?.stop()), this.root.nodes.forEach(rk), this.root.sharedNodes.clear() } } } function CG(t) { t.updateLayout() } function TG(t) { const e = t.resumeFrom?.snapshot || t.snapshot; if (t.isLead() && t.layout && e && t.hasListeners("didUpdate")) { const { layoutBox: n, measuredBox: r } = t.layout, { animationType: i } = t.options, s = e.source !== t.layout.source; i === "size" ? ns(p => { const g = s ? e.measuredBox[p] : e.layoutBox[p], y = ii(g); g.min = n[p].min, g.max = g.min + y }) : _R(i, e.layoutBox, n) && ns(p => { const g = s ? e.measuredBox[p] : e.layoutBox[p], y = ii(n[p]); g.max = g.min + y, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[p].max = t.relativeTarget[p].min + y) }); const a = iu(); uf(a, n, e.layoutBox); const l = iu(); s ? uf(l, t.applyTransform(r, !0), e.measuredBox) : uf(l, n, e.layoutBox); const u = !OR(a); let f = !1; if (!t.resumeFrom) { const p = t.getClosestProjectingParent(); if (p && !p.resumeFrom) { const { snapshot: g, layout: y } = p; if (g && y) { const v = tr(); df(v, e.layoutBox, g.layoutBox); const b = tr(); df(b, n, y.layoutBox), MR(v, b) || (f = !0), p.options.layoutRoot && (t.relativeTarget = b, t.relativeTargetOrigin = v, t.relativeParent = p) } } } t.notifyListeners("didUpdate", { layout: n, snapshot: e, delta: l, layoutDelta: a, hasLayoutChanged: u, hasRelativeLayoutChanged: f }) } else if (t.isLead()) { const { onExitComplete: n } = t.options; n && n() } t.options.transition = void 0 } function NG(t) { t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty)) } function jG(t) { t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1 } function EG(t) { t.clearSnapshot() } function rk(t) { t.clearMeasurements() } function AG(t) { t.isLayoutDirty = !1 } function kG(t) { const { visualElement: e } = t.options; e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform() } function ik(t) { t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0 } function OG(t) { t.resolveTargetDelta() } function MG(t) { t.calcProjection() } function DG(t) { t.resetSkewAndRotation() } function RG(t) { t.removeLeadSnapshot() } function sk(t, e, n) { t.translate = Fn(e.translate, 0, n), t.scale = Fn(e.scale, 1, n), t.origin = e.origin, t.originPoint = e.originPoint } function ak(t, e, n, r) { t.min = Fn(e.min, n.min, r), t.max = Fn(e.max, n.max, r) } function _G(t, e, n, r) { ak(t.x, e.x, n.x, r), ak(t.y, e.y, n.y, r) } function LG(t) { return t.animationValues && t.animationValues.opacityExit !== void 0 } const PG = { duration: .45, ease: [.4, 0, .1, 1] }, ok = t => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), lk = ok("applewebkit/") && !ok("chrome/") ? Math.round : ls; function ck(t) { t.min = lk(t.min), t.max = lk(t.max) } function zG(t) { ck(t.x), ck(t.y) } function _R(t, e, n) { return t === "position" || t === "preserve-aspect" && !FY(tk(e), tk(n), .2) } function IG(t) { return t !== t.root && t.scroll?.wasRoot } const FG = RR({ attachResizeListener: (t, e) => Uf(t, "resize", e), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), Mx = { current: void 0 }, LR = RR({ measureScroll: t => ({ x: t.scrollLeft, y: t.scrollTop }), defaultParent: () => { if (!Mx.current) { const t = new FG({}); t.mount(window), t.setOptions({ layoutScroll: !0 }), Mx.current = t } return Mx.current }, resetTransform: (t, e) => { t.style.transform = e !== void 0 ? e : "none" }, checkIsScrollRoot: t => window.getComputedStyle(t).position === "fixed" }), BG = { pan: { Feature: nG }, drag: { Feature: tG, ProjectionNode: LR, MeasureLayout: ER } }; function uk(t, e, n) { const { props: r } = t; t.animationState && r.whileHover && t.animationState.setActive("whileHover", n === "Start"); const i = "onHover" + n, s = r[i]; s && Bn.postRender(() => s(e, xh(e))) } class $G extends Go { mount() { const { current: e } = this.node; e && (this.unmount = hW(e, (n, r) => (uk(this.node, r, "Start"), i => uk(this.node, i, "End")))) } unmount() { } } class UG extends Go { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let e = !1; try { e = this.node.current.matches(":focus-visible") } catch { e = !0 } !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = gh(Uf(this.node.current, "focus", () => this.onFocus()), Uf(this.node.current, "blur", () => this.onBlur())) } unmount() { } } function dk(t, e, n) { const { props: r } = t; if (t.current instanceof HTMLButtonElement && t.current.disabled) return; t.animationState && r.whileTap && t.animationState.setActive("whileTap", n === "Start"); const i = "onTap" + (n === "End" ? "" : n), s = r[i]; s && Bn.postRender(() => s(e, xh(e))) } class VG extends Go { mount() { const { current: e } = this.node; e && (this.unmount = yW(e, (n, r) => (dk(this.node, r, "Start"), (i, { success: s }) => dk(this.node, i, s ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget })) } unmount() { } } const m1 = new WeakMap, Dx = new WeakMap, HG = t => { const e = m1.get(t.target); e && e(t) }, qG = t => { t.forEach(HG) }; function KG({ root: t, ...e }) { const n = t || document; Dx.has(n) || Dx.set(n, {}); const r = Dx.get(n), i = JSON.stringify(e); return r[i] || (r[i] = new IntersectionObserver(qG, { root: t, ...e })), r[i] } function WG(t, e, n) { const r = KG(e); return m1.set(t, n), r.observe(t), () => { m1.delete(t), r.unobserve(t) } } const YG = { some: 0, all: 1 }; class GG extends Go { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: e = {} } = this.node.getProps(), { root: n, margin: r, amount: i = "some", once: s } = e, a = { root: n ? n.current : void 0, rootMargin: r, threshold: typeof i == "number" ? i : YG[i] }, l = u => { const { isIntersecting: f } = u; if (this.isInView === f || (this.isInView = f, s && !f && this.hasEnteredView)) return; f && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", f); const { onViewportEnter: p, onViewportLeave: g } = this.node.getProps(), y = f ? p : g; y && y(u) }; return WG(this.node.current, a, l) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: e, prevProps: n } = this.node;["amount", "margin", "root"].some(XG(e, n)) && this.startObserver() } unmount() { } } function XG({ viewport: t = {} }, { viewport: e = {} } = {}) { return n => t[n] !== e[n] } const QG = { inView: { Feature: GG }, tap: { Feature: VG }, focus: { Feature: UG }, hover: { Feature: $G } }, JG = { layout: { ProjectionNode: LR, MeasureLayout: ER } }, g1 = { current: null }, PR = { current: !1 }; function ZG() { if (PR.current = !0, !!eS) if (window.matchMedia) { const t = window.matchMedia("(prefers-reduced-motion)"), e = () => g1.current = t.matches; t.addListener(e), e() } else g1.current = !1 } const eX = new WeakMap; function tX(t, e, n) { for (const r in e) { const i = e[r], s = n[r]; if (Yr(i)) t.addValue(r, i); else if (Yr(s)) t.addValue(r, pu(i, { owner: t })); else if (s !== i) if (t.hasValue(r)) { const a = t.getValue(r); a.liveStyle === !0 ? a.jump(i) : a.hasAnimated || a.set(i) } else { const a = t.getStaticValue(r); t.addValue(r, pu(a !== void 0 ? a : i, { owner: t })) } } for (const r in n) e[r] === void 0 && t.removeValue(r); return e } const fk = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]; class nX { scrapeMotionValuesFromProps(e, n, r) { return {} } constructor({ parent: e, props: n, presenceContext: r, reducedMotionConfig: i, blockInitialAnimation: s, visualState: a }, l = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = yS, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { const y = vi.now(); this.renderScheduledAt < y && (this.renderScheduledAt = y, Bn.render(this.render, !1, !0)) }; const { latestValues: u, renderState: f } = a; this.latestValues = u, this.baseTarget = { ...u }, this.initialValues = n.initial ? { ...u } : {}, this.renderState = f, this.parent = e, this.props = n, this.presenceContext = r, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = i, this.options = l, this.blockInitialAnimation = !!s, this.isControllingVariants = jy(n), this.isVariantNode = rR(n), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(e && e.current); const { willChange: p, ...g } = this.scrapeMotionValuesFromProps(n, {}, this); for (const y in g) { const v = g[y]; u[y] !== void 0 && Yr(v) && v.set(u[y], !1) } } mount(e) { this.current = e, eX.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, r) => this.bindToMotionValue(r, n)), PR.current || ZG(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : g1.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { this.projection && this.projection.unmount(), $o(this.notifyUpdate), $o(this.render), this.valueSubscriptions.forEach(e => e()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (const e in this.events) this.events[e].clear(); for (const e in this.features) { const n = this.features[e]; n && (n.unmount(), n.isMounted = !1) } this.current = null } bindToMotionValue(e, n) { this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)(); const r = Ru.has(e); r && this.onBindTransform && this.onBindTransform(); const i = n.on("change", l => { this.latestValues[e] = l, this.props.onUpdate && Bn.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0) }), s = n.on("renderRequest", this.scheduleRender); let a; window.MotionCheckAppearSync && (a = window.MotionCheckAppearSync(this, e, n)), this.valueSubscriptions.set(e, () => { i(), s(), a && a(), n.owner && n.stop() }) } sortNodePosition(e) { return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current) } updateFeatures() { let e = "animation"; for (e in mu) { const n = mu[e]; if (!n) continue; const { isEnabled: r, Feature: i } = n; if (!this.features[e] && i && r(this.props) && (this.features[e] = new i(this)), this.features[e]) { const s = this.features[e]; s.isMounted ? s.update() : (s.mount(), s.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : tr() } getStaticValue(e) { return this.latestValues[e] } setStaticValue(e, n) { this.latestValues[e] = n } update(e, n) { (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = n; for (let r = 0; r < fk.length; r++) { const i = fk[r]; this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]); const s = "on" + i, a = e[s]; a && (this.propEventSubscriptions[i] = this.on(i, a)) } this.prevMotionValues = tX(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(e) { return this.props.variants ? this.props.variants[e] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(e) { const n = this.getClosestVariantNode(); if (n) return n.variantChildren && n.variantChildren.add(e), () => n.variantChildren.delete(e) } addValue(e, n) { const r = this.values.get(e); n !== r && (r && this.removeValue(e), this.bindToMotionValue(e, n), this.values.set(e, n), this.latestValues[e] = n.get()) } removeValue(e) { this.values.delete(e); const n = this.valueSubscriptions.get(e); n && (n(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState) } hasValue(e) { return this.values.has(e) } getValue(e, n) { if (this.props.values && this.props.values[e]) return this.props.values[e]; let r = this.values.get(e); return r === void 0 && n !== void 0 && (r = pu(n === null ? void 0 : n, { owner: this }), this.addValue(e, r)), r } readValue(e, n) { let r = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : this.getBaseTargetFromProps(this.props, e) ?? this.readValueFromInstance(this.current, e, this.options); return r != null && (typeof r == "string" && (dD(r) || hD(r)) ? r = parseFloat(r) : !bW(r) && Uo.test(n) && (r = YD(e, n)), this.setBaseTarget(e, Yr(r) ? r.get() : r)), Yr(r) ? r.get() : r } setBaseTarget(e, n) { this.baseTarget[e] = n } getBaseTarget(e) { const { initial: n } = this.props; let r; if (typeof n == "string" || typeof n == "object") { const s = OS(this.props, n, this.presenceContext?.custom); s && (r = s[e]) } if (n && r !== void 0) return r; const i = this.getBaseTargetFromProps(this.props, e); return i !== void 0 && !Yr(i) ? i : this.initialValues[e] !== void 0 && r === void 0 ? void 0 : this.baseTarget[e] } on(e, n) { return this.events[e] || (this.events[e] = new sS), this.events[e].add(n) } notify(e, ...n) { this.events[e] && this.events[e].notify(...n) } } class zR extends nX { constructor() { super(...arguments), this.KeyframeResolver = lW } sortInstanceNodePosition(e, n) { return e.compareDocumentPosition(n) & 2 ? 1 : -1 } getBaseTargetFromProps(e, n) { return e.style ? e.style[n] : void 0 } removeValueFromRenderState(e, { vars: n, style: r }) { delete n[e], delete r[e] } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: e } = this.props; Yr(e) && (this.childSubscription = e.on("change", n => { this.current && (this.current.textContent = `${n}`) })) } } function IR(t, { style: e, vars: n }, r, i) { Object.assign(t.style, e, i && i.getProjectionStyles(r)); for (const s in n) t.style.setProperty(s, n[s]) } function rX(t) { return window.getComputedStyle(t) } class iX extends zR { constructor() { super(...arguments), this.type = "html", this.renderInstance = IR } readValueFromInstance(e, n) { if (Ru.has(n)) return this.projection?.isProjecting ? r1(n) : EK(e, n); { const r = rX(e), i = (lS(n) ? r.getPropertyValue(n) : r[n]) || 0; return typeof i == "string" ? i.trim() : i } } measureInstanceViewportBox(e, { transformPagePoint: n }) { return CR(e, n) } build(e, n, r) { ES(e, n, r.transformTemplate) } scrapeMotionValuesFromProps(e, n, r) { return MS(e, n, r) } } const FR = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function sX(t, e, n, r) { IR(t, e, void 0, r); for (const i in e.attrs) t.setAttribute(FR.has(i) ? i : jS(i), e.attrs[i]) } class aX extends zR { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = tr } getBaseTargetFromProps(e, n) { return e[n] } readValueFromInstance(e, n) { if (Ru.has(n)) { const r = WD(n); return r && r.default || 0 } return n = FR.has(n) ? n : jS(n), e.getAttribute(n) } scrapeMotionValuesFromProps(e, n, r) { return hR(e, n, r) } build(e, n, r) { cR(e, n, this.isSVGTag, r.transformTemplate, r.style) } renderInstance(e, n, r, i) { sX(e, n, r, i) } mount(e) { this.isSVGTag = dR(e.tagName), super.mount(e) } } const oX = (t, e) => kS(t) ? new aX(e) : new iX(e, { allowProjection: t !== N.Fragment }), lX = sY({ ...MY, ...QG, ...BG, ...JG }, oX), ot = OW(lX); function cX(t) { return Vt({ attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z" }, child: [] }] })(t) } function uX(t) { return Vt({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M0 464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V192H0v272zm320-196c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zm0 128c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zM192 268c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zm0 128c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zM64 268c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H76c-6.6 0-12-5.4-12-12v-40zm0 128c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H76c-6.6 0-12-5.4-12-12v-40zM400 64h-48V16c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v48H160V16c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v48H48C21.5 64 0 85.5 0 112v48h448v-48c0-26.5-21.5-48-48-48z" }, child: [] }] })(t) } function Cs(t) { return Vt({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z" }, child: [] }] })(t) } function Ds(t) { return Vt({ attr: { viewBox: "0 0 320 512" }, child: [{ tag: "path", attr: { d: "M34.52 239.03L228.87 44.69c9.37-9.37 24.57-9.37 33.94 0l22.67 22.67c9.36 9.36 9.37 24.52.04 33.9L131.49 256l154.02 154.75c9.34 9.38 9.32 24.54-.04 33.9l-22.67 22.67c-9.37 9.37-24.57 9.37-33.94 0L34.52 272.97c-9.37-9.37-9.37-24.57 0-33.94z" }, child: [] }] })(t) } function Rs(t) { return Vt({ attr: { viewBox: "0 0 320 512" }, child: [{ tag: "path", attr: { d: "M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z" }, child: [] }] })(t) } function dX(t) { return Vt({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M256,8C119,8,8,119,8,256S119,504,256,504,504,393,504,256,393,8,256,8Zm92.49,313h0l-20,25a16,16,0,0,1-22.49,2.5h0l-67-49.72a40,40,0,0,1-15-31.23V112a16,16,0,0,1,16-16h32a16,16,0,0,1,16,16V256l58,42.5A16,16,0,0,1,348.49,321Z" }, child: [] }] })(t) } function br(t) { return Vt({ attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M402.6 83.2l90.2 90.2c3.8 3.8 3.8 10 0 13.8L274.4 405.6l-92.8 10.3c-12.4 1.4-22.9-9.1-21.5-21.5l10.3-92.8L388.8 83.2c3.8-3.8 10-3.8 13.8 0zm162-22.9l-48.8-48.8c-15.2-15.2-39.9-15.2-55.2 0l-35.4 35.4c-3.8 3.8-3.8 10 0 13.8l90.2 90.2c3.8 3.8 10 3.8 13.8 0l35.4-35.4c15.2-15.3 15.2-40 0-55.2zM384 346.2V448H64V128h229.8c3.2 0 6.2-1.3 8.5-3.5l40-40c7.6-7.6 2.2-20.5-8.5-20.5H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V306.2c0-10.7-12.9-16-20.5-8.5l-40 40c-2.2 2.3-3.5 5.3-3.5 8.5z" }, child: [] }] })(t) } function fX(t) { return Vt({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z" }, child: [] }] })(t) } function BR(t) { return Vt({ attr: { viewBox: "0 0 640 512" }, child: [{ tag: "path", attr: { d: "M320 400c-75.85 0-137.25-58.71-142.9-133.11L72.2 185.82c-13.79 17.3-26.48 35.59-36.72 55.59a32.35 32.35 0 0 0 0 29.19C89.71 376.41 197.07 448 320 448c26.91 0 52.87-4 77.89-10.46L346 397.39a144.13 144.13 0 0 1-26 2.61zm313.82 58.1l-110.55-85.44a331.25 331.25 0 0 0 81.25-102.07 32.35 32.35 0 0 0 0-29.19C550.29 135.59 442.93 64 320 64a308.15 308.15 0 0 0-147.32 37.7L45.46 3.37A16 16 0 0 0 23 6.18L3.37 31.45A16 16 0 0 0 6.18 53.9l588.36 454.73a16 16 0 0 0 22.46-2.81l19.64-25.27a16 16 0 0 0-2.82-22.45zm-183.72-142l-39.3-30.38A94.75 94.75 0 0 0 416 256a94.76 94.76 0 0 0-121.31-92.21A47.65 47.65 0 0 1 304 192a46.64 46.64 0 0 1-1.54 10l-73.61-56.89A142.31 142.31 0 0 1 320 112a143.92 143.92 0 0 1 144 144c0 21.63-5.29 41.79-13.9 60.11z" }, child: [] }] })(t) } function RS(t) { return Vt({ attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M572.52 241.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400a144 144 0 1 1 144-144 143.93 143.93 0 0 1-144 144zm0-240a95.31 95.31 0 0 0-25.31 3.79 47.85 47.85 0 0 1-66.9 66.9A95.78 95.78 0 1 0 288 160z" }, child: [] }] })(t) } function hX(t) { return Vt({ attr: { viewBox: "0 0 384 512" }, child: [{ tag: "path", attr: { d: "M224 136V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zm65.18 216.01H224v80c0 8.84-7.16 16-16 16h-32c-8.84 0-16-7.16-16-16v-80H94.82c-14.28 0-21.41-17.29-11.27-27.36l96.42-95.7c6.65-6.61 17.39-6.61 24.04 0l96.42 95.7c10.15 10.07 3.03 27.36-11.25 27.36zM377 105L279.1 7c-4.5-4.5-10.6-7-17-7H256v128h128v-6.1c0-6.3-2.5-12.4-7-16.9z" }, child: [] }] })(t) } function pX(t) { return Vt({ attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M572.694 292.093L500.27 416.248A63.997 63.997 0 0 1 444.989 448H45.025c-18.523 0-30.064-20.093-20.731-36.093l72.424-124.155A64 64 0 0 1 152 256h399.964c18.523 0 30.064 20.093 20.73 36.093zM152 224h328v-48c0-26.51-21.49-48-48-48H272l-64-64H48C21.49 64 0 85.49 0 112v278.046l69.077-118.418C86.214 242.25 117.989 224 152 224z" }, child: [] }] })(t) } function sg(t) { return Vt({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z" }, child: [] }] })(t) } function hk(t) { return Vt({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M400 224h-24v-72C376 68.2 307.8 0 224 0S72 68.2 72 152v72H48c-26.5 0-48 21.5-48 48v192c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V272c0-26.5-21.5-48-48-48zm-104 0H152v-72c0-39.7 32.3-72 72-72s72 32.3 72 72v72z" }, child: [] }] })(t) } function mX(t) { return Vt({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M424.4 214.7L72.4 6.6C43.8-10.3 0 6.1 0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1 0-82.6z" }, child: [] }] })(t) } function fr(t) { return Vt({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z" }, child: [] }] })(t) } function gX(t) { return Vt({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zM262.655 90c-54.497 0-89.255 22.957-116.549 63.758-3.536 5.286-2.353 12.415 2.715 16.258l34.699 26.31c5.205 3.947 12.621 3.008 16.665-2.122 17.864-22.658 30.113-35.797 57.303-35.797 20.429 0 45.698 13.148 45.698 32.958 0 14.976-12.363 22.667-32.534 33.976C247.128 238.528 216 254.941 216 296v4c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12v-1.333c0-28.462 83.186-29.647 83.186-106.667 0-58.002-60.165-102-116.531-102zM256 338c-25.365 0-46 20.635-46 46 0 25.364 20.635 46 46 46s46-20.636 46-46c0-25.365-20.635-46-46-46z" }, child: [] }] })(t) } function yX(t) { return Vt({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z" }, child: [] }] })(t) } function mt(t) { return Vt({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49 0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156 0c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z" }, child: [] }] })(t) } function vX(t) { return Vt({ attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z" }, child: [] }] })(t) } function xX(t) { return Vt({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z" }, child: [] }] })(t) } function vr(t) { return Vt({ attr: { viewBox: "0 0 352 512" }, child: [{ tag: "path", attr: { d: "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z" }, child: [] }] })(t) } function Cn(t) { return Vt({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M32 464a48 48 0 0 0 48 48h288a48 48 0 0 0 48-48V128H32zm272-256a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zm-96 0a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zm-96 0a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zM432 32H312l-9.4-18.7A24 24 0 0 0 281.1 0H166.8a23.72 23.72 0 0 0-21.4 13.3L136 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16z" }, child: [] }] })(t) } function bX(t) { return Vt({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm95.8 32.6L272 480l-32-136 32-56h-96l32 56-32 136-47.8-191.4C56.9 292 0 350.3 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-72.1-56.9-130.4-128.2-133.8z" }, child: [] }] })(t) } function wX(t) { return Vt({ attr: { viewBox: "0 0 640 512" }, child: [{ tag: "path", attr: { d: "M96 224c35.3 0 64-28.7 64-64s-28.7-64-64-64-64 28.7-64 64 28.7 64 64 64zm448 0c35.3 0 64-28.7 64-64s-28.7-64-64-64-64 28.7-64 64 28.7 64 64 64zm32 32h-64c-17.6 0-33.5 7.1-45.1 18.6 40.3 22.1 68.9 62 75.1 109.4h66c17.7 0 32-14.3 32-32v-32c0-35.3-28.7-64-64-64zm-256 0c61.9 0 112-50.1 112-112S381.9 32 320 32 208 82.1 208 144s50.1 112 112 112zm76.8 32h-8.3c-20.8 10-43.9 16-68.5 16s-47.6-6-68.5-16h-8.3C179.6 288 128 339.6 128 403.2V432c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48v-28.8c0-63.6-51.6-115.2-115.2-115.2zm-223.7-13.4C161.5 263.1 145.6 256 128 256H64c-35.3 0-64 28.7-64 64v32c0 17.7 14.3 32 32 32h65.9c6.3-47.4 34.9-87.3 75.2-109.4z" }, child: [] }] })(t) } function SX({ integrations: t, loading: e, refetch: n }) { const r = ln(), [i, s] = N.useState({ global: "", name: "", order: "", status: "" }), [a, l] = N.useState(1), [u] = N.useState(10), [f, p] = N.useState(null), [g, y] = N.useState(null), [v, b] = N.useState(!1), [S, C] = N.useState(!1), [T, A] = N.useState(null), [M, O] = N.useState(!1), [E, k] = N.useState(null), [z, V] = N.useState(!1), [q, ue] = N.useState({ name: "", description: "", display_order: "", is_active: !0 }), [W, ne] = N.useState(null), [H, we] = N.useState(""), xe = ($, U) => { s(be => ({ ...be, [$]: U })), l(1) }, { data: K, isLoading: te, error: ye, isError: He } = Jt({ queryKey: ["currentUser"], queryFn: () => Ve.get("https://api.nexus.com/api/auth/me", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }), B = async $ => { p($); try { await Ve.patch(`https://api.nexus.com/api/admin/integrations/${$}/toggle-status`, {}, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success("Integration status updated successfully", { duration: 2e3 }), n() } catch (U) { me.error(U.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), U.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), U.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } finally { p(null) } }, ie = $ => { k($), O(!0) }, oe = async () => { if (E) { y(E), O(!1); try { await Ve.delete(`https://api.nexus.com/api/admin/integrations/${E}`, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success("Integration deleted successfully", { duration: 2e3 }), n() } catch ($) { me.error($.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), $.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), $.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } finally { y(null), k(null) } } }, pe = $ => { const U = $.target.files[0]; if (U) { const be = new FileReader; be.onloadend = () => { ne(U), we(be.result) }, be.readAsDataURL(U) } }, Ee = () => { ne(null), we("") }, fe = $ => { const { name: U, value: be, type: Ie, checked: it } = $.target; ue(P => ({ ...P, [U]: Ie === "checkbox" ? it : be })) }, Oe = async $ => { $.preventDefault(), V(!0); try { const U = new FormData; U.append("name", q.name), U.append("description", q.description), U.append("display_order", q.display_order), U.append("is_active", q.is_active ? 1 : 0), W && U.append("logo", W), await Ve.post("https://api.nexus.com/api/admin/integrations", U, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}`, "Content-Type": "multipart/form-data" } }), V(!1), me.success("Integration added successfully", { duration: 2e3 }), b(!1), Xe(), n() } catch (U) { V(!1), me.error(U.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), U.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), U.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } }, et = async $ => { $.preventDefault(), V(!0); try { const U = new FormData; U.append("name", q.name), U.append("description", q.description), U.append("display_order", q.display_order), U.append("is_active", q.is_active ? 1 : 0), W && U.append("logo", W), await Ve.post(`https://api.nexus.com/api/admin/integrations/${T.id}`, U, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}`, "Content-Type": "multipart/form-data" } }), V(!1), me.success("Integration updated successfully", { duration: 2e3 }), C(!1), Xe(), n() } catch (U) { V(!1), me.error(U.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), U.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), U.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } }, Xe = () => { ue({ name: "", description: "", display_order: "", is_active: !0 }), ne(null), we("") }, De = $ => { A($), ue({ name: $.name, description: $.description, display_order: $.display_order, is_active: $.is_active }), ne(null), we($.logo_url || ""), C(!0) }, he = t?.filter($ => (i.global === "" || $.name.toLowerCase().includes(i.global.toLowerCase()) || $.display_order.toString().includes(i.global)) && (i.name === "" || $.name.toLowerCase().includes(i.name.toLowerCase())) && (i.order === "" || $.display_order.toString().includes(i.order)) && (i.status === "" || ($.is_active ? "active" : "inactive").includes(i.status.toLowerCase()))) || [], Be = Math.ceil(he.length / u), Y = he.slice((a - 1) * u, a * u), Je = $ => { const U = $ ? "bg-[#009379] text-white" : "bg-[#930002] text-white"; return d.jsx("span", { className: `flex justify-center w-fit items-center px-2.5 py-1 rounded-md text-xs font-medium ${U} min-w-16 text-center`, children: $ ? "Active" : "Inactive" }) }, $e = () => Be <= 1 ? null : d.jsxs("div", { className: "flex justify-between items-center mt-4 px-4 pb-1", children: [d.jsxs("div", { className: "text-xs", children: ["Showing ", (a - 1) * u + 1, "-", Math.min(a * u, he.length), " of ", he.length, " entries"] }), d.jsxs("div", { className: "flex gap-1", children: [d.jsx("button", { onClick: () => l(1), disabled: a === 1, className: "p-1 disabled:opacity-50", children: d.jsx(Ds, { className: "h-4 w-4" }) }), d.jsxs("span", { className: "px-3 py-1", children: ["Page ", a, " of ", Be] }), d.jsx("button", { onClick: () => l($ => Math.min(Be, $ + 1)), disabled: a === Be, className: "p-1 disabled:opacity-50", children: d.jsx(Rs, { className: "h-4 w-4" }) })] })] }); return d.jsxs("div", { className: "shadow-2xl rounded-2xl overflow-hidden bg-white", children: [d.jsxs("div", { className: "p-4 border-b flex justify-between items-center gap-4", children: [d.jsx("input", { type: "text", value: i.global, onChange: $ => xe("global", $.target.value), placeholder: "Search integrations...", className: "px-3 py-2 rounded-xl shadow-sm focus:outline-2 focus:outline-primary w-full border border-primary transition-all" }), K?.data?.data?.admin?.permissions?.includes("create_integration") && d.jsxs("button", { onClick: () => b(!0), className: "bg-primary hover:bg-darkBlue transition-all text-white px-3 py-2 rounded-xl shadow-sm min-w-max flex items-center gap-2", children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Integration" })] })] }), d.jsx("div", { className: "overflow-x-auto", children: d.jsxs("table", { className: "w-full divide-y divide-gray-200", children: [d.jsx("thead", { className: "bg-gray-50", children: d.jsxs("tr", { children: [d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Name", value: i.name, onChange: $ => xe("name", $.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Order", value: i.order, onChange: $ => xe("order", $.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Status", value: i.status, onChange: $ => xe("status", $.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Actions" })] }) }), d.jsx("tbody", { className: "bg-white divide-y divide-gray-200 text-sm", children: e ? d.jsx("tr", { children: d.jsx("td", { colSpan: "4", className: "px-3 py-4 text-center", children: d.jsxs("div", { className: "flex justify-center items-center gap-2", children: [d.jsx(mt, { className: "animate-spin", size: 18 }), "Loading integrations..."] }) }) }) : Y.length === 0 ? d.jsx("tr", { children: d.jsx("td", { colSpan: "4", className: "px-3 py-4 text-center", children: "No integrations found" }) }) : Y.map($ => d.jsxs("tr", { className: "hover:bg-gray-50", children: [d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsxs("div", { className: "flex items-center gap-2", children: [$.logo_url && d.jsx("img", { src: $.logo_url, alt: "Integration logo", className: "w-8 h-8 rounded-full object-cover" }), d.jsx("div", { children: d.jsx("div", { className: "font-medium", children: $.name }) })] }) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: $.display_order }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: Je($.is_active) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsxs("div", { className: "flex items-center gap-2", children: [K?.data?.data?.admin?.permissions?.includes("edit_integration") && d.jsx("button", { className: "text-blue-500 hover:text-blue-700 p-1", onClick: () => De($), children: d.jsx(br, { size: 18 }) }), K?.data?.data?.admin?.permissions?.includes("toggle_integration") && d.jsx("button", { className: `${$.is_active ? "text-red-500 hover:text-red-700" : "text-green-500 hover:text-green-700"} p-1`, onClick: () => B($.id, $.is_active), disabled: f === $.id, children: f === $.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : $.is_active ? d.jsx(vr, {}) : d.jsx(Cs, {}) }), K?.data?.data?.admin?.permissions?.includes("delete_integration") && d.jsx("button", { className: "text-red-500 hover:text-red-700 p-1", onClick: () => ie($.id), disabled: g === $.id, children: g === $.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : d.jsx(Cn, { size: 18 }) })] }) })] }, $.id)) })] }) }), !e && $e(), v && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => b(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto", onClick: $ => $.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Add New Integration" }), d.jsxs("form", { onSubmit: Oe, children: [d.jsx("div", { className: "grid grid-cols-1 gap-4 mb-4", children: d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Name" }), d.jsx("input", { type: "text", name: "name", value: q.name, onChange: fe, className: "w-full px-3 py-2 border rounded-md", required: !0 })] }) }), d.jsx("div", { className: "grid grid-cols-1 gap-4 mb-4", children: d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Description" }), d.jsx("textarea", { name: "description", value: q.description, onChange: fe, className: "w-full px-3 py-2 border rounded-md", rows: 3 })] }) }), d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4 mb-4", children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Order" }), d.jsx("input", { type: "number", name: "display_order", value: q.display_order, onChange: fe, className: "w-full px-3 py-2 border rounded-md", min: "0", required: !0 })] }), d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Logo" }), d.jsx("div", { className: "flex items-center gap-2", children: H ? d.jsxs("div", { className: "relative", children: [d.jsx("img", { src: H, alt: "Logo preview", className: "w-16 h-16 rounded-md object-cover" }), d.jsx("button", { type: "button", onClick: Ee, className: "absolute -top-2 -right-2 bg-red-500 text-white rounded-full p-1", children: d.jsx(vr, { size: 14 }) })] }) : d.jsxs("label", { className: "flex flex-col items-center justify-center w-full h-16 border-2 border-dashed rounded-md cursor-pointer hover:bg-gray-50", children: [d.jsxs("div", { className: "flex flex-col items-center justify-center", children: [d.jsx(sg, { size: 20, className: "text-gray-400" }), d.jsx("span", { className: "text-xs text-gray-500", children: "Upload logo" })] }), d.jsx("input", { type: "file", accept: "image/*", onChange: pe, className: "hidden" })] }) })] })] }), d.jsxs("div", { className: "flex items-center mb-4", children: [d.jsx("input", { type: "checkbox", name: "is_active", checked: q.is_active, onChange: fe, className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsx("label", { className: "ml-2 block text-sm text-gray-700", children: "Active Integration" })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsx("button", { type: "button", onClick: () => { b(!1), Xe() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: z, children: z ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Adding..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Integration" })] }) })] })] })] }) }) }), S && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => C(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto", onClick: $ => $.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Edit Integration" }), d.jsxs("form", { onSubmit: et, children: [d.jsx("div", { className: "grid grid-cols-1 gap-4 mb-4", children: d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Name" }), d.jsx("input", { type: "text", name: "name", value: q.name, onChange: fe, className: "w-full px-3 py-2 border rounded-md", required: !0 })] }) }), d.jsx("div", { className: "grid grid-cols-1 gap-4 mb-4", children: d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Description" }), d.jsx("textarea", { name: "description", value: q.description, onChange: fe, className: "w-full px-3 py-2 border rounded-md", rows: 3 })] }) }), d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4 mb-4", children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Order" }), d.jsx("input", { type: "number", name: "display_order", value: q.display_order, onChange: fe, className: "w-full px-3 py-2 border rounded-md", min: "0", required: !0 })] }), d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Logo" }), d.jsxs("div", { className: "flex items-center gap-2", children: [H && d.jsxs("div", { className: "relative", children: [d.jsx("img", { src: H, alt: "Logo preview", className: "w-16 h-16 rounded-md object-cover" }), d.jsx("button", { type: "button", onClick: Ee, className: "absolute -top-2 -right-2 bg-red-500 text-white rounded-full p-1", children: d.jsx(vr, { size: 14 }) })] }), d.jsxs("label", { className: "flex flex-col items-center justify-center w-full h-16 border-2 border-dashed rounded-md cursor-pointer hover:bg-gray-50", children: [d.jsxs("div", { className: "flex flex-col items-center justify-center", children: [d.jsx(sg, { size: 20, className: "text-gray-400" }), d.jsx("span", { className: "text-xs text-gray-500", children: H ? "Change logo" : "Upload logo" })] }), d.jsx("input", { type: "file", accept: "image/*", onChange: pe, className: "hidden" })] })] })] })] }), d.jsxs("div", { className: "flex items-center mb-4", children: [d.jsx("input", { type: "checkbox", name: "is_active", checked: q.is_active, onChange: fe, className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsx("label", { className: "ml-2 block text-sm text-gray-700", children: "Active Integration" })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsx("button", { type: "button", onClick: () => { C(!1), Xe() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: z, children: z ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Updating..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(br, { size: 18 }), d.jsx("span", { children: "Update Integration" })] }) })] })] })] }) }) }), M && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => O(!1), children: d.jsx(ot.div, { initial: { scale: .9, opacity: 0 }, animate: { scale: 1, opacity: 1 }, exit: { scale: .9, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md", onClick: $ => $.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsxs("div", { className: "flex items-start", children: [d.jsx("div", { className: "flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100", children: d.jsx(Cn, { className: "h-5 w-5 text-red-600" }) }), d.jsxs("div", { className: "ml-4", children: [d.jsx("h3", { className: "text-lg font-medium text-gray-900", children: "Delete Integration" }), d.jsx("div", { className: "mt-2", children: d.jsx("p", { className: "text-sm text-gray-500", children: "Are you sure you want to delete this integration? This action cannot be undone." }) })] })] }), d.jsxs("div", { className: "mt-5 flex justify-end gap-3", children: [d.jsx("button", { type: "button", onClick: () => O(!1), className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "button", onClick: oe, className: "px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700", children: "Delete" })] })] }) }) })] }) } function CX() { const t = ln(); function e() { return Ve.get("https://api.nexus.com/api/admin/integrations", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) } const { data: n, isLoading: r, refetch: i, isError: s, error: a } = Jt({ queryKey: ["integrations"], queryFn: e }); return N.useEffect(() => { s && (a.response?.status == 401 && (localStorage.removeItem("userToken"), t("/login")), a.response?.status == 403 && (me.error("You are not authorized to view this page"), t("/home"))) }, [s]), d.jsxs("div", { className: "p-4", children: [d.jsx("h1", { className: "text-3xl font-bold text-gray-800 mb-8", children: "Integrations" }), d.jsx(SX, { integrations: n?.data?.data || [], loading: r, refetch: i })] }) } function TX({ admins: t, allPermissions: e, loading: n, refetch: r }) { const i = ln(), [s, a] = N.useState({ global: "", name: "", email: "", status: "", role: "" }), [l, u] = N.useState(1), [f] = N.useState(10), [p, g] = N.useState(null), [y, v] = N.useState(null), [b, S] = N.useState(!1), [C, T] = N.useState(!1), [A, M] = N.useState(!1), [O, E] = N.useState(null), [k, z] = N.useState(!1), [V, q] = N.useState(null), [ue, W] = N.useState(!1), [ne, H] = N.useState({ name: "", email: "", password: "", confirmPassword: "", permissions: [] }), we = ($, U) => { a(be => ({ ...be, [$]: U })), u(1) }, { data: xe, isLoading: K, error: te, isError: ye } = Jt({ queryKey: ["currentUser"], queryFn: () => Ve.get("https://api.nexus.com/api/auth/me", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }), He = async ($, U) => { g($); try { const be = U === "active" ? "inactive" : "active"; await Ve.patch(`https://api.nexus.com/api/admins/${$}/toggle-status`, { status: be }, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success(`Admin ${be === "active" ? "activated" : "deactivated"} successfully`, { duration: 2e3 }), r() } catch (be) { me.error(be.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), be.response?.status == 401 && (localStorage.removeItem("userToken"), i("/login")) } finally { g(null) } }, B = $ => { q($), z(!0) }, ie = async () => { if (V) { v(V), z(!1); try { await Ve.delete(`https://api.nexus.com/api/admins/${V}`, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success("Admin deleted successfully", { duration: 2e3 }), r() } catch ($) { me.error($.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), $.response?.status == 401 && (localStorage.removeItem("userToken"), i("/login")), $.response?.status == 403 && (me.error("You are not authorized to view this page"), i("/home")) } finally { v(null), q(null) } } }, oe = $ => { const { name: U, value: be, type: Ie, checked: it } = $.target; H(P => ({ ...P, [U]: Ie === "checkbox" ? it : be })) }, pe = ($, U) => { H(be => U ? { ...be, permissions: [...be.permissions, $] } : { ...be, permissions: be.permissions.filter(Ie => Ie !== $) }) }, Ee = () => { H({ name: "", email: "", password: "", confirmPassword: "", permissions: [] }) }, fe = $ => { E($), H({ name: $.name, email: $.email, password: "", confirmPassword: "", permissions: [...$.permissions] }), T(!0) }, Oe = $ => { E($), H({ ...ne, permissions: [...$.permissions] }), M(!0) }, et = async $ => { if ($.preventDefault(), ne.password !== ne.confirmPassword) { me.error("Passwords do not match", { duration: 3e3 }); return } W(!0); try { await Ve.post("https://api.nexus.com/api/admins", { name: ne.name, email: ne.email, password: ne.password, permissions: ne.permissions }, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), W(!1), me.success("Admin added successfully", { duration: 2e3 }), S(!1), Ee(), r() } catch (U) { W(!1), me.error(U.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), U.response?.status == 401 && (localStorage.removeItem("userToken"), i("/login")), U.response?.status == 403 && (me.error("You are not authorized to view this page"), i("/home")) } }, Xe = async $ => { if ($.preventDefault(), ne.password && ne.password !== ne.confirmPassword) { me.error("Passwords do not match", { duration: 3e3 }); return } W(!0); try { const U = { name: ne.name, email: ne.email }; ne.password && (U.password = ne.password), await Ve.post(`https://api.nexus.com/api/admins/${O.id}`, U, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), W(!1), me.success("Admin updated successfully", { duration: 2e3 }), T(!1), Ee(), r() } catch (U) { W(!1), me.error(U.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), U.response?.status == 401 && (localStorage.removeItem("userToken"), i("/login")), U.response?.status == 403 && (me.error("You are not authorized to view this page"), i("/home")) } }, De = async $ => { $.preventDefault(), W(!0); try { await Ve.put(`https://api.nexus.com/api/admins/${O.id}/permissions`, { permissions: ne.permissions }, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), W(!1), me.success("Permissions updated successfully", { duration: 2e3 }), M(!1), Ee(), r() } catch (U) { W(!1), me.error(U.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), U.response?.status == 401 && (localStorage.removeItem("userToken"), i("/login")), U.response?.status == 403 && (me.error("You are not authorized to view this page"), i("/home")) } }, he = t?.filter($ => (s.global === "" || $.name.toLowerCase().includes(s.global.toLowerCase()) || $.email.toLowerCase().includes(s.global.toLowerCase())) && (s.name === "" || $.name.toLowerCase().includes(s.name.toLowerCase())) && (s.email === "" || $.email.toLowerCase().includes(s.email.toLowerCase())) && (s.status === "" || $.status.includes(s.status.toLowerCase())) && (s.role === "" || $.role.includes(s.role.toLowerCase()))) || [], Be = Math.ceil(he.length / f), Y = he.slice((l - 1) * f, l * f), Je = $ => { const U = $ === "active" ? "bg-[#009379] text-white" : "bg-[#930002] text-white"; return d.jsx("span", { className: `flex justify-center w-fit items-center px-2.5 py-1 rounded-md text-xs font-medium ${U} min-w-16 text-center`, children: $ === "active" ? "Active" : "Inactive" }) }, $e = () => Be <= 1 ? null : d.jsxs("div", { className: "flex justify-between items-center mt-4 px-4 pb-1", children: [d.jsxs("div", { className: "text-xs", children: ["Showing ", (l - 1) * f + 1, "-", Math.min(l * f, he.length), " of ", he.length, " entries"] }), d.jsxs("div", { className: "flex gap-1", children: [d.jsx("button", { onClick: () => u(1), disabled: l === 1, className: "p-1 disabled:opacity-50", children: d.jsx(Ds, { className: "h-4 w-4" }) }), d.jsxs("span", { className: "px-3 py-1", children: ["Page ", l, " of ", Be] }), d.jsx("button", { onClick: () => u($ => Math.min(Be, $ + 1)), disabled: l === Be, className: "p-1 disabled:opacity-50", children: d.jsx(Rs, { className: "h-4 w-4" }) })] })] }); return d.jsxs("div", { className: "shadow-2xl rounded-2xl overflow-hidden bg-white", children: [d.jsxs("div", { className: "p-4 border-b flex justify-between items-center gap-4", children: [d.jsx("input", { type: "text", value: s.global, onChange: $ => we("global", $.target.value), placeholder: "Search admins...", className: "px-3 py-2 rounded-xl shadow-sm focus:outline-2 focus:outline-primary w-full border border-primary transition-all" }), xe?.data?.data?.admin?.permissions?.includes("create_admin") && d.jsxs("button", { onClick: () => S(!0), className: "bg-primary hover:bg-darkBlue transition-all text-white px-3 py-2 rounded-xl shadow-sm min-w-max flex items-center gap-2", children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Admin" })] })] }), d.jsx("div", { className: "overflow-x-auto", children: d.jsxs("table", { className: "w-full divide-y divide-gray-200", children: [d.jsx("thead", { className: "bg-gray-50", children: d.jsxs("tr", { children: [d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Name", value: s.name, onChange: $ => we("name", $.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Email", value: s.email, onChange: $ => we("email", $.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Role" }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Status", value: s.status, onChange: $ => we("status", $.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Actions" })] }) }), d.jsx("tbody", { className: "bg-white divide-y divide-gray-200 text-sm", children: n ? d.jsx("tr", { children: d.jsx("td", { colSpan: "5", className: "px-3 py-4 text-center", children: d.jsxs("div", { className: "flex justify-center items-center gap-2", children: [d.jsx(mt, { className: "animate-spin", size: 18 }), "Loading admins..."] }) }) }) : Y.length === 0 ? d.jsx("tr", { children: d.jsx("td", { colSpan: "5", className: "px-3 py-4 text-center", children: "No admins found" }) }) : Y.map($ => d.jsxs("tr", { className: "hover:bg-gray-50", children: [d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsx("div", { className: "font-medium", children: $.name }) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: $.email }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap capitalize", children: $.role }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: Je($.status) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsxs("div", { className: "flex items-center gap-2", children: [xe?.data?.data?.admin?.permissions?.includes("edit_admin") && d.jsx("button", { className: "text-blue-500 hover:text-blue-700 p-1", onClick: () => fe($), children: d.jsx(br, { size: 18 }) }), xe?.data?.data?.admin?.permissions?.includes("edit_admin") && d.jsx("button", { className: "text-purple-500 hover:text-purple-700 p-1", onClick: () => Oe($), children: d.jsx(hk, { size: 18 }) }), xe?.data?.data?.admin?.permissions?.includes("edit_admin") && d.jsx("button", { className: `${$.status === "active" ? "text-red-500 hover:text-red-700" : "text-green-500 hover:text-green-700"} p-1`, onClick: () => He($.id, $.status), disabled: p === $.id, children: p === $.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : $.status === "active" ? d.jsx(vr, {}) : d.jsx(Cs, {}) }), xe?.data?.data?.admin?.permissions?.includes("delete_admin") && d.jsx("button", { className: "text-red-500 hover:text-red-700 p-1", onClick: () => B($.id), disabled: y === $.id, children: y === $.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : d.jsx(Cn, { size: 18 }) })] }) })] }, $.id)) })] }) }), !n && $e(), b && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => S(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto", onClick: $ => $.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Add New Admin" }), d.jsxs("form", { onSubmit: et, children: [d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4 mb-4", children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Name" }), d.jsx("input", { type: "text", name: "name", value: ne.name, onChange: oe, className: "w-full px-3 py-2 border rounded-md", required: !0 })] }), d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Email" }), d.jsx("input", { type: "email", name: "email", value: ne.email, onChange: oe, className: "w-full px-3 py-2 border rounded-md", required: !0 })] })] }), d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4 mb-4", children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Password" }), d.jsx("input", { type: "password", name: "password", value: ne.password, onChange: oe, className: "w-full px-3 py-2 border rounded-md", required: !0 })] }), d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Confirm Password" }), d.jsx("input", { type: "password", name: "confirmPassword", value: ne.confirmPassword, onChange: oe, className: "w-full px-3 py-2 border rounded-md", required: !0 })] })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-2", children: "Permissions" }), d.jsx("button", { type: "button", onClick: () => { H($ => ({ ...$, permissions: e.map(U => U.name) })) }, className: "mb-2 text-xs bg-gray-200 hover:bg-gray-300 px-2 py-1 rounded", children: "Select All" }), d.jsx("button", { type: "button", onClick: () => { H($ => ({ ...$, permissions: [] })) }, className: "mb-2 text-xs bg-gray-200 hover:bg-gray-300 px-2 py-1 rounded ml-2", children: "Clear All" }), d.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2 max-h-60 overflow-y-auto p-2 border rounded", children: e.map($ => d.jsxs("div", { className: "flex items-center", children: [d.jsx("input", { type: "checkbox", id: `perm-${$.name}`, checked: ne.permissions.includes($.name), onChange: U => pe($.name, U.target.checked), className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsxs("label", { htmlFor: `perm-${$.name}`, className: "ml-2 text-sm text-gray-700", children: [d.jsx("div", { className: "font-medium", children: $.name.replaceAll("_", " ") }), d.jsx("div", { className: "text-xs text-gray-500", children: $.description })] })] }, $.name)) })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsx("button", { type: "button", onClick: () => { S(!1), Ee() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: ue, children: ue ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Adding..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Admin" })] }) })] })] })] }) }) }), C && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => T(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto", onClick: $ => $.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Edit Admin" }), d.jsxs("form", { onSubmit: Xe, children: [d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4 mb-4", children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Name" }), d.jsx("input", { type: "text", name: "name", value: ne.name, onChange: oe, className: "w-full px-3 py-2 border rounded-md", required: !0 })] }), d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Email" }), d.jsx("input", { type: "email", name: "email", value: ne.email, onChange: oe, className: "w-full px-3 py-2 border rounded-md", required: !0 })] })] }), d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4 mb-4", children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "New Password (leave blank to keep current)" }), d.jsx("input", { type: "password", name: "password", value: ne.password, onChange: oe, className: "w-full px-3 py-2 border rounded-md" })] }), d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Confirm Password" }), d.jsx("input", { type: "password", name: "confirmPassword", value: ne.confirmPassword, onChange: oe, className: "w-full px-3 py-2 border rounded-md" })] })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsx("button", { type: "button", onClick: () => { T(!1), Ee() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: ue, children: ue ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Updating..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(br, { size: 18 }), d.jsx("span", { children: "Update Admin" })] }) })] })] })] }) }) }), A && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => M(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto", onClick: $ => $.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsxs("h2", { className: "text-xl font-bold mb-4", children: ["Manage Permissions for ", O?.name] }), d.jsxs("form", { onSubmit: De, children: [d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-2", children: "Permissions" }), d.jsx("button", { type: "button", onClick: () => { H($ => ({ ...$, permissions: e.map(U => U.name) })) }, className: "mb-2 text-xs bg-gray-200 hover:bg-gray-300 px-2 py-1 rounded", children: "Select All" }), d.jsx("button", { type: "button", onClick: () => { H($ => ({ ...$, permissions: [] })) }, className: "mb-2 text-xs bg-gray-200 hover:bg-gray-300 px-2 py-1 rounded ml-2", children: "Clear All" }), d.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2 max-h-60 overflow-y-auto p-2 border rounded", children: e.map($ => d.jsxs("div", { className: "flex items-center", children: [d.jsx("input", { type: "checkbox", id: `perm-edit-${$.name}`, checked: ne.permissions.includes($.name), onChange: U => pe($.name, U.target.checked), className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsxs("label", { htmlFor: `perm-edit-${$.name}`, className: "ml-2 text-sm text-gray-700", children: [d.jsx("div", { className: "font-medium", children: $.name.replaceAll("_", " ") }), d.jsx("div", { className: "text-xs text-gray-500", children: $.description })] })] }, $.name)) })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsx("button", { type: "button", onClick: () => { M(!1), Ee() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: ue, children: ue ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Updating..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(hk, { size: 18 }), d.jsx("span", { children: "Update Permissions" })] }) })] })] })] }) }) }), k && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => z(!1), children: d.jsx(ot.div, { initial: { scale: .9, opacity: 0 }, animate: { scale: 1, opacity: 1 }, exit: { scale: .9, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md", onClick: $ => $.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsxs("div", { className: "flex items-start", children: [d.jsx("div", { className: "flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100", children: d.jsx(Cn, { className: "h-5 w-5 text-red-600" }) }), d.jsxs("div", { className: "ml-4", children: [d.jsx("h3", { className: "text-lg font-medium text-gray-900", children: "Delete Admin" }), d.jsx("div", { className: "mt-2", children: d.jsx("p", { className: "text-sm text-gray-500", children: "Are you sure you want to delete this admin? This action cannot be undone." }) })] })] }), d.jsxs("div", { className: "mt-5 flex justify-end gap-3", children: [d.jsx("button", { type: "button", onClick: () => z(!1), className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "button", onClick: ie, className: "px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700", children: "Delete" })] })] }) }) })] }) } function NX() { const t = ln(); function e() { return Ve.get("https://api.nexus.com/api/admins", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) } const { data: n, isLoading: r, refetch: i, error: s, isError: a } = Jt({ queryKey: ["admins"], queryFn: e, onError: () => { console.log(s) } }); function l() { return Ve.get("https://api.nexus.com/api/admins/permissions", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) } const { data: u } = Jt({ queryKey: ["permissions"], queryFn: l }); return N.useEffect(() => { a && (s.response?.status == 401 && (localStorage.removeItem("userToken"), t("/login")), s.response?.status == 403 && (me.error("You are not authorized to view this page"), t("/home"))) }, [a]), d.jsxs("div", { className: "p-4", children: [d.jsx("h1", { className: "text-3xl font-bold text-gray-800 mb-8", children: "Admins" }), d.jsx(TX, { admins: n?.data?.data || [], allPermissions: u?.data?.data || [], loading: r, refetch: i })] }) } function jX({ features: t, loading: e, refetch: n }) { const r = ln(), [i, s] = N.useState({ global: "", name: "", key: "", type: "", category: "", status: "" }), [a, l] = N.useState(1), [u] = N.useState(10), [f, p] = N.useState(null), [g, y] = N.useState(null), [v, b] = N.useState(!1), [S, C] = N.useState(!1), [T, A] = N.useState(!1), [M, O] = N.useState(null), [E, k] = N.useState(!1), [z, V] = N.useState({ name: "", type: "text", isAdditionalUsageCharge: !1, status: "active" }), [q, ue] = N.useState({ id: null, name: "", type: "text", isAdditionalUsageCharge: !1, status: "active" }), W = (Y, Je) => { s($e => ({ ...$e, [Y]: Je })), l(1) }, { data: ne, isLoading: H, error: we, isError: xe } = Jt({ queryKey: ["currentUser"], queryFn: () => Ve.get("https://api.nexus.com/api/auth/me", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }), K = async (Y, Je) => { y(Y); try { const $e = Je === "active" ? "inactive" : "active"; await Ve.patch(`https://api.nexus.com/api/admin/features/${Y}/toggle-status`, { status: $e }, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success(`Feature ${$e === "active" ? "activated" : "deactivated"} successfully`, { duration: 2e3 }), n() } catch ($e) { me.error($e.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), $e.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), $e.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } finally { y(null) } }, te = Y => { O(Y), A(!0) }, ye = async () => { if (M) { p(M), A(!1); try { await Ve.delete(`https://api.nexus.com/api/admin/features/${M}`, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success("Feature deleted successfully", { duration: 2e3 }), n() } catch (Y) { me.error(Y.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), Y.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), Y.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } finally { p(null), O(null) } } }, He = Y => { const { name: Je, value: $e, type: $, checked: U } = Y.target; V(be => ({ ...be, [Je]: $ === "checkbox" ? U : $e })) }, B = Y => { const { name: Je, value: $e, type: $, checked: U } = Y.target; ue(be => ({ ...be, [Je]: $ === "checkbox" ? U : $e })) }, ie = () => { V({ name: "", type: "text", isAdditionalUsageCharge: !1, status: "active" }) }, oe = Y => { ue({ id: Y.id, name: Y.name, type: Y.type, isAdditionalUsageCharge: Y.category === "additional_usage_charge", status: Y.status || "active" }), C(!0) }, pe = async Y => { Y.preventDefault(), k(!0); try { const Je = { key: z.name.replace(" ", "_"), name: z.name, type: z.type, category: z.isAdditionalUsageCharge ? "additional_usage_charge" : null, status: z.status }; await Ve.post("https://api.nexus.com/api/admin/features", Je, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), k(!1), me.success("Feature added successfully", { duration: 2e3 }), b(!1), ie(), n() } catch (Je) { k(!1), me.error(Je.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), Je.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), Je.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } }, Ee = async Y => { Y.preventDefault(), k(!0); try { const Je = { name: q.name, type: q.type, category: q.isAdditionalUsageCharge ? "additional_usage_charge" : null, status: q.status }; await Ve.put(`https://api.nexus.com/api/admin/features/${q.id}`, Je, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), k(!1), me.success("Feature updated successfully", { duration: 2e3 }), C(!1), n() } catch (Je) { k(!1), me.error(Je.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), Je.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), Je.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } }, fe = t?.filter(Y => (i.global === "" || Y.name.toLowerCase().includes(i.global.toLowerCase()) || Y.key.toLowerCase().includes(i.global.toLowerCase())) && (i.name === "" || Y.name.toLowerCase().includes(i.name.toLowerCase())) && (i.key === "" || Y.key.toLowerCase().includes(i.key.toLowerCase())) && (i.type === "" || Y.type.includes(i.type.toLowerCase())) && (i.category === "" || (i.category === "additional_usage_charge" ? Y.category === "additional_usage_charge" : Y.category === null)) && (i.status === "" || (Y.status || "active").includes(i.status.toLowerCase()))) || [], Oe = Math.ceil(fe.length / u), et = fe.slice((a - 1) * u, a * u), Xe = Y => Y === "additional_usage_charge" ? d.jsx("span", { className: "bg-green-100 text-green-800 text-xs font-medium px-2.5 py-1 rounded", children: "Additional Usage Charge" }) : d.jsx("span", { className: "bg-gray-100 text-gray-800 text-xs font-medium px-2.5 py-1 rounded", children: "General" }), De = Y => { const Je = Y === "text" ? "blue" : "purple"; return d.jsx("span", { className: `bg-${Je}-100 text-${Je}-800 text-xs font-medium px-2.5 py-1 rounded capitalize`, children: Y }) }, he = Y => { let Je = ""; Y == !0 ? Je = "active" : Je = "inactive"; const $e = (Je || "active") === "active" ? "bg-[#009379] text-white" : "bg-[#930002] text-white"; return d.jsx("span", { className: `flex justify-center w-fit items-center px-2.5 py-1 rounded-md text-xs font-medium ${$e} min-w-16 text-center`, children: (Je || "active") === "active" ? "Active" : "Inactive" }) }, Be = () => Oe <= 1 ? null : d.jsxs("div", { className: "flex justify-between items-center mt-4 px-4 pb-1", children: [d.jsxs("div", { className: "text-xs", children: ["Showing ", (a - 1) * u + 1, "-", Math.min(a * u, fe.length), " of ", fe.length, " entries"] }), d.jsxs("div", { className: "flex gap-1", children: [d.jsx("button", { onClick: () => l(1), disabled: a === 1, className: "p-1 disabled:opacity-50", children: d.jsx(Ds, { className: "h-4 w-4" }) }), d.jsxs("span", { className: "px-3 py-1", children: ["Page ", a, " of ", Oe] }), d.jsx("button", { onClick: () => l(Y => Math.min(Oe, Y + 1)), disabled: a === Oe, className: "p-1 disabled:opacity-50", children: d.jsx(Rs, { className: "h-4 w-4" }) })] })] }); return d.jsxs("div", { className: "shadow-2xl rounded-2xl overflow-hidden bg-white", children: [d.jsxs("div", { className: "p-4 border-b flex justify-between items-center gap-4", children: [d.jsx("input", { type: "text", value: i.global, onChange: Y => W("global", Y.target.value), placeholder: "Search features...", className: "px-3 py-2 rounded-xl shadow-sm focus:outline-2 focus:outline-primary w-full border border-primary transition-all" }), ne?.data?.data?.admin?.permissions?.includes("create_feature") && d.jsxs("button", { onClick: () => b(!0), className: "bg-primary hover:bg-darkBlue transition-all text-white px-3 py-2 rounded-xl shadow-sm min-w-max flex items-center gap-2", children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Feature" })] })] }), d.jsx("div", { className: "overflow-x-auto", children: d.jsxs("table", { className: "w-full divide-y divide-gray-200", children: [d.jsx("thead", { className: "bg-gray-50", children: d.jsxs("tr", { children: [d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Name", value: i.name, onChange: Y => W("name", Y.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Key", value: i.key, onChange: Y => W("key", Y.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsxs("select", { value: i.type, onChange: Y => W("type", Y.target.value), className: "text-xs p-1 border rounded w-full", children: [d.jsx("option", { value: "", children: "All Types" }), d.jsx("option", { value: "text", children: "Text" }), d.jsx("option", { value: "boolean", children: "Boolean" })] }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsxs("select", { value: i.category, onChange: Y => W("category", Y.target.value), className: "text-xs p-1 border rounded w-full", children: [d.jsx("option", { value: "", children: "All Categories" }), d.jsx("option", { value: "additional_usage_charge", children: "Additional Usage Charge" }), d.jsx("option", { value: "general", children: "General" })] }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsxs("select", { value: i.status, onChange: Y => W("status", Y.target.value), className: "text-xs p-1 border rounded w-full", children: [d.jsx("option", { value: "", children: "All Statuses" }), d.jsx("option", { value: "active", children: "Active" }), d.jsx("option", { value: "inactive", children: "Inactive" })] }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Actions" })] }) }), d.jsx("tbody", { className: "bg-white divide-y divide-gray-200 text-sm", children: e ? d.jsx("tr", { children: d.jsx("td", { colSpan: "6", className: "px-3 py-4 text-center", children: d.jsxs("div", { className: "flex justify-center items-center gap-2", children: [d.jsx(mt, { className: "animate-spin", size: 18 }), "Loading features..."] }) }) }) : et.length === 0 ? d.jsx("tr", { children: d.jsx("td", { colSpan: "6", className: "px-3 py-4 text-center", children: "No features found" }) }) : et.map(Y => d.jsxs("tr", { className: "hover:bg-gray-50", children: [d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsx("div", { className: "font-medium", children: Y.name }) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: Y.key }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: De(Y.type) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: Xe(Y.category) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: he(Y.is_active) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsxs("div", { className: "flex items-center gap-2", children: [ne?.data?.data?.admin?.permissions?.includes("edit_feature") && d.jsx("button", { className: "text-blue-500 hover:text-blue-700 p-1", onClick: () => oe(Y), children: d.jsx(br, { size: 18 }) }), Y.is_active ? d.jsx(d.Fragment, { children: d.jsx("button", { className: `${(Y.status || "active") === "active" ? "text-red-500 hover:text-red-700" : "text-green-500 hover:text-green-700"} p-1`, onClick: () => K(Y.id, Y.status || "active"), disabled: g === Y.id, children: g === Y.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : (Y.status || "active") === "active" ? d.jsx(vr, {}) : d.jsx(Cs, {}) }) }) : d.jsx(d.Fragment, { children: d.jsx("button", { className: `${Y.status === "active" ? "text-red-500 hover:text-red-700" : "text-green-500 hover:text-green-700"} p-1`, onClick: () => K(Y.id, Y.status), disabled: g === Y.id, children: g === Y.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : Y.status === "active" ? d.jsx(vr, {}) : d.jsx(Cs, {}) }) }), ne?.data?.data?.admin?.permissions?.includes("delete_feature") && d.jsx("button", { className: "text-red-500 hover:text-red-700 p-1", onClick: () => te(Y.id), disabled: f === Y.id, children: f === Y.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : d.jsx(Cn, { size: 18 }) })] }) })] }, Y.id)) })] }) }), !e && Be(), v && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => b(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto", onClick: Y => Y.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Add New Feature" }), d.jsxs("form", { onSubmit: pe, children: [d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Name" }), d.jsx("input", { type: "text", name: "name", value: z.name, onChange: He, className: "w-full px-3 py-2 border rounded-md", required: !0 })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Type" }), d.jsxs("select", { name: "type", value: z.type, onChange: He, className: "w-full px-3 py-2 border rounded-md", required: !0, children: [d.jsx("option", { value: "text", children: "Text" }), d.jsx("option", { value: "boolean", children: "Boolean" })] })] }), d.jsxs("div", { className: "mb-4 flex items-center", children: [d.jsx("input", { type: "checkbox", id: "isAdditionalUsageCharge", name: "isAdditionalUsageCharge", checked: z.isAdditionalUsageCharge, onChange: He, className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsx("label", { htmlFor: "isAdditionalUsageCharge", className: "ml-2 text-sm text-gray-700", children: "Additional Usage Charge" })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsx("button", { type: "button", onClick: () => { b(!1), ie() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: E, children: E ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Adding..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Feature" })] }) })] })] })] }) }) }), S && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => C(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto", onClick: Y => Y.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Edit Feature" }), d.jsxs("form", { onSubmit: Ee, children: [d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Name" }), d.jsx("input", { type: "text", name: "name", value: q.name, onChange: B, className: "w-full px-3 py-2 border rounded-md", required: !0 })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Type" }), d.jsxs("select", { name: "type", value: q.type, onChange: B, className: "w-full px-3 py-2 border rounded-md", required: !0, children: [d.jsx("option", { value: "text", children: "Text" }), d.jsx("option", { value: "boolean", children: "Boolean" })] })] }), d.jsxs("div", { className: "mb-4 flex items-center", children: [d.jsx("input", { type: "checkbox", id: "editIsAdditionalUsageCharge", name: "isAdditionalUsageCharge", checked: q.isAdditionalUsageCharge, onChange: B, className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsx("label", { htmlFor: "editIsAdditionalUsageCharge", className: "ml-2 text-sm text-gray-700", children: "Additional Usage Charge" })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsx("button", { type: "button", onClick: () => C(!1), className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: E, children: E ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Updating..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(Cs, { size: 18 }), d.jsx("span", { children: "Update Feature" })] }) })] })] })] }) }) }), T && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => A(!1), children: d.jsx(ot.div, { initial: { scale: .9, opacity: 0 }, animate: { scale: 1, opacity: 1 }, exit: { scale: .9, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md", onClick: Y => Y.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsxs("div", { className: "flex items-start", children: [d.jsx("div", { className: "flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100", children: d.jsx(Cn, { className: "h-5 w-5 text-red-600" }) }), d.jsxs("div", { className: "ml-4", children: [d.jsx("h3", { className: "text-lg font-medium text-gray-900", children: "Delete Feature" }), d.jsx("div", { className: "mt-2", children: d.jsx("p", { className: "text-sm text-gray-500", children: "Are you sure you want to delete this feature? This action cannot be undone." }) })] })] }), d.jsxs("div", { className: "mt-5 flex justify-end gap-3", children: [d.jsx("button", { type: "button", onClick: () => A(!1), className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "button", onClick: ye, className: "px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700", children: "Delete" })] })] }) }) })] }) } function $R(t) { return Vt({ attr: { viewBox: "0 0 24 24", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M8 7V11L2 6L8 1V5H13C17.4183 5 21 8.58172 21 13C21 17.4183 17.4183 21 13 21H4V19H13C16.3137 19 19 16.3137 19 13C19 9.68629 16.3137 7 13 7H8Z" }, child: [] }] })(t) } function EX() { const t = ln(); function e() { return Ve.get("https://api.nexus.com/api/admin/features", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) } const { data: n, isLoading: r, refetch: i, isError: s, error: a } = Jt({ queryKey: ["features"], queryFn: e }); return N.useEffect(() => { s && (a.response?.status == 401 && (localStorage.removeItem("userToken"), t("/login")), a.response?.status == 403 && (me.error("You are not authorized to view this page"), t("/home"))) }, [s]), d.jsxs("div", { className: "p-4", children: [d.jsx("button", { className: "bg-gray-200 text-primary p-3 rounded-full aspect-square mb-2", onClick: () => t("/plans"), children: d.jsx($R, {}) }), d.jsx("h1", { className: "text-3xl font-bold text-gray-800 mb-8 mt-3", children: "Plans features" }), d.jsx(jX, { features: n?.data?.data || [], loading: r, refetch: i })] }) } function AX({ plans: t, loading: e, refetch: n }) { const r = ln(), [i, s] = N.useState({ global: "", name: "", description: "", status: "" }), [a, l] = N.useState(1), [u] = N.useState(10), [f, p] = N.useState(null), [g, y] = N.useState(null), [v, b] = N.useState(!1), [S, C] = N.useState(!1), [T, A] = N.useState(!1), [M, O] = N.useState(null), [E, k] = N.useState(!1), [z, V] = N.useState([]), [q, ue] = N.useState([]), [W, ne] = N.useState(null), [H, we] = N.useState({ name: "", title: "", description: "", monthlyPrice: "", annualPrice: "", annualSavings: "", isPopular: !1, features: {}, additionalUsageCharges: {} }); N.useEffect(() => { if (t?.features && t?.additionalUsageCharges) { V(t.features), ue(t.additionalUsageCharges); const U = {}; t.features.forEach(Ie => { U[Ie.key] = { id: Ie.id, value: Ie.type === "boolean" ? !1 : null } }); const be = {}; t.additionalUsageCharges.forEach(Ie => { be[Ie.key] = { id: Ie.id, value: Ie.type === "boolean" ? !1 : null } }), we(Ie => ({ ...Ie, features: U, additionalUsageCharges: be })) } }, [t]); const xe = (U, be) => { s(Ie => ({ ...Ie, [U]: be })), l(1) }, { data: K, isLoading: te, error: ye, isError: He } = Jt({ queryKey: ["currentUser"], queryFn: () => Ve.get("https://api.nexus.com/api/auth/me", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }), B = async (U, be) => { p(U); try { await Ve.patch(`https://api.nexus.com/api/admin/plans/${U}/toggle-status`, {}, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success(`Plan ${be === "active" ? "deactivated" : "activated"} successfully`, { duration: 2e3 }), n() } catch (Ie) { me.error(Ie.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), Ie.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), Ie.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } finally { p(null) } }, ie = U => { O(U), A(!0) }, oe = async () => { if (M) { y(M), A(!1); try { await Ve.delete(`https://api.nexus.com/api/admin/plans/${M}`, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success("Plan deleted successfully", { duration: 2e3 }), n() } catch (U) { me.error(U.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), U.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), U.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } finally { y(null), O(null) } } }, pe = U => { const { name: be, value: Ie, type: it, checked: P } = U.target; we(ee => ({ ...ee, [be]: it === "checkbox" ? P : Ie })) }, Ee = (U, be) => { const it = z.find(P => P.key === U)?.type === "boolean" ? !!be : be; we(P => ({ ...P, features: { ...P.features, [U]: { id: P.features[U]?.id, value: it } } })) }, fe = (U, be) => { const it = q.find(P => P.key === U)?.type === "boolean" ? !!be : be; we(P => ({ ...P, additionalUsageCharges: { ...P.additionalUsageCharges, [U]: { id: P.additionalUsageCharges[U]?.id, value: it } } })) }, Oe = () => { const U = {}; z.forEach(Ie => { U[Ie.key] = { id: Ie.id, value: Ie.type === "boolean" ? !1 : null } }); const be = {}; q.forEach(Ie => { be[Ie.key] = { id: Ie.id, value: Ie.type === "boolean" ? !1 : null } }), we({ name: "", title: "", description: "", monthlyPrice: "", annualPrice: "", annualSavings: "", isPopular: !1, features: U, additionalUsageCharges: be }) }, et = U => { ne(U); const be = {}; z.forEach(it => { const P = U.features[it.key]?.value; be[it.key] = { id: it.id, value: it.type === "boolean" ? !!P : P } }); const Ie = {}; q.forEach(it => { const P = U.additionalUsageCharges[it.key]?.value; Ie[it.key] = { id: it.id, value: it.type === "boolean" ? !!P : P } }), we({ name: U.name, title: U.title || "", description: U.description, monthlyPrice: U.monthlyPrice, annualPrice: U.annualPrice, annualSavings: U.annualSavings || "", isPopular: U.isPopular, features: be, additionalUsageCharges: Ie }), C(!0) }, Xe = async U => { U.preventDefault(), k(!0); try { const be = Object.entries(H.features).map(([P, ee]) => ({ id: ee.id, value: ee.value === null ? z.find(_ => _.key === P)?.type === "boolean" ? !1 : null : ee.value })), Ie = Object.entries(H.additionalUsageCharges).map(([P, ee]) => ({ id: ee.id, value: ee.value === null ? q.find(_ => _.key === P)?.type === "boolean" ? !1 : null : ee.value })), it = [...be, ...Ie]; await Ve.post("https://api.nexus.com/api/admin/plans", { name: H.name, title: H.title, monthly_price: parseFloat(H.monthlyPrice), annual_price: parseFloat(H.annualPrice), annual_savings: H.annualSavings, is_popular: H.isPopular, description: H.description, features: it }, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), k(!1), me.success("Plan added successfully", { duration: 2e3 }), b(!1), Oe(), n() } catch (be) { k(!1), me.error(be.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), be.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), be.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } }, De = async U => { U.preventDefault(), k(!0); try { const be = Object.entries(H.features).map(([P, ee]) => ({ id: ee.id, value: ee.value })), Ie = Object.entries(H.additionalUsageCharges).map(([P, ee]) => ({ id: ee.id, value: ee.value })), it = [...be, ...Ie]; await Ve.put(`https://api.nexus.com/api/admin/plans/${W.id}`, { name: H.name, title: H.title, monthly_price: parseFloat(H.monthlyPrice), annual_price: parseFloat(H.annualPrice), annual_savings: H.annualSavings, is_popular: H.isPopular, description: H.description, features: it }, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), k(!1), me.success("Plan updated successfully", { duration: 2e3 }), C(!1), Oe(), n() } catch (be) { k(!1), me.error(be.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), be.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), be.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } }, he = t?.plans?.filter(U => (i.global === "" || U.name.toLowerCase().includes(i.global.toLowerCase()) || U.description.toLowerCase().includes(i.global.toLowerCase())) && (i.name === "" || U.name.toLowerCase().includes(i.name.toLowerCase())) && (i.description === "" || U.description.toLowerCase().includes(i.description.toLowerCase())) && (i.status === "" || U.status.includes(i.status.toLowerCase()))) || [], Be = Math.ceil(he.length / u), Y = he.slice((a - 1) * u, a * u), Je = U => { let be = ""; U == !0 ? be = "active" : be = "inactive"; const Ie = be === "active" ? "bg-[#009379] text-white" : "bg-[#930002] text-white"; return d.jsx("span", { className: `flex justify-center w-fit items-center px-2.5 py-1 rounded-md text-xs font-medium ${Ie} min-w-16 text-center`, children: be === "active" ? "Active" : "Inactive" }) }, $e = U => d.jsxs("span", { className: "font-medium", children: ["$", parseFloat(U).toFixed(2)] }), $ = () => Be <= 1 ? null : d.jsxs("div", { className: "flex justify-between items-center mt-4 px-4 pb-1", children: [d.jsxs("div", { className: "text-xs", children: ["Showing ", (a - 1) * u + 1, "-", Math.min(a * u, he.length), " of ", he.length, " entries"] }), d.jsxs("div", { className: "flex gap-1", children: [d.jsx("button", { onClick: () => l(1), disabled: a === 1, className: "p-1 disabled:opacity-50", children: d.jsx(Ds, { className: "h-4 w-4" }) }), d.jsxs("span", { className: "px-3 py-1", children: ["Page ", a, " of ", Be] }), d.jsx("button", { onClick: () => l(U => Math.min(Be, U + 1)), disabled: a === Be, className: "p-1 disabled:opacity-50", children: d.jsx(Rs, { className: "h-4 w-4" }) })] })] }); return d.jsxs("div", { className: "shadow-2xl rounded-2xl overflow-hidden bg-white", children: [d.jsxs("div", { className: "p-4 border-b flex justify-between items-center gap-4", children: [d.jsx("input", { required: !0, type: "text", value: i.global, onChange: U => xe("global", U.target.value), placeholder: "Search plans...", className: "px-3 py-2 rounded-xl shadow-sm focus:outline-2 focus:outline-primary w-full border border-primary transition-all" }), K?.data?.data?.admin?.permissions?.includes("create_plan") && d.jsxs("button", { onClick: () => b(!0), className: "bg-primary hover:bg-darkBlue transition-all text-white px-3 py-2 rounded-xl shadow-sm min-w-max flex items-center gap-2", children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Plan" })] })] }), d.jsx("div", { className: "overflow-x-auto", children: d.jsxs("table", { className: "w-full divide-y divide-gray-200", children: [d.jsx("thead", { className: "bg-gray-50", children: d.jsxs("tr", { children: [d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { required: !0, type: "text", placeholder: "Name", value: i.name, onChange: U => xe("name", U.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { required: !0, type: "text", placeholder: "Description", value: i.description, onChange: U => xe("description", U.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Monthly Price" }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Annual Price" }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Popular" }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { required: !0, type: "text", placeholder: "Status", value: i.status, onChange: U => xe("status", U.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Actions" })] }) }), d.jsx("tbody", { className: "bg-white divide-y divide-gray-200 text-sm", children: e ? d.jsx("tr", { children: d.jsx("td", { colSpan: "7", className: "px-3 py-4 text-center", children: d.jsxs("div", { className: "flex justify-center items-center gap-2", children: [d.jsx(mt, { className: "animate-spin", size: 18 }), "Loading plans..."] }) }) }) : Y.length === 0 ? d.jsx("tr", { children: d.jsx("td", { colSpan: "7", className: "px-3 py-4 text-center", children: "No plans found" }) }) : Y.map(U => d.jsxs("tr", { className: "hover:bg-gray-50", children: [d.jsxs("td", { className: "px-3 py-4 whitespace-nowrap", children: [d.jsx("div", { className: "font-medium", children: U.name }), U.title && d.jsx("div", { className: "text-xs text-gray-500", children: U.title })] }), d.jsx("td", { className: "px-3 py-4", children: d.jsx("div", { className: "line-clamp-2", children: U.description }) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: $e(U.monthlyPrice) }), d.jsxs("td", { className: "px-3 py-4 whitespace-nowrap", children: [$e(U.annualPrice), U.annualSavings && d.jsxs("div", { className: "text-xs text-green-600", children: [" ", U.annualSavings] })] }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: U.isPopular ? d.jsx(vX, { className: "text-yellow-500" }) : d.jsx("span", { className: "text-gray-400", children: "" }) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: Je(U.is_active) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsxs("div", { className: "flex items-center gap-2", children: [K?.data?.data?.admin?.permissions?.includes("edit_plan") && d.jsx("button", { className: "text-blue-500 hover:text-blue-700 p-1", onClick: () => et(U), children: d.jsx(br, { size: 18 }) }), U.is_active ? d.jsx(d.Fragment, { children: K?.data?.data?.admin?.permissions?.includes("toggle_plan_status") && d.jsx("button", { className: `${(U.status || "active") === "active" ? "text-red-500 hover:text-red-700" : "text-green-500 hover:text-green-700"} p-1`, onClick: () => B(U.id, U.status || "active"), disabled: f === U.id, children: f === U.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : (U.status || "active") === "active" ? d.jsx(vr, {}) : d.jsx(Cs, {}) }) }) : d.jsx(d.Fragment, { children: K?.data?.data?.admin?.permissions?.includes("toggle_plan_status") && d.jsx("button", { className: `${U.status === "active" ? "text-red-500 hover:text-red-700" : "text-green-500 hover:text-green-700"} p-1`, onClick: () => B(U.id, U.status), disabled: f === U.id, children: f === U.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : U.status === "active" ? d.jsx(vr, {}) : d.jsx(Cs, {}) }) }), K?.data?.data?.admin?.permissions?.includes("delete_plan") && d.jsx("button", { className: "text-red-500 hover:text-red-700 p-1", onClick: () => ie(U.id), disabled: g === U.id, children: g === U.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : d.jsx(Cn, { size: 18 }) })] }) })] }, U.id)) })] }) }), !e && $(), v && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => b(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto", onClick: U => U.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Add New Plan" }), d.jsxs("form", { onSubmit: Xe, children: [d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4 mb-4", children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Name*" }), d.jsx("input", { required: !0, type: "text", name: "name", value: H.name, onChange: pe, className: "w-full px-3 py-2 border rounded-md" })] }), d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Title" }), d.jsx("input", { required: !0, type: "text", name: "title", value: H.title, onChange: pe, className: "w-full px-3 py-2 border rounded-md" })] })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Description*" }), d.jsx("textarea", { name: "description", value: H.description, onChange: pe, className: "w-full px-3 py-2 border rounded-md", rows: "3", required: !0 })] }), d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-4 mb-4", children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Monthly Price*" }), d.jsx("input", { required: !0, type: "number", name: "monthlyPrice", value: H.monthlyPrice, onChange: pe, className: "w-full px-3 py-2 border rounded-md", step: "0.01", min: "0" })] }), d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Annual Price*" }), d.jsx("input", { required: !0, type: "number", name: "annualPrice", value: H.annualPrice, onChange: pe, className: "w-full px-3 py-2 border rounded-md", step: "0.01", min: "0" })] }), d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Annual Savings" }), d.jsx("input", { required: !0, type: "text", name: "annualSavings", value: H.annualSavings, onChange: pe, className: "w-full px-3 py-2 border rounded-md", placeholder: "e.g. 17%" })] })] }), d.jsxs("div", { className: "flex items-center mb-6", children: [d.jsx("input", { type: "checkbox", name: "isPopular", checked: H.isPopular, onChange: pe, className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsx("label", { htmlFor: "isPopular", className: "ml-2 text-sm text-gray-700", children: "Mark as Popular Plan" })] }), z.length > 0 && d.jsxs("div", { className: "mb-6", children: [d.jsx("h3", { className: "text-lg font-medium text-gray-900 mb-3", children: "Features" }), d.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: z.map(U => { const be = H.features[U.key]?.value; return d.jsxs("div", { className: "flex flex-col", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: U.name }), U.type === "boolean" ? d.jsxs("div", { className: "flex items-center", children: [d.jsx("input", { type: "checkbox", checked: !!be, onChange: Ie => Ee(U.key, Ie.target.checked), className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsx("span", { className: "ml-2 text-sm text-gray-700", children: be ? "Enabled" : "Disabled" })] }) : d.jsx("input", { required: !0, type: U.type === "number" ? "number" : "text", value: be || "", onChange: Ie => Ee(U.key, Ie.target.value), className: "w-full px-3 py-2 border rounded-md", placeholder: `Enter ${U.name}` })] }, U.key) }) })] }), q.length > 0 && d.jsxs("div", { className: "mb-6", children: [d.jsx("h3", { className: "text-lg font-medium text-gray-900 mb-3", children: "Additional Usage Charges" }), d.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: q.map(U => { const be = H.additionalUsageCharges[U.key]?.value; return d.jsxs("div", { className: "flex flex-col", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: U.name }), U.type === "boolean" ? d.jsxs("div", { className: "flex items-center", children: [d.jsx("input", { type: "checkbox", checked: !!be, onChange: Ie => fe(U.key, Ie.target.checked), className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsx("span", { className: "ml-2 text-sm text-gray-700", children: be ? "Enabled" : "Disabled" })] }) : d.jsx("input", { required: !0, type: U.type === "number" ? "number" : "text", value: be || "", onChange: Ie => fe(U.key, Ie.target.value), className: "w-full px-3 py-2 border rounded-md", placeholder: `Enter ${U.name}` })] }, U.key) }) })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsx("button", { type: "button", onClick: () => { b(!1), Oe() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: E, children: E ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Adding..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Plan" })] }) })] })] })] }) }) }), S && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => C(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto", onClick: U => U.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Edit Plan" }), d.jsxs("form", { onSubmit: De, children: [d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4 mb-4", children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Name*" }), d.jsx("input", { required: !0, type: "text", name: "name", value: H.name, onChange: pe, className: "w-full px-3 py-2 border rounded-md" })] }), d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Title" }), d.jsx("input", { required: !0, type: "text", name: "title", value: H.title, onChange: pe, className: "w-full px-3 py-2 border rounded-md" })] })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Description*" }), d.jsx("textarea", { name: "description", value: H.description, onChange: pe, className: "w-full px-3 py-2 border rounded-md", rows: "3", required: !0 })] }), d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-4 mb-4", children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Monthly Price*" }), d.jsx("input", { required: !0, type: "number", name: "monthlyPrice", value: H.monthlyPrice, onChange: pe, className: "w-full px-3 py-2 border rounded-md", step: "0.01", min: "0" })] }), d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Annual Price*" }), d.jsx("input", { required: !0, type: "number", name: "annualPrice", value: H.annualPrice, onChange: pe, className: "w-full px-3 py-2 border rounded-md", step: "0.01", min: "0" })] }), d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Annual Savings" }), d.jsx("input", { required: !0, type: "text", name: "annualSavings", value: H.annualSavings, onChange: pe, className: "w-full px-3 py-2 border rounded-md", placeholder: "e.g. 17%" })] })] }), d.jsxs("div", { className: "flex items-center mb-6", children: [d.jsx("input", { type: "checkbox", name: "isPopular", checked: H.isPopular, onChange: pe, className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsx("label", { htmlFor: "isPopular", className: "ml-2 text-sm text-gray-700", children: "Mark as Popular Plan" })] }), z.length > 0 && d.jsxs("div", { className: "mb-6", children: [d.jsx("h3", { className: "text-lg font-medium text-gray-900 mb-3", children: "Features" }), d.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: z.map(U => d.jsxs("div", { className: "flex flex-col", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: U.name }), U.type === "boolean" ? d.jsxs("div", { className: "flex items-center", children: [d.jsx("input", { type: "checkbox", checked: H.features[U.key]?.value || !1, onChange: be => Ee(U.key, be.target.checked), className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsx("span", { className: "ml-2 text-sm text-gray-700", children: H.features[U.key]?.value ? "Enabled" : "Disabled" })] }) : d.jsx("input", { required: !0, type: U.type === "number" ? "number" : "text", value: H.features[U.key]?.value || "", onChange: be => Ee(U.key, be.target.value), className: "w-full px-3 py-2 border rounded-md", placeholder: `Enter ${U.name}` })] }, U.key)) })] }), q.length > 0 && d.jsxs("div", { className: "mb-6", children: [d.jsx("h3", { className: "text-lg font-medium text-gray-900 mb-3", children: "Additional Usage Charges" }), d.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: q.map(U => d.jsxs("div", { className: "flex flex-col", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: U.name }), U.type === "boolean" ? d.jsxs("div", { className: "flex items-center", children: [d.jsx("input", { type: "checkbox", checked: H.additionalUsageCharges[U.key]?.value || !1, onChange: be => fe(U.key, be.target.checked), className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsx("span", { className: "ml-2 text-sm text-gray-700", children: H.additionalUsageCharges[U.key]?.value ? "Enabled" : "Disabled" })] }) : d.jsx("input", { required: !0, type: U.type === "number" ? "number" : "text", value: H.additionalUsageCharges[U.key]?.value || "", onChange: be => fe(U.key, be.target.value), className: "w-full px-3 py-2 border rounded-md", placeholder: `Enter ${U.name}` })] }, U.key)) })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsx("button", { type: "button", onClick: () => { C(!1), Oe() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: E, children: E ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Updating..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(br, { size: 18 }), d.jsx("span", { children: "Update Plan" })] }) })] })] })] }) }) }), T && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => A(!1), children: d.jsx(ot.div, { initial: { scale: .9, opacity: 0 }, animate: { scale: 1, opacity: 1 }, exit: { scale: .9, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md", onClick: U => U.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsxs("div", { className: "flex items-start", children: [d.jsx("div", { className: "flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100", children: d.jsx(Cn, { className: "h-5 w-5 text-red-600" }) }), d.jsxs("div", { className: "ml-4", children: [d.jsx("h3", { className: "text-lg font-medium text-gray-900", children: "Delete Plan" }), d.jsx("div", { className: "mt-2", children: d.jsx("p", { className: "text-sm text-gray-500", children: "Are you sure you want to delete this plan? This action cannot be undone." }) })] })] }), d.jsxs("div", { className: "mt-5 flex justify-end gap-3", children: [d.jsx("button", { type: "button", onClick: () => A(!1), className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "button", onClick: oe, className: "px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700", children: "Delete" })] })] }) }) })] }) } function kX() { const t = ln(), { data: e, isLoading: n } = Jt({ queryKey: ["currentUser"], queryFn: () => Ve.get("https://api.nexus.com/api/auth/me", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }); function r() { return Ve.get("https://api.nexus.com/api/admin/plans", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) } const { data: i, isLoading: s, refetch: a, error: l, isError: u } = Jt({ queryKey: ["plans"], queryFn: r }); return N.useEffect(() => { u && (l.response?.status == 401 && (localStorage.removeItem("userToken"), t("/login")), l.response?.status == 403 && (me.error("You are not authorized to view this page"), t("/home"))) }, [u]), d.jsxs("div", { className: "p-4", children: [e?.data?.data?.admin?.permissions?.includes("view_features") && d.jsxs(d.Fragment, { children: [d.jsx("h1", { className: "text-3xl font-bold text-gray-800 mb-8", children: "Plans Features" }), d.jsx(za, { to: "/plans/features", className: "bg-primary text-white py-2 px-3 rounded-xl", children: "Open plans features" }), d.jsx("hr", { className: "my-5" })] }), d.jsx("h1", { className: "text-3xl font-bold text-gray-800 mb-8", children: "Plans" }), d.jsx(AX, { plans: i?.data?.data || [], loading: s, refetch: a })] }) } function Lr(t) { this.content = t } Lr.prototype = { constructor: Lr, find: function (t) { for (var e = 0; e < this.content.length; e += 2)if (this.content[e] === t) return e; return -1 }, get: function (t) { var e = this.find(t); return e == -1 ? void 0 : this.content[e + 1] }, update: function (t, e, n) { var r = n && n != t ? this.remove(n) : this, i = r.find(t), s = r.content.slice(); return i == -1 ? s.push(n || t, e) : (s[i + 1] = e, n && (s[i] = n)), new Lr(s) }, remove: function (t) { var e = this.find(t); if (e == -1) return this; var n = this.content.slice(); return n.splice(e, 2), new Lr(n) }, addToStart: function (t, e) { return new Lr([t, e].concat(this.remove(t).content)) }, addToEnd: function (t, e) { var n = this.remove(t).content.slice(); return n.push(t, e), new Lr(n) }, addBefore: function (t, e, n) { var r = this.remove(e), i = r.content.slice(), s = r.find(t); return i.splice(s == -1 ? i.length : s, 0, e, n), new Lr(i) }, forEach: function (t) { for (var e = 0; e < this.content.length; e += 2)t(this.content[e], this.content[e + 1]) }, prepend: function (t) { return t = Lr.from(t), t.size ? new Lr(t.content.concat(this.subtract(t).content)) : this }, append: function (t) { return t = Lr.from(t), t.size ? new Lr(this.subtract(t).content.concat(t.content)) : this }, subtract: function (t) { var e = this; t = Lr.from(t); for (var n = 0; n < t.content.length; n += 2)e = e.remove(t.content[n]); return e }, toObject: function () { var t = {}; return this.forEach(function (e, n) { t[e] = n }), t }, get size() { return this.content.length >> 1 } }; Lr.from = function (t) { if (t instanceof Lr) return t; var e = []; if (t) for (var n in t) e.push(n, t[n]); return new Lr(e) }; function UR(t, e, n) { for (let r = 0; ; r++) { if (r == t.childCount || r == e.childCount) return t.childCount == e.childCount ? null : n; let i = t.child(r), s = e.child(r); if (i == s) { n += i.nodeSize; continue } if (!i.sameMarkup(s)) return n; if (i.isText && i.text != s.text) { for (let a = 0; i.text[a] == s.text[a]; a++)n++; return n } if (i.content.size || s.content.size) { let a = UR(i.content, s.content, n + 1); if (a != null) return a } n += i.nodeSize } } function VR(t, e, n, r) { for (let i = t.childCount, s = e.childCount; ;) { if (i == 0 || s == 0) return i == s ? null : { a: n, b: r }; let a = t.child(--i), l = e.child(--s), u = a.nodeSize; if (a == l) { n -= u, r -= u; continue } if (!a.sameMarkup(l)) return { a: n, b: r }; if (a.isText && a.text != l.text) { let f = 0, p = Math.min(a.text.length, l.text.length); for (; f < p && a.text[a.text.length - f - 1] == l.text[l.text.length - f - 1];)f++, n--, r--; return { a: n, b: r } } if (a.content.size || l.content.size) { let f = VR(a.content, l.content, n - 1, r - 1); if (f) return f } n -= u, r -= u } } class Ue { constructor(e, n) { if (this.content = e, this.size = n || 0, n == null) for (let r = 0; r < e.length; r++)this.size += e[r].nodeSize } nodesBetween(e, n, r, i = 0, s) { for (let a = 0, l = 0; l < n; a++) { let u = this.content[a], f = l + u.nodeSize; if (f > e && r(u, i + l, s || null, a) !== !1 && u.content.size) { let p = l + 1; u.nodesBetween(Math.max(0, e - p), Math.min(u.content.size, n - p), r, i + p) } l = f } } descendants(e) { this.nodesBetween(0, this.size, e) } textBetween(e, n, r, i) { let s = "", a = !0; return this.nodesBetween(e, n, (l, u) => { let f = l.isText ? l.text.slice(Math.max(e, u) - u, n - u) : l.isLeaf ? i ? typeof i == "function" ? i(l) : i : l.type.spec.leafText ? l.type.spec.leafText(l) : "" : ""; l.isBlock && (l.isLeaf && f || l.isTextblock) && r && (a ? a = !1 : s += r), s += f }, 0), s } append(e) { if (!e.size) return this; if (!this.size) return e; let n = this.lastChild, r = e.firstChild, i = this.content.slice(), s = 0; for (n.isText && n.sameMarkup(r) && (i[i.length - 1] = n.withText(n.text + r.text), s = 1); s < e.content.length; s++)i.push(e.content[s]); return new Ue(i, this.size + e.size) } cut(e, n = this.size) { if (e == 0 && n == this.size) return this; let r = [], i = 0; if (n > e) for (let s = 0, a = 0; a < n; s++) { let l = this.content[s], u = a + l.nodeSize; u > e && ((a < e || u > n) && (l.isText ? l = l.cut(Math.max(0, e - a), Math.min(l.text.length, n - a)) : l = l.cut(Math.max(0, e - a - 1), Math.min(l.content.size, n - a - 1))), r.push(l), i += l.nodeSize), a = u } return new Ue(r, i) } cutByIndex(e, n) { return e == n ? Ue.empty : e == 0 && n == this.content.length ? this : new Ue(this.content.slice(e, n)) } replaceChild(e, n) { let r = this.content[e]; if (r == n) return this; let i = this.content.slice(), s = this.size + n.nodeSize - r.nodeSize; return i[e] = n, new Ue(i, s) } addToStart(e) { return new Ue([e].concat(this.content), this.size + e.nodeSize) } addToEnd(e) { return new Ue(this.content.concat(e), this.size + e.nodeSize) } eq(e) { if (this.content.length != e.content.length) return !1; for (let n = 0; n < this.content.length; n++)if (!this.content[n].eq(e.content[n])) return !1; return !0 } get firstChild() { return this.content.length ? this.content[0] : null } get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null } get childCount() { return this.content.length } child(e) { let n = this.content[e]; if (!n) throw new RangeError("Index " + e + " out of range for " + this); return n } maybeChild(e) { return this.content[e] || null } forEach(e) { for (let n = 0, r = 0; n < this.content.length; n++) { let i = this.content[n]; e(i, r, n), r += i.nodeSize } } findDiffStart(e, n = 0) { return UR(this, e, n) } findDiffEnd(e, n = this.size, r = e.size) { return VR(this, e, n, r) } findIndex(e, n = -1) { if (e == 0) return Wp(0, e); if (e == this.size) return Wp(this.content.length, e); if (e > this.size || e < 0) throw new RangeError(`Position ${e} outside of fragment (${this})`); for (let r = 0, i = 0; ; r++) { let s = this.child(r), a = i + s.nodeSize; if (a >= e) return a == e || n > 0 ? Wp(r + 1, a) : Wp(r, i); i = a } } toString() { return "<" + this.toStringInner() + ">" } toStringInner() { return this.content.join(", ") } toJSON() { return this.content.length ? this.content.map(e => e.toJSON()) : null } static fromJSON(e, n) { if (!n) return Ue.empty; if (!Array.isArray(n)) throw new RangeError("Invalid input for Fragment.fromJSON"); return new Ue(n.map(e.nodeFromJSON)) } static fromArray(e) { if (!e.length) return Ue.empty; let n, r = 0; for (let i = 0; i < e.length; i++) { let s = e[i]; r += s.nodeSize, i && s.isText && e[i - 1].sameMarkup(s) ? (n || (n = e.slice(0, i)), n[n.length - 1] = s.withText(n[n.length - 1].text + s.text)) : n && n.push(s) } return new Ue(n || e, r) } static from(e) { if (!e) return Ue.empty; if (e instanceof Ue) return e; if (Array.isArray(e)) return this.fromArray(e); if (e.attrs) return new Ue([e], e.nodeSize); throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : "")) } } Ue.empty = new Ue([], 0); const Rx = { index: 0, offset: 0 }; function Wp(t, e) { return Rx.index = t, Rx.offset = e, Rx } function ag(t, e) { if (t === e) return !0; if (!(t && typeof t == "object") || !(e && typeof e == "object")) return !1; let n = Array.isArray(t); if (Array.isArray(e) != n) return !1; if (n) { if (t.length != e.length) return !1; for (let r = 0; r < t.length; r++)if (!ag(t[r], e[r])) return !1 } else { for (let r in t) if (!(r in e) || !ag(t[r], e[r])) return !1; for (let r in e) if (!(r in t)) return !1 } return !0 } let Tn = class y1 { constructor(e, n) { this.type = e, this.attrs = n } addToSet(e) { let n, r = !1; for (let i = 0; i < e.length; i++) { let s = e[i]; if (this.eq(s)) return e; if (this.type.excludes(s.type)) n || (n = e.slice(0, i)); else { if (s.type.excludes(this.type)) return e; !r && s.type.rank > this.type.rank && (n || (n = e.slice(0, i)), n.push(this), r = !0), n && n.push(s) } } return n || (n = e.slice()), r || n.push(this), n } removeFromSet(e) { for (let n = 0; n < e.length; n++)if (this.eq(e[n])) return e.slice(0, n).concat(e.slice(n + 1)); return e } isInSet(e) { for (let n = 0; n < e.length; n++)if (this.eq(e[n])) return !0; return !1 } eq(e) { return this == e || this.type == e.type && ag(this.attrs, e.attrs) } toJSON() { let e = { type: this.type.name }; for (let n in this.attrs) { e.attrs = this.attrs; break } return e } static fromJSON(e, n) { if (!n) throw new RangeError("Invalid input for Mark.fromJSON"); let r = e.marks[n.type]; if (!r) throw new RangeError(`There is no mark type ${n.type} in this schema`); let i = r.create(n.attrs); return r.checkAttrs(i.attrs), i } static sameSet(e, n) { if (e == n) return !0; if (e.length != n.length) return !1; for (let r = 0; r < e.length; r++)if (!e[r].eq(n[r])) return !1; return !0 } static setFrom(e) { if (!e || Array.isArray(e) && e.length == 0) return y1.none; if (e instanceof y1) return [e]; let n = e.slice(); return n.sort((r, i) => r.type.rank - i.type.rank), n } }; Tn.none = []; class og extends Error { } class nt { constructor(e, n, r) { this.content = e, this.openStart = n, this.openEnd = r } get size() { return this.content.size - this.openStart - this.openEnd } insertAt(e, n) { let r = qR(this.content, e + this.openStart, n); return r && new nt(r, this.openStart, this.openEnd) } removeBetween(e, n) { return new nt(HR(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd) } eq(e) { return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd } toString() { return this.content + "(" + this.openStart + "," + this.openEnd + ")" } toJSON() { if (!this.content.size) return null; let e = { content: this.content.toJSON() }; return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e } static fromJSON(e, n) { if (!n) return nt.empty; let r = n.openStart || 0, i = n.openEnd || 0; if (typeof r != "number" || typeof i != "number") throw new RangeError("Invalid input for Slice.fromJSON"); return new nt(Ue.fromJSON(e, n.content), r, i) } static maxOpen(e, n = !0) { let r = 0, i = 0; for (let s = e.firstChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.firstChild)r++; for (let s = e.lastChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.lastChild)i++; return new nt(e, r, i) } } nt.empty = new nt(Ue.empty, 0, 0); function HR(t, e, n) { let { index: r, offset: i } = t.findIndex(e), s = t.maybeChild(r), { index: a, offset: l } = t.findIndex(n); if (i == e || s.isText) { if (l != n && !t.child(a).isText) throw new RangeError("Removing non-flat range"); return t.cut(0, e).append(t.cut(n)) } if (r != a) throw new RangeError("Removing non-flat range"); return t.replaceChild(r, s.copy(HR(s.content, e - i - 1, n - i - 1))) } function qR(t, e, n, r) { let { index: i, offset: s } = t.findIndex(e), a = t.maybeChild(i); if (s == e || a.isText) return t.cut(0, e).append(n).append(t.cut(e)); let l = qR(a.content, e - s - 1, n); return l && t.replaceChild(i, a.copy(l)) } function OX(t, e, n) { if (n.openStart > t.depth) throw new og("Inserted content deeper than insertion position"); if (t.depth - n.openStart != e.depth - n.openEnd) throw new og("Inconsistent open depths"); return KR(t, e, n, 0) } function KR(t, e, n, r) { let i = t.index(r), s = t.node(r); if (i == e.index(r) && r < t.depth - n.openStart) { let a = KR(t, e, n, r + 1); return s.copy(s.content.replaceChild(i, a)) } else if (n.content.size) if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) { let a = t.parent, l = a.content; return Vl(a, l.cut(0, t.parentOffset).append(n.content).append(l.cut(e.parentOffset))) } else { let { start: a, end: l } = MX(n, t); return Vl(s, YR(t, a, l, e, r)) } else return Vl(s, lg(t, e, r)) } function WR(t, e) { if (!e.type.compatibleContent(t.type)) throw new og("Cannot join " + e.type.name + " onto " + t.type.name) } function v1(t, e, n) { let r = t.node(n); return WR(r, e.node(n)), r } function Ul(t, e) { let n = e.length - 1; n >= 0 && t.isText && t.sameMarkup(e[n]) ? e[n] = t.withText(e[n].text + t.text) : e.push(t) } function ff(t, e, n, r) { let i = (e || t).node(n), s = 0, a = e ? e.index(n) : i.childCount; t && (s = t.index(n), t.depth > n ? s++ : t.textOffset && (Ul(t.nodeAfter, r), s++)); for (let l = s; l < a; l++)Ul(i.child(l), r); e && e.depth == n && e.textOffset && Ul(e.nodeBefore, r) } function Vl(t, e) { return t.type.checkContent(e), t.copy(e) } function YR(t, e, n, r, i) { let s = t.depth > i && v1(t, e, i + 1), a = r.depth > i && v1(n, r, i + 1), l = []; return ff(null, t, i, l), s && a && e.index(i) == n.index(i) ? (WR(s, a), Ul(Vl(s, YR(t, e, n, r, i + 1)), l)) : (s && Ul(Vl(s, lg(t, e, i + 1)), l), ff(e, n, i, l), a && Ul(Vl(a, lg(n, r, i + 1)), l)), ff(r, null, i, l), new Ue(l) } function lg(t, e, n) { let r = []; if (ff(null, t, n, r), t.depth > n) { let i = v1(t, e, n + 1); Ul(Vl(i, lg(t, e, n + 1)), r) } return ff(e, null, n, r), new Ue(r) } function MX(t, e) { let n = e.depth - t.openStart, i = e.node(n).copy(t.content); for (let s = n - 1; s >= 0; s--)i = e.node(s).copy(Ue.from(i)); return { start: i.resolveNoCache(t.openStart + n), end: i.resolveNoCache(i.content.size - t.openEnd - n) } } class Vf { constructor(e, n, r) { this.pos = e, this.path = n, this.parentOffset = r, this.depth = n.length / 3 - 1 } resolveDepth(e) { return e == null ? this.depth : e < 0 ? this.depth + e : e } get parent() { return this.node(this.depth) } get doc() { return this.node(0) } node(e) { return this.path[this.resolveDepth(e) * 3] } index(e) { return this.path[this.resolveDepth(e) * 3 + 1] } indexAfter(e) { return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1) } start(e) { return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1 } end(e) { return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size } before(e) { if (e = this.resolveDepth(e), !e) throw new RangeError("There is no position before the top-level node"); return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] } after(e) { if (e = this.resolveDepth(e), !e) throw new RangeError("There is no position after the top-level node"); return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize } get textOffset() { return this.pos - this.path[this.path.length - 1] } get nodeAfter() { let e = this.parent, n = this.index(this.depth); if (n == e.childCount) return null; let r = this.pos - this.path[this.path.length - 1], i = e.child(n); return r ? e.child(n).cut(r) : i } get nodeBefore() { let e = this.index(this.depth), n = this.pos - this.path[this.path.length - 1]; return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1) } posAtIndex(e, n) { n = this.resolveDepth(n); let r = this.path[n * 3], i = n == 0 ? 0 : this.path[n * 3 - 1] + 1; for (let s = 0; s < e; s++)i += r.child(s).nodeSize; return i } marks() { let e = this.parent, n = this.index(); if (e.content.size == 0) return Tn.none; if (this.textOffset) return e.child(n).marks; let r = e.maybeChild(n - 1), i = e.maybeChild(n); if (!r) { let l = r; r = i, i = l } let s = r.marks; for (var a = 0; a < s.length; a++)s[a].type.spec.inclusive === !1 && (!i || !s[a].isInSet(i.marks)) && (s = s[a--].removeFromSet(s)); return s } marksAcross(e) { let n = this.parent.maybeChild(this.index()); if (!n || !n.isInline) return null; let r = n.marks, i = e.parent.maybeChild(e.index()); for (var s = 0; s < r.length; s++)r[s].type.spec.inclusive === !1 && (!i || !r[s].isInSet(i.marks)) && (r = r[s--].removeFromSet(r)); return r } sharedDepth(e) { for (let n = this.depth; n > 0; n--)if (this.start(n) <= e && this.end(n) >= e) return n; return 0 } blockRange(e = this, n) { if (e.pos < this.pos) return e.blockRange(this); for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)if (e.pos <= this.end(r) && (!n || n(this.node(r)))) return new cg(this, e, r); return null } sameParent(e) { return this.pos - this.parentOffset == e.pos - e.parentOffset } max(e) { return e.pos > this.pos ? e : this } min(e) { return e.pos < this.pos ? e : this } toString() { let e = ""; for (let n = 1; n <= this.depth; n++)e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1); return e + ":" + this.parentOffset } static resolve(e, n) { if (!(n >= 0 && n <= e.content.size)) throw new RangeError("Position " + n + " out of range"); let r = [], i = 0, s = n; for (let a = e; ;) { let { index: l, offset: u } = a.content.findIndex(s), f = s - u; if (r.push(a, l, i + u), !f || (a = a.child(l), a.isText)) break; s = f - 1, i += u + 1 } return new Vf(n, r, s) } static resolveCached(e, n) { let r = pk.get(e); if (r) for (let s = 0; s < r.elts.length; s++) { let a = r.elts[s]; if (a.pos == n) return a } else pk.set(e, r = new DX); let i = r.elts[r.i] = Vf.resolve(e, n); return r.i = (r.i + 1) % RX, i } } class DX { constructor() { this.elts = [], this.i = 0 } } const RX = 12, pk = new WeakMap; class cg { constructor(e, n, r) { this.$from = e, this.$to = n, this.depth = r } get start() { return this.$from.before(this.depth + 1) } get end() { return this.$to.after(this.depth + 1) } get parent() { return this.$from.node(this.depth) } get startIndex() { return this.$from.index(this.depth) } get endIndex() { return this.$to.indexAfter(this.depth) } } const _X = Object.create(null); let Lo = class x1 { constructor(e, n, r, i = Tn.none) { this.type = e, this.attrs = n, this.marks = i, this.content = r || Ue.empty } get children() { return this.content.content } get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size } get childCount() { return this.content.childCount } child(e) { return this.content.child(e) } maybeChild(e) { return this.content.maybeChild(e) } forEach(e) { this.content.forEach(e) } nodesBetween(e, n, r, i = 0) { this.content.nodesBetween(e, n, r, i, this) } descendants(e) { this.nodesBetween(0, this.content.size, e) } get textContent() { return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "") } textBetween(e, n, r, i) { return this.content.textBetween(e, n, r, i) } get firstChild() { return this.content.firstChild } get lastChild() { return this.content.lastChild } eq(e) { return this == e || this.sameMarkup(e) && this.content.eq(e.content) } sameMarkup(e) { return this.hasMarkup(e.type, e.attrs, e.marks) } hasMarkup(e, n, r) { return this.type == e && ag(this.attrs, n || e.defaultAttrs || _X) && Tn.sameSet(this.marks, r || Tn.none) } copy(e = null) { return e == this.content ? this : new x1(this.type, this.attrs, e, this.marks) } mark(e) { return e == this.marks ? this : new x1(this.type, this.attrs, this.content, e) } cut(e, n = this.content.size) { return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n)) } slice(e, n = this.content.size, r = !1) { if (e == n) return nt.empty; let i = this.resolve(e), s = this.resolve(n), a = r ? 0 : i.sharedDepth(n), l = i.start(a), f = i.node(a).content.cut(i.pos - l, s.pos - l); return new nt(f, i.depth - a, s.depth - a) } replace(e, n, r) { return OX(this.resolve(e), this.resolve(n), r) } nodeAt(e) { for (let n = this; ;) { let { index: r, offset: i } = n.content.findIndex(e); if (n = n.maybeChild(r), !n) return null; if (i == e || n.isText) return n; e -= i + 1 } } childAfter(e) { let { index: n, offset: r } = this.content.findIndex(e); return { node: this.content.maybeChild(n), index: n, offset: r } } childBefore(e) { if (e == 0) return { node: null, index: 0, offset: 0 }; let { index: n, offset: r } = this.content.findIndex(e); if (r < e) return { node: this.content.child(n), index: n, offset: r }; let i = this.content.child(n - 1); return { node: i, index: n - 1, offset: r - i.nodeSize } } resolve(e) { return Vf.resolveCached(this, e) } resolveNoCache(e) { return Vf.resolve(this, e) } rangeHasMark(e, n, r) { let i = !1; return n > e && this.nodesBetween(e, n, s => (r.isInSet(s.marks) && (i = !0), !i)), i } get isBlock() { return this.type.isBlock } get isTextblock() { return this.type.isTextblock } get inlineContent() { return this.type.inlineContent } get isInline() { return this.type.isInline } get isText() { return this.type.isText } get isLeaf() { return this.type.isLeaf } get isAtom() { return this.type.isAtom } toString() { if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this); let e = this.type.name; return this.content.size && (e += "(" + this.content.toStringInner() + ")"), GR(this.marks, e) } contentMatchAt(e) { let n = this.type.contentMatch.matchFragment(this.content, 0, e); if (!n) throw new Error("Called contentMatchAt on a node with invalid content"); return n } canReplace(e, n, r = Ue.empty, i = 0, s = r.childCount) { let a = this.contentMatchAt(e).matchFragment(r, i, s), l = a && a.matchFragment(this.content, n); if (!l || !l.validEnd) return !1; for (let u = i; u < s; u++)if (!this.type.allowsMarks(r.child(u).marks)) return !1; return !0 } canReplaceWith(e, n, r, i) { if (i && !this.type.allowsMarks(i)) return !1; let s = this.contentMatchAt(e).matchType(r), a = s && s.matchFragment(this.content, n); return a ? a.validEnd : !1 } canAppend(e) { return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type) } check() { this.type.checkContent(this.content), this.type.checkAttrs(this.attrs); let e = Tn.none; for (let n = 0; n < this.marks.length; n++) { let r = this.marks[n]; r.type.checkAttrs(r.attrs), e = r.addToSet(e) } if (!Tn.sameSet(e, this.marks)) throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(n => n.type.name)}`); this.content.forEach(n => n.check()) } toJSON() { let e = { type: this.type.name }; for (let n in this.attrs) { e.attrs = this.attrs; break } return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map(n => n.toJSON())), e } static fromJSON(e, n) { if (!n) throw new RangeError("Invalid input for Node.fromJSON"); let r; if (n.marks) { if (!Array.isArray(n.marks)) throw new RangeError("Invalid mark data for Node.fromJSON"); r = n.marks.map(e.markFromJSON) } if (n.type == "text") { if (typeof n.text != "string") throw new RangeError("Invalid text node in JSON"); return e.text(n.text, r) } let i = Ue.fromJSON(e, n.content), s = e.nodeType(n.type).create(n.attrs, i, r); return s.type.checkAttrs(s.attrs), s } }; Lo.prototype.text = void 0; class ug extends Lo { constructor(e, n, r, i) { if (super(e, n, null, i), !r) throw new RangeError("Empty text nodes are not allowed"); this.text = r } toString() { return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : GR(this.marks, JSON.stringify(this.text)) } get textContent() { return this.text } textBetween(e, n) { return this.text.slice(e, n) } get nodeSize() { return this.text.length } mark(e) { return e == this.marks ? this : new ug(this.type, this.attrs, this.text, e) } withText(e) { return e == this.text ? this : new ug(this.type, this.attrs, e, this.marks) } cut(e = 0, n = this.text.length) { return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n)) } eq(e) { return this.sameMarkup(e) && this.text == e.text } toJSON() { let e = super.toJSON(); return e.text = this.text, e } } function GR(t, e) { for (let n = t.length - 1; n >= 0; n--)e = t[n].type.name + "(" + e + ")"; return e } class Zl {
    constructor(e) { this.validEnd = e, this.next = [], this.wrapCache = [] } static parse(e, n) { let r = new LX(e, n); if (r.next == null) return Zl.empty; let i = XR(r); r.next && r.err("Unexpected trailing text"); let s = UX($X(i)); return VX(s, r), s } matchType(e) { for (let n = 0; n < this.next.length; n++)if (this.next[n].type == e) return this.next[n].next; return null } matchFragment(e, n = 0, r = e.childCount) { let i = this; for (let s = n; i && s < r; s++)i = i.matchType(e.child(s).type); return i } get inlineContent() { return this.next.length != 0 && this.next[0].type.isInline } get defaultType() { for (let e = 0; e < this.next.length; e++) { let { type: n } = this.next[e]; if (!(n.isText || n.hasRequiredAttrs())) return n } return null } compatible(e) { for (let n = 0; n < this.next.length; n++)for (let r = 0; r < e.next.length; r++)if (this.next[n].type == e.next[r].type) return !0; return !1 } fillBefore(e, n = !1, r = 0) { let i = [this]; function s(a, l) { let u = a.matchFragment(e, r); if (u && (!n || u.validEnd)) return Ue.from(l.map(f => f.createAndFill())); for (let f = 0; f < a.next.length; f++) { let { type: p, next: g } = a.next[f]; if (!(p.isText || p.hasRequiredAttrs()) && i.indexOf(g) == -1) { i.push(g); let y = s(g, l.concat(p)); if (y) return y } } return null } return s(this, []) } findWrapping(e) { for (let r = 0; r < this.wrapCache.length; r += 2)if (this.wrapCache[r] == e) return this.wrapCache[r + 1]; let n = this.computeWrapping(e); return this.wrapCache.push(e, n), n } computeWrapping(e) { let n = Object.create(null), r = [{ match: this, type: null, via: null }]; for (; r.length;) { let i = r.shift(), s = i.match; if (s.matchType(e)) { let a = []; for (let l = i; l.type; l = l.via)a.push(l.type); return a.reverse() } for (let a = 0; a < s.next.length; a++) { let { type: l, next: u } = s.next[a]; !l.isLeaf && !l.hasRequiredAttrs() && !(l.name in n) && (!i.type || u.validEnd) && (r.push({ match: l.contentMatch, type: l, via: i }), n[l.name] = !0) } } return null } get edgeCount() { return this.next.length } edge(e) { if (e >= this.next.length) throw new RangeError(`There's no ${e}th edge in this content match`); return this.next[e] } toString() {
      let e = []; function n(r) { e.push(r); for (let i = 0; i < r.next.length; i++)e.indexOf(r.next[i].next) == -1 && n(r.next[i].next) } return n(this), e.map((r, i) => { let s = i + (r.validEnd ? "*" : " ") + " "; for (let a = 0; a < r.next.length; a++)s += (a ? ", " : "") + r.next[a].type.name + "->" + e.indexOf(r.next[a].next); return s }).join(`
`)
    }
  } Zl.empty = new Zl(!0); class LX { constructor(e, n) { this.string = e, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift() } get next() { return this.tokens[this.pos] } eat(e) { return this.next == e && (this.pos++ || !0) } err(e) { throw new SyntaxError(e + " (in content expression '" + this.string + "')") } } function XR(t) { let e = []; do e.push(PX(t)); while (t.eat("|")); return e.length == 1 ? e[0] : { type: "choice", exprs: e } } function PX(t) { let e = []; do e.push(zX(t)); while (t.next && t.next != ")" && t.next != "|"); return e.length == 1 ? e[0] : { type: "seq", exprs: e } } function zX(t) { let e = BX(t); for (; ;)if (t.eat("+")) e = { type: "plus", expr: e }; else if (t.eat("*")) e = { type: "star", expr: e }; else if (t.eat("?")) e = { type: "opt", expr: e }; else if (t.eat("{")) e = IX(t, e); else break; return e } function mk(t) { /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'"); let e = Number(t.next); return t.pos++, e } function IX(t, e) { let n = mk(t), r = n; return t.eat(",") && (t.next != "}" ? r = mk(t) : r = -1), t.eat("}") || t.err("Unclosed braced range"), { type: "range", min: n, max: r, expr: e } } function FX(t, e) { let n = t.nodeTypes, r = n[e]; if (r) return [r]; let i = []; for (let s in n) { let a = n[s]; a.isInGroup(e) && i.push(a) } return i.length == 0 && t.err("No node type or group '" + e + "' found"), i } function BX(t) { if (t.eat("(")) { let e = XR(t); return t.eat(")") || t.err("Missing closing paren"), e } else if (/\W/.test(t.next)) t.err("Unexpected token '" + t.next + "'"); else { let e = FX(t, t.next).map(n => (t.inline == null ? t.inline = n.isInline : t.inline != n.isInline && t.err("Mixing inline and block content"), { type: "name", value: n })); return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e } } } function $X(t) { let e = [[]]; return i(s(t, 0), n()), e; function n() { return e.push([]) - 1 } function r(a, l, u) { let f = { term: u, to: l }; return e[a].push(f), f } function i(a, l) { a.forEach(u => u.to = l) } function s(a, l) { if (a.type == "choice") return a.exprs.reduce((u, f) => u.concat(s(f, l)), []); if (a.type == "seq") for (let u = 0; ; u++) { let f = s(a.exprs[u], l); if (u == a.exprs.length - 1) return f; i(f, l = n()) } else if (a.type == "star") { let u = n(); return r(l, u), i(s(a.expr, u), u), [r(u)] } else if (a.type == "plus") { let u = n(); return i(s(a.expr, l), u), i(s(a.expr, u), u), [r(u)] } else { if (a.type == "opt") return [r(l)].concat(s(a.expr, l)); if (a.type == "range") { let u = l; for (let f = 0; f < a.min; f++) { let p = n(); i(s(a.expr, u), p), u = p } if (a.max == -1) i(s(a.expr, u), u); else for (let f = a.min; f < a.max; f++) { let p = n(); r(u, p), i(s(a.expr, u), p), u = p } return [r(u)] } else { if (a.type == "name") return [r(l, void 0, a.value)]; throw new Error("Unknown expr type") } } } } function QR(t, e) { return e - t } function gk(t, e) { let n = []; return r(e), n.sort(QR); function r(i) { let s = t[i]; if (s.length == 1 && !s[0].term) return r(s[0].to); n.push(i); for (let a = 0; a < s.length; a++) { let { term: l, to: u } = s[a]; !l && n.indexOf(u) == -1 && r(u) } } } function UX(t) { let e = Object.create(null); return n(gk(t, 0)); function n(r) { let i = []; r.forEach(a => { t[a].forEach(({ term: l, to: u }) => { if (!l) return; let f; for (let p = 0; p < i.length; p++)i[p][0] == l && (f = i[p][1]); gk(t, u).forEach(p => { f || i.push([l, f = []]), f.indexOf(p) == -1 && f.push(p) }) }) }); let s = e[r.join(",")] = new Zl(r.indexOf(t.length - 1) > -1); for (let a = 0; a < i.length; a++) { let l = i[a][1].sort(QR); s.next.push({ type: i[a][0], next: e[l.join(",")] || n(l) }) } return s } } function VX(t, e) { for (let n = 0, r = [t]; n < r.length; n++) { let i = r[n], s = !i.validEnd, a = []; for (let l = 0; l < i.next.length; l++) { let { type: u, next: f } = i.next[l]; a.push(u.name), s && !(u.isText || u.hasRequiredAttrs()) && (s = !1), r.indexOf(f) == -1 && r.push(f) } s && e.err("Only non-generatable nodes (" + a.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)") } } function JR(t) { let e = Object.create(null); for (let n in t) { let r = t[n]; if (!r.hasDefault) return null; e[n] = r.default } return e } function ZR(t, e) { let n = Object.create(null); for (let r in t) { let i = e && e[r]; if (i === void 0) { let s = t[r]; if (s.hasDefault) i = s.default; else throw new RangeError("No value supplied for attribute " + r) } n[r] = i } return n } function e5(t, e, n, r) { for (let i in e) if (!(i in t)) throw new RangeError(`Unsupported attribute ${i} for ${n} of type ${i}`); for (let i in t) { let s = t[i]; s.validate && s.validate(e[i]) } } function t5(t, e) { let n = Object.create(null); if (e) for (let r in e) n[r] = new qX(t, r, e[r]); return n } let yk = class n5 { constructor(e, n, r) { this.name = e, this.schema = n, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = t5(e, r.attrs), this.defaultAttrs = JR(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text" } get isInline() { return !this.isBlock } get isTextblock() { return this.isBlock && this.inlineContent } get isLeaf() { return this.contentMatch == Zl.empty } get isAtom() { return this.isLeaf || !!this.spec.atom } isInGroup(e) { return this.groups.indexOf(e) > -1 } get whitespace() { return this.spec.whitespace || (this.spec.code ? "pre" : "normal") } hasRequiredAttrs() { for (let e in this.attrs) if (this.attrs[e].isRequired) return !0; return !1 } compatibleContent(e) { return this == e || this.contentMatch.compatible(e.contentMatch) } computeAttrs(e) { return !e && this.defaultAttrs ? this.defaultAttrs : ZR(this.attrs, e) } create(e = null, n, r) { if (this.isText) throw new Error("NodeType.create can't construct text nodes"); return new Lo(this, this.computeAttrs(e), Ue.from(n), Tn.setFrom(r)) } createChecked(e = null, n, r) { return n = Ue.from(n), this.checkContent(n), new Lo(this, this.computeAttrs(e), n, Tn.setFrom(r)) } createAndFill(e = null, n, r) { if (e = this.computeAttrs(e), n = Ue.from(n), n.size) { let a = this.contentMatch.fillBefore(n); if (!a) return null; n = a.append(n) } let i = this.contentMatch.matchFragment(n), s = i && i.fillBefore(Ue.empty, !0); return s ? new Lo(this, e, n.append(s), Tn.setFrom(r)) : null } validContent(e) { let n = this.contentMatch.matchFragment(e); if (!n || !n.validEnd) return !1; for (let r = 0; r < e.childCount; r++)if (!this.allowsMarks(e.child(r).marks)) return !1; return !0 } checkContent(e) { if (!this.validContent(e)) throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`) } checkAttrs(e) { e5(this.attrs, e, "node", this.name) } allowsMarkType(e) { return this.markSet == null || this.markSet.indexOf(e) > -1 } allowsMarks(e) { if (this.markSet == null) return !0; for (let n = 0; n < e.length; n++)if (!this.allowsMarkType(e[n].type)) return !1; return !0 } allowedMarks(e) { if (this.markSet == null) return e; let n; for (let r = 0; r < e.length; r++)this.allowsMarkType(e[r].type) ? n && n.push(e[r]) : n || (n = e.slice(0, r)); return n ? n.length ? n : Tn.none : e } static compile(e, n) { let r = Object.create(null); e.forEach((s, a) => r[s] = new n5(s, n, a)); let i = n.spec.topNode || "doc"; if (!r[i]) throw new RangeError("Schema is missing its top node type ('" + i + "')"); if (!r.text) throw new RangeError("Every schema needs a 'text' type"); for (let s in r.text.attrs) throw new RangeError("The text node type should not have attributes"); return r } }; function HX(t, e, n) { let r = n.split("|"); return i => { let s = i === null ? "null" : typeof i; if (r.indexOf(s) < 0) throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${t}, got ${s}`) } } class qX { constructor(e, n, r) { this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? HX(e, n, r.validate) : r.validate } get isRequired() { return !this.hasDefault } } class Ey { constructor(e, n, r, i) { this.name = e, this.rank = n, this.schema = r, this.spec = i, this.attrs = t5(e, i.attrs), this.excluded = null; let s = JR(this.attrs); this.instance = s ? new Tn(this, s) : null } create(e = null) { return !e && this.instance ? this.instance : new Tn(this, ZR(this.attrs, e)) } static compile(e, n) { let r = Object.create(null), i = 0; return e.forEach((s, a) => r[s] = new Ey(s, i++, n, a)), r } removeFromSet(e) { for (var n = 0; n < e.length; n++)e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)), n--); return e } isInSet(e) { for (let n = 0; n < e.length; n++)if (e[n].type == this) return e[n] } checkAttrs(e) { e5(this.attrs, e, "mark", this.name) } excludes(e) { return this.excluded.indexOf(e) > -1 } } class r5 { constructor(e) { this.linebreakReplacement = null, this.cached = Object.create(null); let n = this.spec = {}; for (let i in e) n[i] = e[i]; n.nodes = Lr.from(e.nodes), n.marks = Lr.from(e.marks || {}), this.nodes = yk.compile(this.spec.nodes, this), this.marks = Ey.compile(this.spec.marks, this); let r = Object.create(null); for (let i in this.nodes) { if (i in this.marks) throw new RangeError(i + " can not be both a node and a mark"); let s = this.nodes[i], a = s.spec.content || "", l = s.spec.marks; if (s.contentMatch = r[a] || (r[a] = Zl.parse(a, this.nodes)), s.inlineContent = s.contentMatch.inlineContent, s.spec.linebreakReplacement) { if (this.linebreakReplacement) throw new RangeError("Multiple linebreak nodes defined"); if (!s.isInline || !s.isLeaf) throw new RangeError("Linebreak replacement nodes must be inline leaf nodes"); this.linebreakReplacement = s } s.markSet = l == "_" ? null : l ? vk(this, l.split(" ")) : l == "" || !s.inlineContent ? [] : null } for (let i in this.marks) { let s = this.marks[i], a = s.spec.excludes; s.excluded = a == null ? [s] : a == "" ? [] : vk(this, a.split(" ")) } this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = Object.create(null) } node(e, n = null, r, i) { if (typeof e == "string") e = this.nodeType(e); else if (e instanceof yk) { if (e.schema != this) throw new RangeError("Node type from different schema used (" + e.name + ")") } else throw new RangeError("Invalid node type: " + e); return e.createChecked(n, r, i) } text(e, n) { let r = this.nodes.text; return new ug(r, r.defaultAttrs, e, Tn.setFrom(n)) } mark(e, n) { return typeof e == "string" && (e = this.marks[e]), e.create(n) } nodeFromJSON(e) { return Lo.fromJSON(this, e) } markFromJSON(e) { return Tn.fromJSON(this, e) } nodeType(e) { let n = this.nodes[e]; if (!n) throw new RangeError("Unknown node type: " + e); return n } } function vk(t, e) { let n = []; for (let r = 0; r < e.length; r++) { let i = e[r], s = t.marks[i], a = s; if (s) n.push(s); else for (let l in t.marks) { let u = t.marks[l]; (i == "_" || u.spec.group && u.spec.group.split(" ").indexOf(i) > -1) && n.push(a = u) } if (!a) throw new SyntaxError("Unknown mark type: '" + e[r] + "'") } return n } function KX(t) { return t.tag != null } function WX(t) { return t.style != null } let hf = class b1 { constructor(e, n) { this.schema = e, this.rules = n, this.tags = [], this.styles = []; let r = this.matchedStyles = []; n.forEach(i => { if (KX(i)) this.tags.push(i); else if (WX(i)) { let s = /[^=]*/.exec(i.style)[0]; r.indexOf(s) < 0 && r.push(s), this.styles.push(i) } }), this.normalizeLists = !this.tags.some(i => { if (!/^(ul|ol)\b/.test(i.tag) || !i.node) return !1; let s = e.nodes[i.node]; return s.contentMatch.matchType(s) }) } parse(e, n = {}) { let r = new bk(this, n, !1); return r.addAll(e, Tn.none, n.from, n.to), r.finish() } parseSlice(e, n = {}) { let r = new bk(this, n, !0); return r.addAll(e, Tn.none, n.from, n.to), nt.maxOpen(r.finish()) } matchTag(e, n, r) { for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) { let s = this.tags[i]; if (XX(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || n.matchesContext(s.context))) { if (s.getAttrs) { let a = s.getAttrs(e); if (a === !1) continue; s.attrs = a || void 0 } return s } } } matchStyle(e, n, r, i) { for (let s = i ? this.styles.indexOf(i) + 1 : 0; s < this.styles.length; s++) { let a = this.styles[s], l = a.style; if (!(l.indexOf(e) != 0 || a.context && !r.matchesContext(a.context) || l.length > e.length && (l.charCodeAt(e.length) != 61 || l.slice(e.length + 1) != n))) { if (a.getAttrs) { let u = a.getAttrs(n); if (u === !1) continue; a.attrs = u || void 0 } return a } } } static schemaRules(e) { let n = []; function r(i) { let s = i.priority == null ? 50 : i.priority, a = 0; for (; a < n.length; a++) { let l = n[a]; if ((l.priority == null ? 50 : l.priority) < s) break } n.splice(a, 0, i) } for (let i in e.marks) { let s = e.marks[i].spec.parseDOM; s && s.forEach(a => { r(a = wk(a)), a.mark || a.ignore || a.clearMark || (a.mark = i) }) } for (let i in e.nodes) { let s = e.nodes[i].spec.parseDOM; s && s.forEach(a => { r(a = wk(a)), a.node || a.ignore || a.mark || (a.node = i) }) } return n } static fromSchema(e) { return e.cached.domParser || (e.cached.domParser = new b1(e, b1.schemaRules(e))) } }; const i5 = { address: !0, article: !0, aside: !0, blockquote: !0, canvas: !0, dd: !0, div: !0, dl: !0, fieldset: !0, figcaption: !0, figure: !0, footer: !0, form: !0, h1: !0, h2: !0, h3: !0, h4: !0, h5: !0, h6: !0, header: !0, hgroup: !0, hr: !0, li: !0, noscript: !0, ol: !0, output: !0, p: !0, pre: !0, section: !0, table: !0, tfoot: !0, ul: !0 }, YX = { head: !0, noscript: !0, object: !0, script: !0, style: !0, title: !0 }, s5 = { ol: !0, ul: !0 }, Hf = 1, w1 = 2, pf = 4; function xk(t, e, n) { return e != null ? (e ? Hf : 0) | (e === "full" ? w1 : 0) : t && t.whitespace == "pre" ? Hf | w1 : n & ~pf } class Yp { constructor(e, n, r, i, s, a) { this.type = e, this.attrs = n, this.marks = r, this.solid = i, this.options = a, this.content = [], this.activeMarks = Tn.none, this.match = s || (a & pf ? null : e.contentMatch) } findWrapping(e) { if (!this.match) { if (!this.type) return []; let n = this.type.contentMatch.fillBefore(Ue.from(e)); if (n) this.match = this.type.contentMatch.matchFragment(n); else { let r = this.type.contentMatch, i; return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null } } return this.match.findWrapping(e.type) } finish(e) { if (!(this.options & Hf)) { let r = this.content[this.content.length - 1], i; if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) { let s = r; r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - i[0].length)) } } let n = Ue.from(this.content); return !e && this.match && (n = n.append(this.match.fillBefore(Ue.empty, !0))), this.type ? this.type.create(this.attrs, n, this.marks) : n } inlineContext(e) { return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !i5.hasOwnProperty(e.parentNode.nodeName.toLowerCase()) } } class bk {
    constructor(e, n, r) { this.parser = e, this.options = n, this.isOpen = r, this.open = 0, this.localPreserveWS = !1; let i = n.topNode, s, a = xk(null, n.preserveWhitespace, 0) | (r ? pf : 0); i ? s = new Yp(i.type, i.attrs, Tn.none, !0, n.topMatch || i.type.contentMatch, a) : r ? s = new Yp(null, null, Tn.none, !0, null, a) : s = new Yp(e.schema.topNodeType, null, Tn.none, !0, null, a), this.nodes = [s], this.find = n.findPositions, this.needsBlock = !1 } get top() { return this.nodes[this.open] } addDOM(e, n) { e.nodeType == 3 ? this.addTextNode(e, n) : e.nodeType == 1 && this.addElement(e, n) } addTextNode(e, n) {
      let r = e.nodeValue, i = this.top, s = i.options & w1 ? "full" : this.localPreserveWS || (i.options & Hf) > 0; if (s === "full" || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
        if (s) s !== "full" ? r = r.replace(/\r?\n|\r/g, " ") : r = r.replace(/\r\n?/g, `
`); else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) { let a = i.content[i.content.length - 1], l = e.previousSibling; (!a || l && l.nodeName == "BR" || a.isText && /[ \t\r\n\u000c]$/.test(a.text)) && (r = r.slice(1)) } r && this.insertNode(this.parser.schema.text(r), n, !/\S/.test(r)), this.findInText(e)
      } else this.findInside(e)
    } addElement(e, n, r) { let i = this.localPreserveWS, s = this.top; (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0); let a = e.nodeName.toLowerCase(), l; s5.hasOwnProperty(a) && this.parser.normalizeLists && GX(e); let u = this.options.ruleFromNode && this.options.ruleFromNode(e) || (l = this.parser.matchTag(e, this, r)); e: if (u ? u.ignore : YX.hasOwnProperty(a)) this.findInside(e), this.ignoreFallback(e, n); else if (!u || u.skip || u.closeParent) { u && u.closeParent ? this.open = Math.max(0, this.open - 1) : u && u.skip.nodeType && (e = u.skip); let f, p = this.needsBlock; if (i5.hasOwnProperty(a)) s.content.length && s.content[0].isInline && this.open && (this.open--, s = this.top), f = !0, s.type || (this.needsBlock = !0); else if (!e.firstChild) { this.leafFallback(e, n); break e } let g = u && u.skip ? n : this.readStyles(e, n); g && this.addAll(e, g), f && this.sync(s), this.needsBlock = p } else { let f = this.readStyles(e, n); f && this.addElementByRule(e, u, f, u.consuming === !1 ? l : void 0) } this.localPreserveWS = i } leafFallback(e, n) {
      e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), n)
    } ignoreFallback(e, n) { e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n, !0) } readStyles(e, n) { let r = e.style; if (r && r.length) for (let i = 0; i < this.parser.matchedStyles.length; i++) { let s = this.parser.matchedStyles[i], a = r.getPropertyValue(s); if (a) for (let l = void 0; ;) { let u = this.parser.matchStyle(s, a, this, l); if (!u) break; if (u.ignore) return null; if (u.clearMark ? n = n.filter(f => !u.clearMark(f)) : n = n.concat(this.parser.schema.marks[u.mark].create(u.attrs)), u.consuming === !1) l = u; else break } } return n } addElementByRule(e, n, r, i) { let s, a; if (n.node) if (a = this.parser.schema.nodes[n.node], a.isLeaf) this.insertNode(a.create(n.attrs), r, e.nodeName == "BR") || this.leafFallback(e, r); else { let u = this.enter(a, n.attrs || null, r, n.preserveWhitespace); u && (s = !0, r = u) } else { let u = this.parser.schema.marks[n.mark]; r = r.concat(u.create(n.attrs)) } let l = this.top; if (a && a.isLeaf) this.findInside(e); else if (i) this.addElement(e, r, i); else if (n.getContent) this.findInside(e), n.getContent(e, this.parser.schema).forEach(u => this.insertNode(u, r, !1)); else { let u = e; typeof n.contentElement == "string" ? u = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? u = n.contentElement(e) : n.contentElement && (u = n.contentElement), this.findAround(e, u, !0), this.addAll(u, r), this.findAround(e, u, !1) } s && this.sync(l) && this.open-- } addAll(e, n, r, i) { let s = r || 0; for (let a = r ? e.childNodes[r] : e.firstChild, l = i == null ? null : e.childNodes[i]; a != l; a = a.nextSibling, ++s)this.findAtPoint(e, s), this.addDOM(a, n); this.findAtPoint(e, s) } findPlace(e, n, r) { let i, s; for (let a = this.open, l = 0; a >= 0; a--) { let u = this.nodes[a], f = u.findWrapping(e); if (f && (!i || i.length > f.length + l) && (i = f, s = u, !f.length)) break; if (u.solid) { if (r) break; l += 2 } } if (!i) return null; this.sync(s); for (let a = 0; a < i.length; a++)n = this.enterInner(i[a], null, n, !1); return n } insertNode(e, n, r) { if (e.isInline && this.needsBlock && !this.top.type) { let s = this.textblockFromContext(); s && (n = this.enterInner(s, null, n)) } let i = this.findPlace(e, n, r); if (i) { this.closeExtra(); let s = this.top; s.match && (s.match = s.match.matchType(e.type)); let a = Tn.none; for (let l of i.concat(e.marks)) (s.type ? s.type.allowsMarkType(l.type) : Sk(l.type, e.type)) && (a = l.addToSet(a)); return s.content.push(e.mark(a)), !0 } return !1 } enter(e, n, r, i) { let s = this.findPlace(e.create(n), r, !1); return s && (s = this.enterInner(e, n, r, !0, i)), s } enterInner(e, n, r, i = !1, s) { this.closeExtra(); let a = this.top; a.match = a.match && a.match.matchType(e); let l = xk(e, s, a.options); a.options & pf && a.content.length == 0 && (l |= pf); let u = Tn.none; return r = r.filter(f => (a.type ? a.type.allowsMarkType(f.type) : Sk(f.type, e)) ? (u = f.addToSet(u), !1) : !0), this.nodes.push(new Yp(e, n, u, i, null, l)), this.open++, r } closeExtra(e = !1) { let n = this.nodes.length - 1; if (n > this.open) { for (; n > this.open; n--)this.nodes[n - 1].content.push(this.nodes[n].finish(e)); this.nodes.length = this.open + 1 } } finish() { return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen)) } sync(e) { for (let n = this.open; n >= 0; n--) { if (this.nodes[n] == e) return this.open = n, !0; this.localPreserveWS && (this.nodes[n].options |= Hf) } return !1 } get currentPos() { this.closeExtra(); let e = 0; for (let n = this.open; n >= 0; n--) { let r = this.nodes[n].content; for (let i = r.length - 1; i >= 0; i--)e += r[i].nodeSize; n && e++ } return e } findAtPoint(e, n) { if (this.find) for (let r = 0; r < this.find.length; r++)this.find[r].node == e && this.find[r].offset == n && (this.find[r].pos = this.currentPos) } findInside(e) { if (this.find) for (let n = 0; n < this.find.length; n++)this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos) } findAround(e, n, r) { if (e != n && this.find) for (let i = 0; i < this.find.length; i++)this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && n.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos) } findInText(e) { if (this.find) for (let n = 0; n < this.find.length; n++)this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset)) } matchesContext(e) { if (e.indexOf("|") > -1) return e.split(/\s*\|\s*/).some(this.matchesContext, this); let n = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), s = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), a = (l, u) => { for (; l >= 0; l--) { let f = n[l]; if (f == "") { if (l == n.length - 1 || l == 0) continue; for (; u >= s; u--)if (a(l - 1, u)) return !0; return !1 } else { let p = u > 0 || u == 0 && i ? this.nodes[u].type : r && u >= s ? r.node(u - s).type : null; if (!p || p.name != f && !p.isInGroup(f)) return !1; u-- } } return !0 }; return a(n.length - 1, this.open) } textblockFromContext() { let e = this.options.context; if (e) for (let n = e.depth; n >= 0; n--) { let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType; if (r && r.isTextblock && r.defaultAttrs) return r } for (let n in this.parser.schema.nodes) { let r = this.parser.schema.nodes[n]; if (r.isTextblock && r.defaultAttrs) return r } }
  } function GX(t) { for (let e = t.firstChild, n = null; e; e = e.nextSibling) { let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null; r && s5.hasOwnProperty(r) && n ? (n.appendChild(e), e = n) : r == "li" ? n = e : r && (n = null) } } function XX(t, e) { return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e) } function wk(t) { let e = {}; for (let n in t) e[n] = t[n]; return e } function Sk(t, e) { let n = e.schema.nodes; for (let r in n) { let i = n[r]; if (!i.allowsMarkType(t)) continue; let s = [], a = l => { s.push(l); for (let u = 0; u < l.edgeCount; u++) { let { type: f, next: p } = l.edge(u); if (f == e || s.indexOf(p) < 0 && a(p)) return !0 } }; if (a(i.contentMatch)) return !0 } } class hc { constructor(e, n) { this.nodes = e, this.marks = n } serializeFragment(e, n = {}, r) { r || (r = _x(n).createDocumentFragment()); let i = r, s = []; return e.forEach(a => { if (s.length || a.marks.length) { let l = 0, u = 0; for (; l < s.length && u < a.marks.length;) { let f = a.marks[u]; if (!this.marks[f.type.name]) { u++; continue } if (!f.eq(s[l][0]) || f.type.spec.spanning === !1) break; l++, u++ } for (; l < s.length;)i = s.pop()[1]; for (; u < a.marks.length;) { let f = a.marks[u++], p = this.serializeMark(f, a.isInline, n); p && (s.push([f, i]), i.appendChild(p.dom), i = p.contentDOM || p.dom) } } i.appendChild(this.serializeNodeInner(a, n)) }), r } serializeNodeInner(e, n) { let { dom: r, contentDOM: i } = km(_x(n), this.nodes[e.type.name](e), null, e.attrs); if (i) { if (e.isLeaf) throw new RangeError("Content hole not allowed in a leaf node spec"); this.serializeFragment(e.content, n, i) } return r } serializeNode(e, n = {}) { let r = this.serializeNodeInner(e, n); for (let i = e.marks.length - 1; i >= 0; i--) { let s = this.serializeMark(e.marks[i], e.isInline, n); s && ((s.contentDOM || s.dom).appendChild(r), r = s.dom) } return r } serializeMark(e, n, r = {}) { let i = this.marks[e.type.name]; return i && km(_x(r), i(e, n), null, e.attrs) } static renderSpec(e, n, r = null, i) { return km(e, n, r, i) } static fromSchema(e) { return e.cached.domSerializer || (e.cached.domSerializer = new hc(this.nodesFromSchema(e), this.marksFromSchema(e))) } static nodesFromSchema(e) { let n = Ck(e.nodes); return n.text || (n.text = r => r.text), n } static marksFromSchema(e) { return Ck(e.marks) } } function Ck(t) { let e = {}; for (let n in t) { let r = t[n].spec.toDOM; r && (e[n] = r) } return e } function _x(t) { return t.document || window.document } const Tk = new WeakMap; function QX(t) { let e = Tk.get(t); return e === void 0 && Tk.set(t, e = JX(t)), e } function JX(t) { let e = null; function n(r) { if (r && typeof r == "object") if (Array.isArray(r)) if (typeof r[0] == "string") e || (e = []), e.push(r); else for (let i = 0; i < r.length; i++)n(r[i]); else for (let i in r) n(r[i]) } return n(t), e } function km(t, e, n, r) { if (typeof e == "string") return { dom: t.createTextNode(e) }; if (e.nodeType != null) return { dom: e }; if (e.dom && e.dom.nodeType != null) return e; let i = e[0], s; if (typeof i != "string") throw new RangeError("Invalid array passed to renderSpec"); if (r && (s = QX(r)) && s.indexOf(e) > -1) throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack."); let a = i.indexOf(" "); a > 0 && (n = i.slice(0, a), i = i.slice(a + 1)); let l, u = n ? t.createElementNS(n, i) : t.createElement(i), f = e[1], p = 1; if (f && typeof f == "object" && f.nodeType == null && !Array.isArray(f)) { p = 2; for (let g in f) if (f[g] != null) { let y = g.indexOf(" "); y > 0 ? u.setAttributeNS(g.slice(0, y), g.slice(y + 1), f[g]) : u.setAttribute(g, f[g]) } } for (let g = p; g < e.length; g++) { let y = e[g]; if (y === 0) { if (g < e.length - 1 || g > p) throw new RangeError("Content hole must be the only child of its parent node"); return { dom: u, contentDOM: u } } else { let { dom: v, contentDOM: b } = km(t, y, n, r); if (u.appendChild(v), b) { if (l) throw new RangeError("Multiple content holes"); l = b } } } return { dom: u, contentDOM: l } } const a5 = 65535, o5 = Math.pow(2, 16); function ZX(t, e) { return t + e * o5 } function Nk(t) { return t & a5 } function eQ(t) { return (t - (t & a5)) / o5 } const l5 = 1, c5 = 2, Om = 4, u5 = 8; class S1 { constructor(e, n, r) { this.pos = e, this.delInfo = n, this.recover = r } get deleted() { return (this.delInfo & u5) > 0 } get deletedBefore() { return (this.delInfo & (l5 | Om)) > 0 } get deletedAfter() { return (this.delInfo & (c5 | Om)) > 0 } get deletedAcross() { return (this.delInfo & Om) > 0 } } class zi { constructor(e, n = !1) { if (this.ranges = e, this.inverted = n, !e.length && zi.empty) return zi.empty } recover(e) { let n = 0, r = Nk(e); if (!this.inverted) for (let i = 0; i < r; i++)n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]; return this.ranges[r * 3] + n + eQ(e) } mapResult(e, n = 1) { return this._map(e, n, !1) } map(e, n = 1) { return this._map(e, n, !0) } _map(e, n, r) { let i = 0, s = this.inverted ? 2 : 1, a = this.inverted ? 1 : 2; for (let l = 0; l < this.ranges.length; l += 3) { let u = this.ranges[l] - (this.inverted ? i : 0); if (u > e) break; let f = this.ranges[l + s], p = this.ranges[l + a], g = u + f; if (e <= g) { let y = f ? e == u ? -1 : e == g ? 1 : n : n, v = u + i + (y < 0 ? 0 : p); if (r) return v; let b = e == (n < 0 ? u : g) ? null : ZX(l / 3, e - u), S = e == u ? c5 : e == g ? l5 : Om; return (n < 0 ? e != u : e != g) && (S |= u5), new S1(v, S, b) } i += p - f } return r ? e + i : new S1(e + i, 0, null) } touches(e, n) { let r = 0, i = Nk(n), s = this.inverted ? 2 : 1, a = this.inverted ? 1 : 2; for (let l = 0; l < this.ranges.length; l += 3) { let u = this.ranges[l] - (this.inverted ? r : 0); if (u > e) break; let f = this.ranges[l + s], p = u + f; if (e <= p && l == i * 3) return !0; r += this.ranges[l + a] - f } return !1 } forEach(e) { let n = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2; for (let i = 0, s = 0; i < this.ranges.length; i += 3) { let a = this.ranges[i], l = a - (this.inverted ? s : 0), u = a + (this.inverted ? 0 : s), f = this.ranges[i + n], p = this.ranges[i + r]; e(l, l + f, u, u + p), s += p - f } } invert() { return new zi(this.ranges, !this.inverted) } toString() { return (this.inverted ? "-" : "") + JSON.stringify(this.ranges) } static offset(e) { return e == 0 ? zi.empty : new zi(e < 0 ? [0, -e, 0] : [0, 0, e]) } } zi.empty = new zi([]); class qf { constructor(e, n, r = 0, i = e ? e.length : 0) { this.mirror = n, this.from = r, this.to = i, this._maps = e || [], this.ownData = !(e || n) } get maps() { return this._maps } slice(e = 0, n = this.maps.length) { return new qf(this._maps, this.mirror, e, n) } appendMap(e, n) { this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(e), n != null && this.setMirror(this._maps.length - 1, n) } appendMapping(e) { for (let n = 0, r = this._maps.length; n < e._maps.length; n++) { let i = e.getMirror(n); this.appendMap(e._maps[n], i != null && i < n ? r + i : void 0) } } getMirror(e) { if (this.mirror) { for (let n = 0; n < this.mirror.length; n++)if (this.mirror[n] == e) return this.mirror[n + (n % 2 ? -1 : 1)] } } setMirror(e, n) { this.mirror || (this.mirror = []), this.mirror.push(e, n) } appendMappingInverted(e) { for (let n = e.maps.length - 1, r = this._maps.length + e._maps.length; n >= 0; n--) { let i = e.getMirror(n); this.appendMap(e._maps[n].invert(), i != null && i > n ? r - i - 1 : void 0) } } invert() { let e = new qf; return e.appendMappingInverted(this), e } map(e, n = 1) { if (this.mirror) return this._map(e, n, !0); for (let r = this.from; r < this.to; r++)e = this._maps[r].map(e, n); return e } mapResult(e, n = 1) { return this._map(e, n, !1) } _map(e, n, r) { let i = 0; for (let s = this.from; s < this.to; s++) { let a = this._maps[s], l = a.mapResult(e, n); if (l.recover != null) { let u = this.getMirror(s); if (u != null && u > s && u < this.to) { s = u, e = this._maps[u].recover(l.recover); continue } } i |= l.delInfo, e = l.pos } return r ? e : new S1(e, i, null) } } const Lx = Object.create(null); class Qr { getMap() { return zi.empty } merge(e) { return null } static fromJSON(e, n) { if (!n || !n.stepType) throw new RangeError("Invalid input for Step.fromJSON"); let r = Lx[n.stepType]; if (!r) throw new RangeError(`No step type ${n.stepType} defined`); return r.fromJSON(e, n) } static jsonID(e, n) { if (e in Lx) throw new RangeError("Duplicate use of step JSON ID " + e); return Lx[e] = n, n.prototype.jsonID = e, n } } class dr { constructor(e, n) { this.doc = e, this.failed = n } static ok(e) { return new dr(e, null) } static fail(e) { return new dr(null, e) } static fromReplace(e, n, r, i) { try { return dr.ok(e.replace(n, r, i)) } catch (s) { if (s instanceof og) return dr.fail(s.message); throw s } } } function _S(t, e, n) { let r = []; for (let i = 0; i < t.childCount; i++) { let s = t.child(i); s.content.size && (s = s.copy(_S(s.content, e, s))), s.isInline && (s = e(s, n, i)), r.push(s) } return Ue.fromArray(r) } class Oo extends Qr { constructor(e, n, r) { super(), this.from = e, this.to = n, this.mark = r } apply(e) { let n = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), s = new nt(_S(n.content, (a, l) => !a.isAtom || !l.type.allowsMarkType(this.mark.type) ? a : a.mark(this.mark.addToSet(a.marks)), i), n.openStart, n.openEnd); return dr.fromReplace(e, this.from, this.to, s) } invert() { return new Ys(this.from, this.to, this.mark) } map(e) { let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1); return n.deleted && r.deleted || n.pos >= r.pos ? null : new Oo(n.pos, r.pos, this.mark) } merge(e) { return e instanceof Oo && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Oo(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null } toJSON() { return { stepType: "addMark", mark: this.mark.toJSON(), from: this.from, to: this.to } } static fromJSON(e, n) { if (typeof n.from != "number" || typeof n.to != "number") throw new RangeError("Invalid input for AddMarkStep.fromJSON"); return new Oo(n.from, n.to, e.markFromJSON(n.mark)) } } Qr.jsonID("addMark", Oo); class Ys extends Qr { constructor(e, n, r) { super(), this.from = e, this.to = n, this.mark = r } apply(e) { let n = e.slice(this.from, this.to), r = new nt(_S(n.content, i => i.mark(this.mark.removeFromSet(i.marks)), e), n.openStart, n.openEnd); return dr.fromReplace(e, this.from, this.to, r) } invert() { return new Oo(this.from, this.to, this.mark) } map(e) { let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1); return n.deleted && r.deleted || n.pos >= r.pos ? null : new Ys(n.pos, r.pos, this.mark) } merge(e) { return e instanceof Ys && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Ys(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null } toJSON() { return { stepType: "removeMark", mark: this.mark.toJSON(), from: this.from, to: this.to } } static fromJSON(e, n) { if (typeof n.from != "number" || typeof n.to != "number") throw new RangeError("Invalid input for RemoveMarkStep.fromJSON"); return new Ys(n.from, n.to, e.markFromJSON(n.mark)) } } Qr.jsonID("removeMark", Ys); class Mo extends Qr { constructor(e, n) { super(), this.pos = e, this.mark = n } apply(e) { let n = e.nodeAt(this.pos); if (!n) return dr.fail("No node at mark step's position"); let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks)); return dr.fromReplace(e, this.pos, this.pos + 1, new nt(Ue.from(r), 0, n.isLeaf ? 0 : 1)) } invert(e) { let n = e.nodeAt(this.pos); if (n) { let r = this.mark.addToSet(n.marks); if (r.length == n.marks.length) { for (let i = 0; i < n.marks.length; i++)if (!n.marks[i].isInSet(r)) return new Mo(this.pos, n.marks[i]); return new Mo(this.pos, this.mark) } } return new ec(this.pos, this.mark) } map(e) { let n = e.mapResult(this.pos, 1); return n.deletedAfter ? null : new Mo(n.pos, this.mark) } toJSON() { return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() } } static fromJSON(e, n) { if (typeof n.pos != "number") throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON"); return new Mo(n.pos, e.markFromJSON(n.mark)) } } Qr.jsonID("addNodeMark", Mo); class ec extends Qr { constructor(e, n) { super(), this.pos = e, this.mark = n } apply(e) { let n = e.nodeAt(this.pos); if (!n) return dr.fail("No node at mark step's position"); let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks)); return dr.fromReplace(e, this.pos, this.pos + 1, new nt(Ue.from(r), 0, n.isLeaf ? 0 : 1)) } invert(e) { let n = e.nodeAt(this.pos); return !n || !this.mark.isInSet(n.marks) ? this : new Mo(this.pos, this.mark) } map(e) { let n = e.mapResult(this.pos, 1); return n.deletedAfter ? null : new ec(n.pos, this.mark) } toJSON() { return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() } } static fromJSON(e, n) { if (typeof n.pos != "number") throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON"); return new ec(n.pos, e.markFromJSON(n.mark)) } } Qr.jsonID("removeNodeMark", ec); class Er extends Qr { constructor(e, n, r, i = !1) { super(), this.from = e, this.to = n, this.slice = r, this.structure = i } apply(e) { return this.structure && C1(e, this.from, this.to) ? dr.fail("Structure replace would overwrite content") : dr.fromReplace(e, this.from, this.to, this.slice) } getMap() { return new zi([this.from, this.to - this.from, this.slice.size]) } invert(e) { return new Er(this.from, this.from + this.slice.size, e.slice(this.from, this.to)) } map(e) { let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1); return n.deletedAcross && r.deletedAcross ? null : new Er(n.pos, Math.max(n.pos, r.pos), this.slice, this.structure) } merge(e) { if (!(e instanceof Er) || e.structure || this.structure) return null; if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) { let n = this.slice.size + e.slice.size == 0 ? nt.empty : new nt(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd); return new Er(this.from, this.to + (e.to - e.from), n, this.structure) } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) { let n = this.slice.size + e.slice.size == 0 ? nt.empty : new nt(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd); return new Er(e.from, this.to, n, this.structure) } else return null } toJSON() { let e = { stepType: "replace", from: this.from, to: this.to }; return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e } static fromJSON(e, n) { if (typeof n.from != "number" || typeof n.to != "number") throw new RangeError("Invalid input for ReplaceStep.fromJSON"); return new Er(n.from, n.to, nt.fromJSON(e, n.slice), !!n.structure) } } Qr.jsonID("replace", Er); class Ar extends Qr { constructor(e, n, r, i, s, a, l = !1) { super(), this.from = e, this.to = n, this.gapFrom = r, this.gapTo = i, this.slice = s, this.insert = a, this.structure = l } apply(e) { if (this.structure && (C1(e, this.from, this.gapFrom) || C1(e, this.gapTo, this.to))) return dr.fail("Structure gap-replace would overwrite content"); let n = e.slice(this.gapFrom, this.gapTo); if (n.openStart || n.openEnd) return dr.fail("Gap is not a flat range"); let r = this.slice.insertAt(this.insert, n.content); return r ? dr.fromReplace(e, this.from, this.to, r) : dr.fail("Content does not fit in gap") } getMap() { return new zi([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]) } invert(e) { let n = this.gapTo - this.gapFrom; return new Ar(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure) } map(e) { let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1), s = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1); return n.deletedAcross && r.deletedAcross || i < n.pos || s > r.pos ? null : new Ar(n.pos, r.pos, i, s, this.slice, this.insert, this.structure) } toJSON() { let e = { stepType: "replaceAround", from: this.from, to: this.to, gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert }; return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e } static fromJSON(e, n) { if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number") throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON"); return new Ar(n.from, n.to, n.gapFrom, n.gapTo, nt.fromJSON(e, n.slice), n.insert, !!n.structure) } } Qr.jsonID("replaceAround", Ar); function C1(t, e, n) { let r = t.resolve(e), i = n - e, s = r.depth; for (; i > 0 && s > 0 && r.indexAfter(s) == r.node(s).childCount;)s--, i--; if (i > 0) { let a = r.node(s).maybeChild(r.indexAfter(s)); for (; i > 0;) { if (!a || a.isLeaf) return !0; a = a.firstChild, i-- } } return !1 } function tQ(t, e, n, r) { let i = [], s = [], a, l; t.doc.nodesBetween(e, n, (u, f, p) => { if (!u.isInline) return; let g = u.marks; if (!r.isInSet(g) && p.type.allowsMarkType(r.type)) { let y = Math.max(f, e), v = Math.min(f + u.nodeSize, n), b = r.addToSet(g); for (let S = 0; S < g.length; S++)g[S].isInSet(b) || (a && a.to == y && a.mark.eq(g[S]) ? a.to = v : i.push(a = new Ys(y, v, g[S]))); l && l.to == y ? l.to = v : s.push(l = new Oo(y, v, r)) } }), i.forEach(u => t.step(u)), s.forEach(u => t.step(u)) } function nQ(t, e, n, r) { let i = [], s = 0; t.doc.nodesBetween(e, n, (a, l) => { if (!a.isInline) return; s++; let u = null; if (r instanceof Ey) { let f = a.marks, p; for (; p = r.isInSet(f);)(u || (u = [])).push(p), f = p.removeFromSet(f) } else r ? r.isInSet(a.marks) && (u = [r]) : u = a.marks; if (u && u.length) { let f = Math.min(l + a.nodeSize, n); for (let p = 0; p < u.length; p++) { let g = u[p], y; for (let v = 0; v < i.length; v++) { let b = i[v]; b.step == s - 1 && g.eq(i[v].style) && (y = b) } y ? (y.to = f, y.step = s) : i.push({ style: g, from: Math.max(l, e), to: f, step: s }) } } }), i.forEach(a => t.step(new Ys(a.from, a.to, a.style))) } function LS(t, e, n, r = n.contentMatch, i = !0) { let s = t.doc.nodeAt(e), a = [], l = e + 1; for (let u = 0; u < s.childCount; u++) { let f = s.child(u), p = l + f.nodeSize, g = r.matchType(f.type); if (!g) a.push(new Er(l, p, nt.empty)); else { r = g; for (let y = 0; y < f.marks.length; y++)n.allowsMarkType(f.marks[y].type) || t.step(new Ys(l, p, f.marks[y])); if (i && f.isText && n.whitespace != "pre") { let y, v = /\r?\n|\r/g, b; for (; y = v.exec(f.text);)b || (b = new nt(Ue.from(n.schema.text(" ", n.allowedMarks(f.marks))), 0, 0)), a.push(new Er(l + y.index, l + y.index + y[0].length, b)) } } l = p } if (!r.validEnd) { let u = r.fillBefore(Ue.empty, !0); t.replace(l, l, new nt(u, 0, 0)) } for (let u = a.length - 1; u >= 0; u--)t.step(a[u]) } function rQ(t, e, n) { return (e == 0 || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n)) } function _u(t) { let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex); for (let r = t.depth; ; --r) { let i = t.$from.node(r), s = t.$from.index(r), a = t.$to.indexAfter(r); if (r < t.depth && i.canReplace(s, a, n)) return r; if (r == 0 || i.type.spec.isolating || !rQ(i, s, a)) break } return null } function iQ(t, e, n) { let { $from: r, $to: i, depth: s } = e, a = r.before(s + 1), l = i.after(s + 1), u = a, f = l, p = Ue.empty, g = 0; for (let b = s, S = !1; b > n; b--)S || r.index(b) > 0 ? (S = !0, p = Ue.from(r.node(b).copy(p)), g++) : u--; let y = Ue.empty, v = 0; for (let b = s, S = !1; b > n; b--)S || i.after(b + 1) < i.end(b) ? (S = !0, y = Ue.from(i.node(b).copy(y)), v++) : f++; t.step(new Ar(u, f, a, l, new nt(p.append(y), g, v), p.size - g, !0)) } function PS(t, e, n = null, r = t) { let i = sQ(t, e), s = i && aQ(r, e); return s ? i.map(jk).concat({ type: e, attrs: n }).concat(s.map(jk)) : null } function jk(t) { return { type: t, attrs: null } } function sQ(t, e) { let { parent: n, startIndex: r, endIndex: i } = t, s = n.contentMatchAt(r).findWrapping(e); if (!s) return null; let a = s.length ? s[0] : e; return n.canReplaceWith(r, i, a) ? s : null } function aQ(t, e) { let { parent: n, startIndex: r, endIndex: i } = t, s = n.child(r), a = e.contentMatch.findWrapping(s.type); if (!a) return null; let u = (a.length ? a[a.length - 1] : e).contentMatch; for (let f = r; u && f < i; f++)u = u.matchType(n.child(f).type); return !u || !u.validEnd ? null : a } function oQ(t, e, n) { let r = Ue.empty; for (let a = n.length - 1; a >= 0; a--) { if (r.size) { let l = n[a].type.contentMatch.matchFragment(r); if (!l || !l.validEnd) throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper") } r = Ue.from(n[a].type.create(n[a].attrs, r)) } let i = e.start, s = e.end; t.step(new Ar(i, s, i, s, new nt(r, 0, 0), n.length, !0)) } function lQ(t, e, n, r, i) { if (!r.isTextblock) throw new RangeError("Type given to setBlockType should be a textblock"); let s = t.steps.length; t.doc.nodesBetween(e, n, (a, l) => { let u = typeof i == "function" ? i(a) : i; if (a.isTextblock && !a.hasMarkup(r, u) && cQ(t.doc, t.mapping.slice(s).map(l), r)) { let f = null; if (r.schema.linebreakReplacement) { let v = r.whitespace == "pre", b = !!r.contentMatch.matchType(r.schema.linebreakReplacement); v && !b ? f = !1 : !v && b && (f = !0) } f === !1 && f5(t, a, l, s), LS(t, t.mapping.slice(s).map(l, 1), r, void 0, f === null); let p = t.mapping.slice(s), g = p.map(l, 1), y = p.map(l + a.nodeSize, 1); return t.step(new Ar(g, y, g + 1, y - 1, new nt(Ue.from(r.create(u, null, a.marks)), 0, 0), 1, !0)), f === !0 && d5(t, a, l, s), !1 } }) } function d5(t, e, n, r) { e.forEach((i, s) => { if (i.isText) { let a, l = /\r?\n|\r/g; for (; a = l.exec(i.text);) { let u = t.mapping.slice(r).map(n + 1 + s + a.index); t.replaceWith(u, u + 1, e.type.schema.linebreakReplacement.create()) } } }) } function f5(t, e, n, r) {
    e.forEach((i, s) => {
      if (i.type == i.type.schema.linebreakReplacement) {
        let a = t.mapping.slice(r).map(n + 1 + s); t.replaceWith(a, a + 1, e.type.schema.text(`
`))
      }
    })
  } function cQ(t, e, n) { let r = t.resolve(e), i = r.index(); return r.parent.canReplaceWith(i, i + 1, n) } function uQ(t, e, n, r, i) { let s = t.doc.nodeAt(e); if (!s) throw new RangeError("No node at given position"); n || (n = s.type); let a = n.create(r, null, i || s.marks); if (s.isLeaf) return t.replaceWith(e, e + s.nodeSize, a); if (!n.validContent(s.content)) throw new RangeError("Invalid content for node type " + n.name); t.step(new Ar(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new nt(Ue.from(a), 0, 0), 1, !0)) } function Ia(t, e, n = 1, r) { let i = t.resolve(e), s = i.depth - n, a = r && r[r.length - 1] || i.parent; if (s < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !a.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount))) return !1; for (let f = i.depth - 1, p = n - 2; f > s; f--, p--) { let g = i.node(f), y = i.index(f); if (g.type.spec.isolating) return !1; let v = g.content.cutByIndex(y, g.childCount), b = r && r[p + 1]; b && (v = v.replaceChild(0, b.type.create(b.attrs))); let S = r && r[p] || g; if (!g.canReplace(y + 1, g.childCount) || !S.type.validContent(v)) return !1 } let l = i.indexAfter(s), u = r && r[0]; return i.node(s).canReplaceWith(l, l, u ? u.type : i.node(s + 1).type) } function dQ(t, e, n = 1, r) { let i = t.doc.resolve(e), s = Ue.empty, a = Ue.empty; for (let l = i.depth, u = i.depth - n, f = n - 1; l > u; l--, f--) { s = Ue.from(i.node(l).copy(s)); let p = r && r[f]; a = Ue.from(p ? p.type.create(p.attrs, a) : i.node(l).copy(a)) } t.step(new Er(e, e, new nt(s.append(a), n, n), !0)) } function Xo(t, e) { let n = t.resolve(e), r = n.index(); return h5(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1) } function fQ(t, e) { e.content.size || t.type.compatibleContent(e.type); let n = t.contentMatchAt(t.childCount), { linebreakReplacement: r } = t.type.schema; for (let i = 0; i < e.childCount; i++) { let s = e.child(i), a = s.type == r ? t.type.schema.nodes.text : s.type; if (n = n.matchType(a), !n || !t.type.allowsMarks(s.marks)) return !1 } return n.validEnd } function h5(t, e) { return !!(t && e && !t.isLeaf && fQ(t, e)) } function Ay(t, e, n = -1) { let r = t.resolve(e); for (let i = r.depth; ; i--) { let s, a, l = r.index(i); if (i == r.depth ? (s = r.nodeBefore, a = r.nodeAfter) : n > 0 ? (s = r.node(i + 1), l++, a = r.node(i).maybeChild(l)) : (s = r.node(i).maybeChild(l - 1), a = r.node(i + 1)), s && !s.isTextblock && h5(s, a) && r.node(i).canReplace(l, l + 1)) return e; if (i == 0) break; e = n < 0 ? r.before(i) : r.after(i) } } function hQ(t, e, n) { let r = null, { linebreakReplacement: i } = t.doc.type.schema, s = t.doc.resolve(e - n), a = s.node().type; if (i && a.inlineContent) { let p = a.whitespace == "pre", g = !!a.contentMatch.matchType(i); p && !g ? r = !1 : !p && g && (r = !0) } let l = t.steps.length; if (r === !1) { let p = t.doc.resolve(e + n); f5(t, p.node(), p.before(), l) } a.inlineContent && LS(t, e + n - 1, a, s.node().contentMatchAt(s.index()), r == null); let u = t.mapping.slice(l), f = u.map(e - n); if (t.step(new Er(f, u.map(e + n, -1), nt.empty, !0)), r === !0) { let p = t.doc.resolve(f); d5(t, p.node(), p.before(), t.steps.length) } return t } function pQ(t, e, n) { let r = t.resolve(e); if (r.parent.canReplaceWith(r.index(), r.index(), n)) return e; if (r.parentOffset == 0) for (let i = r.depth - 1; i >= 0; i--) { let s = r.index(i); if (r.node(i).canReplaceWith(s, s, n)) return r.before(i + 1); if (s > 0) return null } if (r.parentOffset == r.parent.content.size) for (let i = r.depth - 1; i >= 0; i--) { let s = r.indexAfter(i); if (r.node(i).canReplaceWith(s, s, n)) return r.after(i + 1); if (s < r.node(i).childCount) return null } return null } function p5(t, e, n) { let r = t.resolve(e); if (!n.content.size) return e; let i = n.content; for (let s = 0; s < n.openStart; s++)i = i.firstChild.content; for (let s = 1; s <= (n.openStart == 0 && n.size ? 2 : 1); s++)for (let a = r.depth; a >= 0; a--) { let l = a == r.depth ? 0 : r.pos <= (r.start(a + 1) + r.end(a + 1)) / 2 ? -1 : 1, u = r.index(a) + (l > 0 ? 1 : 0), f = r.node(a), p = !1; if (s == 1) p = f.canReplace(u, u, i); else { let g = f.contentMatchAt(u).findWrapping(i.firstChild.type); p = g && f.canReplaceWith(u, u, g[0]) } if (p) return l == 0 ? r.pos : l < 0 ? r.before(a + 1) : r.after(a + 1) } return null } function ky(t, e, n = e, r = nt.empty) { if (e == n && !r.size) return null; let i = t.resolve(e), s = t.resolve(n); return m5(i, s, r) ? new Er(e, n, r) : new mQ(i, s, r).fit() } function m5(t, e, n) { return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content) } class mQ { constructor(e, n, r) { this.$from = e, this.$to = n, this.unplaced = r, this.frontier = [], this.placed = Ue.empty; for (let i = 0; i <= e.depth; i++) { let s = e.node(i); this.frontier.push({ type: s.type, match: s.contentMatchAt(e.indexAfter(i)) }) } for (let i = e.depth; i > 0; i--)this.placed = Ue.from(e.node(i).copy(this.placed)) } get depth() { return this.frontier.length - 1 } fit() { for (; this.unplaced.size;) { let f = this.findFittable(); f ? this.placeNodes(f) : this.openMore() || this.dropNode() } let e = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(e < 0 ? this.$to : r.doc.resolve(e)); if (!i) return null; let s = this.placed, a = r.depth, l = i.depth; for (; a && l && s.childCount == 1;)s = s.firstChild.content, a--, l--; let u = new nt(s, a, l); return e > -1 ? new Ar(r.pos, e, this.$to.pos, this.$to.end(), u, n) : u.size || r.pos != this.$to.pos ? new Er(r.pos, i.pos, u) : null } findFittable() { let e = this.unplaced.openStart; for (let n = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) { let s = n.firstChild; if (n.childCount > 1 && (i = 0), s.type.spec.isolating && i <= r) { e = r; break } n = s.content } for (let n = 1; n <= 2; n++)for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) { let i, s = null; r ? (s = Px(this.unplaced.content, r - 1).firstChild, i = s.content) : i = this.unplaced.content; let a = i.firstChild; for (let l = this.depth; l >= 0; l--) { let { type: u, match: f } = this.frontier[l], p, g = null; if (n == 1 && (a ? f.matchType(a.type) || (g = f.fillBefore(Ue.from(a), !1)) : s && u.compatibleContent(s.type))) return { sliceDepth: r, frontierDepth: l, parent: s, inject: g }; if (n == 2 && a && (p = f.findWrapping(a.type))) return { sliceDepth: r, frontierDepth: l, parent: s, wrap: p }; if (s && f.matchType(s.type)) break } } } openMore() { let { content: e, openStart: n, openEnd: r } = this.unplaced, i = Px(e, n); return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new nt(e, n + 1, Math.max(r, i.size + n >= e.size - r ? n + 1 : 0)), !0) } dropNode() { let { content: e, openStart: n, openEnd: r } = this.unplaced, i = Px(e, n); if (i.childCount <= 1 && n > 0) { let s = e.size - n <= n + i.size; this.unplaced = new nt(Jd(e, n - 1, 1), n - 1, s ? n - 1 : r) } else this.unplaced = new nt(Jd(e, n, 1), n, r) } placeNodes({ sliceDepth: e, frontierDepth: n, parent: r, inject: i, wrap: s }) { for (; this.depth > n;)this.closeFrontierNode(); if (s) for (let S = 0; S < s.length; S++)this.openFrontierNode(s[S]); let a = this.unplaced, l = r ? r.content : a.content, u = a.openStart - e, f = 0, p = [], { match: g, type: y } = this.frontier[n]; if (i) { for (let S = 0; S < i.childCount; S++)p.push(i.child(S)); g = g.matchFragment(i) } let v = l.size + e - (a.content.size - a.openEnd); for (; f < l.childCount;) { let S = l.child(f), C = g.matchType(S.type); if (!C) break; f++, (f > 1 || u == 0 || S.content.size) && (g = C, p.push(g5(S.mark(y.allowedMarks(S.marks)), f == 1 ? u : 0, f == l.childCount ? v : -1))) } let b = f == l.childCount; b || (v = -1), this.placed = Zd(this.placed, n, Ue.from(p)), this.frontier[n].match = g, b && v < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode(); for (let S = 0, C = l; S < v; S++) { let T = C.lastChild; this.frontier.push({ type: T.type, match: T.contentMatchAt(T.childCount) }), C = T.content } this.unplaced = b ? e == 0 ? nt.empty : new nt(Jd(a.content, e - 1, 1), e - 1, v < 0 ? a.openEnd : e - 1) : new nt(Jd(a.content, e, f), a.openStart, a.openEnd) } mustMoveInline() { if (!this.$to.parent.isTextblock) return -1; let e = this.frontier[this.depth], n; if (!e.type.isTextblock || !zx(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth) return -1; let { depth: r } = this.$to, i = this.$to.after(r); for (; r > 1 && i == this.$to.end(--r);)++i; return i } findCloseLevel(e) { e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) { let { match: r, type: i } = this.frontier[n], s = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)), a = zx(e, n, i, r, s); if (a) { for (let l = n - 1; l >= 0; l--) { let { match: u, type: f } = this.frontier[l], p = zx(e, l, f, u, !0); if (!p || p.childCount) continue e } return { depth: n, fit: a, move: s ? e.doc.resolve(e.after(n + 1)) : e } } } } close(e) { let n = this.findCloseLevel(e); if (!n) return null; for (; this.depth > n.depth;)this.closeFrontierNode(); n.fit.childCount && (this.placed = Zd(this.placed, n.depth, n.fit)), e = n.move; for (let r = n.depth + 1; r <= e.depth; r++) { let i = e.node(r), s = i.type.contentMatch.fillBefore(i.content, !0, e.index(r)); this.openFrontierNode(i.type, i.attrs, s) } return e } openFrontierNode(e, n = null, r) { let i = this.frontier[this.depth]; i.match = i.match.matchType(e), this.placed = Zd(this.placed, this.depth, Ue.from(e.create(n, r))), this.frontier.push({ type: e, match: e.contentMatch }) } closeFrontierNode() { let n = this.frontier.pop().match.fillBefore(Ue.empty, !0); n.childCount && (this.placed = Zd(this.placed, this.frontier.length, n)) } } function Jd(t, e, n) { return e == 0 ? t.cutByIndex(n, t.childCount) : t.replaceChild(0, t.firstChild.copy(Jd(t.firstChild.content, e - 1, n))) } function Zd(t, e, n) { return e == 0 ? t.append(n) : t.replaceChild(t.childCount - 1, t.lastChild.copy(Zd(t.lastChild.content, e - 1, n))) } function Px(t, e) { for (let n = 0; n < e; n++)t = t.firstChild.content; return t } function g5(t, e, n) { if (e <= 0) return t; let r = t.content; return e > 1 && (r = r.replaceChild(0, g5(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0))), e > 0 && (r = t.type.contentMatch.fillBefore(r).append(r), n <= 0 && (r = r.append(t.type.contentMatch.matchFragment(r).fillBefore(Ue.empty, !0)))), t.copy(r) } function zx(t, e, n, r, i) { let s = t.node(e), a = i ? t.indexAfter(e) : t.index(e); if (a == s.childCount && !n.compatibleContent(s.type)) return null; let l = r.fillBefore(s.content, !0, a); return l && !gQ(n, s.content, a) ? l : null } function gQ(t, e, n) { for (let r = n; r < e.childCount; r++)if (!t.allowsMarks(e.child(r).marks)) return !0; return !1 } function yQ(t) { return t.spec.defining || t.spec.definingForContent } function vQ(t, e, n, r) { if (!r.size) return t.deleteRange(e, n); let i = t.doc.resolve(e), s = t.doc.resolve(n); if (m5(i, s, r)) return t.step(new Er(e, n, r)); let a = v5(i, t.doc.resolve(n)); a[a.length - 1] == 0 && a.pop(); let l = -(i.depth + 1); a.unshift(l); for (let y = i.depth, v = i.pos - 1; y > 0; y--, v--) { let b = i.node(y).type.spec; if (b.defining || b.definingAsContext || b.isolating) break; a.indexOf(y) > -1 ? l = y : i.before(y) == v && a.splice(1, 0, -y) } let u = a.indexOf(l), f = [], p = r.openStart; for (let y = r.content, v = 0; ; v++) { let b = y.firstChild; if (f.push(b), v == r.openStart) break; y = b.content } for (let y = p - 1; y >= 0; y--) { let v = f[y], b = yQ(v.type); if (b && !v.sameMarkup(i.node(Math.abs(l) - 1))) p = y; else if (b || !v.type.isTextblock) break } for (let y = r.openStart; y >= 0; y--) { let v = (y + p + 1) % (r.openStart + 1), b = f[v]; if (b) for (let S = 0; S < a.length; S++) { let C = a[(S + u) % a.length], T = !0; C < 0 && (T = !1, C = -C); let A = i.node(C - 1), M = i.index(C - 1); if (A.canReplaceWith(M, M, b.type, b.marks)) return t.replace(i.before(C), T ? s.after(C) : n, new nt(y5(r.content, 0, r.openStart, v), v, r.openEnd)) } } let g = t.steps.length; for (let y = a.length - 1; y >= 0 && (t.replace(e, n, r), !(t.steps.length > g)); y--) { let v = a[y]; v < 0 || (e = i.before(v), n = s.after(v)) } } function y5(t, e, n, r, i) { if (e < n) { let s = t.firstChild; t = t.replaceChild(0, s.copy(y5(s.content, e + 1, n, r, s))) } if (e > r) { let s = i.contentMatchAt(0), a = s.fillBefore(t).append(t); t = a.append(s.matchFragment(a).fillBefore(Ue.empty, !0)) } return t } function xQ(t, e, n, r) { if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) { let i = pQ(t.doc, e, r.type); i != null && (e = n = i) } t.replaceRange(e, n, new nt(Ue.from(r), 0, 0)) } function bQ(t, e, n) { let r = t.doc.resolve(e), i = t.doc.resolve(n), s = v5(r, i); for (let a = 0; a < s.length; a++) { let l = s[a], u = a == s.length - 1; if (u && l == 0 || r.node(l).type.contentMatch.validEnd) return t.delete(r.start(l), i.end(l)); if (l > 0 && (u || r.node(l - 1).canReplace(r.index(l - 1), i.indexAfter(l - 1)))) return t.delete(r.before(l), i.after(l)) } for (let a = 1; a <= r.depth && a <= i.depth; a++)if (e - r.start(a) == r.depth - a && n > r.end(a) && i.end(a) - n != i.depth - a && r.start(a - 1) == i.start(a - 1) && r.node(a - 1).canReplace(r.index(a - 1), i.index(a - 1))) return t.delete(r.before(a), n); t.delete(e, n) } function v5(t, e) { let n = [], r = Math.min(t.depth, e.depth); for (let i = r; i >= 0; i--) { let s = t.start(i); if (s < t.pos - (t.depth - i) || e.end(i) > e.pos + (e.depth - i) || t.node(i).type.spec.isolating || e.node(i).type.spec.isolating) break; (s == e.start(i) || i == t.depth && i == e.depth && t.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == s - 1) && n.push(i) } return n } class uu extends Qr { constructor(e, n, r) { super(), this.pos = e, this.attr = n, this.value = r } apply(e) { let n = e.nodeAt(this.pos); if (!n) return dr.fail("No node at attribute step's position"); let r = Object.create(null); for (let s in n.attrs) r[s] = n.attrs[s]; r[this.attr] = this.value; let i = n.type.create(r, null, n.marks); return dr.fromReplace(e, this.pos, this.pos + 1, new nt(Ue.from(i), 0, n.isLeaf ? 0 : 1)) } getMap() { return zi.empty } invert(e) { return new uu(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]) } map(e) { let n = e.mapResult(this.pos, 1); return n.deletedAfter ? null : new uu(n.pos, this.attr, this.value) } toJSON() { return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value } } static fromJSON(e, n) { if (typeof n.pos != "number" || typeof n.attr != "string") throw new RangeError("Invalid input for AttrStep.fromJSON"); return new uu(n.pos, n.attr, n.value) } } Qr.jsonID("attr", uu); class Kf extends Qr { constructor(e, n) { super(), this.attr = e, this.value = n } apply(e) { let n = Object.create(null); for (let i in e.attrs) n[i] = e.attrs[i]; n[this.attr] = this.value; let r = e.type.create(n, e.content, e.marks); return dr.ok(r) } getMap() { return zi.empty } invert(e) { return new Kf(this.attr, e.attrs[this.attr]) } map(e) { return this } toJSON() { return { stepType: "docAttr", attr: this.attr, value: this.value } } static fromJSON(e, n) { if (typeof n.attr != "string") throw new RangeError("Invalid input for DocAttrStep.fromJSON"); return new Kf(n.attr, n.value) } } Qr.jsonID("docAttr", Kf); let gu = class extends Error { }; gu = function t(e) { let n = Error.call(this, e); return n.__proto__ = t.prototype, n }; gu.prototype = Object.create(Error.prototype); gu.prototype.constructor = gu; gu.prototype.name = "TransformError"; class zS { constructor(e) { this.doc = e, this.steps = [], this.docs = [], this.mapping = new qf } get before() { return this.docs.length ? this.docs[0] : this.doc } step(e) { let n = this.maybeStep(e); if (n.failed) throw new gu(n.failed); return this } maybeStep(e) { let n = e.apply(this.doc); return n.failed || this.addStep(e, n.doc), n } get docChanged() { return this.steps.length > 0 } addStep(e, n) { this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = n } replace(e, n = e, r = nt.empty) { let i = ky(this.doc, e, n, r); return i && this.step(i), this } replaceWith(e, n, r) { return this.replace(e, n, new nt(Ue.from(r), 0, 0)) } delete(e, n) { return this.replace(e, n, nt.empty) } insert(e, n) { return this.replaceWith(e, e, n) } replaceRange(e, n, r) { return vQ(this, e, n, r), this } replaceRangeWith(e, n, r) { return xQ(this, e, n, r), this } deleteRange(e, n) { return bQ(this, e, n), this } lift(e, n) { return iQ(this, e, n), this } join(e, n = 1) { return hQ(this, e, n), this } wrap(e, n) { return oQ(this, e, n), this } setBlockType(e, n = e, r, i = null) { return lQ(this, e, n, r, i), this } setNodeMarkup(e, n, r = null, i) { return uQ(this, e, n, r, i), this } setNodeAttribute(e, n, r) { return this.step(new uu(e, n, r)), this } setDocAttribute(e, n) { return this.step(new Kf(e, n)), this } addNodeMark(e, n) { return this.step(new Mo(e, n)), this } removeNodeMark(e, n) { let r = this.doc.nodeAt(e); if (!r) throw new RangeError("No node at position " + e); if (n instanceof Tn) n.isInSet(r.marks) && this.step(new ec(e, n)); else { let i = r.marks, s, a = []; for (; s = n.isInSet(i);)a.push(new ec(e, s)), i = s.removeFromSet(i); for (let l = a.length - 1; l >= 0; l--)this.step(a[l]) } return this } split(e, n = 1, r) { return dQ(this, e, n, r), this } addMark(e, n, r) { return tQ(this, e, n, r), this } removeMark(e, n, r) { return nQ(this, e, n, r), this } clearIncompatible(e, n, r) { return LS(this, e, n, r), this } } const Ix = Object.create(null); class Ot { constructor(e, n, r) { this.$anchor = e, this.$head = n, this.ranges = r || [new x5(e.min(n), e.max(n))] } get anchor() { return this.$anchor.pos } get head() { return this.$head.pos } get from() { return this.$from.pos } get to() { return this.$to.pos } get $from() { return this.ranges[0].$from } get $to() { return this.ranges[0].$to } get empty() { let e = this.ranges; for (let n = 0; n < e.length; n++)if (e[n].$from.pos != e[n].$to.pos) return !1; return !0 } content() { return this.$from.doc.slice(this.from, this.to, !0) } replace(e, n = nt.empty) { let r = n.content.lastChild, i = null; for (let l = 0; l < n.openEnd; l++)i = r, r = r.lastChild; let s = e.steps.length, a = this.ranges; for (let l = 0; l < a.length; l++) { let { $from: u, $to: f } = a[l], p = e.mapping.slice(s); e.replaceRange(p.map(u.pos), p.map(f.pos), l ? nt.empty : n), l == 0 && kk(e, s, (r ? r.isInline : i && i.isTextblock) ? -1 : 1) } } replaceWith(e, n) { let r = e.steps.length, i = this.ranges; for (let s = 0; s < i.length; s++) { let { $from: a, $to: l } = i[s], u = e.mapping.slice(r), f = u.map(a.pos), p = u.map(l.pos); s ? e.deleteRange(f, p) : (e.replaceRangeWith(f, p, n), kk(e, r, n.isInline ? -1 : 1)) } } static findFrom(e, n, r = !1) { let i = e.parent.inlineContent ? new Et(e) : Qc(e.node(0), e.parent, e.pos, e.index(), n, r); if (i) return i; for (let s = e.depth - 1; s >= 0; s--) { let a = n < 0 ? Qc(e.node(0), e.node(s), e.before(s + 1), e.index(s), n, r) : Qc(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, n, r); if (a) return a } return null } static near(e, n = 1) { return this.findFrom(e, n) || this.findFrom(e, -n) || new $i(e.node(0)) } static atStart(e) { return Qc(e, e, 0, 0, 1) || new $i(e) } static atEnd(e) { return Qc(e, e, e.content.size, e.childCount, -1) || new $i(e) } static fromJSON(e, n) { if (!n || !n.type) throw new RangeError("Invalid input for Selection.fromJSON"); let r = Ix[n.type]; if (!r) throw new RangeError(`No selection type ${n.type} defined`); return r.fromJSON(e, n) } static jsonID(e, n) { if (e in Ix) throw new RangeError("Duplicate use of selection JSON ID " + e); return Ix[e] = n, n.prototype.jsonID = e, n } getBookmark() { return Et.between(this.$anchor, this.$head).getBookmark() } } Ot.prototype.visible = !0; class x5 { constructor(e, n) { this.$from = e, this.$to = n } } let Ek = !1; function Ak(t) { !Ek && !t.parent.inlineContent && (Ek = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + t.parent.type.name + ")")) } class Et extends Ot { constructor(e, n = e) { Ak(e), Ak(n), super(e, n) } get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null } map(e, n) { let r = e.resolve(n.map(this.head)); if (!r.parent.inlineContent) return Ot.near(r); let i = e.resolve(n.map(this.anchor)); return new Et(i.parent.inlineContent ? i : r, r) } replace(e, n = nt.empty) { if (super.replace(e, n), n == nt.empty) { let r = this.$from.marksAcross(this.$to); r && e.ensureMarks(r) } } eq(e) { return e instanceof Et && e.anchor == this.anchor && e.head == this.head } getBookmark() { return new Oy(this.anchor, this.head) } toJSON() { return { type: "text", anchor: this.anchor, head: this.head } } static fromJSON(e, n) { if (typeof n.anchor != "number" || typeof n.head != "number") throw new RangeError("Invalid input for TextSelection.fromJSON"); return new Et(e.resolve(n.anchor), e.resolve(n.head)) } static create(e, n, r = n) { let i = e.resolve(n); return new this(i, r == n ? i : e.resolve(r)) } static between(e, n, r) { let i = e.pos - n.pos; if ((!r || i) && (r = i >= 0 ? 1 : -1), !n.parent.inlineContent) { let s = Ot.findFrom(n, r, !0) || Ot.findFrom(n, -r, !0); if (s) n = s.$head; else return Ot.near(n, r) } return e.parent.inlineContent || (i == 0 ? e = n : (e = (Ot.findFrom(e, -r, !0) || Ot.findFrom(e, r, !0)).$anchor, e.pos < n.pos != i < 0 && (e = n))), new Et(e, n) } } Ot.jsonID("text", Et); class Oy { constructor(e, n) { this.anchor = e, this.head = n } map(e) { return new Oy(e.map(this.anchor), e.map(this.head)) } resolve(e) { return Et.between(e.resolve(this.anchor), e.resolve(this.head)) } } class Ct extends Ot { constructor(e) { let n = e.nodeAfter, r = e.node(0).resolve(e.pos + n.nodeSize); super(e, r), this.node = n } map(e, n) { let { deleted: r, pos: i } = n.mapResult(this.anchor), s = e.resolve(i); return r ? Ot.near(s) : new Ct(s) } content() { return new nt(Ue.from(this.node), 0, 0) } eq(e) { return e instanceof Ct && e.anchor == this.anchor } toJSON() { return { type: "node", anchor: this.anchor } } getBookmark() { return new IS(this.anchor) } static fromJSON(e, n) { if (typeof n.anchor != "number") throw new RangeError("Invalid input for NodeSelection.fromJSON"); return new Ct(e.resolve(n.anchor)) } static create(e, n) { return new Ct(e.resolve(n)) } static isSelectable(e) { return !e.isText && e.type.spec.selectable !== !1 } } Ct.prototype.visible = !1; Ot.jsonID("node", Ct); class IS { constructor(e) { this.anchor = e } map(e) { let { deleted: n, pos: r } = e.mapResult(this.anchor); return n ? new Oy(r, r) : new IS(r) } resolve(e) { let n = e.resolve(this.anchor), r = n.nodeAfter; return r && Ct.isSelectable(r) ? new Ct(n) : Ot.near(n) } } class $i extends Ot { constructor(e) { super(e.resolve(0), e.resolve(e.content.size)) } replace(e, n = nt.empty) { if (n == nt.empty) { e.delete(0, e.doc.content.size); let r = Ot.atStart(e.doc); r.eq(e.selection) || e.setSelection(r) } else super.replace(e, n) } toJSON() { return { type: "all" } } static fromJSON(e) { return new $i(e) } map(e) { return new $i(e) } eq(e) { return e instanceof $i } getBookmark() { return wQ } } Ot.jsonID("all", $i); const wQ = { map() { return this }, resolve(t) { return new $i(t) } }; function Qc(t, e, n, r, i, s = !1) { if (e.inlineContent) return Et.create(t, n); for (let a = r - (i > 0 ? 0 : 1); i > 0 ? a < e.childCount : a >= 0; a += i) { let l = e.child(a); if (l.isAtom) { if (!s && Ct.isSelectable(l)) return Ct.create(t, n - (i < 0 ? l.nodeSize : 0)) } else { let u = Qc(t, l, n + i, i < 0 ? l.childCount : 0, i, s); if (u) return u } n += l.nodeSize * i } return null } function kk(t, e, n) { let r = t.steps.length - 1; if (r < e) return; let i = t.steps[r]; if (!(i instanceof Er || i instanceof Ar)) return; let s = t.mapping.maps[r], a; s.forEach((l, u, f, p) => { a == null && (a = p) }), t.setSelection(Ot.near(t.doc.resolve(a), n)) } const Ok = 1, Gp = 2, Mk = 4; class SQ extends zS { constructor(e) { super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks } get selection() { return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection } setSelection(e) { if (e.$from.doc != this.doc) throw new RangeError("Selection passed to setSelection must point at the current document"); return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | Ok) & ~Gp, this.storedMarks = null, this } get selectionSet() { return (this.updated & Ok) > 0 } setStoredMarks(e) { return this.storedMarks = e, this.updated |= Gp, this } ensureMarks(e) { return Tn.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this } addStoredMark(e) { return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks())) } removeStoredMark(e) { return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks())) } get storedMarksSet() { return (this.updated & Gp) > 0 } addStep(e, n) { super.addStep(e, n), this.updated = this.updated & ~Gp, this.storedMarks = null } setTime(e) { return this.time = e, this } replaceSelection(e) { return this.selection.replace(this, e), this } replaceSelectionWith(e, n = !0) { let r = this.selection; return n && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || Tn.none))), r.replaceWith(this, e), this } deleteSelection() { return this.selection.replace(this), this } insertText(e, n, r) { let i = this.doc.type.schema; if (n == null) return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection(); { if (r == null && (r = n), r = r ?? n, !e) return this.deleteRange(n, r); let s = this.storedMarks; if (!s) { let a = this.doc.resolve(n); s = r == n ? a.marks() : a.marksAcross(this.doc.resolve(r)) } return this.replaceRangeWith(n, r, i.text(e, s)), this.selection.empty || this.setSelection(Ot.near(this.selection.$to)), this } } setMeta(e, n) { return this.meta[typeof e == "string" ? e : e.key] = n, this } getMeta(e) { return this.meta[typeof e == "string" ? e : e.key] } get isGeneric() { for (let e in this.meta) return !1; return !0 } scrollIntoView() { return this.updated |= Mk, this } get scrolledIntoView() { return (this.updated & Mk) > 0 } } function Dk(t, e) { return !e || !t ? t : t.bind(e) } class ef { constructor(e, n, r) { this.name = e, this.init = Dk(n.init, r), this.apply = Dk(n.apply, r) } } const CQ = [new ef("doc", { init(t) { return t.doc || t.schema.topNodeType.createAndFill() }, apply(t) { return t.doc } }), new ef("selection", { init(t, e) { return t.selection || Ot.atStart(e.doc) }, apply(t) { return t.selection } }), new ef("storedMarks", { init(t) { return t.storedMarks || null }, apply(t, e, n, r) { return r.selection.$cursor ? t.storedMarks : null } }), new ef("scrollToSelection", { init() { return 0 }, apply(t, e) { return t.scrolledIntoView ? e + 1 : e } })]; class Fx { constructor(e, n) { this.schema = e, this.plugins = [], this.pluginsByKey = Object.create(null), this.fields = CQ.slice(), n && n.forEach(r => { if (this.pluginsByKey[r.key]) throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")"); this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new ef(r.key, r.spec.state, r)) }) } } class ou { constructor(e) { this.config = e } get schema() { return this.config.schema } get plugins() { return this.config.plugins } apply(e) { return this.applyTransaction(e).state } filterTransaction(e, n = -1) { for (let r = 0; r < this.config.plugins.length; r++)if (r != n) { let i = this.config.plugins[r]; if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this)) return !1 } return !0 } applyTransaction(e) { if (!this.filterTransaction(e)) return { state: this, transactions: [] }; let n = [e], r = this.applyInner(e), i = null; for (; ;) { let s = !1; for (let a = 0; a < this.config.plugins.length; a++) { let l = this.config.plugins[a]; if (l.spec.appendTransaction) { let u = i ? i[a].n : 0, f = i ? i[a].state : this, p = u < n.length && l.spec.appendTransaction.call(l, u ? n.slice(u) : n, f, r); if (p && r.filterTransaction(p, a)) { if (p.setMeta("appendedTransaction", e), !i) { i = []; for (let g = 0; g < this.config.plugins.length; g++)i.push(g < a ? { state: r, n: n.length } : { state: this, n: 0 }) } n.push(p), r = r.applyInner(p), s = !0 } i && (i[a] = { state: r, n: n.length }) } } if (!s) return { state: r, transactions: n } } } applyInner(e) { if (!e.before.eq(this.doc)) throw new RangeError("Applying a mismatched transaction"); let n = new ou(this.config), r = this.config.fields; for (let i = 0; i < r.length; i++) { let s = r[i]; n[s.name] = s.apply(e, this[s.name], this, n) } return n } get tr() { return new SQ(this) } static create(e) { let n = new Fx(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new ou(n); for (let i = 0; i < n.fields.length; i++)r[n.fields[i].name] = n.fields[i].init(e, r); return r } reconfigure(e) { let n = new Fx(this.schema, e.plugins), r = n.fields, i = new ou(n); for (let s = 0; s < r.length; s++) { let a = r[s].name; i[a] = this.hasOwnProperty(a) ? this[a] : r[s].init(e, i) } return i } toJSON(e) { let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() }; if (this.storedMarks && (n.storedMarks = this.storedMarks.map(r => r.toJSON())), e && typeof e == "object") for (let r in e) { if (r == "doc" || r == "selection") throw new RangeError("The JSON fields `doc` and `selection` are reserved"); let i = e[r], s = i.spec.state; s && s.toJSON && (n[r] = s.toJSON.call(i, this[i.key])) } return n } static fromJSON(e, n, r) { if (!n) throw new RangeError("Invalid input for EditorState.fromJSON"); if (!e.schema) throw new RangeError("Required config field 'schema' missing"); let i = new Fx(e.schema, e.plugins), s = new ou(i); return i.fields.forEach(a => { if (a.name == "doc") s.doc = Lo.fromJSON(e.schema, n.doc); else if (a.name == "selection") s.selection = Ot.fromJSON(s.doc, n.selection); else if (a.name == "storedMarks") n.storedMarks && (s.storedMarks = n.storedMarks.map(e.schema.markFromJSON)); else { if (r) for (let l in r) { let u = r[l], f = u.spec.state; if (u.key == a.name && f && f.fromJSON && Object.prototype.hasOwnProperty.call(n, l)) { s[a.name] = f.fromJSON.call(u, e, n[l], s); return } } s[a.name] = a.init(e, s) } }), s } } function b5(t, e, n) { for (let r in t) { let i = t[r]; i instanceof Function ? i = i.bind(e) : r == "handleDOMEvents" && (i = b5(i, e, {})), n[r] = i } return n } class hr { constructor(e) { this.spec = e, this.props = {}, e.props && b5(e.props, this, this.props), this.key = e.key ? e.key.key : w5("plugin") } getState(e) { return e[this.key] } } const Bx = Object.create(null); function w5(t) { return t in Bx ? t + "$" + ++Bx[t] : (Bx[t] = 0, t + "$") } class Br { constructor(e = "key") { this.key = w5(e) } get(e) { return e.config.pluginsByKey[this.key] } getState(e) { return e[this.key] } } const zr = function (t) { for (var e = 0; ; e++)if (t = t.previousSibling, !t) return e }, yu = function (t) { let e = t.assignedSlot || t.parentNode; return e && e.nodeType == 11 ? e.host : e }; let T1 = null; const Da = function (t, e, n) { let r = T1 || (T1 = document.createRange()); return r.setEnd(t, n ?? t.nodeValue.length), r.setStart(t, e || 0), r }, TQ = function () { T1 = null }, tc = function (t, e, n, r) { return n && (Rk(t, e, n, r, -1) || Rk(t, e, n, r, 1)) }, NQ = /^(img|br|input|textarea|hr)$/i; function Rk(t, e, n, r, i) { for (var s; ;) { if (t == n && e == r) return !0; if (e == (i < 0 ? 0 : as(t))) { let a = t.parentNode; if (!a || a.nodeType != 1 || bh(t) || NQ.test(t.nodeName) || t.contentEditable == "false") return !1; e = zr(t) + (i < 0 ? 0 : 1), t = a } else if (t.nodeType == 1) { let a = t.childNodes[e + (i < 0 ? -1 : 0)]; if (a.nodeType == 1 && a.contentEditable == "false") if (!((s = a.pmViewDesc) === null || s === void 0) && s.ignoreForSelection) e += i; else return !1; else t = a, e = i < 0 ? as(t) : 0 } else return !1 } } function as(t) { return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length } function jQ(t, e) { for (; ;) { if (t.nodeType == 3 && e) return t; if (t.nodeType == 1 && e > 0) { if (t.contentEditable == "false") return null; t = t.childNodes[e - 1], e = as(t) } else if (t.parentNode && !bh(t)) e = zr(t), t = t.parentNode; else return null } } function EQ(t, e) { for (; ;) { if (t.nodeType == 3 && e < t.nodeValue.length) return t; if (t.nodeType == 1 && e < t.childNodes.length) { if (t.contentEditable == "false") return null; t = t.childNodes[e], e = 0 } else if (t.parentNode && !bh(t)) e = zr(t) + 1, t = t.parentNode; else return null } } function AQ(t, e, n) { for (let r = e == 0, i = e == as(t); r || i;) { if (t == n) return !0; let s = zr(t); if (t = t.parentNode, !t) return !1; r = r && s == 0, i = i && s == as(t) } } function bh(t) { let e; for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode); return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t) } const My = function (t) { return t.focusNode && tc(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset) }; function Nl(t, e) { let n = document.createEvent("Event"); return n.initEvent("keydown", !0, !0), n.keyCode = t, n.key = n.code = e, n } function kQ(t) { let e = t.activeElement; for (; e && e.shadowRoot;)e = e.shadowRoot.activeElement; return e } function OQ(t, e, n) { if (t.caretPositionFromPoint) try { let r = t.caretPositionFromPoint(e, n); if (r) return { node: r.offsetNode, offset: Math.min(as(r.offsetNode), r.offset) } } catch { } if (t.caretRangeFromPoint) { let r = t.caretRangeFromPoint(e, n); if (r) return { node: r.startContainer, offset: Math.min(as(r.startContainer), r.startOffset) } } } const ra = typeof navigator < "u" ? navigator : null, _k = typeof document < "u" ? document : null, Qo = ra && ra.userAgent || "", N1 = /Edge\/(\d+)/.exec(Qo), S5 = /MSIE \d/.exec(Qo), j1 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Qo), wi = !!(S5 || j1 || N1), Po = S5 ? document.documentMode : j1 ? +j1[1] : N1 ? +N1[1] : 0, Es = !wi && /gecko\/(\d+)/i.test(Qo); Es && +(/Firefox\/(\d+)/.exec(Qo) || [0, 0])[1]; const E1 = !wi && /Chrome\/(\d+)/.exec(Qo), Gr = !!E1, C5 = E1 ? +E1[1] : 0, ai = !wi && !!ra && /Apple Computer/.test(ra.vendor), vu = ai && (/Mobile\/\w+/.test(Qo) || !!ra && ra.maxTouchPoints > 2), ss = vu || (ra ? /Mac/.test(ra.platform) : !1), MQ = ra ? /Win/.test(ra.platform) : !1, _a = /Android \d/.test(Qo), wh = !!_k && "webkitFontSmoothing" in _k.documentElement.style, DQ = wh ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0; function RQ(t) { let e = t.defaultView && t.defaultView.visualViewport; return e ? { left: 0, right: e.width, top: 0, bottom: e.height } : { left: 0, right: t.documentElement.clientWidth, top: 0, bottom: t.documentElement.clientHeight } } function Na(t, e) { return typeof t == "number" ? t : t[e] } function _Q(t) { let e = t.getBoundingClientRect(), n = e.width / t.offsetWidth || 1, r = e.height / t.offsetHeight || 1; return { left: e.left, right: e.left + t.clientWidth * n, top: e.top, bottom: e.top + t.clientHeight * r } } function Lk(t, e, n) { let r = t.someProp("scrollThreshold") || 0, i = t.someProp("scrollMargin") || 5, s = t.dom.ownerDocument; for (let a = n || t.dom; a;) { if (a.nodeType != 1) { a = yu(a); continue } let l = a, u = l == s.body, f = u ? RQ(s) : _Q(l), p = 0, g = 0; if (e.top < f.top + Na(r, "top") ? g = -(f.top - e.top + Na(i, "top")) : e.bottom > f.bottom - Na(r, "bottom") && (g = e.bottom - e.top > f.bottom - f.top ? e.top + Na(i, "top") - f.top : e.bottom - f.bottom + Na(i, "bottom")), e.left < f.left + Na(r, "left") ? p = -(f.left - e.left + Na(i, "left")) : e.right > f.right - Na(r, "right") && (p = e.right - f.right + Na(i, "right")), p || g) if (u) s.defaultView.scrollBy(p, g); else { let v = l.scrollLeft, b = l.scrollTop; g && (l.scrollTop += g), p && (l.scrollLeft += p); let S = l.scrollLeft - v, C = l.scrollTop - b; e = { left: e.left - S, top: e.top - C, right: e.right - S, bottom: e.bottom - C } } let y = u ? "fixed" : getComputedStyle(a).position; if (/^(fixed|sticky)$/.test(y)) break; a = y == "absolute" ? a.offsetParent : yu(a) } } function LQ(t) { let e = t.dom.getBoundingClientRect(), n = Math.max(0, e.top), r, i; for (let s = (e.left + e.right) / 2, a = n + 1; a < Math.min(innerHeight, e.bottom); a += 5) { let l = t.root.elementFromPoint(s, a); if (!l || l == t.dom || !t.dom.contains(l)) continue; let u = l.getBoundingClientRect(); if (u.top >= n - 20) { r = l, i = u.top; break } } return { refDOM: r, refTop: i, stack: T5(t.dom) } } function T5(t) { let e = [], n = t.ownerDocument; for (let r = t; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n); r = yu(r)); return e } function PQ({ refDOM: t, refTop: e, stack: n }) { let r = t ? t.getBoundingClientRect().top : 0; N5(n, r == 0 ? 0 : r - e) } function N5(t, e) { for (let n = 0; n < t.length; n++) { let { dom: r, top: i, left: s } = t[n]; r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != s && (r.scrollLeft = s) } } let qc = null; function zQ(t) { if (t.setActive) return t.setActive(); if (qc) return t.focus(qc); let e = T5(t); t.focus(qc == null ? { get preventScroll() { return qc = { preventScroll: !0 }, !0 } } : void 0), qc || (qc = !1, N5(e, 0)) } function j5(t, e) { let n, r = 2e8, i, s = 0, a = e.top, l = e.top, u, f; for (let p = t.firstChild, g = 0; p; p = p.nextSibling, g++) { let y; if (p.nodeType == 1) y = p.getClientRects(); else if (p.nodeType == 3) y = Da(p).getClientRects(); else continue; for (let v = 0; v < y.length; v++) { let b = y[v]; if (b.top <= a && b.bottom >= l) { a = Math.max(b.bottom, a), l = Math.min(b.top, l); let S = b.left > e.left ? b.left - e.left : b.right < e.left ? e.left - b.right : 0; if (S < r) { n = p, r = S, i = S && n.nodeType == 3 ? { left: b.right < e.left ? b.right : b.left, top: e.top } : e, p.nodeType == 1 && S && (s = g + (e.left >= (b.left + b.right) / 2 ? 1 : 0)); continue } } else b.top > e.top && !u && b.left <= e.left && b.right >= e.left && (u = p, f = { left: Math.max(b.left, Math.min(b.right, e.left)), top: b.top }); !n && (e.left >= b.right && e.top >= b.top || e.left >= b.left && e.top >= b.bottom) && (s = g + 1) } } return !n && u && (n = u, i = f, r = 0), n && n.nodeType == 3 ? IQ(n, i) : !n || r && n.nodeType == 1 ? { node: t, offset: s } : j5(n, i) } function IQ(t, e) { let n = t.nodeValue.length, r = document.createRange(); for (let i = 0; i < n; i++) { r.setEnd(t, i + 1), r.setStart(t, i); let s = xo(r, 1); if (s.top != s.bottom && FS(e, s)) return { node: t, offset: i + (e.left >= (s.left + s.right) / 2 ? 1 : 0) } } return { node: t, offset: 0 } } function FS(t, e) { return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1 } function FQ(t, e) { let n = t.parentNode; return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t } function BQ(t, e, n) { let { node: r, offset: i } = j5(e, n), s = -1; if (r.nodeType == 1 && !r.firstChild) { let a = r.getBoundingClientRect(); s = a.left != a.right && n.left > (a.left + a.right) / 2 ? 1 : -1 } return t.docView.posFromDOM(r, i, s) } function $Q(t, e, n, r) { let i = -1; for (let s = e, a = !1; s != t.dom;) { let l = t.docView.nearestDesc(s, !0), u; if (!l) return null; if (l.dom.nodeType == 1 && (l.node.isBlock && l.parent || !l.contentDOM) && ((u = l.dom.getBoundingClientRect()).width || u.height) && (l.node.isBlock && l.parent && (!a && u.left > r.left || u.top > r.top ? i = l.posBefore : (!a && u.right < r.left || u.bottom < r.top) && (i = l.posAfter), a = !0), !l.contentDOM && i < 0 && !l.node.isText)) return (l.node.isBlock ? r.top < (u.top + u.bottom) / 2 : r.left < (u.left + u.right) / 2) ? l.posBefore : l.posAfter; s = l.dom.parentNode } return i > -1 ? i : t.docView.posFromDOM(e, n, -1) } function E5(t, e, n) { let r = t.childNodes.length; if (r && n.top < n.bottom) for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - n.top) / (n.bottom - n.top)) - 2)), s = i; ;) { let a = t.childNodes[s]; if (a.nodeType == 1) { let l = a.getClientRects(); for (let u = 0; u < l.length; u++) { let f = l[u]; if (FS(e, f)) return E5(a, e, f) } } if ((s = (s + 1) % r) == i) break } return t } function UQ(t, e) { let n = t.dom.ownerDocument, r, i = 0, s = OQ(n, e.left, e.top); s && ({ node: r, offset: i } = s); let a = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top), l; if (!a || !t.dom.contains(a.nodeType != 1 ? a.parentNode : a)) { let f = t.dom.getBoundingClientRect(); if (!FS(e, f) || (a = E5(t.dom, e, f), !a)) return null } if (ai) for (let f = a; r && f; f = yu(f))f.draggable && (r = void 0); if (a = FQ(a, e), r) { if (Es && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) { let p = r.childNodes[i], g; p.nodeName == "IMG" && (g = p.getBoundingClientRect()).right <= e.left && g.bottom > e.top && i++ } let f; wh && i && r.nodeType == 1 && (f = r.childNodes[i - 1]).nodeType == 1 && f.contentEditable == "false" && f.getBoundingClientRect().top >= e.top && i--, r == t.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? l = t.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (l = $Q(t, r, i, e)) } l == null && (l = BQ(t, a, e)); let u = t.docView.nearestDesc(a, !0); return { pos: l, inside: u ? u.posAtStart - u.border : -1 } } function Pk(t) { return t.top < t.bottom || t.left < t.right } function xo(t, e) { let n = t.getClientRects(); if (n.length) { let r = n[e < 0 ? 0 : n.length - 1]; if (Pk(r)) return r } return Array.prototype.find.call(n, Pk) || t.getBoundingClientRect() } const VQ = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/; function A5(t, e, n) { let { node: r, offset: i, atom: s } = t.docView.domFromPos(e, n < 0 ? -1 : 1), a = wh || Es; if (r.nodeType == 3) if (a && (VQ.test(r.nodeValue) || (n < 0 ? !i : i == r.nodeValue.length))) { let u = xo(Da(r, i, i), n); if (Es && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) { let f = xo(Da(r, i - 1, i - 1), -1); if (f.top == u.top) { let p = xo(Da(r, i, i + 1), -1); if (p.top != u.top) return Ud(p, p.left < f.left) } } return u } else { let u = i, f = i, p = n < 0 ? 1 : -1; return n < 0 && !i ? (f++, p = -1) : n >= 0 && i == r.nodeValue.length ? (u--, p = 1) : n < 0 ? u-- : f++, Ud(xo(Da(r, u, f), p), p < 0) } if (!t.state.doc.resolve(e - (s || 0)).parent.inlineContent) { if (s == null && i && (n < 0 || i == as(r))) { let u = r.childNodes[i - 1]; if (u.nodeType == 1) return $x(u.getBoundingClientRect(), !1) } if (s == null && i < as(r)) { let u = r.childNodes[i]; if (u.nodeType == 1) return $x(u.getBoundingClientRect(), !0) } return $x(r.getBoundingClientRect(), n >= 0) } if (s == null && i && (n < 0 || i == as(r))) { let u = r.childNodes[i - 1], f = u.nodeType == 3 ? Da(u, as(u) - (a ? 0 : 1)) : u.nodeType == 1 && (u.nodeName != "BR" || !u.nextSibling) ? u : null; if (f) return Ud(xo(f, 1), !1) } if (s == null && i < as(r)) { let u = r.childNodes[i]; for (; u.pmViewDesc && u.pmViewDesc.ignoreForCoords;)u = u.nextSibling; let f = u ? u.nodeType == 3 ? Da(u, 0, a ? 0 : 1) : u.nodeType == 1 ? u : null : null; if (f) return Ud(xo(f, -1), !0) } return Ud(xo(r.nodeType == 3 ? Da(r) : r, -n), n >= 0) } function Ud(t, e) { if (t.width == 0) return t; let n = e ? t.left : t.right; return { top: t.top, bottom: t.bottom, left: n, right: n } } function $x(t, e) { if (t.height == 0) return t; let n = e ? t.top : t.bottom; return { top: n, bottom: n, left: t.left, right: t.right } } function k5(t, e, n) { let r = t.state, i = t.root.activeElement; r != e && t.updateState(e), i != t.dom && t.focus(); try { return n() } finally { r != e && t.updateState(r), i != t.dom && i && i.focus() } } function HQ(t, e, n) { let r = e.selection, i = n == "up" ? r.$from : r.$to; return k5(t, e, () => { let { node: s } = t.docView.domFromPos(i.pos, n == "up" ? -1 : 1); for (; ;) { let l = t.docView.nearestDesc(s, !0); if (!l) break; if (l.node.isBlock) { s = l.contentDOM || l.dom; break } s = l.dom.parentNode } let a = A5(t, i.pos, 1); for (let l = s.firstChild; l; l = l.nextSibling) { let u; if (l.nodeType == 1) u = l.getClientRects(); else if (l.nodeType == 3) u = Da(l, 0, l.nodeValue.length).getClientRects(); else continue; for (let f = 0; f < u.length; f++) { let p = u[f]; if (p.bottom > p.top + 1 && (n == "up" ? a.top - p.top > (p.bottom - a.top) * 2 : p.bottom - a.bottom > (a.bottom - p.top) * 2)) return !1 } } return !0 }) } const qQ = /[\u0590-\u08ac]/; function KQ(t, e, n) { let { $head: r } = e.selection; if (!r.parent.isTextblock) return !1; let i = r.parentOffset, s = !i, a = i == r.parent.content.size, l = t.domSelection(); return l ? !qQ.test(r.parent.textContent) || !l.modify ? n == "left" || n == "backward" ? s : a : k5(t, e, () => { let { focusNode: u, focusOffset: f, anchorNode: p, anchorOffset: g } = t.domSelectionRange(), y = l.caretBidiLevel; l.modify("move", n, "character"); let v = r.depth ? t.docView.domAfterPos(r.before()) : t.dom, { focusNode: b, focusOffset: S } = t.domSelectionRange(), C = b && !v.contains(b.nodeType == 1 ? b : b.parentNode) || u == b && f == S; try { l.collapse(p, g), u && (u != p || f != g) && l.extend && l.extend(u, f) } catch { } return y != null && (l.caretBidiLevel = y), C }) : r.pos == r.start() || r.pos == r.end() } let zk = null, Ik = null, Fk = !1; function WQ(t, e, n) { return zk == e && Ik == n ? Fk : (zk = e, Ik = n, Fk = n == "up" || n == "down" ? HQ(t, e, n) : KQ(t, e, n)) } const cs = 0, Bk = 1, Rl = 2, ia = 3; class Sh {
    constructor(e, n, r, i) { this.parent = e, this.children = n, this.dom = r, this.contentDOM = i, this.dirty = cs, r.pmViewDesc = this } matchesWidget(e) { return !1 } matchesMark(e) { return !1 } matchesNode(e, n, r) { return !1 } matchesHack(e) { return !1 } parseRule() { return null } stopEvent(e) { return !1 } get size() { let e = 0; for (let n = 0; n < this.children.length; n++)e += this.children[n].size; return e } get border() { return 0 } destroy() { this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0); for (let e = 0; e < this.children.length; e++)this.children[e].destroy() } posBeforeChild(e) { for (let n = 0, r = this.posAtStart; ; n++) { let i = this.children[n]; if (i == e) return r; r += i.size } } get posBefore() { return this.parent.posBeforeChild(this) } get posAtStart() { return this.parent ? this.parent.posBeforeChild(this) + this.border : 0 } get posAfter() { return this.posBefore + this.size } get posAtEnd() { return this.posAtStart + this.size - 2 * this.border } localPosFromDOM(e, n, r) { if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode)) if (r < 0) { let s, a; if (e == this.contentDOM) s = e.childNodes[n - 1]; else { for (; e.parentNode != this.contentDOM;)e = e.parentNode; s = e.previousSibling } for (; s && !((a = s.pmViewDesc) && a.parent == this);)s = s.previousSibling; return s ? this.posBeforeChild(a) + a.size : this.posAtStart } else { let s, a; if (e == this.contentDOM) s = e.childNodes[n]; else { for (; e.parentNode != this.contentDOM;)e = e.parentNode; s = e.nextSibling } for (; s && !((a = s.pmViewDesc) && a.parent == this);)s = s.nextSibling; return s ? this.posBeforeChild(a) : this.posAtEnd } let i; if (e == this.dom && this.contentDOM) i = n > zr(this.contentDOM); else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) i = e.compareDocumentPosition(this.contentDOM) & 2; else if (this.dom.firstChild) { if (n == 0) for (let s = e; ; s = s.parentNode) { if (s == this.dom) { i = !1; break } if (s.previousSibling) break } if (i == null && n == e.childNodes.length) for (let s = e; ; s = s.parentNode) { if (s == this.dom) { i = !0; break } if (s.nextSibling) break } } return i ?? r > 0 ? this.posAtEnd : this.posAtStart } nearestDesc(e, n = !1) { for (let r = !0, i = e; i; i = i.parentNode) { let s = this.getDesc(i), a; if (s && (!n || s.node)) if (r && (a = s.nodeDOM) && !(a.nodeType == 1 ? a.contains(e.nodeType == 1 ? e : e.parentNode) : a == e)) r = !1; else return s } } getDesc(e) { let n = e.pmViewDesc; for (let r = n; r; r = r.parent)if (r == this) return n } posFromDOM(e, n, r) { for (let i = e; i; i = i.parentNode) { let s = this.getDesc(i); if (s) return s.localPosFromDOM(e, n, r) } return -1 } descAt(e) { for (let n = 0, r = 0; n < this.children.length; n++) { let i = this.children[n], s = r + i.size; if (r == e && s != r) { for (; !i.border && i.children.length;)for (let a = 0; a < i.children.length; a++) { let l = i.children[a]; if (l.size) { i = l; break } } return i } if (e < s) return i.descAt(e - r - i.border); r = s } } domFromPos(e, n) { if (!this.contentDOM) return { node: this.dom, offset: 0, atom: e + 1 }; let r = 0, i = 0; for (let s = 0; r < this.children.length; r++) { let a = this.children[r], l = s + a.size; if (l > e || a instanceof M5) { i = e - s; break } s = l } if (i) return this.children[r].domFromPos(i - this.children[r].border, n); for (let s; r && !(s = this.children[r - 1]).size && s instanceof O5 && s.side >= 0; r--); if (n <= 0) { let s, a = !0; for (; s = r ? this.children[r - 1] : null, !(!s || s.dom.parentNode == this.contentDOM); r--, a = !1); return s && n && a && !s.border && !s.domAtom ? s.domFromPos(s.size, n) : { node: this.contentDOM, offset: s ? zr(s.dom) + 1 : 0 } } else { let s, a = !0; for (; s = r < this.children.length ? this.children[r] : null, !(!s || s.dom.parentNode == this.contentDOM); r++, a = !1); return s && a && !s.border && !s.domAtom ? s.domFromPos(0, n) : { node: this.contentDOM, offset: s ? zr(s.dom) : this.contentDOM.childNodes.length } } } parseRange(e, n, r = 0) { if (this.children.length == 0) return { node: this.contentDOM, from: e, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length }; let i = -1, s = -1; for (let a = r, l = 0; ; l++) { let u = this.children[l], f = a + u.size; if (i == -1 && e <= f) { let p = a + u.border; if (e >= p && n <= f - u.border && u.node && u.contentDOM && this.contentDOM.contains(u.contentDOM)) return u.parseRange(e, n, p); e = a; for (let g = l; g > 0; g--) { let y = this.children[g - 1]; if (y.size && y.dom.parentNode == this.contentDOM && !y.emptyChildAt(1)) { i = zr(y.dom) + 1; break } e -= y.size } i == -1 && (i = 0) } if (i > -1 && (f > n || l == this.children.length - 1)) { n = f; for (let p = l + 1; p < this.children.length; p++) { let g = this.children[p]; if (g.size && g.dom.parentNode == this.contentDOM && !g.emptyChildAt(-1)) { s = zr(g.dom); break } n += g.size } s == -1 && (s = this.contentDOM.childNodes.length); break } a = f } return { node: this.contentDOM, from: e, to: n, fromOffset: i, toOffset: s } } emptyChildAt(e) { if (this.border || !this.contentDOM || !this.children.length) return !1; let n = this.children[e < 0 ? 0 : this.children.length - 1]; return n.size == 0 || n.emptyChildAt(e) } domAfterPos(e) { let { node: n, offset: r } = this.domFromPos(e, 0); if (n.nodeType != 1 || r == n.childNodes.length) throw new RangeError("No node after pos " + e); return n.childNodes[r] } setSelection(e, n, r, i = !1) {
      let s = Math.min(e, n), a = Math.max(e, n); for (let v = 0, b = 0; v < this.children.length; v++) { let S = this.children[v], C = b + S.size; if (s > b && a < C) return S.setSelection(e - b - S.border, n - b - S.border, r, i); b = C } let l = this.domFromPos(e, e ? -1 : 1), u = n == e ? l : this.domFromPos(n, n ? -1 : 1), f = r.root.getSelection(), p = r.domSelectionRange(), g = !1; if ((Es || ai) && e == n) {
        let { node: v, offset: b } = l; if (v.nodeType == 3) {
          if (g = !!(b && v.nodeValue[b - 1] == `
`), g && b == v.nodeValue.length) for (let S = v, C; S; S = S.parentNode) { if (C = S.nextSibling) { C.nodeName == "BR" && (l = u = { node: C.parentNode, offset: zr(C) + 1 }); break } let T = S.pmViewDesc; if (T && T.node && T.node.isBlock) break }
        } else { let S = v.childNodes[b - 1]; g = S && (S.nodeName == "BR" || S.contentEditable == "false") }
      } if (Es && p.focusNode && p.focusNode != u.node && p.focusNode.nodeType == 1) { let v = p.focusNode.childNodes[p.focusOffset]; v && v.contentEditable == "false" && (i = !0) } if (!(i || g && ai) && tc(l.node, l.offset, p.anchorNode, p.anchorOffset) && tc(u.node, u.offset, p.focusNode, p.focusOffset)) return; let y = !1; if ((f.extend || e == n) && !g) { f.collapse(l.node, l.offset); try { e != n && f.extend(u.node, u.offset), y = !0 } catch { } } if (!y) { if (e > n) { let b = l; l = u, u = b } let v = document.createRange(); v.setEnd(u.node, u.offset), v.setStart(l.node, l.offset), f.removeAllRanges(), f.addRange(v) }
    } ignoreMutation(e) { return !this.contentDOM && e.type != "selection" } get contentLost() { return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM) } markDirty(e, n) { for (let r = 0, i = 0; i < this.children.length; i++) { let s = this.children[i], a = r + s.size; if (r == a ? e <= a && n >= r : e < a && n > r) { let l = r + s.border, u = a - s.border; if (e >= l && n <= u) { this.dirty = e == r || n == a ? Rl : Bk, e == l && n == u && (s.contentLost || s.dom.parentNode != this.contentDOM) ? s.dirty = ia : s.markDirty(e - l, n - l); return } else s.dirty = s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length ? Rl : ia } r = a } this.dirty = Rl } markParentsDirty() { let e = 1; for (let n = this.parent; n; n = n.parent, e++) { let r = e == 1 ? Rl : Bk; n.dirty < r && (n.dirty = r) } } get domAtom() { return !1 } get ignoreForCoords() { return !1 } get ignoreForSelection() { return !1 } isText(e) { return !1 }
  } class O5 extends Sh { constructor(e, n, r, i) { let s, a = n.type.toDOM; if (typeof a == "function" && (a = a(r, () => { if (!s) return i; if (s.parent) return s.parent.posBeforeChild(s) })), !n.type.spec.raw) { if (a.nodeType != 1) { let l = document.createElement("span"); l.appendChild(a), a = l } a.contentEditable = "false", a.classList.add("ProseMirror-widget") } super(e, [], a, null), this.widget = n, this.widget = n, s = this } matchesWidget(e) { return this.dirty == cs && e.type.eq(this.widget.type) } parseRule() { return { ignore: !0 } } stopEvent(e) { let n = this.widget.spec.stopEvent; return n ? n(e) : !1 } ignoreMutation(e) { return e.type != "selection" || this.widget.spec.ignoreSelection } destroy() { this.widget.type.destroy(this.dom), super.destroy() } get domAtom() { return !0 } get ignoreForSelection() { return !!this.widget.type.spec.relaxedSide } get side() { return this.widget.type.side } } class YQ extends Sh { constructor(e, n, r, i) { super(e, [], n, null), this.textDOM = r, this.text = i } get size() { return this.text.length } localPosFromDOM(e, n) { return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n } domFromPos(e) { return { node: this.textDOM, offset: e } } ignoreMutation(e) { return e.type === "characterData" && e.target.nodeValue == e.oldValue } } class nc extends Sh { constructor(e, n, r, i, s) { super(e, [], r, i), this.mark = n, this.spec = s } static create(e, n, r, i) { let s = i.nodeViews[n.type.name], a = s && s(n, i, r); return (!a || !a.dom) && (a = hc.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)), new nc(e, n, a.dom, a.contentDOM || a.dom, a) } parseRule() { return this.dirty & ia || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM } } matchesMark(e) { return this.dirty != ia && this.mark.eq(e) } markDirty(e, n) { if (super.markDirty(e, n), this.dirty != cs) { let r = this.parent; for (; !r.node;)r = r.parent; r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = cs } } slice(e, n, r) { let i = nc.create(this.parent, this.mark, !0, r), s = this.children, a = this.size; n < a && (s = k1(s, n, a, r)), e > 0 && (s = k1(s, 0, e, r)); for (let l = 0; l < s.length; l++)s[l].parent = i; return i.children = s, i } ignoreMutation(e) { return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e) } destroy() { this.spec.destroy && this.spec.destroy(), super.destroy() } } class zo extends Sh { constructor(e, n, r, i, s, a, l, u, f) { super(e, [], s, a), this.node = n, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = l } static create(e, n, r, i, s, a) { let l = s.nodeViews[n.type.name], u, f = l && l(n, s, () => { if (!u) return a; if (u.parent) return u.parent.posBeforeChild(u) }, r, i), p = f && f.dom, g = f && f.contentDOM; if (n.isText) { if (!p) p = document.createTextNode(n.text); else if (p.nodeType != 3) throw new RangeError("Text must be rendered as a DOM text node") } else p || ({ dom: p, contentDOM: g } = hc.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs)); !g && !n.isText && p.nodeName != "BR" && (p.hasAttribute("contenteditable") || (p.contentEditable = "false"), n.type.spec.draggable && (p.draggable = !0)); let y = p; return p = _5(p, r, n), f ? u = new GQ(e, n, r, i, p, g || null, y, f, s, a + 1) : n.isText ? new Dy(e, n, r, i, p, y, s) : new zo(e, n, r, i, p, g || null, y, s, a + 1) } parseRule() { if (this.node.type.spec.reparseInView) return null; let e = { node: this.node.type.name, attrs: this.node.attrs }; if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM) e.getContent = () => this.node.content; else if (!this.contentLost) e.contentElement = this.contentDOM; else { for (let n = this.children.length - 1; n >= 0; n--) { let r = this.children[n]; if (this.dom.contains(r.dom.parentNode)) { e.contentElement = r.dom.parentNode; break } } e.contentElement || (e.getContent = () => Ue.empty) } return e } matchesNode(e, n, r) { return this.dirty == cs && e.eq(this.node) && dg(n, this.outerDeco) && r.eq(this.innerDeco) } get size() { return this.node.nodeSize } get border() { return this.node.isLeaf ? 0 : 1 } updateChildren(e, n) { let r = this.node.inlineContent, i = n, s = e.composing ? this.localCompositionInfo(e, n) : null, a = s && s.pos > -1 ? s : null, l = s && s.pos < 0, u = new QQ(this, a && a.node, e); eJ(this.node, this.innerDeco, (f, p, g) => { f.spec.marks ? u.syncToMarks(f.spec.marks, r, e) : f.type.side >= 0 && !g && u.syncToMarks(p == this.node.childCount ? Tn.none : this.node.child(p).marks, r, e), u.placeWidget(f, e, i) }, (f, p, g, y) => { u.syncToMarks(f.marks, r, e); let v; u.findNodeMatch(f, p, g, y) || l && e.state.selection.from > i && e.state.selection.to < i + f.nodeSize && (v = u.findIndexWithChild(s.node)) > -1 && u.updateNodeAt(f, p, g, v, e) || u.updateNextNode(f, p, g, e, y, i) || u.addNode(f, p, g, e, i), i += f.nodeSize }), u.syncToMarks([], r, e), this.node.isTextblock && u.addTextblockHacks(), u.destroyRest(), (u.changed || this.dirty == Rl) && (a && this.protectLocalComposition(e, a), D5(this.contentDOM, this.children, e), vu && tJ(this.dom)) } localCompositionInfo(e, n) { let { from: r, to: i } = e.state.selection; if (!(e.state.selection instanceof Et) || r < n || i > n + this.node.content.size) return null; let s = e.input.compositionNode; if (!s || !this.dom.contains(s.parentNode)) return null; if (this.node.inlineContent) { let a = s.nodeValue, l = nJ(this.node.content, a, r - n, i - n); return l < 0 ? null : { node: s, pos: l, text: a } } else return { node: s, pos: -1, text: "" } } protectLocalComposition(e, { node: n, pos: r, text: i }) { if (this.getDesc(n)) return; let s = n; for (; s.parentNode != this.contentDOM; s = s.parentNode) { for (; s.previousSibling;)s.parentNode.removeChild(s.previousSibling); for (; s.nextSibling;)s.parentNode.removeChild(s.nextSibling); s.pmViewDesc && (s.pmViewDesc = void 0) } let a = new YQ(this, s, n, i); e.input.compositionNodes.push(a), this.children = k1(this.children, r, r + i.length, e, a) } update(e, n, r, i) { return this.dirty == ia || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, r, i), !0) } updateInner(e, n, r, i) { this.updateOuterDeco(n), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = cs } updateOuterDeco(e) { if (dg(e, this.outerDeco)) return; let n = this.nodeDOM.nodeType != 1, r = this.dom; this.dom = R5(this.dom, this.nodeDOM, A1(this.outerDeco, this.node, n), A1(e, this.node, n)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e } selectNode() { this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0) } deselectNode() { this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable")) } get domAtom() { return this.node.isAtom } } function $k(t, e, n, r, i) { _5(r, e, t); let s = new zo(void 0, t, e, n, r, r, r, i, 0); return s.contentDOM && s.updateChildren(i, 0), s } class Dy extends zo { constructor(e, n, r, i, s, a, l) { super(e, n, r, i, s, null, a, l, 0) } parseRule() { let e = this.nodeDOM.parentNode; for (; e && e != this.dom && !e.pmIsDeco;)e = e.parentNode; return { skip: e || !0 } } update(e, n, r, i) { return this.dirty == ia || this.dirty != cs && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n), (this.dirty != cs || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = cs, !0) } inParent() { let e = this.parent.contentDOM; for (let n = this.nodeDOM; n; n = n.parentNode)if (n == e) return !0; return !1 } domFromPos(e) { return { node: this.nodeDOM, offset: e } } localPosFromDOM(e, n, r) { return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, r) } ignoreMutation(e) { return e.type != "characterData" && e.type != "selection" } slice(e, n, r) { let i = this.node.cut(e, n), s = document.createTextNode(i.text); return new Dy(this.parent, i, this.outerDeco, this.innerDeco, s, s, r) } markDirty(e, n) { super.markDirty(e, n), this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = ia) } get domAtom() { return !1 } isText(e) { return this.node.text == e } } class M5 extends Sh { parseRule() { return { ignore: !0 } } matchesHack(e) { return this.dirty == cs && this.dom.nodeName == e } get domAtom() { return !0 } get ignoreForCoords() { return this.dom.nodeName == "IMG" } } class GQ extends zo { constructor(e, n, r, i, s, a, l, u, f, p) { super(e, n, r, i, s, a, l, f, p), this.spec = u } update(e, n, r, i) { if (this.dirty == ia) return !1; if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) { let s = this.spec.update(e, n, r); return s && this.updateInner(e, n, r, i), s } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, r, i) } selectNode() { this.spec.selectNode ? this.spec.selectNode() : super.selectNode() } deselectNode() { this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode() } setSelection(e, n, r, i) { this.spec.setSelection ? this.spec.setSelection(e, n, r.root) : super.setSelection(e, n, r, i) } destroy() { this.spec.destroy && this.spec.destroy(), super.destroy() } stopEvent(e) { return this.spec.stopEvent ? this.spec.stopEvent(e) : !1 } ignoreMutation(e) { return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e) } } function D5(t, e, n) { let r = t.firstChild, i = !1; for (let s = 0; s < e.length; s++) { let a = e[s], l = a.dom; if (l.parentNode == t) { for (; l != r;)r = Uk(r), i = !0; r = r.nextSibling } else i = !0, t.insertBefore(l, r); if (a instanceof nc) { let u = r ? r.previousSibling : t.lastChild; D5(a.contentDOM, a.children, n), r = u ? u.nextSibling : t.firstChild } } for (; r;)r = Uk(r), i = !0; i && n.trackWrites == t && (n.trackWrites = null) } const mf = function (t) { t && (this.nodeName = t) }; mf.prototype = Object.create(null); const _l = [new mf]; function A1(t, e, n) { if (t.length == 0) return _l; let r = n ? _l[0] : new mf, i = [r]; for (let s = 0; s < t.length; s++) { let a = t[s].type.attrs; if (a) { a.nodeName && i.push(r = new mf(a.nodeName)); for (let l in a) { let u = a[l]; u != null && (n && i.length == 1 && i.push(r = new mf(e.isInline ? "span" : "div")), l == "class" ? r.class = (r.class ? r.class + " " : "") + u : l == "style" ? r.style = (r.style ? r.style + ";" : "") + u : l != "nodeName" && (r[l] = u)) } } } return i } function R5(t, e, n, r) { if (n == _l && r == _l) return e; let i = e; for (let s = 0; s < r.length; s++) { let a = r[s], l = n[s]; if (s) { let u; l && l.nodeName == a.nodeName && i != t && (u = i.parentNode) && u.nodeName.toLowerCase() == a.nodeName || (u = document.createElement(a.nodeName), u.pmIsDeco = !0, u.appendChild(i), l = _l[0]), i = u } XQ(i, l || _l[0], a) } return i } function XQ(t, e, n) { for (let r in e) r != "class" && r != "style" && r != "nodeName" && !(r in n) && t.removeAttribute(r); for (let r in n) r != "class" && r != "style" && r != "nodeName" && n[r] != e[r] && t.setAttribute(r, n[r]); if (e.class != n.class) { let r = e.class ? e.class.split(" ").filter(Boolean) : [], i = n.class ? n.class.split(" ").filter(Boolean) : []; for (let s = 0; s < r.length; s++)i.indexOf(r[s]) == -1 && t.classList.remove(r[s]); for (let s = 0; s < i.length; s++)r.indexOf(i[s]) == -1 && t.classList.add(i[s]); t.classList.length == 0 && t.removeAttribute("class") } if (e.style != n.style) { if (e.style) { let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i; for (; i = r.exec(e.style);)t.style.removeProperty(i[1]) } n.style && (t.style.cssText += n.style) } } function _5(t, e, n) { return R5(t, t, _l, A1(e, n, t.nodeType != 1)) } function dg(t, e) { if (t.length != e.length) return !1; for (let n = 0; n < t.length; n++)if (!t[n].type.eq(e[n].type)) return !1; return !0 } function Uk(t) { let e = t.nextSibling; return t.parentNode.removeChild(t), e } class QQ { constructor(e, n, r) { this.lock = n, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = JQ(e.node.content, e) } destroyBetween(e, n) { if (e != n) { for (let r = e; r < n; r++)this.top.children[r].destroy(); this.top.children.splice(e, n - e), this.changed = !0 } } destroyRest() { this.destroyBetween(this.index, this.top.children.length) } syncToMarks(e, n, r) { let i = 0, s = this.stack.length >> 1, a = Math.min(s, e.length); for (; i < a && (i == s - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1;)i++; for (; i < s;)this.destroyRest(), this.top.dirty = cs, this.index = this.stack.pop(), this.top = this.stack.pop(), s--; for (; s < e.length;) { this.stack.push(this.top, this.index + 1); let l = -1; for (let u = this.index; u < Math.min(this.index + 3, this.top.children.length); u++) { let f = this.top.children[u]; if (f.matchesMark(e[s]) && !this.isLocked(f.dom)) { l = u; break } } if (l > -1) l > this.index && (this.changed = !0, this.destroyBetween(this.index, l)), this.top = this.top.children[this.index]; else { let u = nc.create(this.top, e[s], n, r); this.top.children.splice(this.index, 0, u), this.top = u, this.changed = !0 } this.index = 0, s++ } } findNodeMatch(e, n, r, i) { let s = -1, a; if (i >= this.preMatch.index && (a = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && a.matchesNode(e, n, r)) s = this.top.children.indexOf(a, this.index); else for (let l = this.index, u = Math.min(this.top.children.length, l + 5); l < u; l++) { let f = this.top.children[l]; if (f.matchesNode(e, n, r) && !this.preMatch.matched.has(f)) { s = l; break } } return s < 0 ? !1 : (this.destroyBetween(this.index, s), this.index++, !0) } updateNodeAt(e, n, r, i, s) { let a = this.top.children[i]; return a.dirty == ia && a.dom == a.contentDOM && (a.dirty = Rl), a.update(e, n, r, s) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1 } findIndexWithChild(e) { for (; ;) { let n = e.parentNode; if (!n) return -1; if (n == this.top.contentDOM) { let r = e.pmViewDesc; if (r) { for (let i = this.index; i < this.top.children.length; i++)if (this.top.children[i] == r) return i } return -1 } e = n } } updateNextNode(e, n, r, i, s, a) { for (let l = this.index; l < this.top.children.length; l++) { let u = this.top.children[l]; if (u instanceof zo) { let f = this.preMatch.matched.get(u); if (f != null && f != s) return !1; let p = u.dom, g, y = this.isLocked(p) && !(e.isText && u.node && u.node.isText && u.nodeDOM.nodeValue == e.text && u.dirty != ia && dg(n, u.outerDeco)); if (!y && u.update(e, n, r, i)) return this.destroyBetween(this.index, l), u.dom != p && (this.changed = !0), this.index++, !0; if (!y && (g = this.recreateWrapper(u, e, n, r, i, a))) return this.destroyBetween(this.index, l), this.top.children[this.index] = g, g.contentDOM && (g.dirty = Rl, g.updateChildren(i, a + 1), g.dirty = cs), this.changed = !0, this.index++, !0; break } } return !1 } recreateWrapper(e, n, r, i, s, a) { if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content) || !dg(r, e.outerDeco) || !i.eq(e.innerDeco)) return null; let l = zo.create(this.top, n, r, i, s, a); if (l.contentDOM) { l.children = e.children, e.children = []; for (let u of l.children) u.parent = l } return e.destroy(), l } addNode(e, n, r, i, s) { let a = zo.create(this.top, e, n, r, i, s); a.contentDOM && a.updateChildren(i, s + 1), this.top.children.splice(this.index++, 0, a), this.changed = !0 } placeWidget(e, n, r) { let i = this.index < this.top.children.length ? this.top.children[this.index] : null; if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode)) this.index++; else { let s = new O5(this.top, e, n, r); this.top.children.splice(this.index++, 0, s), this.changed = !0 } } addTextblockHacks() { let e = this.top.children[this.index - 1], n = this.top; for (; e instanceof nc;)n = e, e = n.children[n.children.length - 1]; (!e || !(e instanceof Dy) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((ai || Gr) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top)) } addHackNode(e, n) { if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e)) this.index++; else { let r = document.createElement(e); e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak"); let i = new M5(this.top, [], r, null); n != this.top ? n.children.push(i) : n.children.splice(this.index++, 0, i), this.changed = !0 } } isLocked(e) { return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode)) } } function JQ(t, e) { let n = e, r = n.children.length, i = t.childCount, s = new Map, a = []; e: for (; i > 0;) { let l; for (; ;)if (r) { let f = n.children[r - 1]; if (f instanceof nc) n = f, r = f.children.length; else { l = f, r--; break } } else { if (n == e) break e; r = n.parent.children.indexOf(n), n = n.parent } let u = l.node; if (u) { if (u != t.child(i - 1)) break; --i, s.set(l, i), a.push(l) } } return { index: i, matched: s, matches: a.reverse() } } function ZQ(t, e) { return t.type.side - e.type.side } function eJ(t, e, n, r) { let i = e.locals(t), s = 0; if (i.length == 0) { for (let f = 0; f < t.childCount; f++) { let p = t.child(f); r(p, i, e.forChild(s, p), f), s += p.nodeSize } return } let a = 0, l = [], u = null; for (let f = 0; ;) { let p, g; for (; a < i.length && i[a].to == s;) { let C = i[a++]; C.widget && (p ? (g || (g = [p])).push(C) : p = C) } if (p) if (g) { g.sort(ZQ); for (let C = 0; C < g.length; C++)n(g[C], f, !!u) } else n(p, f, !!u); let y, v; if (u) v = -1, y = u, u = null; else if (f < t.childCount) v = f, y = t.child(f++); else break; for (let C = 0; C < l.length; C++)l[C].to <= s && l.splice(C--, 1); for (; a < i.length && i[a].from <= s && i[a].to > s;)l.push(i[a++]); let b = s + y.nodeSize; if (y.isText) { let C = b; a < i.length && i[a].from < C && (C = i[a].from); for (let T = 0; T < l.length; T++)l[T].to < C && (C = l[T].to); C < b && (u = y.cut(C - s), y = y.cut(0, C - s), b = C, v = -1) } else for (; a < i.length && i[a].to < b;)a++; let S = y.isInline && !y.isLeaf ? l.filter(C => !C.inline) : l.slice(); r(y, S, e.forChild(s, y), v), s = b } } function tJ(t) { if (t.nodeName == "UL" || t.nodeName == "OL") { let e = t.style.cssText; t.style.cssText = e + "; list-style: square !important", window.getComputedStyle(t).listStyle, t.style.cssText = e } } function nJ(t, e, n, r) { for (let i = 0, s = 0; i < t.childCount && s <= r;) { let a = t.child(i++), l = s; if (s += a.nodeSize, !a.isText) continue; let u = a.text; for (; i < t.childCount;) { let f = t.child(i++); if (s += f.nodeSize, !f.isText) break; u += f.text } if (s >= n) { if (s >= r && u.slice(r - e.length - l, r - l) == e) return r - e.length; let f = l < r ? u.lastIndexOf(e, r - l - 1) : -1; if (f >= 0 && f + e.length + l >= n) return l + f; if (n == r && u.length >= r + e.length - l && u.slice(r - l, r - l + e.length) == e) return r } } return -1 } function k1(t, e, n, r, i) { let s = []; for (let a = 0, l = 0; a < t.length; a++) { let u = t[a], f = l, p = l += u.size; f >= n || p <= e ? s.push(u) : (f < e && s.push(u.slice(0, e - f, r)), i && (s.push(i), i = void 0), p > n && s.push(u.slice(n - f, u.size, r))) } return s } function BS(t, e = null) { let n = t.domSelectionRange(), r = t.state.doc; if (!n.focusNode) return null; let i = t.docView.nearestDesc(n.focusNode), s = i && i.size == 0, a = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1); if (a < 0) return null; let l = r.resolve(a), u, f; if (My(n)) { for (u = a; i && !i.node;)i = i.parent; let g = i.node; if (i && g.isAtom && Ct.isSelectable(g) && i.parent && !(g.isInline && AQ(n.focusNode, n.focusOffset, i.dom))) { let y = i.posBefore; f = new Ct(a == y ? l : r.resolve(y)) } } else { if (n instanceof t.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) { let g = a, y = a; for (let v = 0; v < n.rangeCount; v++) { let b = n.getRangeAt(v); g = Math.min(g, t.docView.posFromDOM(b.startContainer, b.startOffset, 1)), y = Math.max(y, t.docView.posFromDOM(b.endContainer, b.endOffset, -1)) } if (g < 0) return null;[u, a] = y == t.state.selection.anchor ? [y, g] : [g, y], l = r.resolve(a) } else u = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1); if (u < 0) return null } let p = r.resolve(u); if (!f) { let g = e == "pointer" || t.state.selection.head < l.pos && !s ? 1 : -1; f = $S(t, p, l, g) } return f } function L5(t) { return t.editable ? t.hasFocus() : z5(t) && document.activeElement && document.activeElement.contains(t.dom) } function Fa(t, e = !1) { let n = t.state.selection; if (P5(t, n), !!L5(t)) { if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && Gr) { let r = t.domSelectionRange(), i = t.domObserver.currentSelection; if (r.anchorNode && i.anchorNode && tc(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) { t.input.mouseDown.delayedSelectionSync = !0, t.domObserver.setCurSelection(); return } } if (t.domObserver.disconnectSelection(), t.cursorWrapper) iJ(t); else { let { anchor: r, head: i } = n, s, a; Vk && !(n instanceof Et) && (n.$from.parent.inlineContent || (s = Hk(t, n.from)), !n.empty && !n.$from.parent.inlineContent && (a = Hk(t, n.to))), t.docView.setSelection(r, i, t, e), Vk && (s && qk(s), a && qk(a)), n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && rJ(t)) } t.domObserver.setCurSelection(), t.domObserver.connectSelection() } } const Vk = ai || Gr && C5 < 63; function Hk(t, e) { let { node: n, offset: r } = t.docView.domFromPos(e, 0), i = r < n.childNodes.length ? n.childNodes[r] : null, s = r ? n.childNodes[r - 1] : null; if (ai && i && i.contentEditable == "false") return Ux(i); if ((!i || i.contentEditable == "false") && (!s || s.contentEditable == "false")) { if (i) return Ux(i); if (s) return Ux(s) } } function Ux(t) { return t.contentEditable = "true", ai && t.draggable && (t.draggable = !1, t.wasDraggable = !0), t } function qk(t) { t.contentEditable = "false", t.wasDraggable && (t.draggable = !0, t.wasDraggable = null) } function rJ(t) { let e = t.dom.ownerDocument; e.removeEventListener("selectionchange", t.input.hideSelectionGuard); let n = t.domSelectionRange(), r = n.anchorNode, i = n.anchorOffset; e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => { (n.anchorNode != r || n.anchorOffset != i) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard), setTimeout(() => { (!L5(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection") }, 20)) }) } function iJ(t) { let e = t.domSelection(), n = document.createRange(); if (!e) return; let r = t.cursorWrapper.dom, i = r.nodeName == "IMG"; i ? n.setStart(r.parentNode, zr(r) + 1) : n.setStart(r, 0), n.collapse(!0), e.removeAllRanges(), e.addRange(n), !i && !t.state.selection.visible && wi && Po <= 11 && (r.disabled = !0, r.disabled = !1) } function P5(t, e) { if (e instanceof Ct) { let n = t.docView.descAt(e.from); n != t.lastSelectedViewDesc && (Kk(t), n && n.selectNode(), t.lastSelectedViewDesc = n) } else Kk(t) } function Kk(t) { t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(), t.lastSelectedViewDesc = void 0) } function $S(t, e, n, r) { return t.someProp("createSelectionBetween", i => i(t, e, n)) || Et.between(e, n, r) } function Wk(t) { return t.editable && !t.hasFocus() ? !1 : z5(t) } function z5(t) { let e = t.domSelectionRange(); if (!e.anchorNode) return !1; try { return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode)) } catch { return !1 } } function sJ(t) { let e = t.docView.domFromPos(t.state.selection.anchor, 0), n = t.domSelectionRange(); return tc(e.node, e.offset, n.anchorNode, n.anchorOffset) } function O1(t, e) { let { $anchor: n, $head: r } = t.selection, i = e > 0 ? n.max(r) : n.min(r), s = i.parent.inlineContent ? i.depth ? t.doc.resolve(e > 0 ? i.after() : i.before()) : null : i; return s && Ot.findFrom(s, e) } function bo(t, e) { return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0 } function Yk(t, e, n) { let r = t.state.selection; if (r instanceof Et) if (n.indexOf("s") > -1) { let { $head: i } = r, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter; if (!s || s.isText || !s.isLeaf) return !1; let a = t.state.doc.resolve(i.pos + s.nodeSize * (e < 0 ? -1 : 1)); return bo(t, new Et(r.$anchor, a)) } else if (r.empty) { if (t.endOfTextblock(e > 0 ? "forward" : "backward")) { let i = O1(t.state, e); return i && i instanceof Ct ? bo(t, i) : !1 } else if (!(ss && n.indexOf("m") > -1)) { let i = r.$head, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, a; if (!s || s.isText) return !1; let l = e < 0 ? i.pos - s.nodeSize : i.pos; return s.isAtom || (a = t.docView.descAt(l)) && !a.contentDOM ? Ct.isSelectable(s) ? bo(t, new Ct(e < 0 ? t.state.doc.resolve(i.pos - s.nodeSize) : i)) : wh ? bo(t, new Et(t.state.doc.resolve(e < 0 ? l : l + s.nodeSize))) : !1 : !1 } } else return !1; else { if (r instanceof Ct && r.node.isInline) return bo(t, new Et(e > 0 ? r.$to : r.$from)); { let i = O1(t.state, e); return i ? bo(t, i) : !1 } } } function fg(t) { return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length } function gf(t, e) { let n = t.pmViewDesc; return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR") } function Kc(t, e) { return e < 0 ? aJ(t) : oJ(t) } function aJ(t) { let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset; if (!n) return; let i, s, a = !1; for (Es && n.nodeType == 1 && r < fg(n) && gf(n.childNodes[r], -1) && (a = !0); ;)if (r > 0) { if (n.nodeType != 1) break; { let l = n.childNodes[r - 1]; if (gf(l, -1)) i = n, s = --r; else if (l.nodeType == 3) n = l, r = n.nodeValue.length; else break } } else { if (I5(n)) break; { let l = n.previousSibling; for (; l && gf(l, -1);)i = n.parentNode, s = zr(l), l = l.previousSibling; if (l) n = l, r = fg(n); else { if (n = n.parentNode, n == t.dom) break; r = 0 } } } a ? M1(t, n, r) : i && M1(t, i, s) } function oJ(t) { let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset; if (!n) return; let i = fg(n), s, a; for (; ;)if (r < i) { if (n.nodeType != 1) break; let l = n.childNodes[r]; if (gf(l, 1)) s = n, a = ++r; else break } else { if (I5(n)) break; { let l = n.nextSibling; for (; l && gf(l, 1);)s = l.parentNode, a = zr(l) + 1, l = l.nextSibling; if (l) n = l, r = 0, i = fg(n); else { if (n = n.parentNode, n == t.dom) break; r = i = 0 } } } s && M1(t, s, a) } function I5(t) { let e = t.pmViewDesc; return e && e.node && e.node.isBlock } function lJ(t, e) { for (; t && e == t.childNodes.length && !bh(t);)e = zr(t) + 1, t = t.parentNode; for (; t && e < t.childNodes.length;) { let n = t.childNodes[e]; if (n.nodeType == 3) return n; if (n.nodeType == 1 && n.contentEditable == "false") break; t = n, e = 0 } } function cJ(t, e) { for (; t && !e && !bh(t);)e = zr(t), t = t.parentNode; for (; t && e;) { let n = t.childNodes[e - 1]; if (n.nodeType == 3) return n; if (n.nodeType == 1 && n.contentEditable == "false") break; t = n, e = t.childNodes.length } } function M1(t, e, n) { if (e.nodeType != 3) { let s, a; (a = lJ(e, n)) ? (e = a, n = 0) : (s = cJ(e, n)) && (e = s, n = s.nodeValue.length) } let r = t.domSelection(); if (!r) return; if (My(r)) { let s = document.createRange(); s.setEnd(e, n), s.setStart(e, n), r.removeAllRanges(), r.addRange(s) } else r.extend && r.extend(e, n); t.domObserver.setCurSelection(); let { state: i } = t; setTimeout(() => { t.state == i && Fa(t) }, 50) } function Gk(t, e) { let n = t.state.doc.resolve(e); if (!(Gr || MQ) && n.parent.inlineContent) { let i = t.coordsAtPos(e); if (e > n.start()) { let s = t.coordsAtPos(e - 1), a = (s.top + s.bottom) / 2; if (a > i.top && a < i.bottom && Math.abs(s.left - i.left) > 1) return s.left < i.left ? "ltr" : "rtl" } if (e < n.end()) { let s = t.coordsAtPos(e + 1), a = (s.top + s.bottom) / 2; if (a > i.top && a < i.bottom && Math.abs(s.left - i.left) > 1) return s.left > i.left ? "ltr" : "rtl" } } return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr" } function Xk(t, e, n) { let r = t.state.selection; if (r instanceof Et && !r.empty || n.indexOf("s") > -1 || ss && n.indexOf("m") > -1) return !1; let { $from: i, $to: s } = r; if (!i.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) { let a = O1(t.state, e); if (a && a instanceof Ct) return bo(t, a) } if (!i.parent.inlineContent) { let a = e < 0 ? i : s, l = r instanceof $i ? Ot.near(a, e) : Ot.findFrom(a, e); return l ? bo(t, l) : !1 } return !1 } function Qk(t, e) { if (!(t.state.selection instanceof Et)) return !0; let { $head: n, $anchor: r, empty: i } = t.state.selection; if (!n.sameParent(r)) return !0; if (!i) return !1; if (t.endOfTextblock(e > 0 ? "forward" : "backward")) return !0; let s = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter); if (s && !s.isText) { let a = t.state.tr; return e < 0 ? a.delete(n.pos - s.nodeSize, n.pos) : a.delete(n.pos, n.pos + s.nodeSize), t.dispatch(a), !0 } return !1 } function Jk(t, e, n) { t.domObserver.stop(), e.contentEditable = n, t.domObserver.start() } function uJ(t) { if (!ai || t.state.selection.$head.parentOffset > 0) return !1; let { focusNode: e, focusOffset: n } = t.domSelectionRange(); if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") { let r = e.firstChild; Jk(t, r, "true"), setTimeout(() => Jk(t, r, "false"), 20) } return !1 } function dJ(t) { let e = ""; return t.ctrlKey && (e += "c"), t.metaKey && (e += "m"), t.altKey && (e += "a"), t.shiftKey && (e += "s"), e } function fJ(t, e) { let n = e.keyCode, r = dJ(e); if (n == 8 || ss && n == 72 && r == "c") return Qk(t, -1) || Kc(t, -1); if (n == 46 && !e.shiftKey || ss && n == 68 && r == "c") return Qk(t, 1) || Kc(t, 1); if (n == 13 || n == 27) return !0; if (n == 37 || ss && n == 66 && r == "c") { let i = n == 37 ? Gk(t, t.state.selection.from) == "ltr" ? -1 : 1 : -1; return Yk(t, i, r) || Kc(t, i) } else if (n == 39 || ss && n == 70 && r == "c") { let i = n == 39 ? Gk(t, t.state.selection.from) == "ltr" ? 1 : -1 : 1; return Yk(t, i, r) || Kc(t, i) } else { if (n == 38 || ss && n == 80 && r == "c") return Xk(t, -1, r) || Kc(t, -1); if (n == 40 || ss && n == 78 && r == "c") return uJ(t) || Xk(t, 1, r) || Kc(t, 1); if (r == (ss ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90)) return !0 } return !1 } function US(t, e) {
    t.someProp("transformCopied", v => { e = v(e, t) }); let n = [], { content: r, openStart: i, openEnd: s } = e; for (; i > 1 && s > 1 && r.childCount == 1 && r.firstChild.childCount == 1;) { i--, s--; let v = r.firstChild; n.push(v.type.name, v.attrs != v.type.defaultAttrs ? v.attrs : null), r = v.content } let a = t.someProp("clipboardSerializer") || hc.fromSchema(t.state.schema), l = H5(), u = l.createElement("div"); u.appendChild(a.serializeFragment(r, { document: l })); let f = u.firstChild, p, g = 0; for (; f && f.nodeType == 1 && (p = V5[f.nodeName.toLowerCase()]);) { for (let v = p.length - 1; v >= 0; v--) { let b = l.createElement(p[v]); for (; u.firstChild;)b.appendChild(u.firstChild); u.appendChild(b), g++ } f = u.firstChild } f && f.nodeType == 1 && f.setAttribute("data-pm-slice", `${i} ${s}${g ? ` -${g}` : ""} ${JSON.stringify(n)}`); let y = t.someProp("clipboardTextSerializer", v => v(e, t)) || e.content.textBetween(0, e.content.size, `

`); return { dom: u, text: y, slice: e }
  } function F5(t, e, n, r, i) {
    let s = i.parent.type.spec.code, a, l; if (!n && !e) return null; let u = e && (r || s || !n); if (u) {
      if (t.someProp("transformPastedText", y => { e = y(e, s || r, t) }), s) return e ? new nt(Ue.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : nt.empty; let g = t.someProp("clipboardTextParser", y => y(e, i, r, t)); if (g) l = g; else { let y = i.marks(), { schema: v } = t.state, b = hc.fromSchema(v); a = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach(S => { let C = a.appendChild(document.createElement("p")); S && C.appendChild(b.serializeNode(v.text(S, y))) }) }
    } else t.someProp("transformPastedHTML", g => { n = g(n, t) }), a = gJ(n), wh && yJ(a); let f = a && a.querySelector("[data-pm-slice]"), p = f && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(f.getAttribute("data-pm-slice") || ""); if (p && p[3]) for (let g = +p[3]; g > 0; g--) { let y = a.firstChild; for (; y && y.nodeType != 1;)y = y.nextSibling; if (!y) break; a = y } if (l || (l = (t.someProp("clipboardParser") || t.someProp("domParser") || hf.fromSchema(t.state.schema)).parseSlice(a, { preserveWhitespace: !!(u || p), context: i, ruleFromNode(y) { return y.nodeName == "BR" && !y.nextSibling && y.parentNode && !hJ.test(y.parentNode.nodeName) ? { ignore: !0 } : null } })), p) l = vJ(Zk(l, +p[1], +p[2]), p[4]); else if (l = nt.maxOpen(pJ(l.content, i), !0), l.openStart || l.openEnd) { let g = 0, y = 0; for (let v = l.content.firstChild; g < l.openStart && !v.type.spec.isolating; g++, v = v.firstChild); for (let v = l.content.lastChild; y < l.openEnd && !v.type.spec.isolating; y++, v = v.lastChild); l = Zk(l, g, y) } return t.someProp("transformPasted", g => { l = g(l, t) }), l
  } const hJ = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i; function pJ(t, e) { if (t.childCount < 2) return t; for (let n = e.depth; n >= 0; n--) { let i = e.node(n).contentMatchAt(e.index(n)), s, a = []; if (t.forEach(l => { if (!a) return; let u = i.findWrapping(l.type), f; if (!u) return a = null; if (f = a.length && s.length && $5(u, s, l, a[a.length - 1], 0)) a[a.length - 1] = f; else { a.length && (a[a.length - 1] = U5(a[a.length - 1], s.length)); let p = B5(l, u); a.push(p), i = i.matchType(p.type), s = u } }), a) return Ue.from(a) } return t } function B5(t, e, n = 0) { for (let r = e.length - 1; r >= n; r--)t = e[r].create(null, Ue.from(t)); return t } function $5(t, e, n, r, i) { if (i < t.length && i < e.length && t[i] == e[i]) { let s = $5(t, e, n, r.lastChild, i + 1); if (s) return r.copy(r.content.replaceChild(r.childCount - 1, s)); if (r.contentMatchAt(r.childCount).matchType(i == t.length - 1 ? n.type : t[i + 1])) return r.copy(r.content.append(Ue.from(B5(n, t, i + 1)))) } } function U5(t, e) { if (e == 0) return t; let n = t.content.replaceChild(t.childCount - 1, U5(t.lastChild, e - 1)), r = t.contentMatchAt(t.childCount).fillBefore(Ue.empty, !0); return t.copy(n.append(r)) } function D1(t, e, n, r, i, s) { let a = e < 0 ? t.firstChild : t.lastChild, l = a.content; return t.childCount > 1 && (s = 0), i < r - 1 && (l = D1(l, e, n, r, i + 1, s)), i >= n && (l = e < 0 ? a.contentMatchAt(0).fillBefore(l, s <= i).append(l) : l.append(a.contentMatchAt(a.childCount).fillBefore(Ue.empty, !0))), t.replaceChild(e < 0 ? 0 : t.childCount - 1, a.copy(l)) } function Zk(t, e, n) { return e < t.openStart && (t = new nt(D1(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)), n < t.openEnd && (t = new nt(D1(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)), t } const V5 = { thead: ["table"], tbody: ["table"], tfoot: ["table"], caption: ["table"], colgroup: ["table"], col: ["table", "colgroup"], tr: ["table", "tbody"], td: ["table", "tbody", "tr"], th: ["table", "tbody", "tr"] }; let e4 = null; function H5() { return e4 || (e4 = document.implementation.createHTMLDocument("title")) } let Vx = null; function mJ(t) { let e = window.trustedTypes; return e ? (Vx || (Vx = e.defaultPolicy || e.createPolicy("ProseMirrorClipboard", { createHTML: n => n })), Vx.createHTML(t)) : t } function gJ(t) { let e = /^(\s*<meta [^>]*>)*/.exec(t); e && (t = t.slice(e[0].length)); let n = H5().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(t), i; if ((i = r && V5[r[1].toLowerCase()]) && (t = i.map(s => "<" + s + ">").join("") + t + i.map(s => "</" + s + ">").reverse().join("")), n.innerHTML = mJ(t), i) for (let s = 0; s < i.length; s++)n = n.querySelector(i[s]) || n; return n } function yJ(t) { let e = t.querySelectorAll(Gr ? "span:not([class]):not([style])" : "span.Apple-converted-space"); for (let n = 0; n < e.length; n++) { let r = e[n]; r.childNodes.length == 1 && r.textContent == "" && r.parentNode && r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r) } } function vJ(t, e) { if (!t.size) return t; let n = t.content.firstChild.type.schema, r; try { r = JSON.parse(e) } catch { return t } let { content: i, openStart: s, openEnd: a } = t; for (let l = r.length - 2; l >= 0; l -= 2) { let u = n.nodes[r[l]]; if (!u || u.hasRequiredAttrs()) break; i = Ue.from(u.create(r[l + 1], i)), s++, a++ } return new nt(i, s, a) } const oi = {}, li = {}, xJ = { touchstart: !0, touchmove: !0 }; class bJ { constructor() { this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = Object.create(null), this.hideSelectionGuard = null } } function wJ(t) { for (let e in oi) { let n = oi[e]; t.dom.addEventListener(e, t.input.eventHandlers[e] = r => { CJ(t, r) && !VS(t, r) && (t.editable || !(r.type in li)) && n(t, r) }, xJ[e] ? { passive: !0 } : void 0) } ai && t.dom.addEventListener("input", () => null), R1(t) } function Do(t, e) { t.input.lastSelectionOrigin = e, t.input.lastSelectionTime = Date.now() } function SJ(t) { t.domObserver.stop(); for (let e in t.input.eventHandlers) t.dom.removeEventListener(e, t.input.eventHandlers[e]); clearTimeout(t.input.composingTimeout), clearTimeout(t.input.lastIOSEnterFallbackTimeout) } function R1(t) { t.someProp("handleDOMEvents", e => { for (let n in e) t.input.eventHandlers[n] || t.dom.addEventListener(n, t.input.eventHandlers[n] = r => VS(t, r)) }) } function VS(t, e) { return t.someProp("handleDOMEvents", n => { let r = n[e.type]; return r ? r(t, e) || e.defaultPrevented : !1 }) } function CJ(t, e) { if (!e.bubbles) return !0; if (e.defaultPrevented) return !1; for (let n = e.target; n != t.dom; n = n.parentNode)if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e)) return !1; return !0 } function TJ(t, e) { !VS(t, e) && oi[e.type] && (t.editable || !(e.type in li)) && oi[e.type](t, e) } li.keydown = (t, e) => { let n = e; if (t.input.shiftKey = n.keyCode == 16 || n.shiftKey, !K5(t, n) && (t.input.lastKeyCode = n.keyCode, t.input.lastKeyCodeTime = Date.now(), !(_a && Gr && n.keyCode == 13))) if (n.keyCode != 229 && t.domObserver.forceFlush(), vu && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) { let r = Date.now(); t.input.lastIOSEnter = r, t.input.lastIOSEnterFallbackTimeout = setTimeout(() => { t.input.lastIOSEnter == r && (t.someProp("handleKeyDown", i => i(t, Nl(13, "Enter"))), t.input.lastIOSEnter = 0) }, 200) } else t.someProp("handleKeyDown", r => r(t, n)) || fJ(t, n) ? n.preventDefault() : Do(t, "key") }; li.keyup = (t, e) => { e.keyCode == 16 && (t.input.shiftKey = !1) }; li.keypress = (t, e) => { let n = e; if (K5(t, n) || !n.charCode || n.ctrlKey && !n.altKey || ss && n.metaKey) return; if (t.someProp("handleKeyPress", i => i(t, n))) { n.preventDefault(); return } let r = t.state.selection; if (!(r instanceof Et) || !r.$from.sameParent(r.$to)) { let i = String.fromCharCode(n.charCode), s = () => t.state.tr.insertText(i).scrollIntoView(); !/[\r\n]/.test(i) && !t.someProp("handleTextInput", a => a(t, r.$from.pos, r.$to.pos, i, s)) && t.dispatch(s()), n.preventDefault() } }; function Ry(t) { return { left: t.clientX, top: t.clientY } } function NJ(t, e) { let n = e.x - t.clientX, r = e.y - t.clientY; return n * n + r * r < 100 } function HS(t, e, n, r, i) { if (r == -1) return !1; let s = t.state.doc.resolve(r); for (let a = s.depth + 1; a > 0; a--)if (t.someProp(e, l => a > s.depth ? l(t, n, s.nodeAfter, s.before(a), i, !0) : l(t, n, s.node(a), s.before(a), i, !1))) return !0; return !1 } function du(t, e, n) { if (t.focused || t.focus(), t.state.selection.eq(e)) return; let r = t.state.tr.setSelection(e); r.setMeta("pointer", !0), t.dispatch(r) } function jJ(t, e) { if (e == -1) return !1; let n = t.state.doc.resolve(e), r = n.nodeAfter; return r && r.isAtom && Ct.isSelectable(r) ? (du(t, new Ct(n)), !0) : !1 } function EJ(t, e) { if (e == -1) return !1; let n = t.state.selection, r, i; n instanceof Ct && (r = n.node); let s = t.state.doc.resolve(e); for (let a = s.depth + 1; a > 0; a--) { let l = a > s.depth ? s.nodeAfter : s.node(a); if (Ct.isSelectable(l)) { r && n.$from.depth > 0 && a >= n.$from.depth && s.before(n.$from.depth + 1) == n.$from.pos ? i = s.before(n.$from.depth) : i = s.before(a); break } } return i != null ? (du(t, Ct.create(t.state.doc, i)), !0) : !1 } function AJ(t, e, n, r, i) { return HS(t, "handleClickOn", e, n, r) || t.someProp("handleClick", s => s(t, e, r)) || (i ? EJ(t, n) : jJ(t, n)) } function kJ(t, e, n, r) { return HS(t, "handleDoubleClickOn", e, n, r) || t.someProp("handleDoubleClick", i => i(t, e, r)) } function OJ(t, e, n, r) { return HS(t, "handleTripleClickOn", e, n, r) || t.someProp("handleTripleClick", i => i(t, e, r)) || MJ(t, n, r) } function MJ(t, e, n) { if (n.button != 0) return !1; let r = t.state.doc; if (e == -1) return r.inlineContent ? (du(t, Et.create(r, 0, r.content.size)), !0) : !1; let i = r.resolve(e); for (let s = i.depth + 1; s > 0; s--) { let a = s > i.depth ? i.nodeAfter : i.node(s), l = i.before(s); if (a.inlineContent) du(t, Et.create(r, l + 1, l + 1 + a.content.size)); else if (Ct.isSelectable(a)) du(t, Ct.create(r, l)); else continue; return !0 } } function qS(t) { return hg(t) } const q5 = ss ? "metaKey" : "ctrlKey"; oi.mousedown = (t, e) => { let n = e; t.input.shiftKey = n.shiftKey; let r = qS(t), i = Date.now(), s = "singleClick"; i - t.input.lastClick.time < 500 && NJ(n, t.input.lastClick) && !n[q5] && t.input.lastClick.button == n.button && (t.input.lastClick.type == "singleClick" ? s = "doubleClick" : t.input.lastClick.type == "doubleClick" && (s = "tripleClick")), t.input.lastClick = { time: i, x: n.clientX, y: n.clientY, type: s, button: n.button }; let a = t.posAtCoords(Ry(n)); a && (s == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(), t.input.mouseDown = new DJ(t, a, n, !!r)) : (s == "doubleClick" ? kJ : OJ)(t, a.pos, a.inside, n) ? n.preventDefault() : Do(t, "pointer")) }; class DJ { constructor(e, n, r, i) { this.view = e, this.pos = n, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[q5], this.allowDefault = r.shiftKey; let s, a; if (n.inside > -1) s = e.state.doc.nodeAt(n.inside), a = n.inside; else { let p = e.state.doc.resolve(n.pos); s = p.parent, a = p.depth ? p.before() : 0 } const l = i ? null : r.target, u = l ? e.docView.nearestDesc(l, !0) : null; this.target = u && u.dom.nodeType == 1 ? u.dom : null; let { selection: f } = e.state; (r.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1 || f instanceof Ct && f.from <= a && f.to > a) && (this.mightDrag = { node: s, pos: a, addAttr: !!(this.target && !this.target.draggable), setUneditable: !!(this.target && Es && !this.target.hasAttribute("contentEditable")) }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => { this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false") }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), Do(e, "pointer") } done() { this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Fa(this.view)), this.view.input.mouseDown = null } up(e) { if (this.done(), !this.view.dom.contains(e.target)) return; let n = this.pos; this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(Ry(e))), this.updateAllowDefault(e), this.allowDefault || !n ? Do(this.view, "pointer") : AJ(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || ai && this.mightDrag && !this.mightDrag.node.isAtom || Gr && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (du(this.view, Ot.near(this.view.state.doc.resolve(n.pos))), e.preventDefault()) : Do(this.view, "pointer") } move(e) { this.updateAllowDefault(e), Do(this.view, "pointer"), e.buttons == 0 && this.done() } updateAllowDefault(e) { !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0) } } oi.touchstart = t => { t.input.lastTouch = Date.now(), qS(t), Do(t, "pointer") }; oi.touchmove = t => { t.input.lastTouch = Date.now(), Do(t, "pointer") }; oi.contextmenu = t => qS(t); function K5(t, e) { return t.composing ? !0 : ai && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8, !0) : !1 } const RJ = _a ? 5e3 : -1; li.compositionstart = li.compositionupdate = t => { if (!t.composing) { t.domObserver.flush(); let { state: e } = t, n = e.selection.$to; if (e.selection instanceof Et && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some(r => r.type.spec.inclusive === !1))) t.markCursor = t.state.storedMarks || n.marks(), hg(t, !0), t.markCursor = null; else if (hg(t, !e.selection.empty), Es && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) { let r = t.domSelectionRange(); for (let i = r.focusNode, s = r.focusOffset; i && i.nodeType == 1 && s != 0;) { let a = s < 0 ? i.lastChild : i.childNodes[s - 1]; if (!a) break; if (a.nodeType == 3) { let l = t.domSelection(); l && l.collapse(a, a.nodeValue.length); break } else i = a, s = -1 } } t.input.composing = !0 } W5(t, RJ) }; li.compositionend = (t, e) => { t.composing && (t.input.composing = !1, t.input.compositionEndedAt = e.timeStamp, t.input.compositionPendingChanges = t.domObserver.pendingRecords().length ? t.input.compositionID : 0, t.input.compositionNode = null, t.input.compositionPendingChanges && Promise.resolve().then(() => t.domObserver.flush()), t.input.compositionID++, W5(t, 20)) }; function W5(t, e) { clearTimeout(t.input.composingTimeout), e > -1 && (t.input.composingTimeout = setTimeout(() => hg(t), e)) } function Y5(t) { for (t.composing && (t.input.composing = !1, t.input.compositionEndedAt = LJ()); t.input.compositionNodes.length > 0;)t.input.compositionNodes.pop().markParentsDirty() } function _J(t) { let e = t.domSelectionRange(); if (!e.focusNode) return null; let n = jQ(e.focusNode, e.focusOffset), r = EQ(e.focusNode, e.focusOffset); if (n && r && n != r) { let i = r.pmViewDesc, s = t.domObserver.lastChangedTextNode; if (n == s || r == s) return s; if (!i || !i.isText(r.nodeValue)) return r; if (t.input.compositionNode == r) { let a = n.pmViewDesc; if (!(!a || !a.isText(n.nodeValue))) return r } } return n || r } function LJ() { let t = document.createEvent("Event"); return t.initEvent("event", !0, !0), t.timeStamp } function hg(t, e = !1) { if (!(_a && t.domObserver.flushingSoon >= 0)) { if (t.domObserver.forceFlush(), Y5(t), e || t.docView && t.docView.dirty) { let n = BS(t), r = t.state.selection; return n && !n.eq(r) ? t.dispatch(t.state.tr.setSelection(n)) : (t.markCursor || e) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent ? t.dispatch(t.state.tr.deleteSelection()) : t.updateState(t.state), !0 } return !1 } } function PJ(t, e) { if (!t.dom.parentNode) return; let n = t.dom.parentNode.appendChild(document.createElement("div")); n.appendChild(e), n.style.cssText = "position: fixed; left: -10000px; top: 10px"; let r = getSelection(), i = document.createRange(); i.selectNodeContents(e), t.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => { n.parentNode && n.parentNode.removeChild(n), t.focus() }, 50) } const Wf = wi && Po < 15 || vu && DQ < 604; oi.copy = li.cut = (t, e) => { let n = e, r = t.state.selection, i = n.type == "cut"; if (r.empty) return; let s = Wf ? null : n.clipboardData, a = r.content(), { dom: l, text: u } = US(t, a); s ? (n.preventDefault(), s.clearData(), s.setData("text/html", l.innerHTML), s.setData("text/plain", u)) : PJ(t, l), i && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut")) }; function zJ(t) { return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null } function IJ(t, e) { if (!t.dom.parentNode) return; let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code, r = t.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div")); n || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus(); let i = t.input.shiftKey && t.input.lastKeyCode != 45; setTimeout(() => { t.focus(), r.parentNode && r.parentNode.removeChild(r), n ? Yf(t, r.value, null, i, e) : Yf(t, r.textContent, r.innerHTML, i, e) }, 50) } function Yf(t, e, n, r, i) { let s = F5(t, e, n, r, t.state.selection.$from); if (t.someProp("handlePaste", u => u(t, i, s || nt.empty))) return !0; if (!s) return !1; let a = zJ(s), l = a ? t.state.tr.replaceSelectionWith(a, r) : t.state.tr.replaceSelection(s); return t.dispatch(l.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0 } function G5(t) { let e = t.getData("text/plain") || t.getData("Text"); if (e) return e; let n = t.getData("text/uri-list"); return n ? n.replace(/\r?\n/g, " ") : "" } li.paste = (t, e) => { let n = e; if (t.composing && !_a) return; let r = Wf ? null : n.clipboardData, i = t.input.shiftKey && t.input.lastKeyCode != 45; r && Yf(t, G5(r), r.getData("text/html"), i, n) ? n.preventDefault() : IJ(t, n) }; class X5 { constructor(e, n, r) { this.slice = e, this.move = n, this.node = r } } const FJ = ss ? "altKey" : "ctrlKey"; function Q5(t, e) { let n = t.someProp("dragCopies", r => !r(e)); return n ?? !e[FJ] } oi.dragstart = (t, e) => { let n = e, r = t.input.mouseDown; if (r && r.done(), !n.dataTransfer) return; let i = t.state.selection, s = i.empty ? null : t.posAtCoords(Ry(n)), a; if (!(s && s.pos >= i.from && s.pos <= (i instanceof Ct ? i.to - 1 : i.to))) { if (r && r.mightDrag) a = Ct.create(t.state.doc, r.mightDrag.pos); else if (n.target && n.target.nodeType == 1) { let g = t.docView.nearestDesc(n.target, !0); g && g.node.type.spec.draggable && g != t.docView && (a = Ct.create(t.state.doc, g.posBefore)) } } let l = (a || t.state.selection).content(), { dom: u, text: f, slice: p } = US(t, l); (!n.dataTransfer.files.length || !Gr || C5 > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(Wf ? "Text" : "text/html", u.innerHTML), n.dataTransfer.effectAllowed = "copyMove", Wf || n.dataTransfer.setData("text/plain", f), t.dragging = new X5(p, Q5(t, n), a) }; oi.dragend = t => { let e = t.dragging; window.setTimeout(() => { t.dragging == e && (t.dragging = null) }, 50) }; li.dragover = li.dragenter = (t, e) => e.preventDefault(); li.drop = (t, e) => { let n = e, r = t.dragging; if (t.dragging = null, !n.dataTransfer) return; let i = t.posAtCoords(Ry(n)); if (!i) return; let s = t.state.doc.resolve(i.pos), a = r && r.slice; a ? t.someProp("transformPasted", b => { a = b(a, t) }) : a = F5(t, G5(n.dataTransfer), Wf ? null : n.dataTransfer.getData("text/html"), !1, s); let l = !!(r && Q5(t, n)); if (t.someProp("handleDrop", b => b(t, n, a || nt.empty, l))) { n.preventDefault(); return } if (!a) return; n.preventDefault(); let u = a ? p5(t.state.doc, s.pos, a) : s.pos; u == null && (u = s.pos); let f = t.state.tr; if (l) { let { node: b } = r; b ? b.replace(f) : f.deleteSelection() } let p = f.mapping.map(u), g = a.openStart == 0 && a.openEnd == 0 && a.content.childCount == 1, y = f.doc; if (g ? f.replaceRangeWith(p, p, a.content.firstChild) : f.replaceRange(p, p, a), f.doc.eq(y)) return; let v = f.doc.resolve(p); if (g && Ct.isSelectable(a.content.firstChild) && v.nodeAfter && v.nodeAfter.sameMarkup(a.content.firstChild)) f.setSelection(new Ct(v)); else { let b = f.mapping.map(u); f.mapping.maps[f.mapping.maps.length - 1].forEach((S, C, T, A) => b = A), f.setSelection($S(t, v, f.doc.resolve(b))) } t.focus(), t.dispatch(f.setMeta("uiEvent", "drop")) }; oi.focus = t => { t.input.lastFocus = Date.now(), t.focused || (t.domObserver.stop(), t.dom.classList.add("ProseMirror-focused"), t.domObserver.start(), t.focused = !0, setTimeout(() => { t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && Fa(t) }, 20)) }; oi.blur = (t, e) => { let n = e; t.focused && (t.domObserver.stop(), t.dom.classList.remove("ProseMirror-focused"), t.domObserver.start(), n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(), t.focused = !1) }; oi.beforeinput = (t, e) => { if (Gr && _a && e.inputType == "deleteContentBackward") { t.domObserver.flushSoon(); let { domChangeCount: r } = t.input; setTimeout(() => { if (t.input.domChangeCount != r || (t.dom.blur(), t.focus(), t.someProp("handleKeyDown", s => s(t, Nl(8, "Backspace"))))) return; let { $cursor: i } = t.state.selection; i && i.pos > 0 && t.dispatch(t.state.tr.delete(i.pos - 1, i.pos).scrollIntoView()) }, 50) } }; for (let t in li) oi[t] = li[t]; function Gf(t, e) { if (t == e) return !0; for (let n in t) if (t[n] !== e[n]) return !1; for (let n in e) if (!(n in t)) return !1; return !0 } class pg { constructor(e, n) { this.toDOM = e, this.spec = n || Hl, this.side = this.spec.side || 0 } map(e, n, r, i) { let { pos: s, deleted: a } = e.mapResult(n.from + i, this.side < 0 ? -1 : 1); return a ? null : new si(s - r, s - r, this) } valid() { return !0 } eq(e) { return this == e || e instanceof pg && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Gf(this.spec, e.spec)) } destroy(e) { this.spec.destroy && this.spec.destroy(e) } } class Io { constructor(e, n) { this.attrs = e, this.spec = n || Hl } map(e, n, r, i) { let s = e.map(n.from + i, this.spec.inclusiveStart ? -1 : 1) - r, a = e.map(n.to + i, this.spec.inclusiveEnd ? 1 : -1) - r; return s >= a ? null : new si(s, a, this) } valid(e, n) { return n.from < n.to } eq(e) { return this == e || e instanceof Io && Gf(this.attrs, e.attrs) && Gf(this.spec, e.spec) } static is(e) { return e.type instanceof Io } destroy() { } } class KS { constructor(e, n) { this.attrs = e, this.spec = n || Hl } map(e, n, r, i) { let s = e.mapResult(n.from + i, 1); if (s.deleted) return null; let a = e.mapResult(n.to + i, -1); return a.deleted || a.pos <= s.pos ? null : new si(s.pos - r, a.pos - r, this) } valid(e, n) { let { index: r, offset: i } = e.content.findIndex(n.from), s; return i == n.from && !(s = e.child(r)).isText && i + s.nodeSize == n.to } eq(e) { return this == e || e instanceof KS && Gf(this.attrs, e.attrs) && Gf(this.spec, e.spec) } destroy() { } } class si { constructor(e, n, r) { this.from = e, this.to = n, this.type = r } copy(e, n) { return new si(e, n, this.type) } eq(e, n = 0) { return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to } map(e, n, r) { return this.type.map(e, this, n, r) } static widget(e, n, r) { return new si(e, e, new pg(n, r)) } static inline(e, n, r, i) { return new si(e, n, new Io(r, i)) } static node(e, n, r, i) { return new si(e, n, new KS(r, i)) } get spec() { return this.type.spec } get inline() { return this.type instanceof Io } get widget() { return this.type instanceof pg } } const Jc = [], Hl = {}; class Yn { constructor(e, n) { this.local = e.length ? e : Jc, this.children = n.length ? n : Jc } static create(e, n) { return n.length ? mg(n, e, 0, Hl) : Kr } find(e, n, r) { let i = []; return this.findInner(e ?? 0, n ?? 1e9, i, 0, r), i } findInner(e, n, r, i, s) { for (let a = 0; a < this.local.length; a++) { let l = this.local[a]; l.from <= n && l.to >= e && (!s || s(l.spec)) && r.push(l.copy(l.from + i, l.to + i)) } for (let a = 0; a < this.children.length; a += 3)if (this.children[a] < n && this.children[a + 1] > e) { let l = this.children[a] + 1; this.children[a + 2].findInner(e - l, n - l, r, i + l, s) } } map(e, n, r) { return this == Kr || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, r || Hl) } mapInner(e, n, r, i, s) { let a; for (let l = 0; l < this.local.length; l++) { let u = this.local[l].map(e, r, i); u && u.type.valid(n, u) ? (a || (a = [])).push(u) : s.onRemove && s.onRemove(this.local[l].spec) } return this.children.length ? BJ(this.children, a || [], e, n, r, i, s) : a ? new Yn(a.sort(ql), Jc) : Kr } add(e, n) { return n.length ? this == Kr ? Yn.create(e, n) : this.addInner(e, n, 0) : this } addInner(e, n, r) { let i, s = 0; e.forEach((l, u) => { let f = u + r, p; if (p = Z5(n, l, f)) { for (i || (i = this.children.slice()); s < i.length && i[s] < u;)s += 3; i[s] == u ? i[s + 2] = i[s + 2].addInner(l, p, f + 1) : i.splice(s, 0, u, u + l.nodeSize, mg(p, l, f + 1, Hl)), s += 3 } }); let a = J5(s ? e_(n) : n, -r); for (let l = 0; l < a.length; l++)a[l].type.valid(e, a[l]) || a.splice(l--, 1); return new Yn(a.length ? this.local.concat(a).sort(ql) : this.local, i || this.children) } remove(e) { return e.length == 0 || this == Kr ? this : this.removeInner(e, 0) } removeInner(e, n) { let r = this.children, i = this.local; for (let s = 0; s < r.length; s += 3) { let a, l = r[s] + n, u = r[s + 1] + n; for (let p = 0, g; p < e.length; p++)(g = e[p]) && g.from > l && g.to < u && (e[p] = null, (a || (a = [])).push(g)); if (!a) continue; r == this.children && (r = this.children.slice()); let f = r[s + 2].removeInner(a, l + 1); f != Kr ? r[s + 2] = f : (r.splice(s, 3), s -= 3) } if (i.length) { for (let s = 0, a; s < e.length; s++)if (a = e[s]) for (let l = 0; l < i.length; l++)i[l].eq(a, n) && (i == this.local && (i = this.local.slice()), i.splice(l--, 1)) } return r == this.children && i == this.local ? this : i.length || r.length ? new Yn(i, r) : Kr } forChild(e, n) { if (this == Kr) return this; if (n.isLeaf) return Yn.empty; let r, i; for (let l = 0; l < this.children.length; l += 3)if (this.children[l] >= e) { this.children[l] == e && (r = this.children[l + 2]); break } let s = e + 1, a = s + n.content.size; for (let l = 0; l < this.local.length; l++) { let u = this.local[l]; if (u.from < a && u.to > s && u.type instanceof Io) { let f = Math.max(s, u.from) - s, p = Math.min(a, u.to) - s; f < p && (i || (i = [])).push(u.copy(f, p)) } } if (i) { let l = new Yn(i.sort(ql), Jc); return r ? new jo([l, r]) : l } return r || Kr } eq(e) { if (this == e) return !0; if (!(e instanceof Yn) || this.local.length != e.local.length || this.children.length != e.children.length) return !1; for (let n = 0; n < this.local.length; n++)if (!this.local[n].eq(e.local[n])) return !1; for (let n = 0; n < this.children.length; n += 3)if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2])) return !1; return !0 } locals(e) { return WS(this.localsInner(e)) } localsInner(e) { if (this == Kr) return Jc; if (e.inlineContent || !this.local.some(Io.is)) return this.local; let n = []; for (let r = 0; r < this.local.length; r++)this.local[r].type instanceof Io || n.push(this.local[r]); return n } forEachSet(e) { e(this) } } Yn.empty = new Yn([], []); Yn.removeOverlap = WS; const Kr = Yn.empty; class jo { constructor(e) { this.members = e } map(e, n) { const r = this.members.map(i => i.map(e, n, Hl)); return jo.from(r) } forChild(e, n) { if (n.isLeaf) return Yn.empty; let r = []; for (let i = 0; i < this.members.length; i++) { let s = this.members[i].forChild(e, n); s != Kr && (s instanceof jo ? r = r.concat(s.members) : r.push(s)) } return jo.from(r) } eq(e) { if (!(e instanceof jo) || e.members.length != this.members.length) return !1; for (let n = 0; n < this.members.length; n++)if (!this.members[n].eq(e.members[n])) return !1; return !0 } locals(e) { let n, r = !0; for (let i = 0; i < this.members.length; i++) { let s = this.members[i].localsInner(e); if (s.length) if (!n) n = s; else { r && (n = n.slice(), r = !1); for (let a = 0; a < s.length; a++)n.push(s[a]) } } return n ? WS(r ? n : n.sort(ql)) : Jc } static from(e) { switch (e.length) { case 0: return Kr; case 1: return e[0]; default: return new jo(e.every(n => n instanceof Yn) ? e : e.reduce((n, r) => n.concat(r instanceof Yn ? r : r.members), [])) } } forEachSet(e) { for (let n = 0; n < this.members.length; n++)this.members[n].forEachSet(e) } } function BJ(t, e, n, r, i, s, a) { let l = t.slice(); for (let f = 0, p = s; f < n.maps.length; f++) { let g = 0; n.maps[f].forEach((y, v, b, S) => { let C = S - b - (v - y); for (let T = 0; T < l.length; T += 3) { let A = l[T + 1]; if (A < 0 || y > A + p - g) continue; let M = l[T] + p - g; v >= M ? l[T + 1] = y <= M ? -2 : -1 : y >= p && C && (l[T] += C, l[T + 1] += C) } g += C }), p = n.maps[f].map(p, -1) } let u = !1; for (let f = 0; f < l.length; f += 3)if (l[f + 1] < 0) { if (l[f + 1] == -2) { u = !0, l[f + 1] = -1; continue } let p = n.map(t[f] + s), g = p - i; if (g < 0 || g >= r.content.size) { u = !0; continue } let y = n.map(t[f + 1] + s, -1), v = y - i, { index: b, offset: S } = r.content.findIndex(g), C = r.maybeChild(b); if (C && S == g && S + C.nodeSize == v) { let T = l[f + 2].mapInner(n, C, p + 1, t[f] + s + 1, a); T != Kr ? (l[f] = g, l[f + 1] = v, l[f + 2] = T) : (l[f + 1] = -2, u = !0) } else u = !0 } if (u) { let f = $J(l, t, e, n, i, s, a), p = mg(f, r, 0, a); e = p.local; for (let g = 0; g < l.length; g += 3)l[g + 1] < 0 && (l.splice(g, 3), g -= 3); for (let g = 0, y = 0; g < p.children.length; g += 3) { let v = p.children[g]; for (; y < l.length && l[y] < v;)y += 3; l.splice(y, 0, p.children[g], p.children[g + 1], p.children[g + 2]) } } return new Yn(e.sort(ql), l) } function J5(t, e) { if (!e || !t.length) return t; let n = []; for (let r = 0; r < t.length; r++) { let i = t[r]; n.push(new si(i.from + e, i.to + e, i.type)) } return n } function $J(t, e, n, r, i, s, a) { function l(u, f) { for (let p = 0; p < u.local.length; p++) { let g = u.local[p].map(r, i, f); g ? n.push(g) : a.onRemove && a.onRemove(u.local[p].spec) } for (let p = 0; p < u.children.length; p += 3)l(u.children[p + 2], u.children[p] + f + 1) } for (let u = 0; u < t.length; u += 3)t[u + 1] == -1 && l(t[u + 2], e[u] + s + 1); return n } function Z5(t, e, n) { if (e.isLeaf) return null; let r = n + e.nodeSize, i = null; for (let s = 0, a; s < t.length; s++)(a = t[s]) && a.from > n && a.to < r && ((i || (i = [])).push(a), t[s] = null); return i } function e_(t) { let e = []; for (let n = 0; n < t.length; n++)t[n] != null && e.push(t[n]); return e } function mg(t, e, n, r) { let i = [], s = !1; e.forEach((l, u) => { let f = Z5(t, l, u + n); if (f) { s = !0; let p = mg(f, l, n + u + 1, r); p != Kr && i.push(u, u + l.nodeSize, p) } }); let a = J5(s ? e_(t) : t, -n).sort(ql); for (let l = 0; l < a.length; l++)a[l].type.valid(e, a[l]) || (r.onRemove && r.onRemove(a[l].spec), a.splice(l--, 1)); return a.length || i.length ? new Yn(a, i) : Kr } function ql(t, e) { return t.from - e.from || t.to - e.to } function WS(t) { let e = t; for (let n = 0; n < e.length - 1; n++) { let r = e[n]; if (r.from != r.to) for (let i = n + 1; i < e.length; i++) { let s = e[i]; if (s.from == r.from) { s.to != r.to && (e == t && (e = t.slice()), e[i] = s.copy(s.from, r.to), t4(e, i + 1, s.copy(r.to, s.to))); continue } else { s.from < r.to && (e == t && (e = t.slice()), e[n] = r.copy(r.from, s.from), t4(e, i, r.copy(s.from, r.to))); break } } } return e } function t4(t, e, n) { for (; e < t.length && ql(n, t[e]) > 0;)e++; t.splice(e, 0, n) } function Hx(t) { let e = []; return t.someProp("decorations", n => { let r = n(t.state); r && r != Kr && e.push(r) }), t.cursorWrapper && e.push(Yn.create(t.state.doc, [t.cursorWrapper.deco])), jo.from(e) } const UJ = { childList: !0, characterData: !0, characterDataOldValue: !0, attributes: !0, attributeOldValue: !0, subtree: !0 }, VJ = wi && Po <= 11; class HJ { constructor() { this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0 } set(e) { this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset } clear() { this.anchorNode = this.focusNode = null } eq(e) { return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset } } class qJ { constructor(e, n) { this.view = e, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new HJ, this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver(r => { for (let i = 0; i < r.length; i++)this.queue.push(r[i]); wi && Po <= 11 && r.some(i => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush() }), VJ && (this.onCharData = r => { this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon() }), this.onSelectionChange = this.onSelectionChange.bind(this) } flushSoon() { this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => { this.flushingSoon = -1, this.flush() }, 20)) } forceFlush() { this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush()) } start() { this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, UJ)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection() } stop() { if (this.observer) { let e = this.observer.takeRecords(); if (e.length) { for (let n = 0; n < e.length; n++)this.queue.push(e[n]); window.setTimeout(() => this.flush(), 20) } this.observer.disconnect() } this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection() } connectSelection() { this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange) } disconnectSelection() { this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange) } suppressSelectionUpdates() { this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50) } onSelectionChange() { if (Wk(this.view)) { if (this.suppressingSelectionUpdates) return Fa(this.view); if (wi && Po <= 11 && !this.view.state.selection.empty) { let e = this.view.domSelectionRange(); if (e.focusNode && tc(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)) return this.flushSoon() } this.flush() } } setCurSelection() { this.currentSelection.set(this.view.domSelectionRange()) } ignoreSelectionChange(e) { if (!e.focusNode) return !0; let n = new Set, r; for (let s = e.focusNode; s; s = yu(s))n.add(s); for (let s = e.anchorNode; s; s = yu(s))if (n.has(s)) { r = s; break } let i = r && this.view.docView.nearestDesc(r); if (i && i.ignoreMutation({ type: "selection", target: r.nodeType == 3 ? r.parentNode : r })) return this.setCurSelection(), !0 } pendingRecords() { if (this.observer) for (let e of this.observer.takeRecords()) this.queue.push(e); return this.queue } flush() { let { view: e } = this; if (!e.docView || this.flushingSoon > -1) return; let n = this.pendingRecords(); n.length && (this.queue = []); let r = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && Wk(e) && !this.ignoreSelectionChange(r), s = -1, a = -1, l = !1, u = []; if (e.editable) for (let p = 0; p < n.length; p++) { let g = this.registerMutation(n[p], u); g && (s = s < 0 ? g.from : Math.min(g.from, s), a = a < 0 ? g.to : Math.max(g.to, a), g.typeOver && (l = !0)) } if (Es && u.length) { let p = u.filter(g => g.nodeName == "BR"); if (p.length == 2) { let [g, y] = p; g.parentNode && g.parentNode.parentNode == y.parentNode ? y.remove() : g.remove() } else { let { focusNode: g } = this.currentSelection; for (let y of p) { let v = y.parentNode; v && v.nodeName == "LI" && (!g || YJ(e, g) != v) && y.remove() } } } let f = null; s < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && My(r) && (f = BS(e)) && f.eq(Ot.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, Fa(e), this.currentSelection.set(r), e.scrollToSelection()) : (s > -1 || i) && (s > -1 && (e.docView.markDirty(s, a), KJ(e)), this.handleDOMChange(s, a, l, u), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || Fa(e), this.currentSelection.set(r)) } registerMutation(e, n) { if (n.indexOf(e.target) > -1) return null; let r = this.view.docView.nearestDesc(e.target); if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e)) return null; if (e.type == "childList") { for (let p = 0; p < e.addedNodes.length; p++) { let g = e.addedNodes[p]; n.push(g), g.nodeType == 3 && (this.lastChangedTextNode = g) } if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target)) return { from: r.posBefore, to: r.posAfter }; let i = e.previousSibling, s = e.nextSibling; if (wi && Po <= 11 && e.addedNodes.length) for (let p = 0; p < e.addedNodes.length; p++) { let { previousSibling: g, nextSibling: y } = e.addedNodes[p]; (!g || Array.prototype.indexOf.call(e.addedNodes, g) < 0) && (i = g), (!y || Array.prototype.indexOf.call(e.addedNodes, y) < 0) && (s = y) } let a = i && i.parentNode == e.target ? zr(i) + 1 : 0, l = r.localPosFromDOM(e.target, a, -1), u = s && s.parentNode == e.target ? zr(s) : e.target.childNodes.length, f = r.localPosFromDOM(e.target, u, 1); return { from: l, to: f } } else return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, { from: r.posAtStart, to: r.posAtEnd, typeOver: e.target.nodeValue == e.oldValue }) } } let n4 = new WeakMap, r4 = !1; function KJ(t) { if (!n4.has(t) && (n4.set(t, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)) { if (t.requiresGeckoHackNode = Es, r4) return; console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), r4 = !0 } } function i4(t, e) { let n = e.startContainer, r = e.startOffset, i = e.endContainer, s = e.endOffset, a = t.domAtPos(t.state.selection.anchor); return tc(a.node, a.offset, i, s) && ([n, r, i, s] = [i, s, n, r]), { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: s } } function WJ(t, e) { if (e.getComposedRanges) { let i = e.getComposedRanges(t.root)[0]; if (i) return i4(t, i) } let n; function r(i) { i.preventDefault(), i.stopImmediatePropagation(), n = i.getTargetRanges()[0] } return t.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), t.dom.removeEventListener("beforeinput", r, !0), n ? i4(t, n) : null } function YJ(t, e) { for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) { let r = t.docView.nearestDesc(n, !0); if (r && r.node.isBlock) return n } return null } function GJ(t, e, n) { let { node: r, fromOffset: i, toOffset: s, from: a, to: l } = t.docView.parseRange(e, n), u = t.domSelectionRange(), f, p = u.anchorNode; if (p && t.dom.contains(p.nodeType == 1 ? p : p.parentNode) && (f = [{ node: p, offset: u.anchorOffset }], My(u) || f.push({ node: u.focusNode, offset: u.focusOffset })), Gr && t.input.lastKeyCode === 8) for (let C = s; C > i; C--) { let T = r.childNodes[C - 1], A = T.pmViewDesc; if (T.nodeName == "BR" && !A) { s = C; break } if (!A || A.size) break } let g = t.state.doc, y = t.someProp("domParser") || hf.fromSchema(t.state.schema), v = g.resolve(a), b = null, S = y.parse(r, { topNode: v.parent, topMatch: v.parent.contentMatchAt(v.index()), topOpen: !0, from: i, to: s, preserveWhitespace: v.parent.type.whitespace == "pre" ? "full" : !0, findPositions: f, ruleFromNode: XJ, context: v }); if (f && f[0].pos != null) { let C = f[0].pos, T = f[1] && f[1].pos; T == null && (T = C), b = { anchor: C + a, head: T + a } } return { doc: S, sel: b, from: a, to: l } } function XJ(t) { let e = t.pmViewDesc; if (e) return e.parseRule(); if (t.nodeName == "BR" && t.parentNode) { if (ai && /^(ul|ol)$/i.test(t.parentNode.nodeName)) { let n = document.createElement("div"); return n.appendChild(document.createElement("li")), { skip: n } } else if (t.parentNode.lastChild == t || ai && /^(tr|table)$/i.test(t.parentNode.nodeName)) return { ignore: !0 } } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder")) return { ignore: !0 }; return null } const QJ = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i; function JJ(t, e, n, r, i) { let s = t.input.compositionPendingChanges || (t.composing ? t.input.compositionID : 0); if (t.input.compositionPendingChanges = 0, e < 0) { let V = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null, q = BS(t, V); if (q && !t.state.selection.eq(q)) { if (Gr && _a && t.input.lastKeyCode === 13 && Date.now() - 100 < t.input.lastKeyCodeTime && t.someProp("handleKeyDown", W => W(t, Nl(13, "Enter")))) return; let ue = t.state.tr.setSelection(q); V == "pointer" ? ue.setMeta("pointer", !0) : V == "key" && ue.scrollIntoView(), s && ue.setMeta("composition", s), t.dispatch(ue) } return } let a = t.state.doc.resolve(e), l = a.sharedDepth(n); e = a.before(l + 1), n = t.state.doc.resolve(n).after(l + 1); let u = t.state.selection, f = GJ(t, e, n), p = t.state.doc, g = p.slice(f.from, f.to), y, v; t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime ? (y = t.state.selection.to, v = "end") : (y = t.state.selection.from, v = "start"), t.input.lastKeyCode = null; let b = tZ(g.content, f.doc.content, f.from, y, v); if (b && t.input.domChangeCount++, (vu && t.input.lastIOSEnter > Date.now() - 225 || _a) && i.some(V => V.nodeType == 1 && !QJ.test(V.nodeName)) && (!b || b.endA >= b.endB) && t.someProp("handleKeyDown", V => V(t, Nl(13, "Enter")))) { t.input.lastIOSEnter = 0; return } if (!b) if (r && u instanceof Et && !u.empty && u.$head.sameParent(u.$anchor) && !t.composing && !(f.sel && f.sel.anchor != f.sel.head)) b = { start: u.from, endA: u.to, endB: u.to }; else { if (f.sel) { let V = s4(t, t.state.doc, f.sel); if (V && !V.eq(t.state.selection)) { let q = t.state.tr.setSelection(V); s && q.setMeta("composition", s), t.dispatch(q) } } return } t.state.selection.from < t.state.selection.to && b.start == b.endB && t.state.selection instanceof Et && (b.start > t.state.selection.from && b.start <= t.state.selection.from + 2 && t.state.selection.from >= f.from ? b.start = t.state.selection.from : b.endA < t.state.selection.to && b.endA >= t.state.selection.to - 2 && t.state.selection.to <= f.to && (b.endB += t.state.selection.to - b.endA, b.endA = t.state.selection.to)), wi && Po <= 11 && b.endB == b.start + 1 && b.endA == b.start && b.start > f.from && f.doc.textBetween(b.start - f.from - 1, b.start - f.from + 1) == " " && (b.start--, b.endA--, b.endB--); let S = f.doc.resolveNoCache(b.start - f.from), C = f.doc.resolveNoCache(b.endB - f.from), T = p.resolve(b.start), A = S.sameParent(C) && S.parent.inlineContent && T.end() >= b.endA, M; if ((vu && t.input.lastIOSEnter > Date.now() - 225 && (!A || i.some(V => V.nodeName == "DIV" || V.nodeName == "P")) || !A && S.pos < f.doc.content.size && (!S.sameParent(C) || !S.parent.inlineContent) && !/\S/.test(f.doc.textBetween(S.pos, C.pos, "", "")) && (M = Ot.findFrom(f.doc.resolve(S.pos + 1), 1, !0)) && M.head > S.pos) && t.someProp("handleKeyDown", V => V(t, Nl(13, "Enter")))) { t.input.lastIOSEnter = 0; return } if (t.state.selection.anchor > b.start && eZ(p, b.start, b.endA, S, C) && t.someProp("handleKeyDown", V => V(t, Nl(8, "Backspace")))) { _a && Gr && t.domObserver.suppressSelectionUpdates(); return } Gr && b.endB == b.start && (t.input.lastChromeDelete = Date.now()), _a && !A && S.start() != C.start() && C.parentOffset == 0 && S.depth == C.depth && f.sel && f.sel.anchor == f.sel.head && f.sel.head == b.endA && (b.endB -= 2, C = f.doc.resolveNoCache(b.endB - f.from), setTimeout(() => { t.someProp("handleKeyDown", function (V) { return V(t, Nl(13, "Enter")) }) }, 20)); let O = b.start, E = b.endA, k = V => { let q = V || t.state.tr.replace(O, E, f.doc.slice(b.start - f.from, b.endB - f.from)); if (f.sel) { let ue = s4(t, q.doc, f.sel); ue && !(Gr && t.composing && ue.empty && (b.start != b.endB || t.input.lastChromeDelete < Date.now() - 100) && (ue.head == O || ue.head == q.mapping.map(E) - 1) || wi && ue.empty && ue.head == O) && q.setSelection(ue) } return s && q.setMeta("composition", s), q.scrollIntoView() }, z; if (A) { if (S.pos == C.pos) { wi && Po <= 11 && S.parentOffset == 0 && (t.domObserver.suppressSelectionUpdates(), setTimeout(() => Fa(t), 20)); let V = k(t.state.tr.delete(O, E)), q = p.resolve(b.start).marksAcross(p.resolve(b.endA)); q && V.ensureMarks(q), t.dispatch(V) } else if (b.endA == b.endB && (z = ZJ(S.parent.content.cut(S.parentOffset, C.parentOffset), T.parent.content.cut(T.parentOffset, b.endA - T.start())))) { let V = k(t.state.tr); z.type == "add" ? V.addMark(O, E, z.mark) : V.removeMark(O, E, z.mark), t.dispatch(V) } else if (S.parent.child(S.index()).isText && S.index() == C.index() - (C.textOffset ? 0 : 1)) { let V = S.parent.textBetween(S.parentOffset, C.parentOffset), q = () => k(t.state.tr.insertText(V, O, E)); t.someProp("handleTextInput", ue => ue(t, O, E, V, q)) || t.dispatch(q()) } } else t.dispatch(k()) } function s4(t, e, n) { return Math.max(n.anchor, n.head) > e.content.size ? null : $S(t, e.resolve(n.anchor), e.resolve(n.head)) } function ZJ(t, e) { let n = t.firstChild.marks, r = e.firstChild.marks, i = n, s = r, a, l, u; for (let p = 0; p < r.length; p++)i = r[p].removeFromSet(i); for (let p = 0; p < n.length; p++)s = n[p].removeFromSet(s); if (i.length == 1 && s.length == 0) l = i[0], a = "add", u = p => p.mark(l.addToSet(p.marks)); else if (i.length == 0 && s.length == 1) l = s[0], a = "remove", u = p => p.mark(l.removeFromSet(p.marks)); else return null; let f = []; for (let p = 0; p < e.childCount; p++)f.push(u(e.child(p))); if (Ue.from(f).eq(t)) return { mark: l, type: a } } function eZ(t, e, n, r, i) { if (n - e <= i.pos - r.pos || qx(r, !0, !1) < i.pos) return !1; let s = t.resolve(e); if (!r.parent.isTextblock) { let l = s.nodeAfter; return l != null && n == e + l.nodeSize } if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock) return !1; let a = t.resolve(qx(s, !0, !0)); return !a.parent.isTextblock || a.pos > n || qx(a, !0, !1) < n ? !1 : r.parent.content.cut(r.parentOffset).eq(a.parent.content) } function qx(t, e, n) { let r = t.depth, i = e ? t.end() : t.pos; for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount);)r--, i++, e = !1; if (n) { let s = t.node(r).maybeChild(t.indexAfter(r)); for (; s && !s.isLeaf;)s = s.firstChild, i++ } return i } function tZ(t, e, n, r, i) { let s = t.findDiffStart(e, n); if (s == null) return null; let { a, b: l } = t.findDiffEnd(e, n + t.size, n + e.size); if (i == "end") { let u = Math.max(0, s - Math.min(a, l)); r -= a + u - s } if (a < s && t.size < e.size) { let u = r <= s && r >= a ? s - r : 0; s -= u, s && s < e.size && a4(e.textBetween(s - 1, s + 1)) && (s += u ? 1 : -1), l = s + (l - a), a = s } else if (l < s) { let u = r <= s && r >= l ? s - r : 0; s -= u, s && s < t.size && a4(t.textBetween(s - 1, s + 1)) && (s += u ? 1 : -1), a = s + (a - l), l = s } return { start: s, endA: a, endB: l } } function a4(t) { if (t.length != 2) return !1; let e = t.charCodeAt(0), n = t.charCodeAt(1); return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319 } class t_ { constructor(e, n) { this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new bJ, this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(d4), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = c4(this), l4(this), this.nodeViews = u4(this), this.docView = $k(this.state.doc, o4(this), Hx(this), this.dom, this), this.domObserver = new qJ(this, (r, i, s, a) => JJ(this, r, i, s, a)), this.domObserver.start(), wJ(this), this.updatePluginViews() } get composing() { return this.input.composing } get props() { if (this._props.state != this.state) { let e = this._props; this._props = {}; for (let n in e) this._props[n] = e[n]; this._props.state = this.state } return this._props } update(e) { e.handleDOMEvents != this._props.handleDOMEvents && R1(this); let n = this._props; this._props = e, e.plugins && (e.plugins.forEach(d4), this.directPlugins = e.plugins), this.updateStateInner(e.state, n) } setProps(e) { let n = {}; for (let r in this._props) n[r] = this._props[r]; n.state = this.state; for (let r in e) n[r] = e[r]; this.update(n) } updateState(e) { this.updateStateInner(e, this._props) } updateStateInner(e, n) { var r; let i = this.state, s = !1, a = !1; e.storedMarks && this.composing && (Y5(this), a = !0), this.state = e; let l = i.plugins != e.plugins || this._props.plugins != n.plugins; if (l || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) { let v = u4(this); rZ(v, this.nodeViews) && (this.nodeViews = v, s = !0) } (l || n.handleDOMEvents != this._props.handleDOMEvents) && R1(this), this.editable = c4(this), l4(this); let u = Hx(this), f = o4(this), p = i.plugins != e.plugins && !i.doc.eq(e.doc) ? "reset" : e.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", g = s || !this.docView.matchesNode(e.doc, f, u); (g || !e.selection.eq(i.selection)) && (a = !0); let y = p == "preserve" && a && this.dom.style.overflowAnchor == null && LQ(this); if (a) { this.domObserver.stop(); let v = g && (wi || Gr) && !this.composing && !i.selection.empty && !e.selection.empty && nZ(i.selection, e.selection); if (g) { let b = Gr ? this.trackWrites = this.domSelectionRange().focusNode : null; this.composing && (this.input.compositionNode = _J(this)), (s || !this.docView.update(e.doc, f, u, this)) && (this.docView.updateOuterDeco(f), this.docView.destroy(), this.docView = $k(e.doc, f, u, this.dom, this)), b && !this.trackWrites && (v = !0) } v || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && sJ(this)) ? Fa(this, v) : (P5(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start() } this.updatePluginViews(i), !((r = this.dragging) === null || r === void 0) && r.node && !i.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, i), p == "reset" ? this.dom.scrollTop = 0 : p == "to selection" ? this.scrollToSelection() : y && PQ(y) } scrollToSelection() { let e = this.domSelectionRange().focusNode; if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) { if (!this.someProp("handleScrollToSelection", n => n(this))) if (this.state.selection instanceof Ct) { let n = this.docView.domAfterPos(this.state.selection.from); n.nodeType == 1 && Lk(this, n.getBoundingClientRect(), e) } else Lk(this, this.coordsAtPos(this.state.selection.head, 1), e) } } destroyPluginViews() { let e; for (; e = this.pluginViews.pop();)e.destroy && e.destroy() } updatePluginViews(e) { if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) { this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews(); for (let n = 0; n < this.directPlugins.length; n++) { let r = this.directPlugins[n]; r.spec.view && this.pluginViews.push(r.spec.view(this)) } for (let n = 0; n < this.state.plugins.length; n++) { let r = this.state.plugins[n]; r.spec.view && this.pluginViews.push(r.spec.view(this)) } } else for (let n = 0; n < this.pluginViews.length; n++) { let r = this.pluginViews[n]; r.update && r.update(this, e) } } updateDraggedNode(e, n) { let r = e.node, i = -1; if (this.state.doc.nodeAt(r.from) == r.node) i = r.from; else { let s = r.from + (this.state.doc.content.size - n.doc.content.size); (s > 0 && this.state.doc.nodeAt(s)) == r.node && (i = s) } this.dragging = new X5(e.slice, e.move, i < 0 ? void 0 : Ct.create(this.state.doc, i)) } someProp(e, n) { let r = this._props && this._props[e], i; if (r != null && (i = n ? n(r) : r)) return i; for (let a = 0; a < this.directPlugins.length; a++) { let l = this.directPlugins[a].props[e]; if (l != null && (i = n ? n(l) : l)) return i } let s = this.state.plugins; if (s) for (let a = 0; a < s.length; a++) { let l = s[a].props[e]; if (l != null && (i = n ? n(l) : l)) return i } } hasFocus() { if (wi) { let e = this.root.activeElement; if (e == this.dom) return !0; if (!e || !this.dom.contains(e)) return !1; for (; e && this.dom != e && this.dom.contains(e);) { if (e.contentEditable == "false") return !1; e = e.parentElement } return !0 } return this.root.activeElement == this.dom } focus() { this.domObserver.stop(), this.editable && zQ(this.dom), Fa(this), this.domObserver.start() } get root() { let e = this._root; if (e == null) { for (let n = this.dom.parentNode; n; n = n.parentNode)if (n.nodeType == 9 || n.nodeType == 11 && n.host) return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n } return e || document } updateRoot() { this._root = null } posAtCoords(e) { return UQ(this, e) } coordsAtPos(e, n = 1) { return A5(this, e, n) } domAtPos(e, n = 0) { return this.docView.domFromPos(e, n) } nodeDOM(e) { let n = this.docView.descAt(e); return n ? n.nodeDOM : null } posAtDOM(e, n, r = -1) { let i = this.docView.posFromDOM(e, n, r); if (i == null) throw new RangeError("DOM position not inside the editor"); return i } endOfTextblock(e, n) { return WQ(this, n || this.state, e) } pasteHTML(e, n) { return Yf(this, "", e, !1, n || new ClipboardEvent("paste")) } pasteText(e, n) { return Yf(this, e, null, !0, n || new ClipboardEvent("paste")) } serializeForClipboard(e) { return US(this, e) } destroy() { this.docView && (SJ(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Hx(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, TQ()) } get isDestroyed() { return this.docView == null } dispatchEvent(e) { return TJ(this, e) } domSelectionRange() { let e = this.domSelection(); return e ? ai && this.root.nodeType === 11 && kQ(this.dom.ownerDocument) == this.dom && WJ(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 } } domSelection() { return this.root.getSelection() } } t_.prototype.dispatch = function (t) { let e = this._props.dispatchTransaction; e ? e.call(this, t) : this.updateState(this.state.apply(t)) }; function o4(t) { let e = Object.create(null); return e.class = "ProseMirror", e.contenteditable = String(t.editable), t.someProp("attributes", n => { if (typeof n == "function" && (n = n(t.state)), n) for (let r in n) r == "class" ? e.class += " " + n[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + n[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(n[r])) }), e.translate || (e.translate = "no"), [si.node(0, t.state.doc.content.size, e)] } function l4(t) { if (t.markCursor) { let e = document.createElement("img"); e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), t.cursorWrapper = { dom: e, deco: si.widget(t.state.selection.from, e, { raw: !0, marks: t.markCursor }) } } else t.cursorWrapper = null } function c4(t) { return !t.someProp("editable", e => e(t.state) === !1) } function nZ(t, e) { let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head)); return t.$anchor.start(n) != e.$anchor.start(n) } function u4(t) { let e = Object.create(null); function n(r) { for (let i in r) Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]) } return t.someProp("nodeViews", n), t.someProp("markViews", n), e } function rZ(t, e) { let n = 0, r = 0; for (let i in t) { if (t[i] != e[i]) return !0; n++ } for (let i in e) r++; return n != r } function d4(t) { if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction) throw new RangeError("Plugins passed directly to the view must not have a state component") } var Vo = { 8: "Backspace", 9: "Tab", 10: "Enter", 12: "NumLock", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 44: "PrintScreen", 45: "Insert", 46: "Delete", 59: ";", 61: "=", 91: "Meta", 92: "Meta", 106: "*", 107: "+", 108: ",", 109: "-", 110: ".", 111: "/", 144: "NumLock", 145: "ScrollLock", 160: "Shift", 161: "Shift", 162: "Control", 163: "Control", 164: "Alt", 165: "Alt", 173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'" }, gg = { 48: ")", 49: "!", 50: "@", 51: "#", 52: "$", 53: "%", 54: "^", 55: "&", 56: "*", 57: "(", 59: ":", 61: "+", 173: "_", 186: ":", 187: "+", 188: "<", 189: "_", 190: ">", 191: "?", 192: "~", 219: "{", 220: "|", 221: "}", 222: '"' }, iZ = typeof navigator < "u" && /Mac/.test(navigator.platform), sZ = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent); for (var Ir = 0; Ir < 10; Ir++)Vo[48 + Ir] = Vo[96 + Ir] = String(Ir); for (var Ir = 1; Ir <= 24; Ir++)Vo[Ir + 111] = "F" + Ir; for (var Ir = 65; Ir <= 90; Ir++)Vo[Ir] = String.fromCharCode(Ir + 32), gg[Ir] = String.fromCharCode(Ir); for (var Kx in Vo) gg.hasOwnProperty(Kx) || (gg[Kx] = Vo[Kx]); function aZ(t) { var e = iZ && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || sZ && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? gg : Vo)[t.keyCode] || t.key || "Unidentified"; return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n } const oZ = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform), lZ = typeof navigator < "u" && /Win/.test(navigator.platform); function cZ(t) { let e = t.split(/-(?!$)/), n = e[e.length - 1]; n == "Space" && (n = " "); let r, i, s, a; for (let l = 0; l < e.length - 1; l++) { let u = e[l]; if (/^(cmd|meta|m)$/i.test(u)) a = !0; else if (/^a(lt)?$/i.test(u)) r = !0; else if (/^(c|ctrl|control)$/i.test(u)) i = !0; else if (/^s(hift)?$/i.test(u)) s = !0; else if (/^mod$/i.test(u)) oZ ? a = !0 : i = !0; else throw new Error("Unrecognized modifier name: " + u) } return r && (n = "Alt-" + n), i && (n = "Ctrl-" + n), a && (n = "Meta-" + n), s && (n = "Shift-" + n), n } function uZ(t) { let e = Object.create(null); for (let n in t) e[cZ(n)] = t[n]; return e } function Wx(t, e, n = !0) { return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n && e.shiftKey && (t = "Shift-" + t), t } function dZ(t) { return new hr({ props: { handleKeyDown: YS(t) } }) } function YS(t) { let e = uZ(t); return function (n, r) { let i = aZ(r), s, a = e[Wx(i, r)]; if (a && a(n.state, n.dispatch, n)) return !0; if (i.length == 1 && i != " ") { if (r.shiftKey) { let l = e[Wx(i, r, !1)]; if (l && l(n.state, n.dispatch, n)) return !0 } if ((r.altKey || r.metaKey || r.ctrlKey) && !(lZ && r.ctrlKey && r.altKey) && (s = Vo[r.keyCode]) && s != i) { let l = e[Wx(s, r)]; if (l && l(n.state, n.dispatch, n)) return !0 } } return !1 } } const GS = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0); function n_(t, e) { let { $cursor: n } = t.selection; return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0) ? null : n } const r_ = (t, e, n) => { let r = n_(t, n); if (!r) return !1; let i = XS(r); if (!i) { let a = r.blockRange(), l = a && _u(a); return l == null ? !1 : (e && e(t.tr.lift(a, l).scrollIntoView()), !0) } let s = i.nodeBefore; if (f_(t, i, e, -1)) return !0; if (r.parent.content.size == 0 && (xu(s, "end") || Ct.isSelectable(s))) for (let a = r.depth; ; a--) { let l = ky(t.doc, r.before(a), r.after(a), nt.empty); if (l && l.slice.size < l.to - l.from) { if (e) { let u = t.tr.step(l); u.setSelection(xu(s, "end") ? Ot.findFrom(u.doc.resolve(u.mapping.map(i.pos, -1)), -1) : Ct.create(u.doc, i.pos - s.nodeSize)), e(u.scrollIntoView()) } return !0 } if (a == 1 || r.node(a - 1).childCount > 1) break } return s.isAtom && i.depth == r.depth - 1 ? (e && e(t.tr.delete(i.pos - s.nodeSize, i.pos).scrollIntoView()), !0) : !1 }, fZ = (t, e, n) => { let r = n_(t, n); if (!r) return !1; let i = XS(r); return i ? i_(t, i, e) : !1 }, hZ = (t, e, n) => { let r = a_(t, n); if (!r) return !1; let i = QS(r); return i ? i_(t, i, e) : !1 }; function i_(t, e, n) { let r = e.nodeBefore, i = r, s = e.pos - 1; for (; !i.isTextblock; s--) { if (i.type.spec.isolating) return !1; let p = i.lastChild; if (!p) return !1; i = p } let a = e.nodeAfter, l = a, u = e.pos + 1; for (; !l.isTextblock; u++) { if (l.type.spec.isolating) return !1; let p = l.firstChild; if (!p) return !1; l = p } let f = ky(t.doc, s, u, nt.empty); if (!f || f.from != s || f instanceof Er && f.slice.size >= u - s) return !1; if (n) { let p = t.tr.step(f); p.setSelection(Et.create(p.doc, s)), n(p.scrollIntoView()) } return !0 } function xu(t, e, n = !1) { for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) { if (r.isTextblock) return !0; if (n && r.childCount != 1) return !1 } return !1 } const s_ = (t, e, n) => { let { $head: r, empty: i } = t.selection, s = r; if (!i) return !1; if (r.parent.isTextblock) { if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0) return !1; s = XS(r) } let a = s && s.nodeBefore; return !a || !Ct.isSelectable(a) ? !1 : (e && e(t.tr.setSelection(Ct.create(t.doc, s.pos - a.nodeSize)).scrollIntoView()), !0) }; function XS(t) { if (!t.parent.type.spec.isolating) for (let e = t.depth - 1; e >= 0; e--) { if (t.index(e) > 0) return t.doc.resolve(t.before(e + 1)); if (t.node(e).type.spec.isolating) break } return null } function a_(t, e) { let { $cursor: n } = t.selection; return !n || (e ? !e.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size) ? null : n } const o_ = (t, e, n) => { let r = a_(t, n); if (!r) return !1; let i = QS(r); if (!i) return !1; let s = i.nodeAfter; if (f_(t, i, e, 1)) return !0; if (r.parent.content.size == 0 && (xu(s, "start") || Ct.isSelectable(s))) { let a = ky(t.doc, r.before(), r.after(), nt.empty); if (a && a.slice.size < a.to - a.from) { if (e) { let l = t.tr.step(a); l.setSelection(xu(s, "start") ? Ot.findFrom(l.doc.resolve(l.mapping.map(i.pos)), 1) : Ct.create(l.doc, l.mapping.map(i.pos))), e(l.scrollIntoView()) } return !0 } } return s.isAtom && i.depth == r.depth - 1 ? (e && e(t.tr.delete(i.pos, i.pos + s.nodeSize).scrollIntoView()), !0) : !1 }, l_ = (t, e, n) => { let { $head: r, empty: i } = t.selection, s = r; if (!i) return !1; if (r.parent.isTextblock) { if (n ? !n.endOfTextblock("forward", t) : r.parentOffset < r.parent.content.size) return !1; s = QS(r) } let a = s && s.nodeAfter; return !a || !Ct.isSelectable(a) ? !1 : (e && e(t.tr.setSelection(Ct.create(t.doc, s.pos)).scrollIntoView()), !0) }; function QS(t) { if (!t.parent.type.spec.isolating) for (let e = t.depth - 1; e >= 0; e--) { let n = t.node(e); if (t.index(e) + 1 < n.childCount) return t.doc.resolve(t.after(e + 1)); if (n.type.spec.isolating) break } return null } const pZ = (t, e) => { let n = t.selection, r = n instanceof Ct, i; if (r) { if (n.node.isTextblock || !Xo(t.doc, n.from)) return !1; i = n.from } else if (i = Ay(t.doc, n.from, -1), i == null) return !1; if (e) { let s = t.tr.join(i); r && s.setSelection(Ct.create(s.doc, i - t.doc.resolve(i).nodeBefore.nodeSize)), e(s.scrollIntoView()) } return !0 }, mZ = (t, e) => { let n = t.selection, r; if (n instanceof Ct) { if (n.node.isTextblock || !Xo(t.doc, n.to)) return !1; r = n.to } else if (r = Ay(t.doc, n.to, 1), r == null) return !1; return e && e(t.tr.join(r).scrollIntoView()), !0 }, gZ = (t, e) => { let { $from: n, $to: r } = t.selection, i = n.blockRange(r), s = i && _u(i); return s == null ? !1 : (e && e(t.tr.lift(i, s).scrollIntoView()), !0) }, c_ = (t, e) => {
    let { $head: n, $anchor: r } = t.selection; return !n.parent.type.spec.code || !n.sameParent(r) ? !1 : (e && e(t.tr.insertText(`
`).scrollIntoView()), !0)
  }; function JS(t) { for (let e = 0; e < t.edgeCount; e++) { let { type: n } = t.edge(e); if (n.isTextblock && !n.hasRequiredAttrs()) return n } return null } const yZ = (t, e) => { let { $head: n, $anchor: r } = t.selection; if (!n.parent.type.spec.code || !n.sameParent(r)) return !1; let i = n.node(-1), s = n.indexAfter(-1), a = JS(i.contentMatchAt(s)); if (!a || !i.canReplaceWith(s, s, a)) return !1; if (e) { let l = n.after(), u = t.tr.replaceWith(l, l, a.createAndFill()); u.setSelection(Ot.near(u.doc.resolve(l), 1)), e(u.scrollIntoView()) } return !0 }, u_ = (t, e) => { let n = t.selection, { $from: r, $to: i } = n; if (n instanceof $i || r.parent.inlineContent || i.parent.inlineContent) return !1; let s = JS(i.parent.contentMatchAt(i.indexAfter())); if (!s || !s.isTextblock) return !1; if (e) { let a = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, l = t.tr.insert(a, s.createAndFill()); l.setSelection(Et.create(l.doc, a + 1)), e(l.scrollIntoView()) } return !0 }, d_ = (t, e) => { let { $cursor: n } = t.selection; if (!n || n.parent.content.size) return !1; if (n.depth > 1 && n.after() != n.end(-1)) { let s = n.before(); if (Ia(t.doc, s)) return e && e(t.tr.split(s).scrollIntoView()), !0 } let r = n.blockRange(), i = r && _u(r); return i == null ? !1 : (e && e(t.tr.lift(r, i).scrollIntoView()), !0) }; function vZ(t) { return (e, n) => { let { $from: r, $to: i } = e.selection; if (e.selection instanceof Ct && e.selection.node.isBlock) return !r.parentOffset || !Ia(e.doc, r.pos) ? !1 : (n && n(e.tr.split(r.pos).scrollIntoView()), !0); if (!r.depth) return !1; let s = [], a, l, u = !1, f = !1; for (let v = r.depth; ; v--)if (r.node(v).isBlock) { u = r.end(v) == r.pos + (r.depth - v), f = r.start(v) == r.pos - (r.depth - v), l = JS(r.node(v - 1).contentMatchAt(r.indexAfter(v - 1))), s.unshift(u && l ? { type: l } : null), a = v; break } else { if (v == 1) return !1; s.unshift(null) } let p = e.tr; (e.selection instanceof Et || e.selection instanceof $i) && p.deleteSelection(); let g = p.mapping.map(r.pos), y = Ia(p.doc, g, s.length, s); if (y || (s[0] = l ? { type: l } : null, y = Ia(p.doc, g, s.length, s)), !y) return !1; if (p.split(g, s.length, s), !u && f && r.node(a).type != l) { let v = p.mapping.map(r.before(a)), b = p.doc.resolve(v); l && r.node(a - 1).canReplaceWith(b.index(), b.index() + 1, l) && p.setNodeMarkup(p.mapping.map(r.before(a)), l) } return n && n(p.scrollIntoView()), !0 } } const xZ = vZ(), bZ = (t, e) => { let { $from: n, to: r } = t.selection, i, s = n.sharedDepth(r); return s == 0 ? !1 : (i = n.before(s), e && e(t.tr.setSelection(Ct.create(t.doc, i))), !0) }; function wZ(t, e, n) { let r = e.nodeBefore, i = e.nodeAfter, s = e.index(); return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && e.parent.canReplace(s - 1, s) ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(s, s + 1) || !(i.isTextblock || Xo(t.doc, e.pos)) ? !1 : (n && n(t.tr.join(e.pos).scrollIntoView()), !0) } function f_(t, e, n, r) { let i = e.nodeBefore, s = e.nodeAfter, a, l, u = i.type.spec.isolating || s.type.spec.isolating; if (!u && wZ(t, e, n)) return !0; let f = !u && e.parent.canReplace(e.index(), e.index() + 1); if (f && (a = (l = i.contentMatchAt(i.childCount)).findWrapping(s.type)) && l.matchType(a[0] || s.type).validEnd) { if (n) { let v = e.pos + s.nodeSize, b = Ue.empty; for (let T = a.length - 1; T >= 0; T--)b = Ue.from(a[T].create(null, b)); b = Ue.from(i.copy(b)); let S = t.tr.step(new Ar(e.pos - 1, v, e.pos, v, new nt(b, 1, 0), a.length, !0)), C = S.doc.resolve(v + 2 * a.length); C.nodeAfter && C.nodeAfter.type == i.type && Xo(S.doc, C.pos) && S.join(C.pos), n(S.scrollIntoView()) } return !0 } let p = s.type.spec.isolating || r > 0 && u ? null : Ot.findFrom(e, 1), g = p && p.$from.blockRange(p.$to), y = g && _u(g); if (y != null && y >= e.depth) return n && n(t.tr.lift(g, y).scrollIntoView()), !0; if (f && xu(s, "start", !0) && xu(i, "end")) { let v = i, b = []; for (; b.push(v), !v.isTextblock;)v = v.lastChild; let S = s, C = 1; for (; !S.isTextblock; S = S.firstChild)C++; if (v.canReplace(v.childCount, v.childCount, S.content)) { if (n) { let T = Ue.empty; for (let M = b.length - 1; M >= 0; M--)T = Ue.from(b[M].copy(T)); let A = t.tr.step(new Ar(e.pos - b.length, e.pos + s.nodeSize, e.pos + C, e.pos + s.nodeSize - C, new nt(T, b.length, 0), 0, !0)); n(A.scrollIntoView()) } return !0 } } return !1 } function h_(t) { return function (e, n) { let r = e.selection, i = t < 0 ? r.$from : r.$to, s = i.depth; for (; i.node(s).isInline;) { if (!s) return !1; s-- } return i.node(s).isTextblock ? (n && n(e.tr.setSelection(Et.create(e.doc, t < 0 ? i.start(s) : i.end(s)))), !0) : !1 } } const SZ = h_(-1), CZ = h_(1); function TZ(t, e = null) { return function (n, r) { let { $from: i, $to: s } = n.selection, a = i.blockRange(s), l = a && PS(a, t, e); return l ? (r && r(n.tr.wrap(a, l).scrollIntoView()), !0) : !1 } } function f4(t, e = null) { return function (n, r) { let i = !1; for (let s = 0; s < n.selection.ranges.length && !i; s++) { let { $from: { pos: a }, $to: { pos: l } } = n.selection.ranges[s]; n.doc.nodesBetween(a, l, (u, f) => { if (i) return !1; if (!(!u.isTextblock || u.hasMarkup(t, e))) if (u.type == t) i = !0; else { let p = n.doc.resolve(f), g = p.index(); i = p.parent.canReplaceWith(g, g + 1, t) } }) } if (!i) return !1; if (r) { let s = n.tr; for (let a = 0; a < n.selection.ranges.length; a++) { let { $from: { pos: l }, $to: { pos: u } } = n.selection.ranges[a]; s.setBlockType(l, u, t, e) } r(s.scrollIntoView()) } return !0 } } function ZS(...t) { return function (e, n, r) { for (let i = 0; i < t.length; i++)if (t[i](e, n, r)) return !0; return !1 } } ZS(GS, r_, s_); ZS(GS, o_, l_); ZS(c_, u_, d_, xZ); typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin"; function NZ(t, e = null) { return function (n, r) { let { $from: i, $to: s } = n.selection, a = i.blockRange(s); if (!a) return !1; let l = r ? n.tr : null; return jZ(l, a, t, e) ? (r && r(l.scrollIntoView()), !0) : !1 } } function jZ(t, e, n, r = null) { let i = !1, s = e, a = e.$from.doc; if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(n) && e.startIndex == 0) { if (e.$from.index(e.depth - 1) == 0) return !1; let u = a.resolve(e.start - 2); s = new cg(u, u, e.depth), e.endIndex < e.parent.childCount && (e = new cg(e.$from, a.resolve(e.$to.end(e.depth)), e.depth)), i = !0 } let l = PS(s, n, r, e); return l ? (t && EZ(t, e, l, i, n), !0) : !1 } function EZ(t, e, n, r, i) { let s = Ue.empty; for (let p = n.length - 1; p >= 0; p--)s = Ue.from(n[p].type.create(n[p].attrs, s)); t.step(new Ar(e.start - (r ? 2 : 0), e.end, e.start, e.end, new nt(s, 0, 0), n.length, !0)); let a = 0; for (let p = 0; p < n.length; p++)n[p].type == i && (a = p + 1); let l = n.length - a, u = e.start + n.length - (r ? 2 : 0), f = e.parent; for (let p = e.startIndex, g = e.endIndex, y = !0; p < g; p++, y = !1)!y && Ia(t.doc, u, l) && (t.split(u, l), u += 2 * l), u += f.child(p).nodeSize; return t } function AZ(t) { return function (e, n) { let { $from: r, $to: i } = e.selection, s = r.blockRange(i, a => a.childCount > 0 && a.firstChild.type == t); return s ? n ? r.node(s.depth - 1).type == t ? kZ(e, n, t, s) : OZ(e, n, s) : !0 : !1 } } function kZ(t, e, n, r) { let i = t.tr, s = r.end, a = r.$to.end(r.depth); s < a && (i.step(new Ar(s - 1, a, s, a, new nt(Ue.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new cg(i.doc.resolve(r.$from.pos), i.doc.resolve(a), r.depth)); const l = _u(r); if (l == null) return !1; i.lift(r, l); let u = i.doc.resolve(i.mapping.map(s, -1) - 1); return Xo(i.doc, u.pos) && u.nodeBefore.type == u.nodeAfter.type && i.join(u.pos), e(i.scrollIntoView()), !0 } function OZ(t, e, n) { let r = t.tr, i = n.parent; for (let v = n.end, b = n.endIndex - 1, S = n.startIndex; b > S; b--)v -= i.child(b).nodeSize, r.delete(v - 1, v + 1); let s = r.doc.resolve(n.start), a = s.nodeAfter; if (r.mapping.map(n.end) != n.start + s.nodeAfter.nodeSize) return !1; let l = n.startIndex == 0, u = n.endIndex == i.childCount, f = s.node(-1), p = s.index(-1); if (!f.canReplace(p + (l ? 0 : 1), p + 1, a.content.append(u ? Ue.empty : Ue.from(i)))) return !1; let g = s.pos, y = g + a.nodeSize; return r.step(new Ar(g - (l ? 1 : 0), y + (u ? 1 : 0), g + 1, y - 1, new nt((l ? Ue.empty : Ue.from(i.copy(Ue.empty))).append(u ? Ue.empty : Ue.from(i.copy(Ue.empty))), l ? 0 : 1, u ? 0 : 1), l ? 0 : 1)), e(r.scrollIntoView()), !0 } function MZ(t) { return function (e, n) { let { $from: r, $to: i } = e.selection, s = r.blockRange(i, f => f.childCount > 0 && f.firstChild.type == t); if (!s) return !1; let a = s.startIndex; if (a == 0) return !1; let l = s.parent, u = l.child(a - 1); if (u.type != t) return !1; if (n) { let f = u.lastChild && u.lastChild.type == l.type, p = Ue.from(f ? t.create() : null), g = new nt(Ue.from(t.create(null, Ue.from(l.type.create(null, p)))), f ? 3 : 1, 0), y = s.start, v = s.end; n(e.tr.step(new Ar(y - (f ? 3 : 1), v, y, v, g, 1, !0)).scrollIntoView()) } return !0 } } function _y(t) { const { state: e, transaction: n } = t; let { selection: r } = n, { doc: i } = n, { storedMarks: s } = n; return { ...e, apply: e.apply.bind(e), applyTransaction: e.applyTransaction.bind(e), plugins: e.plugins, schema: e.schema, reconfigure: e.reconfigure.bind(e), toJSON: e.toJSON.bind(e), get storedMarks() { return s }, get selection() { return r }, get doc() { return i }, get tr() { return r = n.selection, i = n.doc, s = n.storedMarks, n } } } class Ly { constructor(e) { this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state } get hasCustomState() { return !!this.customState } get state() { return this.customState || this.editor.state } get commands() { const { rawCommands: e, editor: n, state: r } = this, { view: i } = n, { tr: s } = r, a = this.buildProps(s); return Object.fromEntries(Object.entries(e).map(([l, u]) => [l, (...p) => { const g = u(...p)(a); return !s.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(s), g }])) } get chain() { return () => this.createChain() } get can() { return () => this.createCan() } createChain(e, n = !0) { const { rawCommands: r, editor: i, state: s } = this, { view: a } = i, l = [], u = !!e, f = e || s.tr, p = () => (!u && n && !f.getMeta("preventDispatch") && !this.hasCustomState && a.dispatch(f), l.every(y => y === !0)), g = { ...Object.fromEntries(Object.entries(r).map(([y, v]) => [y, (...S) => { const C = this.buildProps(f, n), T = v(...S)(C); return l.push(T), g }])), run: p }; return g } createCan(e) { const { rawCommands: n, state: r } = this, i = !1, s = e || r.tr, a = this.buildProps(s, i); return { ...Object.fromEntries(Object.entries(n).map(([u, f]) => [u, (...p) => f(...p)({ ...a, dispatch: void 0 })])), chain: () => this.createChain(s, i) } } buildProps(e, n = !0) { const { rawCommands: r, editor: i, state: s } = this, { view: a } = i, l = { tr: e, editor: i, view: a, state: _y({ state: s, transaction: e }), dispatch: n ? () => { } : void 0, chain: () => this.createChain(e, n), can: () => this.createCan(e), get commands() { return Object.fromEntries(Object.entries(r).map(([u, f]) => [u, (...p) => f(...p)(l)])) } }; return l } } class DZ { constructor() { this.callbacks = {} } on(e, n) { return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(n), this } emit(e, ...n) { const r = this.callbacks[e]; return r && r.forEach(i => i.apply(this, n)), this } off(e, n) { const r = this.callbacks[e]; return r && (n ? this.callbacks[e] = r.filter(i => i !== n) : delete this.callbacks[e]), this } once(e, n) { const r = (...i) => { this.off(e, r), n.apply(this, i) }; return this.on(e, r) } removeAllListeners() { this.callbacks = {} } } function pt(t, e, n) { return t.config[e] === void 0 && t.parent ? pt(t.parent, e, n) : typeof t.config[e] == "function" ? t.config[e].bind({ ...n, parent: t.parent ? pt(t.parent, e, n) : null }) : t.config[e] } function Py(t) { const e = t.filter(i => i.type === "extension"), n = t.filter(i => i.type === "node"), r = t.filter(i => i.type === "mark"); return { baseExtensions: e, nodeExtensions: n, markExtensions: r } } function p_(t) { const e = [], { nodeExtensions: n, markExtensions: r } = Py(t), i = [...n, ...r], s = { default: null, rendered: !0, renderHTML: null, parseHTML: null, keepOnSplit: !0, isRequired: !1 }; return t.forEach(a => { const l = { name: a.name, options: a.options, storage: a.storage, extensions: i }, u = pt(a, "addGlobalAttributes", l); if (!u) return; u().forEach(p => { p.types.forEach(g => { Object.entries(p.attributes).forEach(([y, v]) => { e.push({ type: g, name: y, attribute: { ...s, ...v } }) }) }) }) }), i.forEach(a => { const l = { name: a.name, options: a.options, storage: a.storage }, u = pt(a, "addAttributes", l); if (!u) return; const f = u(); Object.entries(f).forEach(([p, g]) => { const y = { ...s, ...g }; typeof y?.default == "function" && (y.default = y.default()), y?.isRequired && y?.default === void 0 && delete y.default, e.push({ type: a.name, name: p, attribute: y }) }) }), e } function Or(t, e) { if (typeof t == "string") { if (!e.nodes[t]) throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`); return e.nodes[t] } return t } function Ln(...t) { return t.filter(e => !!e).reduce((e, n) => { const r = { ...e }; return Object.entries(n).forEach(([i, s]) => { if (!r[i]) { r[i] = s; return } if (i === "class") { const l = s ? String(s).split(" ") : [], u = r[i] ? r[i].split(" ") : [], f = l.filter(p => !u.includes(p)); r[i] = [...u, ...f].join(" ") } else if (i === "style") { const l = s ? s.split(";").map(p => p.trim()).filter(Boolean) : [], u = r[i] ? r[i].split(";").map(p => p.trim()).filter(Boolean) : [], f = new Map; u.forEach(p => { const [g, y] = p.split(":").map(v => v.trim()); f.set(g, y) }), l.forEach(p => { const [g, y] = p.split(":").map(v => v.trim()); f.set(g, y) }), r[i] = Array.from(f.entries()).map(([p, g]) => `${p}: ${g}`).join("; ") } else r[i] = s }), r }, {}) } function _1(t, e) { return e.filter(n => n.type === t.type.name).filter(n => n.attribute.rendered).map(n => n.attribute.renderHTML ? n.attribute.renderHTML(t.attrs) || {} : { [n.name]: t.attrs[n.name] }).reduce((n, r) => Ln(n, r), {}) } function m_(t) { return typeof t == "function" } function Ut(t, e = void 0, ...n) { return m_(t) ? e ? t.bind(e)(...n) : t(...n) : t } function RZ(t = {}) { return Object.keys(t).length === 0 && t.constructor === Object } function _Z(t) { return typeof t != "string" ? t : t.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(t) : t === "true" ? !0 : t === "false" ? !1 : t } function h4(t, e) { return "style" in t ? t : { ...t, getAttrs: n => { const r = t.getAttrs ? t.getAttrs(n) : t.attrs; if (r === !1) return !1; const i = e.reduce((s, a) => { const l = a.attribute.parseHTML ? a.attribute.parseHTML(n) : _Z(n.getAttribute(a.name)); return l == null ? s : { ...s, [a.name]: l } }, {}); return { ...r, ...i } } } } function p4(t) { return Object.fromEntries(Object.entries(t).filter(([e, n]) => e === "attrs" && RZ(n) ? !1 : n != null)) } function LZ(t, e) { var n; const r = p_(t), { nodeExtensions: i, markExtensions: s } = Py(t), a = (n = i.find(f => pt(f, "topNode"))) === null || n === void 0 ? void 0 : n.name, l = Object.fromEntries(i.map(f => { const p = r.filter(T => T.type === f.name), g = { name: f.name, options: f.options, storage: f.storage, editor: e }, y = t.reduce((T, A) => { const M = pt(A, "extendNodeSchema", g); return { ...T, ...M ? M(f) : {} } }, {}), v = p4({ ...y, content: Ut(pt(f, "content", g)), marks: Ut(pt(f, "marks", g)), group: Ut(pt(f, "group", g)), inline: Ut(pt(f, "inline", g)), atom: Ut(pt(f, "atom", g)), selectable: Ut(pt(f, "selectable", g)), draggable: Ut(pt(f, "draggable", g)), code: Ut(pt(f, "code", g)), whitespace: Ut(pt(f, "whitespace", g)), linebreakReplacement: Ut(pt(f, "linebreakReplacement", g)), defining: Ut(pt(f, "defining", g)), isolating: Ut(pt(f, "isolating", g)), attrs: Object.fromEntries(p.map(T => { var A; return [T.name, { default: (A = T?.attribute) === null || A === void 0 ? void 0 : A.default }] })) }), b = Ut(pt(f, "parseHTML", g)); b && (v.parseDOM = b.map(T => h4(T, p))); const S = pt(f, "renderHTML", g); S && (v.toDOM = T => S({ node: T, HTMLAttributes: _1(T, p) })); const C = pt(f, "renderText", g); return C && (v.toText = C), [f.name, v] })), u = Object.fromEntries(s.map(f => { const p = r.filter(C => C.type === f.name), g = { name: f.name, options: f.options, storage: f.storage, editor: e }, y = t.reduce((C, T) => { const A = pt(T, "extendMarkSchema", g); return { ...C, ...A ? A(f) : {} } }, {}), v = p4({ ...y, inclusive: Ut(pt(f, "inclusive", g)), excludes: Ut(pt(f, "excludes", g)), group: Ut(pt(f, "group", g)), spanning: Ut(pt(f, "spanning", g)), code: Ut(pt(f, "code", g)), attrs: Object.fromEntries(p.map(C => { var T; return [C.name, { default: (T = C?.attribute) === null || T === void 0 ? void 0 : T.default }] })) }), b = Ut(pt(f, "parseHTML", g)); b && (v.parseDOM = b.map(C => h4(C, p))); const S = pt(f, "renderHTML", g); return S && (v.toDOM = C => S({ mark: C, HTMLAttributes: _1(C, p) })), [f.name, v] })); return new r5({ topNode: a, nodes: l, marks: u }) } function Yx(t, e) { return e.nodes[t] || e.marks[t] || null } function m4(t, e) { return Array.isArray(e) ? e.some(n => (typeof n == "string" ? n : n.name) === t.name) : e } function e2(t, e) { const n = hc.fromSchema(e).serializeFragment(t), i = document.implementation.createHTMLDocument().createElement("div"); return i.appendChild(n), i.innerHTML } const PZ = (t, e = 500) => { let n = ""; const r = t.parentOffset; return t.parent.nodesBetween(Math.max(0, r - e), r, (i, s, a, l) => { var u, f; const p = ((f = (u = i.type.spec).toText) === null || f === void 0 ? void 0 : f.call(u, { node: i, pos: s, parent: a, index: l })) || i.textContent || "%leaf%"; n += i.isAtom && !i.isText ? p : p.slice(0, Math.max(0, r - s)) }), n }; function t2(t) { return Object.prototype.toString.call(t) === "[object RegExp]" } class zy { constructor(e) { this.find = e.find, this.handler = e.handler } } const zZ = (t, e) => { if (t2(e)) return e.exec(t); const n = e(t); if (!n) return null; const r = [n.text]; return r.index = n.index, r.input = t, r.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(n.replaceWith)), r }; function Xp(t) { var e; const { editor: n, from: r, to: i, text: s, rules: a, plugin: l } = t, { view: u } = n; if (u.composing) return !1; const f = u.state.doc.resolve(r); if (f.parent.type.spec.code || !((e = f.nodeBefore || f.nodeAfter) === null || e === void 0) && e.marks.find(y => y.type.spec.code)) return !1; let p = !1; const g = PZ(f) + s; return a.forEach(y => { if (p) return; const v = zZ(g, y.find); if (!v) return; const b = u.state.tr, S = _y({ state: u.state, transaction: b }), C = { from: r - (v[0].length - s.length), to: i }, { commands: T, chain: A, can: M } = new Ly({ editor: n, state: S }); y.handler({ state: S, range: C, match: v, commands: T, chain: A, can: M }) === null || !b.steps.length || (b.setMeta(l, { transform: b, from: r, to: i, text: s }), u.dispatch(b), p = !0) }), p } function IZ(t) {
    const { editor: e, rules: n } = t, r = new hr({
      state: { init() { return null }, apply(i, s, a) { const l = i.getMeta(r); if (l) return l; const u = i.getMeta("applyInputRules"); return !!u && setTimeout(() => { let { text: p } = u; typeof p == "string" ? p = p : p = e2(Ue.from(p), a.schema); const { from: g } = u, y = g + p.length; Xp({ editor: e, from: g, to: y, text: p, rules: n, plugin: r }) }), i.selectionSet || i.docChanged ? null : s } }, props: {
        handleTextInput(i, s, a, l) { return Xp({ editor: e, from: s, to: a, text: l, rules: n, plugin: r }) }, handleDOMEvents: { compositionend: i => (setTimeout(() => { const { $cursor: s } = i.state.selection; s && Xp({ editor: e, from: s.pos, to: s.pos, text: "", rules: n, plugin: r }) }), !1) }, handleKeyDown(i, s) {
          if (s.key !== "Enter") return !1; const { $cursor: a } = i.state.selection; return a ? Xp({
            editor: e, from: a.pos, to: a.pos, text: `
`, rules: n, plugin: r
          }) : !1
        }
      }, isInputRules: !0
    }); return r
  } function FZ(t) { return Object.prototype.toString.call(t).slice(8, -1) } function Qp(t) { return FZ(t) !== "Object" ? !1 : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype } function Iy(t, e) { const n = { ...t }; return Qp(t) && Qp(e) && Object.keys(e).forEach(r => { Qp(e[r]) && Qp(t[r]) ? n[r] = Iy(t[r], e[r]) : n[r] = e[r] }), n } class As { constructor(e = {}) { this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = { name: this.name, defaultOptions: {} }, this.config = { ...this.config, ...e }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Ut(pt(this, "addOptions", { name: this.name }))), this.storage = Ut(pt(this, "addStorage", { name: this.name, options: this.options })) || {} } static create(e = {}) { return new As(e) } configure(e = {}) { const n = this.extend({ ...this.config, addOptions: () => Iy(this.options, e) }); return n.name = this.name, n.parent = this.parent, n } extend(e = {}) { const n = new As(e); return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Ut(pt(n, "addOptions", { name: n.name })), n.storage = Ut(pt(n, "addStorage", { name: n.name, options: n.options })), n } static handleExit({ editor: e, mark: n }) { const { tr: r } = e.state, i = e.state.selection.$from; if (i.pos === i.end()) { const a = i.marks(); if (!!!a.find(f => f?.type.name === n.name)) return !1; const u = a.find(f => f?.type.name === n.name); return u && r.removeStoredMark(u), r.insertText(" ", i.pos), e.view.dispatch(r), !0 } return !1 } } function BZ(t) { return typeof t == "number" } class $Z { constructor(e) { this.find = e.find, this.handler = e.handler } } const UZ = (t, e, n) => { if (t2(e)) return [...t.matchAll(e)]; const r = e(t, n); return r ? r.map(i => { const s = [i.text]; return s.index = i.index, s.input = t, s.data = i.data, i.replaceWith && (i.text.includes(i.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), s.push(i.replaceWith)), s }) : [] }; function VZ(t) { const { editor: e, state: n, from: r, to: i, rule: s, pasteEvent: a, dropEvent: l } = t, { commands: u, chain: f, can: p } = new Ly({ editor: e, state: n }), g = []; return n.doc.nodesBetween(r, i, (v, b) => { if (!v.isTextblock || v.type.spec.code) return; const S = Math.max(r, b), C = Math.min(i, b + v.content.size), T = v.textBetween(S - b, C - b, void 0, ""); UZ(T, s.find, a).forEach(M => { if (M.index === void 0) return; const O = S + M.index + 1, E = O + M[0].length, k = { from: n.tr.mapping.map(O), to: n.tr.mapping.map(E) }, z = s.handler({ state: n, range: k, match: M, commands: u, chain: f, can: p, pasteEvent: a, dropEvent: l }); g.push(z) }) }), g.every(v => v !== null) } let Jp = null; const HZ = t => { var e; const n = new ClipboardEvent("paste", { clipboardData: new DataTransfer }); return (e = n.clipboardData) === null || e === void 0 || e.setData("text/html", t), n }; function qZ(t) { const { editor: e, rules: n } = t; let r = null, i = !1, s = !1, a = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, l; try { l = typeof DragEvent < "u" ? new DragEvent("drop") : null } catch { l = null } const u = ({ state: p, from: g, to: y, rule: v, pasteEvt: b }) => { const S = p.tr, C = _y({ state: p, transaction: S }); if (!(!VZ({ editor: e, state: C, from: Math.max(g - 1, 0), to: y.b - 1, rule: v, pasteEvent: b, dropEvent: l }) || !S.steps.length)) { try { l = typeof DragEvent < "u" ? new DragEvent("drop") : null } catch { l = null } return a = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, S } }; return n.map(p => new hr({ view(g) { const y = b => { var S; r = !((S = g.dom.parentElement) === null || S === void 0) && S.contains(b.target) ? g.dom.parentElement : null, r && (Jp = e) }, v = () => { Jp && (Jp = null) }; return window.addEventListener("dragstart", y), window.addEventListener("dragend", v), { destroy() { window.removeEventListener("dragstart", y), window.removeEventListener("dragend", v) } } }, props: { handleDOMEvents: { drop: (g, y) => { if (s = r === g.dom.parentElement, l = y, !s) { const v = Jp; v?.isEditable && setTimeout(() => { const b = v.state.selection; b && v.commands.deleteRange({ from: b.from, to: b.to }) }, 10) } return !1 }, paste: (g, y) => { var v; const b = (v = y.clipboardData) === null || v === void 0 ? void 0 : v.getData("text/html"); return a = y, i = !!b?.includes("data-pm-slice"), !1 } } }, appendTransaction: (g, y, v) => { const b = g[0], S = b.getMeta("uiEvent") === "paste" && !i, C = b.getMeta("uiEvent") === "drop" && !s, T = b.getMeta("applyPasteRules"), A = !!T; if (!S && !C && !A) return; if (A) { let { text: E } = T; typeof E == "string" ? E = E : E = e2(Ue.from(E), v.schema); const { from: k } = T, z = k + E.length, V = HZ(E); return u({ rule: p, state: v, from: k, to: { b: z }, pasteEvt: V }) } const M = y.doc.content.findDiffStart(v.doc.content), O = y.doc.content.findDiffEnd(v.doc.content); if (!(!BZ(M) || !O || M === O.b)) return u({ rule: p, state: v, from: M, to: O, pasteEvt: a }) } })) } function KZ(t) { const e = t.filter((n, r) => t.indexOf(n) !== r); return Array.from(new Set(e)) } class lu { constructor(e, n) { this.splittableMarks = [], this.editor = n, this.extensions = lu.resolve(e), this.schema = LZ(this.extensions, n), this.setupExtensions() } static resolve(e) { const n = lu.sort(lu.flatten(e)), r = KZ(n.map(i => i.name)); return r.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${r.map(i => `'${i}'`).join(", ")}]. This can lead to issues.`), n } static flatten(e) { return e.map(n => { const r = { name: n.name, options: n.options, storage: n.storage }, i = pt(n, "addExtensions", r); return i ? [n, ...this.flatten(i())] : n }).flat(10) } static sort(e) { return e.sort((r, i) => { const s = pt(r, "priority") || 100, a = pt(i, "priority") || 100; return s > a ? -1 : s < a ? 1 : 0 }) } get commands() { return this.extensions.reduce((e, n) => { const r = { name: n.name, options: n.options, storage: n.storage, editor: this.editor, type: Yx(n.name, this.schema) }, i = pt(n, "addCommands", r); return i ? { ...e, ...i() } : e }, {}) } get plugins() { const { editor: e } = this, n = lu.sort([...this.extensions].reverse()), r = [], i = [], s = n.map(a => { const l = { name: a.name, options: a.options, storage: a.storage, editor: e, type: Yx(a.name, this.schema) }, u = [], f = pt(a, "addKeyboardShortcuts", l); let p = {}; if (a.type === "mark" && pt(a, "exitable", l) && (p.ArrowRight = () => As.handleExit({ editor: e, mark: a })), f) { const S = Object.fromEntries(Object.entries(f()).map(([C, T]) => [C, () => T({ editor: e })])); p = { ...p, ...S } } const g = dZ(p); u.push(g); const y = pt(a, "addInputRules", l); m4(a, e.options.enableInputRules) && y && r.push(...y()); const v = pt(a, "addPasteRules", l); m4(a, e.options.enablePasteRules) && v && i.push(...v()); const b = pt(a, "addProseMirrorPlugins", l); if (b) { const S = b(); u.push(...S) } return u }).flat(); return [IZ({ editor: e, rules: r }), ...qZ({ editor: e, rules: i }), ...s] } get attributes() { return p_(this.extensions) } get nodeViews() { const { editor: e } = this, { nodeExtensions: n } = Py(this.extensions); return Object.fromEntries(n.filter(r => !!pt(r, "addNodeView")).map(r => { const i = this.attributes.filter(u => u.type === r.name), s = { name: r.name, options: r.options, storage: r.storage, editor: e, type: Or(r.name, this.schema) }, a = pt(r, "addNodeView", s); if (!a) return []; const l = (u, f, p, g, y) => { const v = _1(u, i); return a()({ node: u, view: f, getPos: p, decorations: g, innerDecorations: y, editor: e, extension: r, HTMLAttributes: v }) }; return [r.name, l] })) } setupExtensions() { this.extensions.forEach(e => { var n; this.editor.extensionStorage[e.name] = e.storage; const r = { name: e.name, options: e.options, storage: e.storage, editor: this.editor, type: Yx(e.name, this.schema) }; e.type === "mark" && (!((n = Ut(pt(e, "keepOnSplit", r))) !== null && n !== void 0) || n) && this.splittableMarks.push(e.name); const i = pt(e, "onBeforeCreate", r), s = pt(e, "onCreate", r), a = pt(e, "onUpdate", r), l = pt(e, "onSelectionUpdate", r), u = pt(e, "onTransaction", r), f = pt(e, "onFocus", r), p = pt(e, "onBlur", r), g = pt(e, "onDestroy", r); i && this.editor.on("beforeCreate", i), s && this.editor.on("create", s), a && this.editor.on("update", a), l && this.editor.on("selectionUpdate", l), u && this.editor.on("transaction", u), f && this.editor.on("focus", f), p && this.editor.on("blur", p), g && this.editor.on("destroy", g) }) } } class Fr { constructor(e = {}) { this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = { name: this.name, defaultOptions: {} }, this.config = { ...this.config, ...e }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Ut(pt(this, "addOptions", { name: this.name }))), this.storage = Ut(pt(this, "addStorage", { name: this.name, options: this.options })) || {} } static create(e = {}) { return new Fr(e) } configure(e = {}) { const n = this.extend({ ...this.config, addOptions: () => Iy(this.options, e) }); return n.name = this.name, n.parent = this.parent, n } extend(e = {}) { const n = new Fr({ ...this.config, ...e }); return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Ut(pt(n, "addOptions", { name: n.name })), n.storage = Ut(pt(n, "addStorage", { name: n.name, options: n.options })), n } } function g_(t, e, n) {
    const { from: r, to: i } = e, { blockSeparator: s = `

`, textSerializers: a = {} } = n || {}; let l = ""; return t.nodesBetween(r, i, (u, f, p, g) => { var y; u.isBlock && f > r && (l += s); const v = a?.[u.type.name]; if (v) return p && (l += v({ node: u, pos: f, parent: p, index: g, range: e })), !1; u.isText && (l += (y = u?.text) === null || y === void 0 ? void 0 : y.slice(Math.max(r, f) - f, i - f)) }), l
  } function y_(t) { return Object.fromEntries(Object.entries(t.nodes).filter(([, e]) => e.spec.toText).map(([e, n]) => [e, n.spec.toText])) } const WZ = Fr.create({ name: "clipboardTextSerializer", addOptions() { return { blockSeparator: void 0 } }, addProseMirrorPlugins() { return [new hr({ key: new Br("clipboardTextSerializer"), props: { clipboardTextSerializer: () => { const { editor: t } = this, { state: e, schema: n } = t, { doc: r, selection: i } = e, { ranges: s } = i, a = Math.min(...s.map(p => p.$from.pos)), l = Math.max(...s.map(p => p.$to.pos)), u = y_(n); return g_(r, { from: a, to: l }, { ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {}, textSerializers: u }) } } })] } }), YZ = () => ({ editor: t, view: e }) => (requestAnimationFrame(() => { var n; t.isDestroyed || (e.dom.blur(), (n = window?.getSelection()) === null || n === void 0 || n.removeAllRanges()) }), !0), GZ = (t = !1) => ({ commands: e }) => e.setContent("", t), XZ = () => ({ state: t, tr: e, dispatch: n }) => { const { selection: r } = e, { ranges: i } = r; return n && i.forEach(({ $from: s, $to: a }) => { t.doc.nodesBetween(s.pos, a.pos, (l, u) => { if (l.type.isText) return; const { doc: f, mapping: p } = e, g = f.resolve(p.map(u)), y = f.resolve(p.map(u + l.nodeSize)), v = g.blockRange(y); if (!v) return; const b = _u(v); if (l.type.isTextblock) { const { defaultType: S } = g.parent.contentMatchAt(g.index()); e.setNodeMarkup(v.start, S) } (b || b === 0) && e.lift(v, b) }) }), !0 }, QZ = t => e => t(e), JZ = () => ({ state: t, dispatch: e }) => u_(t, e), ZZ = (t, e) => ({ editor: n, tr: r }) => { const { state: i } = n, s = i.doc.slice(t.from, t.to); r.deleteRange(t.from, t.to); const a = r.mapping.map(e); return r.insert(a, s.content), r.setSelection(new Et(r.doc.resolve(Math.max(a - 1, 0)))), !0 }, eee = () => ({ tr: t, dispatch: e }) => { const { selection: n } = t, r = n.$anchor.node(); if (r.content.size > 0) return !1; const i = t.selection.$anchor; for (let s = i.depth; s > 0; s -= 1)if (i.node(s).type === r.type) { if (e) { const l = i.before(s), u = i.after(s); t.delete(l, u).scrollIntoView() } return !0 } return !1 }, tee = t => ({ tr: e, state: n, dispatch: r }) => { const i = Or(t, n.schema), s = e.selection.$anchor; for (let a = s.depth; a > 0; a -= 1)if (s.node(a).type === i) { if (r) { const u = s.before(a), f = s.after(a); e.delete(u, f).scrollIntoView() } return !0 } return !1 }, nee = t => ({ tr: e, dispatch: n }) => { const { from: r, to: i } = t; return n && e.delete(r, i), !0 }, ree = () => ({ state: t, dispatch: e }) => GS(t, e), iee = () => ({ commands: t }) => t.keyboardShortcut("Enter"), see = () => ({ state: t, dispatch: e }) => yZ(t, e); function yg(t, e, n = { strict: !0 }) { const r = Object.keys(e); return r.length ? r.every(i => n.strict ? e[i] === t[i] : t2(e[i]) ? e[i].test(t[i]) : e[i] === t[i]) : !0 } function v_(t, e, n = {}) { return t.find(r => r.type === e && yg(Object.fromEntries(Object.keys(n).map(i => [i, r.attrs[i]])), n)) } function g4(t, e, n = {}) { return !!v_(t, e, n) } function n2(t, e, n) { var r; if (!t || !e) return; let i = t.parent.childAfter(t.parentOffset); if ((!i.node || !i.node.marks.some(p => p.type === e)) && (i = t.parent.childBefore(t.parentOffset)), !i.node || !i.node.marks.some(p => p.type === e) || (n = n || ((r = i.node.marks[0]) === null || r === void 0 ? void 0 : r.attrs), !v_([...i.node.marks], e, n))) return; let a = i.index, l = t.start() + i.offset, u = a + 1, f = l + i.node.nodeSize; for (; a > 0 && g4([...t.parent.child(a - 1).marks], e, n);)a -= 1, l -= t.parent.child(a).nodeSize; for (; u < t.parent.childCount && g4([...t.parent.child(u).marks], e, n);)f += t.parent.child(u).nodeSize, u += 1; return { from: l, to: f } } function Jo(t, e) { if (typeof t == "string") { if (!e.marks[t]) throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`); return e.marks[t] } return t } const aee = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => { const s = Jo(t, r.schema), { doc: a, selection: l } = n, { $from: u, from: f, to: p } = l; if (i) { const g = n2(u, s, e); if (g && g.from <= f && g.to >= p) { const y = Et.create(a, g.from, g.to); n.setSelection(y) } } return !0 }, oee = t => e => { const n = typeof t == "function" ? t(e) : t; for (let r = 0; r < n.length; r += 1)if (n[r](e)) return !0; return !1 }; function r2(t) { return t instanceof Et } function La(t = 0, e = 0, n = 0) { return Math.min(Math.max(t, e), n) } function x_(t, e = null) { if (!e) return null; const n = Ot.atStart(t), r = Ot.atEnd(t); if (e === "start" || e === !0) return n; if (e === "end") return r; const i = n.from, s = r.to; return e === "all" ? Et.create(t, La(0, i, s), La(t.content.size, i, s)) : Et.create(t, La(e, i, s), La(e, i, s)) } function lee() { return navigator.platform === "Android" || /android/i.test(navigator.userAgent) } function i2() { return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document } const cee = (t = null, e = {}) => ({ editor: n, view: r, tr: i, dispatch: s }) => { e = { scrollIntoView: !0, ...e }; const a = () => { (i2() || lee()) && r.dom.focus(), requestAnimationFrame(() => { n.isDestroyed || (r.focus(), e?.scrollIntoView && n.commands.scrollIntoView()) }) }; if (r.hasFocus() && t === null || t === !1) return !0; if (s && t === null && !r2(n.state.selection)) return a(), !0; const l = x_(i.doc, t) || n.state.selection, u = n.state.selection.eq(l); return s && (u || i.setSelection(l), u && i.storedMarks && i.setStoredMarks(i.storedMarks), a()), !0 }, uee = (t, e) => n => t.every((r, i) => e(r, { ...n, index: i })), dee = (t, e) => ({ tr: n, commands: r }) => r.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e), b_ = t => { const e = t.childNodes; for (let n = e.length - 1; n >= 0; n -= 1) { const r = e[n]; r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? t.removeChild(r) : r.nodeType === 1 && b_(r) } return t }; function Zp(t) { const e = `<body>${t}</body>`, n = new window.DOMParser().parseFromString(e, "text/html").body; return b_(n) } function Xf(t, e, n) { if (t instanceof Lo || t instanceof Ue) return t; n = { slice: !0, parseOptions: {}, ...n }; const r = typeof t == "object" && t !== null, i = typeof t == "string"; if (r) try { if (Array.isArray(t) && t.length > 0) return Ue.fromArray(t.map(l => e.nodeFromJSON(l))); const a = e.nodeFromJSON(t); return n.errorOnInvalidContent && a.check(), a } catch (s) { if (n.errorOnInvalidContent) throw new Error("[tiptap error]: Invalid JSON content", { cause: s }); return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t, "Error:", s), Xf("", e, n) } if (i) { if (n.errorOnInvalidContent) { let a = !1, l = ""; const u = new r5({ topNode: e.spec.topNode, marks: e.spec.marks, nodes: e.spec.nodes.append({ __tiptap__private__unknown__catch__all__node: { content: "inline*", group: "block", parseDOM: [{ tag: "*", getAttrs: f => (a = !0, l = typeof f == "string" ? f : f.outerHTML, null) }] } }) }); if (n.slice ? hf.fromSchema(u).parseSlice(Zp(t), n.parseOptions) : hf.fromSchema(u).parse(Zp(t), n.parseOptions), n.errorOnInvalidContent && a) throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${l}`) }) } const s = hf.fromSchema(e); return n.slice ? s.parseSlice(Zp(t), n.parseOptions).content : s.parse(Zp(t), n.parseOptions) } return Xf("", e, n) } function fee(t, e, n) { const r = t.steps.length - 1; if (r < e) return; const i = t.steps[r]; if (!(i instanceof Er || i instanceof Ar)) return; const s = t.mapping.maps[r]; let a = 0; s.forEach((l, u, f, p) => { a === 0 && (a = p) }), t.setSelection(Ot.near(t.doc.resolve(a), n)) } const hee = t => !("type" in t), pee = (t, e, n) => ({ tr: r, dispatch: i, editor: s }) => { var a; if (i) { n = { parseOptions: s.options.parseOptions, updateSelection: !0, applyInputRules: !1, applyPasteRules: !1, ...n }; let l; const u = C => { s.emit("contentError", { editor: s, error: C, disableCollaboration: () => { s.storage.collaboration && (s.storage.collaboration.isDisabled = !0) } }) }, f = { preserveWhitespace: "full", ...n.parseOptions }; if (!n.errorOnInvalidContent && !s.options.enableContentCheck && s.options.emitContentError) try { Xf(e, s.schema, { parseOptions: f, errorOnInvalidContent: !0 }) } catch (C) { u(C) } try { l = Xf(e, s.schema, { parseOptions: f, errorOnInvalidContent: (a = n.errorOnInvalidContent) !== null && a !== void 0 ? a : s.options.enableContentCheck }) } catch (C) { return u(C), !1 } let { from: p, to: g } = typeof t == "number" ? { from: t, to: t } : { from: t.from, to: t.to }, y = !0, v = !0; if ((hee(l) ? l : [l]).forEach(C => { C.check(), y = y ? C.isText && C.marks.length === 0 : !1, v = v ? C.isBlock : !1 }), p === g && v) { const { parent: C } = r.doc.resolve(p); C.isTextblock && !C.type.spec.code && !C.childCount && (p -= 1, g += 1) } let S; if (y) { if (Array.isArray(e)) S = e.map(C => C.text || "").join(""); else if (e instanceof Ue) { let C = ""; e.forEach(T => { T.text && (C += T.text) }), S = C } else typeof e == "object" && e && e.text ? S = e.text : S = e; r.insertText(S, p, g) } else S = l, r.replaceWith(p, g, S); n.updateSelection && fee(r, r.steps.length - 1, -1), n.applyInputRules && r.setMeta("applyInputRules", { from: p, text: S }), n.applyPasteRules && r.setMeta("applyPasteRules", { from: p, text: S }) } return !0 }, mee = () => ({ state: t, dispatch: e }) => pZ(t, e), gee = () => ({ state: t, dispatch: e }) => mZ(t, e), yee = () => ({ state: t, dispatch: e }) => r_(t, e), vee = () => ({ state: t, dispatch: e }) => o_(t, e), xee = () => ({ state: t, dispatch: e, tr: n }) => { try { const r = Ay(t.doc, t.selection.$from.pos, -1); return r == null ? !1 : (n.join(r, 2), e && e(n), !0) } catch { return !1 } }, bee = () => ({ state: t, dispatch: e, tr: n }) => { try { const r = Ay(t.doc, t.selection.$from.pos, 1); return r == null ? !1 : (n.join(r, 2), e && e(n), !0) } catch { return !1 } }, wee = () => ({ state: t, dispatch: e }) => fZ(t, e), See = () => ({ state: t, dispatch: e }) => hZ(t, e); function w_() { return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1 } function Cee(t) { const e = t.split(/-(?!$)/); let n = e[e.length - 1]; n === "Space" && (n = " "); let r, i, s, a; for (let l = 0; l < e.length - 1; l += 1) { const u = e[l]; if (/^(cmd|meta|m)$/i.test(u)) a = !0; else if (/^a(lt)?$/i.test(u)) r = !0; else if (/^(c|ctrl|control)$/i.test(u)) i = !0; else if (/^s(hift)?$/i.test(u)) s = !0; else if (/^mod$/i.test(u)) i2() || w_() ? a = !0 : i = !0; else throw new Error(`Unrecognized modifier name: ${u}`) } return r && (n = `Alt-${n}`), i && (n = `Ctrl-${n}`), a && (n = `Meta-${n}`), s && (n = `Shift-${n}`), n } const Tee = t => ({ editor: e, view: n, tr: r, dispatch: i }) => { const s = Cee(t).split(/-(?!$)/), a = s.find(f => !["Alt", "Ctrl", "Meta", "Shift"].includes(f)), l = new KeyboardEvent("keydown", { key: a === "Space" ? " " : a, altKey: s.includes("Alt"), ctrlKey: s.includes("Ctrl"), metaKey: s.includes("Meta"), shiftKey: s.includes("Shift"), bubbles: !0, cancelable: !0 }), u = e.captureTransaction(() => { n.someProp("handleKeyDown", f => f(n, l)) }); return u?.steps.forEach(f => { const p = f.map(r.mapping); p && i && r.maybeStep(p) }), !0 }; function Qf(t, e, n = {}) { const { from: r, to: i, empty: s } = t.selection, a = e ? Or(e, t.schema) : null, l = []; t.doc.nodesBetween(r, i, (g, y) => { if (g.isText) return; const v = Math.max(r, y), b = Math.min(i, y + g.nodeSize); l.push({ node: g, from: v, to: b }) }); const u = i - r, f = l.filter(g => a ? a.name === g.node.type.name : !0).filter(g => yg(g.node.attrs, n, { strict: !1 })); return s ? !!f.length : f.reduce((g, y) => g + y.to - y.from, 0) >= u } const Nee = (t, e = {}) => ({ state: n, dispatch: r }) => { const i = Or(t, n.schema); return Qf(n, i, e) ? gZ(n, r) : !1 }, jee = () => ({ state: t, dispatch: e }) => d_(t, e), Eee = t => ({ state: e, dispatch: n }) => { const r = Or(t, e.schema); return AZ(r)(e, n) }, Aee = () => ({ state: t, dispatch: e }) => c_(t, e); function Fy(t, e) { return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null } function y4(t, e) { const n = typeof e == "string" ? [e] : e; return Object.keys(t).reduce((r, i) => (n.includes(i) || (r[i] = t[i]), r), {}) } const kee = (t, e) => ({ tr: n, state: r, dispatch: i }) => { let s = null, a = null; const l = Fy(typeof t == "string" ? t : t.name, r.schema); return l ? (l === "node" && (s = Or(t, r.schema)), l === "mark" && (a = Jo(t, r.schema)), i && n.selection.ranges.forEach(u => { r.doc.nodesBetween(u.$from.pos, u.$to.pos, (f, p) => { s && s === f.type && n.setNodeMarkup(p, void 0, y4(f.attrs, e)), a && f.marks.length && f.marks.forEach(g => { a === g.type && n.addMark(p, p + f.nodeSize, a.create(y4(g.attrs, e))) }) }) }), !0) : !1 }, Oee = () => ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0), Mee = () => ({ tr: t, dispatch: e }) => { if (e) { const n = new $i(t.doc); t.setSelection(n) } return !0 }, Dee = () => ({ state: t, dispatch: e }) => s_(t, e), Ree = () => ({ state: t, dispatch: e }) => l_(t, e), _ee = () => ({ state: t, dispatch: e }) => bZ(t, e), Lee = () => ({ state: t, dispatch: e }) => CZ(t, e), Pee = () => ({ state: t, dispatch: e }) => SZ(t, e); function L1(t, e, n = {}, r = {}) { return Xf(t, e, { slice: !1, parseOptions: n, errorOnInvalidContent: r.errorOnInvalidContent }) } const zee = (t, e = !1, n = {}, r = {}) => ({ editor: i, tr: s, dispatch: a, commands: l }) => { var u, f; const { doc: p } = s; if (n.preserveWhitespace !== "full") { const g = L1(t, i.schema, n, { errorOnInvalidContent: (u = r.errorOnInvalidContent) !== null && u !== void 0 ? u : i.options.enableContentCheck }); return a && s.replaceWith(0, p.content.size, g).setMeta("preventUpdate", !e), !0 } return a && s.setMeta("preventUpdate", !e), l.insertContentAt({ from: 0, to: p.content.size }, t, { parseOptions: n, errorOnInvalidContent: (f = r.errorOnInvalidContent) !== null && f !== void 0 ? f : i.options.enableContentCheck }) }; function S_(t, e) { const n = Jo(e, t.schema), { from: r, to: i, empty: s } = t.selection, a = []; s ? (t.storedMarks && a.push(...t.storedMarks), a.push(...t.selection.$head.marks())) : t.doc.nodesBetween(r, i, u => { a.push(...u.marks) }); const l = a.find(u => u.type.name === n.name); return l ? { ...l.attrs } : {} } function Iee(t, e) { const n = new zS(t); return e.forEach(r => { r.steps.forEach(i => { n.step(i) }) }), n } function Fee(t) { for (let e = 0; e < t.edgeCount; e += 1) { const { type: n } = t.edge(e); if (n.isTextblock && !n.hasRequiredAttrs()) return n } return null } function Bee(t, e, n) { const r = []; return t.nodesBetween(e.from, e.to, (i, s) => { n(i) && r.push({ node: i, pos: s }) }), r } function C_(t, e) { for (let n = t.depth; n > 0; n -= 1) { const r = t.node(n); if (e(r)) return { pos: n > 0 ? t.before(n) : 0, start: t.start(n), depth: n, node: r } } } function s2(t) { return e => C_(e.$from, t) } function $ee(t, e) { const n = { from: 0, to: t.content.size }; return g_(t, n, e) } function Uee(t, e) { const n = Or(e, t.schema), { from: r, to: i } = t.selection, s = []; t.doc.nodesBetween(r, i, l => { s.push(l) }); const a = s.reverse().find(l => l.type.name === n.name); return a ? { ...a.attrs } : {} } function T_(t, e) { const n = Fy(typeof e == "string" ? e : e.name, t.schema); return n === "node" ? Uee(t, e) : n === "mark" ? S_(t, e) : {} } function Vee(t, e = JSON.stringify) { const n = {}; return t.filter(r => { const i = e(r); return Object.prototype.hasOwnProperty.call(n, i) ? !1 : n[i] = !0 }) } function Hee(t) { const e = Vee(t); return e.length === 1 ? e : e.filter((n, r) => !e.filter((s, a) => a !== r).some(s => n.oldRange.from >= s.oldRange.from && n.oldRange.to <= s.oldRange.to && n.newRange.from >= s.newRange.from && n.newRange.to <= s.newRange.to)) } function qee(t) { const { mapping: e, steps: n } = t, r = []; return e.maps.forEach((i, s) => { const a = []; if (i.ranges.length) i.forEach((l, u) => { a.push({ from: l, to: u }) }); else { const { from: l, to: u } = n[s]; if (l === void 0 || u === void 0) return; a.push({ from: l, to: u }) } a.forEach(({ from: l, to: u }) => { const f = e.slice(s).map(l, -1), p = e.slice(s).map(u), g = e.invert().map(f, -1), y = e.invert().map(p); r.push({ oldRange: { from: g, to: y }, newRange: { from: f, to: p } }) }) }), Hee(r) } function a2(t, e, n) { const r = []; return t === e ? n.resolve(t).marks().forEach(i => { const s = n.resolve(t), a = n2(s, i.type); a && r.push({ mark: i, ...a }) }) : n.nodesBetween(t, e, (i, s) => { !i || i?.nodeSize === void 0 || r.push(...i.marks.map(a => ({ from: s, to: s + i.nodeSize, mark: a }))) }), r } function Mm(t, e, n) { return Object.fromEntries(Object.entries(n).filter(([r]) => { const i = t.find(s => s.type === e && s.name === r); return i ? i.attribute.keepOnSplit : !1 })) } function P1(t, e, n = {}) { const { empty: r, ranges: i } = t.selection, s = e ? Jo(e, t.schema) : null; if (r) return !!(t.storedMarks || t.selection.$from.marks()).filter(g => s ? s.name === g.type.name : !0).find(g => yg(g.attrs, n, { strict: !1 })); let a = 0; const l = []; if (i.forEach(({ $from: g, $to: y }) => { const v = g.pos, b = y.pos; t.doc.nodesBetween(v, b, (S, C) => { if (!S.isText && !S.marks.length) return; const T = Math.max(v, C), A = Math.min(b, C + S.nodeSize), M = A - T; a += M, l.push(...S.marks.map(O => ({ mark: O, from: T, to: A }))) }) }), a === 0) return !1; const u = l.filter(g => s ? s.name === g.mark.type.name : !0).filter(g => yg(g.mark.attrs, n, { strict: !1 })).reduce((g, y) => g + y.to - y.from, 0), f = l.filter(g => s ? g.mark.type !== s && g.mark.type.excludes(s) : !0).reduce((g, y) => g + y.to - y.from, 0); return (u > 0 ? u + f : u) >= a } function Kee(t, e, n = {}) { if (!e) return Qf(t, null, n) || P1(t, null, n); const r = Fy(e, t.schema); return r === "node" ? Qf(t, e, n) : r === "mark" ? P1(t, e, n) : !1 } function v4(t, e) { const { nodeExtensions: n } = Py(e), r = n.find(a => a.name === t); if (!r) return !1; const i = { name: r.name, options: r.options, storage: r.storage }, s = Ut(pt(r, "group", i)); return typeof s != "string" ? !1 : s.split(" ").includes("list") } function o2(t, { checkChildren: e = !0, ignoreWhitespace: n = !1 } = {}) { var r; if (n) { if (t.type.name === "hardBreak") return !0; if (t.isText) return /^\s*$/m.test((r = t.text) !== null && r !== void 0 ? r : "") } if (t.isText) return !t.text; if (t.isAtom || t.isLeaf) return !1; if (t.content.childCount === 0) return !0; if (e) { let i = !0; return t.content.forEach(s => { i !== !1 && (o2(s, { ignoreWhitespace: n, checkChildren: e }) || (i = !1)) }), i } return !1 } function N_(t) { return t instanceof Ct } function Wee(t, e, n) { const i = t.state.doc.content.size, s = La(e, 0, i), a = La(n, 0, i), l = t.coordsAtPos(s), u = t.coordsAtPos(a, -1), f = Math.min(l.top, u.top), p = Math.max(l.bottom, u.bottom), g = Math.min(l.left, u.left), y = Math.max(l.right, u.right), v = y - g, b = p - f, T = { top: f, bottom: p, left: g, right: y, width: v, height: b, x: g, y: f }; return { ...T, toJSON: () => T } } function Yee(t, e, n) { var r; const { selection: i } = e; let s = null; if (r2(i) && (s = i.$cursor), s) { const l = (r = t.storedMarks) !== null && r !== void 0 ? r : s.marks(); return !!n.isInSet(l) || !l.some(u => u.type.excludes(n)) } const { ranges: a } = i; return a.some(({ $from: l, $to: u }) => { let f = l.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1; return t.doc.nodesBetween(l.pos, u.pos, (p, g, y) => { if (f) return !1; if (p.isInline) { const v = !y || y.type.allowsMarkType(n), b = !!n.isInSet(p.marks) || !p.marks.some(S => S.type.excludes(n)); f = v && b } return !f }), f }) } const Gee = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => { const { selection: s } = n, { empty: a, ranges: l } = s, u = Jo(t, r.schema); if (i) if (a) { const f = S_(r, u); n.addStoredMark(u.create({ ...f, ...e })) } else l.forEach(f => { const p = f.$from.pos, g = f.$to.pos; r.doc.nodesBetween(p, g, (y, v) => { const b = Math.max(v, p), S = Math.min(v + y.nodeSize, g); y.marks.find(T => T.type === u) ? y.marks.forEach(T => { u === T.type && n.addMark(b, S, u.create({ ...T.attrs, ...e })) }) : n.addMark(b, S, u.create(e)) }) }); return Yee(r, n, u) }, Xee = (t, e) => ({ tr: n }) => (n.setMeta(t, e), !0), Qee = (t, e = {}) => ({ state: n, dispatch: r, chain: i }) => { const s = Or(t, n.schema); let a; return n.selection.$anchor.sameParent(n.selection.$head) && (a = n.selection.$anchor.parent.attrs), s.isTextblock ? i().command(({ commands: l }) => f4(s, { ...a, ...e })(n) ? !0 : l.clearNodes()).command(({ state: l }) => f4(s, { ...a, ...e })(l, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1) }, Jee = t => ({ tr: e, dispatch: n }) => { if (n) { const { doc: r } = e, i = La(t, 0, r.content.size), s = Ct.create(r, i); e.setSelection(s) } return !0 }, Zee = t => ({ tr: e, dispatch: n }) => { if (n) { const { doc: r } = e, { from: i, to: s } = typeof t == "number" ? { from: t, to: t } : t, a = Et.atStart(r).from, l = Et.atEnd(r).to, u = La(i, a, l), f = La(s, a, l), p = Et.create(r, u, f); e.setSelection(p) } return !0 }, ete = t => ({ state: e, dispatch: n }) => { const r = Or(t, e.schema); return MZ(r)(e, n) }; function x4(t, e) { const n = t.storedMarks || t.selection.$to.parentOffset && t.selection.$from.marks(); if (n) { const r = n.filter(i => e?.includes(i.type.name)); t.tr.ensureMarks(r) } } const tte = ({ keepMarks: t = !0 } = {}) => ({ tr: e, state: n, dispatch: r, editor: i }) => { const { selection: s, doc: a } = e, { $from: l, $to: u } = s, f = i.extensionManager.attributes, p = Mm(f, l.node().type.name, l.node().attrs); if (s instanceof Ct && s.node.isBlock) return !l.parentOffset || !Ia(a, l.pos) ? !1 : (r && (t && x4(n, i.extensionManager.splittableMarks), e.split(l.pos).scrollIntoView()), !0); if (!l.parent.isBlock) return !1; const g = u.parentOffset === u.parent.content.size, y = l.depth === 0 ? void 0 : Fee(l.node(-1).contentMatchAt(l.indexAfter(-1))); let v = g && y ? [{ type: y, attrs: p }] : void 0, b = Ia(e.doc, e.mapping.map(l.pos), 1, v); if (!v && !b && Ia(e.doc, e.mapping.map(l.pos), 1, y ? [{ type: y }] : void 0) && (b = !0, v = y ? [{ type: y, attrs: p }] : void 0), r) { if (b && (s instanceof Et && e.deleteSelection(), e.split(e.mapping.map(l.pos), 1, v), y && !g && !l.parentOffset && l.parent.type !== y)) { const S = e.mapping.map(l.before()), C = e.doc.resolve(S); l.node(-1).canReplaceWith(C.index(), C.index() + 1, y) && e.setNodeMarkup(e.mapping.map(l.before()), y) } t && x4(n, i.extensionManager.splittableMarks), e.scrollIntoView() } return b }, nte = (t, e = {}) => ({ tr: n, state: r, dispatch: i, editor: s }) => { var a; const l = Or(t, r.schema), { $from: u, $to: f } = r.selection, p = r.selection.node; if (p && p.isBlock || u.depth < 2 || !u.sameParent(f)) return !1; const g = u.node(-1); if (g.type !== l) return !1; const y = s.extensionManager.attributes; if (u.parent.content.size === 0 && u.node(-1).childCount === u.indexAfter(-1)) { if (u.depth === 2 || u.node(-3).type !== l || u.index(-2) !== u.node(-2).childCount - 1) return !1; if (i) { let T = Ue.empty; const A = u.index(-1) ? 1 : u.index(-2) ? 2 : 3; for (let V = u.depth - A; V >= u.depth - 3; V -= 1)T = Ue.from(u.node(V).copy(T)); const M = u.indexAfter(-1) < u.node(-2).childCount ? 1 : u.indexAfter(-2) < u.node(-3).childCount ? 2 : 3, O = { ...Mm(y, u.node().type.name, u.node().attrs), ...e }, E = ((a = l.contentMatch.defaultType) === null || a === void 0 ? void 0 : a.createAndFill(O)) || void 0; T = T.append(Ue.from(l.createAndFill(null, E) || void 0)); const k = u.before(u.depth - (A - 1)); n.replace(k, u.after(-M), new nt(T, 4 - A, 0)); let z = -1; n.doc.nodesBetween(k, n.doc.content.size, (V, q) => { if (z > -1) return !1; V.isTextblock && V.content.size === 0 && (z = q + 1) }), z > -1 && n.setSelection(Et.near(n.doc.resolve(z))), n.scrollIntoView() } return !0 } const v = f.pos === u.end() ? g.contentMatchAt(0).defaultType : null, b = { ...Mm(y, g.type.name, g.attrs), ...e }, S = { ...Mm(y, u.node().type.name, u.node().attrs), ...e }; n.delete(u.pos, f.pos); const C = v ? [{ type: l, attrs: b }, { type: v, attrs: S }] : [{ type: l, attrs: b }]; if (!Ia(n.doc, u.pos, 2)) return !1; if (i) { const { selection: T, storedMarks: A } = r, { splittableMarks: M } = s.extensionManager, O = A || T.$to.parentOffset && T.$from.marks(); if (n.split(u.pos, 2, C).scrollIntoView(), !O || !i) return !0; const E = O.filter(k => M.includes(k.type.name)); n.ensureMarks(E) } return !0 }, Gx = (t, e) => { const n = s2(a => a.type === e)(t.selection); if (!n) return !0; const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth); if (r === void 0) return !0; const i = t.doc.nodeAt(r); return n.node.type === i?.type && Xo(t.doc, n.pos) && t.join(n.pos), !0 }, Xx = (t, e) => { const n = s2(a => a.type === e)(t.selection); if (!n) return !0; const r = t.doc.resolve(n.start).after(n.depth); if (r === void 0) return !0; const i = t.doc.nodeAt(r); return n.node.type === i?.type && Xo(t.doc, r) && t.join(r), !0 }, rte = (t, e, n, r = {}) => ({ editor: i, tr: s, state: a, dispatch: l, chain: u, commands: f, can: p }) => { const { extensions: g, splittableMarks: y } = i.extensionManager, v = Or(t, a.schema), b = Or(e, a.schema), { selection: S, storedMarks: C } = a, { $from: T, $to: A } = S, M = T.blockRange(A), O = C || S.$to.parentOffset && S.$from.marks(); if (!M) return !1; const E = s2(k => v4(k.type.name, g))(S); if (M.depth >= 1 && E && M.depth - E.depth <= 1) { if (E.node.type === v) return f.liftListItem(b); if (v4(E.node.type.name, g) && v.validContent(E.node.content) && l) return u().command(() => (s.setNodeMarkup(E.pos, v), !0)).command(() => Gx(s, v)).command(() => Xx(s, v)).run() } return !n || !O || !l ? u().command(() => p().wrapInList(v, r) ? !0 : f.clearNodes()).wrapInList(v, r).command(() => Gx(s, v)).command(() => Xx(s, v)).run() : u().command(() => { const k = p().wrapInList(v, r), z = O.filter(V => y.includes(V.type.name)); return s.ensureMarks(z), k ? !0 : f.clearNodes() }).wrapInList(v, r).command(() => Gx(s, v)).command(() => Xx(s, v)).run() }, ite = (t, e = {}, n = {}) => ({ state: r, commands: i }) => { const { extendEmptyMarkRange: s = !1 } = n, a = Jo(t, r.schema); return P1(r, a, e) ? i.unsetMark(a, { extendEmptyMarkRange: s }) : i.setMark(a, e) }, ste = (t, e, n = {}) => ({ state: r, commands: i }) => { const s = Or(t, r.schema), a = Or(e, r.schema), l = Qf(r, s, n); let u; return r.selection.$anchor.sameParent(r.selection.$head) && (u = r.selection.$anchor.parent.attrs), l ? i.setNode(a, u) : i.setNode(s, { ...u, ...n }) }, ate = (t, e = {}) => ({ state: n, commands: r }) => { const i = Or(t, n.schema); return Qf(n, i, e) ? r.lift(i) : r.wrapIn(i, e) }, ote = () => ({ state: t, dispatch: e }) => { const n = t.plugins; for (let r = 0; r < n.length; r += 1) { const i = n[r]; let s; if (i.spec.isInputRules && (s = i.getState(t))) { if (e) { const a = t.tr, l = s.transform; for (let u = l.steps.length - 1; u >= 0; u -= 1)a.step(l.steps[u].invert(l.docs[u])); if (s.text) { const u = a.doc.resolve(s.from).marks(); a.replaceWith(s.from, s.to, t.schema.text(s.text, u)) } else a.delete(s.from, s.to) } return !0 } } return !1 }, lte = () => ({ tr: t, dispatch: e }) => { const { selection: n } = t, { empty: r, ranges: i } = n; return r || e && i.forEach(s => { t.removeMark(s.$from.pos, s.$to.pos) }), !0 }, cte = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => { var s; const { extendEmptyMarkRange: a = !1 } = e, { selection: l } = n, u = Jo(t, r.schema), { $from: f, empty: p, ranges: g } = l; if (!i) return !0; if (p && a) { let { from: y, to: v } = l; const b = (s = f.marks().find(C => C.type === u)) === null || s === void 0 ? void 0 : s.attrs, S = n2(f, u, b); S && (y = S.from, v = S.to), n.removeMark(y, v, u) } else g.forEach(y => { n.removeMark(y.$from.pos, y.$to.pos, u) }); return n.removeStoredMark(u), !0 }, ute = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => { let s = null, a = null; const l = Fy(typeof t == "string" ? t : t.name, r.schema); return l ? (l === "node" && (s = Or(t, r.schema)), l === "mark" && (a = Jo(t, r.schema)), i && n.selection.ranges.forEach(u => { const f = u.$from.pos, p = u.$to.pos; let g, y, v, b; n.selection.empty ? r.doc.nodesBetween(f, p, (S, C) => { s && s === S.type && (v = Math.max(C, f), b = Math.min(C + S.nodeSize, p), g = C, y = S) }) : r.doc.nodesBetween(f, p, (S, C) => { C < f && s && s === S.type && (v = Math.max(C, f), b = Math.min(C + S.nodeSize, p), g = C, y = S), C >= f && C <= p && (s && s === S.type && n.setNodeMarkup(C, void 0, { ...S.attrs, ...e }), a && S.marks.length && S.marks.forEach(T => { if (a === T.type) { const A = Math.max(C, f), M = Math.min(C + S.nodeSize, p); n.addMark(A, M, a.create({ ...T.attrs, ...e })) } })) }), y && (g !== void 0 && n.setNodeMarkup(g, void 0, { ...y.attrs, ...e }), a && y.marks.length && y.marks.forEach(S => { a === S.type && n.addMark(v, b, a.create({ ...S.attrs, ...e })) })) }), !0) : !1 }, dte = (t, e = {}) => ({ state: n, dispatch: r }) => { const i = Or(t, n.schema); return TZ(i, e)(n, r) }, fte = (t, e = {}) => ({ state: n, dispatch: r }) => { const i = Or(t, n.schema); return NZ(i, e)(n, r) }; var hte = Object.freeze({ __proto__: null, blur: YZ, clearContent: GZ, clearNodes: XZ, command: QZ, createParagraphNear: JZ, cut: ZZ, deleteCurrentNode: eee, deleteNode: tee, deleteRange: nee, deleteSelection: ree, enter: iee, exitCode: see, extendMarkRange: aee, first: oee, focus: cee, forEach: uee, insertContent: dee, insertContentAt: pee, joinBackward: yee, joinDown: gee, joinForward: vee, joinItemBackward: xee, joinItemForward: bee, joinTextblockBackward: wee, joinTextblockForward: See, joinUp: mee, keyboardShortcut: Tee, lift: Nee, liftEmptyBlock: jee, liftListItem: Eee, newlineInCode: Aee, resetAttributes: kee, scrollIntoView: Oee, selectAll: Mee, selectNodeBackward: Dee, selectNodeForward: Ree, selectParentNode: _ee, selectTextblockEnd: Lee, selectTextblockStart: Pee, setContent: zee, setMark: Gee, setMeta: Xee, setNode: Qee, setNodeSelection: Jee, setTextSelection: Zee, sinkListItem: ete, splitBlock: tte, splitListItem: nte, toggleList: rte, toggleMark: ite, toggleNode: ste, toggleWrap: ate, undoInputRule: ote, unsetAllMarks: lte, unsetMark: cte, updateAttributes: ute, wrapIn: dte, wrapInList: fte }); const pte = Fr.create({ name: "commands", addCommands() { return { ...hte } } }), mte = Fr.create({ name: "drop", addProseMirrorPlugins() { return [new hr({ key: new Br("tiptapDrop"), props: { handleDrop: (t, e, n, r) => { this.editor.emit("drop", { editor: this.editor, event: e, slice: n, moved: r }) } } })] } }), gte = Fr.create({ name: "editable", addProseMirrorPlugins() { return [new hr({ key: new Br("editable"), props: { editable: () => this.editor.options.editable } })] } }), yte = new Br("focusEvents"), vte = Fr.create({ name: "focusEvents", addProseMirrorPlugins() { const { editor: t } = this; return [new hr({ key: yte, props: { handleDOMEvents: { focus: (e, n) => { t.isFocused = !0; const r = t.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1); return e.dispatch(r), !1 }, blur: (e, n) => { t.isFocused = !1; const r = t.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1); return e.dispatch(r), !1 } } } })] } }), xte = Fr.create({ name: "keymap", addKeyboardShortcuts() { const t = () => this.editor.commands.first(({ commands: a }) => [() => a.undoInputRule(), () => a.command(({ tr: l }) => { const { selection: u, doc: f } = l, { empty: p, $anchor: g } = u, { pos: y, parent: v } = g, b = g.parent.isTextblock && y > 0 ? l.doc.resolve(y - 1) : g, S = b.parent.type.spec.isolating, C = g.pos - g.parentOffset, T = S && b.parent.childCount === 1 ? C === g.pos : Ot.atStart(f).from === y; return !p || !v.type.isTextblock || v.textContent.length || !T || T && g.parent.type.name === "paragraph" ? !1 : a.clearNodes() }), () => a.deleteSelection(), () => a.joinBackward(), () => a.selectNodeBackward()]), e = () => this.editor.commands.first(({ commands: a }) => [() => a.deleteSelection(), () => a.deleteCurrentNode(), () => a.joinForward(), () => a.selectNodeForward()]), r = { Enter: () => this.editor.commands.first(({ commands: a }) => [() => a.newlineInCode(), () => a.createParagraphNear(), () => a.liftEmptyBlock(), () => a.splitBlock()]), "Mod-Enter": () => this.editor.commands.exitCode(), Backspace: t, "Mod-Backspace": t, "Shift-Backspace": t, Delete: e, "Mod-Delete": e, "Mod-a": () => this.editor.commands.selectAll() }, i = { ...r }, s = { ...r, "Ctrl-h": t, "Alt-Backspace": t, "Ctrl-d": e, "Ctrl-Alt-Backspace": e, "Alt-Delete": e, "Alt-d": e, "Ctrl-a": () => this.editor.commands.selectTextblockStart(), "Ctrl-e": () => this.editor.commands.selectTextblockEnd() }; return i2() || w_() ? s : i }, addProseMirrorPlugins() { return [new hr({ key: new Br("clearDocument"), appendTransaction: (t, e, n) => { if (t.some(S => S.getMeta("composition"))) return; const r = t.some(S => S.docChanged) && !e.doc.eq(n.doc), i = t.some(S => S.getMeta("preventClearDocument")); if (!r || i) return; const { empty: s, from: a, to: l } = e.selection, u = Ot.atStart(e.doc).from, f = Ot.atEnd(e.doc).to; if (s || !(a === u && l === f) || !o2(n.doc)) return; const y = n.tr, v = _y({ state: n, transaction: y }), { commands: b } = new Ly({ editor: this.editor, state: v }); if (b.clearNodes(), !!y.steps.length) return y } })] } }), bte = Fr.create({ name: "paste", addProseMirrorPlugins() { return [new hr({ key: new Br("tiptapPaste"), props: { handlePaste: (t, e, n) => { this.editor.emit("paste", { editor: this.editor, event: e, slice: n }) } } })] } }), wte = Fr.create({ name: "tabindex", addProseMirrorPlugins() { return [new hr({ key: new Br("tabindex"), props: { attributes: () => this.editor.isEditable ? { tabindex: "0" } : {} } })] } }); class jl { get name() { return this.node.type.name } constructor(e, n, r = !1, i = null) { this.currentNode = null, this.actualDepth = null, this.isBlock = r, this.resolvedPos = e, this.editor = n, this.currentNode = i } get node() { return this.currentNode || this.resolvedPos.node() } get element() { return this.editor.view.domAtPos(this.pos).node } get depth() { var e; return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth } get pos() { return this.resolvedPos.pos } get content() { return this.node.content } set content(e) { let n = this.from, r = this.to; if (this.isBlock) { if (this.content.size === 0) { console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`); return } n = this.from + 1, r = this.to - 1 } this.editor.commands.insertContentAt({ from: n, to: r }, e) } get attributes() { return this.node.attrs } get textContent() { return this.node.textContent } get size() { return this.node.nodeSize } get from() { return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth) } get range() { return { from: this.from, to: this.to } } get to() { return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1) } get parent() { if (this.depth === 0) return null; const e = this.resolvedPos.start(this.resolvedPos.depth - 1), n = this.resolvedPos.doc.resolve(e); return new jl(n, this.editor) } get before() { let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2)); return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new jl(e, this.editor) } get after() { let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1)); return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new jl(e, this.editor) } get children() { const e = []; return this.node.content.forEach((n, r) => { const i = n.isBlock && !n.isTextblock, s = n.isAtom && !n.isText, a = this.pos + r + (s ? 0 : 1); if (a < 0 || a > this.resolvedPos.doc.nodeSize - 2) return; const l = this.resolvedPos.doc.resolve(a); if (!i && l.depth <= this.depth) return; const u = new jl(l, this.editor, i, i ? n : null); i && (u.actualDepth = this.depth + 1), e.push(new jl(l, this.editor, i, i ? n : null)) }), e } get firstChild() { return this.children[0] || null } get lastChild() { const e = this.children; return e[e.length - 1] || null } closest(e, n = {}) { let r = null, i = this.parent; for (; i && !r;) { if (i.node.type.name === e) if (Object.keys(n).length > 0) { const s = i.node.attrs, a = Object.keys(n); for (let l = 0; l < a.length; l += 1) { const u = a[l]; if (s[u] !== n[u]) break } } else r = i; i = i.parent } return r } querySelector(e, n = {}) { return this.querySelectorAll(e, n, !0)[0] || null } querySelectorAll(e, n = {}, r = !1) { let i = []; if (!this.children || this.children.length === 0) return i; const s = Object.keys(n); return this.children.forEach(a => { r && i.length > 0 || (a.node.type.name === e && s.every(u => n[u] === a.node.attrs[u]) && i.push(a), !(r && i.length > 0) && (i = i.concat(a.querySelectorAll(e, n, r)))) }), i } setAttribute(e) { const { tr: n } = this.editor.state; n.setNodeMarkup(this.from, void 0, { ...this.node.attrs, ...e }), this.editor.view.dispatch(n) } } const Ste = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`; function Cte(t, e, n) { const r = document.querySelector("style[data-tiptap-style]"); if (r !== null) return r; const i = document.createElement("style"); return e && i.setAttribute("nonce", e), i.setAttribute("data-tiptap-style", ""), i.innerHTML = t, document.getElementsByTagName("head")[0].appendChild(i), i } class Tte extends DZ {
    constructor(e = {}) { super(), this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.options = { element: document.createElement("div"), content: "", injectCSS: !0, injectNonce: void 0, extensions: [], autofocus: !1, editable: !0, editorProps: {}, parseOptions: {}, coreExtensionOptions: {}, enableInputRules: !0, enablePasteRules: !0, enableCoreExtensions: !0, enableContentCheck: !1, emitContentError: !1, onBeforeCreate: () => null, onCreate: () => null, onUpdate: () => null, onSelectionUpdate: () => null, onTransaction: () => null, onFocus: () => null, onBlur: () => null, onDestroy: () => null, onContentError: ({ error: n }) => { throw n }, onPaste: () => null, onDrop: () => null }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: n, slice: r, moved: i }) => this.options.onDrop(n, r, i)), this.on("paste", ({ event: n, slice: r }) => this.options.onPaste(n, r)), window.setTimeout(() => { this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0) }, 0) } get storage() { return this.extensionStorage } get commands() { return this.commandManager.commands } chain() { return this.commandManager.chain() } can() { return this.commandManager.can() } injectCSS() { this.options.injectCSS && document && (this.css = Cte(Ste, this.options.injectNonce)) } setOptions(e = {}) { this.options = { ...this.options, ...e }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state)) } setEditable(e, n = !0) { this.setOptions({ editable: e }), n && this.emit("update", { editor: this, transaction: this.state.tr }) } get isEditable() { return this.options.editable && this.view && this.view.editable } get state() { return this.view.state } registerPlugin(e, n) { const r = m_(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e], i = this.state.reconfigure({ plugins: r }); return this.view.updateState(i), i } unregisterPlugin(e) { if (this.isDestroyed) return; const n = this.state.plugins; let r = n; if ([].concat(e).forEach(s => { const a = typeof s == "string" ? `${s}$` : s.key; r = r.filter(l => !l.key.startsWith(a)) }), n.length === r.length) return; const i = this.state.reconfigure({ plugins: r }); return this.view.updateState(i), i } createExtensionManager() { var e, n; const i = [...this.options.enableCoreExtensions ? [gte, WZ.configure({ blockSeparator: (n = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || n === void 0 ? void 0 : n.blockSeparator }), pte, vte, xte, wte, mte, bte].filter(s => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[s.name] !== !1 : !0) : [], ...this.options.extensions].filter(s => ["extension", "node", "mark"].includes(s?.type)); this.extensionManager = new lu(i, this) } createCommandManager() { this.commandManager = new Ly({ editor: this }) } createSchema() { this.schema = this.extensionManager.schema } createView() { var e; let n; try { n = L1(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck }) } catch (a) { if (!(a instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(a.message)) throw a; this.emit("contentError", { editor: this, error: a, disableCollaboration: () => { this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter(l => l.name !== "collaboration"), this.createExtensionManager() } }), n = L1(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: !1 }) } const r = x_(n, this.options.autofocus); this.view = new t_(this.options.element, { ...this.options.editorProps, attributes: { role: "textbox", ...(e = this.options.editorProps) === null || e === void 0 ? void 0 : e.attributes }, dispatchTransaction: this.dispatchTransaction.bind(this), state: ou.create({ doc: n, selection: r || void 0 }) }); const i = this.state.reconfigure({ plugins: this.extensionManager.plugins }); this.view.updateState(i), this.createNodeViews(), this.prependClass(); const s = this.view.dom; s.editor = this } createNodeViews() { this.view.isDestroyed || this.view.setProps({ nodeViews: this.extensionManager.nodeViews }) } prependClass() { this.view.dom.className = `tiptap ${this.view.dom.className}` } captureTransaction(e) { this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1; const n = this.capturedTransaction; return this.capturedTransaction = null, n } dispatchTransaction(e) { if (this.view.isDestroyed) return; if (this.isCapturingTransaction) { if (!this.capturedTransaction) { this.capturedTransaction = e; return } e.steps.forEach(a => { var l; return (l = this.capturedTransaction) === null || l === void 0 ? void 0 : l.step(a) }); return } const n = this.state.apply(e), r = !this.state.selection.eq(n.selection); this.emit("beforeTransaction", { editor: this, transaction: e, nextState: n }), this.view.updateState(n), this.emit("transaction", { editor: this, transaction: e }), r && this.emit("selectionUpdate", { editor: this, transaction: e }); const i = e.getMeta("focus"), s = e.getMeta("blur"); i && this.emit("focus", { editor: this, event: i.event, transaction: e }), s && this.emit("blur", { editor: this, event: s.event, transaction: e }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", { editor: this, transaction: e }) } getAttributes(e) { return T_(this.state, e) } isActive(e, n) { const r = typeof e == "string" ? e : null, i = typeof e == "string" ? n : e; return Kee(this.state, r, i) } getJSON() { return this.state.doc.toJSON() } getHTML() { return e2(this.state.doc.content, this.schema) } getText(e) {
      const { blockSeparator: n = `

`, textSerializers: r = {} } = e || {}; return $ee(this.state.doc, { blockSeparator: n, textSerializers: { ...y_(this.schema), ...r } })
    } get isEmpty() { return o2(this.state.doc) } getCharacterCount() { return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2 } destroy() { if (this.emit("destroy"), this.view) { const e = this.view.dom; e && e.editor && delete e.editor, this.view.destroy() } this.removeAllListeners() } get isDestroyed() { var e; return !(!((e = this.view) === null || e === void 0) && e.docView) } $node(e, n) { var r; return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelector(e, n)) || null } $nodes(e, n) { var r; return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelectorAll(e, n)) || null } $pos(e) { const n = this.state.doc.resolve(e); return new jl(n, this) } get $doc() { return this.$pos(0) }
  } function bu(t) { return new zy({ find: t.find, handler: ({ state: e, range: n, match: r }) => { const i = Ut(t.getAttributes, void 0, r); if (i === !1 || i === null) return null; const { tr: s } = e, a = r[r.length - 1], l = r[0]; if (a) { const u = l.search(/\S/), f = n.from + l.indexOf(a), p = f + a.length; if (a2(n.from, n.to, e.doc).filter(v => v.mark.type.excluded.find(S => S === t.type && S !== v.mark.type)).filter(v => v.to > f).length) return null; p < n.to && s.delete(p, n.to), f > n.from && s.delete(n.from + u, f); const y = n.from + u + a.length; s.addMark(n.from + u, y, t.type.create(i || {})), s.removeStoredMark(t.type) } } }) } function j_(t) { return new zy({ find: t.find, handler: ({ state: e, range: n, match: r }) => { const i = Ut(t.getAttributes, void 0, r) || {}, { tr: s } = e, a = n.from; let l = n.to; const u = t.type.create(i); if (r[1]) { const f = r[0].lastIndexOf(r[1]); let p = a + f; p > l ? p = l : l = p + r[1].length; const g = r[0][r[0].length - 1]; s.insertText(g, a + r[0].length - 1), s.replaceWith(p, l, u) } else if (r[0]) { const f = t.type.isInline ? a : a - 1; s.insert(f, t.type.create(i)).delete(s.mapping.map(a), s.mapping.map(l)) } s.scrollIntoView() } }) } function z1(t) { return new zy({ find: t.find, handler: ({ state: e, range: n, match: r }) => { const i = e.doc.resolve(n.from), s = Ut(t.getAttributes, void 0, r) || {}; if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), t.type)) return null; e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, s) } }) } function Jf(t) { return new zy({ find: t.find, handler: ({ state: e, range: n, match: r, chain: i }) => { const s = Ut(t.getAttributes, void 0, r) || {}, a = e.tr.delete(n.from, n.to), u = a.doc.resolve(n.from).blockRange(), f = u && PS(u, t.type, s); if (!f) return null; if (a.wrap(u, f), t.keepMarks && t.editor) { const { selection: g, storedMarks: y } = e, { splittableMarks: v } = t.editor.extensionManager, b = y || g.$to.parentOffset && g.$from.marks(); if (b) { const S = b.filter(C => v.includes(C.type.name)); a.ensureMarks(S) } } if (t.keepAttributes) { const g = t.type.name === "bulletList" || t.type.name === "orderedList" ? "listItem" : "taskList"; i().updateAttributes(g, s).run() } const p = a.doc.resolve(n.from - 1).nodeBefore; p && p.type === t.type && Xo(a.doc, n.from - 1) && (!t.joinPredicate || t.joinPredicate(r, p)) && a.join(n.from - 1) } }) } class Qn { constructor(e = {}) { this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = { name: this.name, defaultOptions: {} }, this.config = { ...this.config, ...e }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = Ut(pt(this, "addOptions", { name: this.name }))), this.storage = Ut(pt(this, "addStorage", { name: this.name, options: this.options })) || {} } static create(e = {}) { return new Qn(e) } configure(e = {}) { const n = this.extend({ ...this.config, addOptions: () => Iy(this.options, e) }); return n.name = this.name, n.parent = this.parent, n } extend(e = {}) { const n = new Qn(e); return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = Ut(pt(n, "addOptions", { name: n.name })), n.storage = Ut(pt(n, "addStorage", { name: n.name, options: n.options })), n } } function rc(t) { return new $Z({ find: t.find, handler: ({ state: e, range: n, match: r, pasteEvent: i }) => { const s = Ut(t.getAttributes, void 0, r, i); if (s === !1 || s === null) return null; const { tr: a } = e, l = r[r.length - 1], u = r[0]; let f = n.to; if (l) { const p = u.search(/\S/), g = n.from + u.indexOf(l), y = g + l.length; if (a2(n.from, n.to, e.doc).filter(b => b.mark.type.excluded.find(C => C === t.type && C !== b.mark.type)).filter(b => b.to > g).length) return null; y < n.to && a.delete(y, n.to), g > n.from && a.delete(n.from + p, g), f = n.from + p + l.length, a.addMark(n.from + p, f, t.type.create(s || {})), a.removeStoredMark(t.type) } } }) } function Nte(t, e) { const { selection: n } = t, { $from: r } = n; if (n instanceof Ct) { const s = r.index(); return r.parent.canReplaceWith(s, s + 1, e) } let i = r.depth; for (; i >= 0;) { const s = r.index(i); if (r.node(i).contentMatchAt(s).matchType(e)) return !0; i -= 1 } return !1 } var Si = "top", fs = "bottom", hs = "right", Ci = "left", l2 = "auto", Ch = [Si, fs, hs, Ci], wu = "start", Zf = "end", jte = "clippingParents", E_ = "viewport", Vd = "popper", Ete = "reference", b4 = Ch.reduce(function (t, e) { return t.concat([e + "-" + wu, e + "-" + Zf]) }, []), A_ = [].concat(Ch, [l2]).reduce(function (t, e) { return t.concat([e, e + "-" + wu, e + "-" + Zf]) }, []), Ate = "beforeRead", kte = "read", Ote = "afterRead", Mte = "beforeMain", Dte = "main", Rte = "afterMain", _te = "beforeWrite", Lte = "write", Pte = "afterWrite", zte = [Ate, kte, Ote, Mte, Dte, Rte, _te, Lte, Pte]; function sa(t) { return t ? (t.nodeName || "").toLowerCase() : null } function Ui(t) { if (t == null) return window; if (t.toString() !== "[object Window]") { var e = t.ownerDocument; return e && e.defaultView || window } return t } function ic(t) { var e = Ui(t).Element; return t instanceof e || t instanceof Element } function us(t) { var e = Ui(t).HTMLElement; return t instanceof e || t instanceof HTMLElement } function c2(t) { if (typeof ShadowRoot > "u") return !1; var e = Ui(t).ShadowRoot; return t instanceof e || t instanceof ShadowRoot } function Ite(t) { var e = t.state; Object.keys(e.elements).forEach(function (n) { var r = e.styles[n] || {}, i = e.attributes[n] || {}, s = e.elements[n]; !us(s) || !sa(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function (a) { var l = i[a]; l === !1 ? s.removeAttribute(a) : s.setAttribute(a, l === !0 ? "" : l) })) }) } function Fte(t) { var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function () { Object.keys(e.elements).forEach(function (r) { var i = e.elements[r], s = e.attributes[r] || {}, a = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), l = a.reduce(function (u, f) { return u[f] = "", u }, {}); !us(i) || !sa(i) || (Object.assign(i.style, l), Object.keys(s).forEach(function (u) { i.removeAttribute(u) })) }) } } const k_ = { name: "applyStyles", enabled: !0, phase: "write", fn: Ite, effect: Fte, requires: ["computeStyles"] }; function ea(t) { return t.split("-")[0] } var Kl = Math.max, vg = Math.min, Su = Math.round; function I1() { var t = navigator.userAgentData; return t != null && t.brands && Array.isArray(t.brands) ? t.brands.map(function (e) { return e.brand + "/" + e.version }).join(" ") : navigator.userAgent } function O_() { return !/^((?!chrome|android).)*safari/i.test(I1()) } function Cu(t, e, n) { e === void 0 && (e = !1), n === void 0 && (n = !1); var r = t.getBoundingClientRect(), i = 1, s = 1; e && us(t) && (i = t.offsetWidth > 0 && Su(r.width) / t.offsetWidth || 1, s = t.offsetHeight > 0 && Su(r.height) / t.offsetHeight || 1); var a = ic(t) ? Ui(t) : window, l = a.visualViewport, u = !O_() && n, f = (r.left + (u && l ? l.offsetLeft : 0)) / i, p = (r.top + (u && l ? l.offsetTop : 0)) / s, g = r.width / i, y = r.height / s; return { width: g, height: y, top: p, right: f + g, bottom: p + y, left: f, x: f, y: p } } function u2(t) { var e = Cu(t), n = t.offsetWidth, r = t.offsetHeight; return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r } } function M_(t, e) { var n = e.getRootNode && e.getRootNode(); if (t.contains(e)) return !0; if (n && c2(n)) { var r = e; do { if (r && t.isSameNode(r)) return !0; r = r.parentNode || r.host } while (r) } return !1 } function Va(t) { return Ui(t).getComputedStyle(t) } function Bte(t) { return ["table", "td", "th"].indexOf(sa(t)) >= 0 } function Zo(t) { return ((ic(t) ? t.ownerDocument : t.document) || window.document).documentElement } function By(t) { return sa(t) === "html" ? t : t.assignedSlot || t.parentNode || (c2(t) ? t.host : null) || Zo(t) } function w4(t) { return !us(t) || Va(t).position === "fixed" ? null : t.offsetParent } function $te(t) { var e = /firefox/i.test(I1()), n = /Trident/i.test(I1()); if (n && us(t)) { var r = Va(t); if (r.position === "fixed") return null } var i = By(t); for (c2(i) && (i = i.host); us(i) && ["html", "body"].indexOf(sa(i)) < 0;) { var s = Va(i); if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none") return i; i = i.parentNode } return null } function Th(t) { for (var e = Ui(t), n = w4(t); n && Bte(n) && Va(n).position === "static";)n = w4(n); return n && (sa(n) === "html" || sa(n) === "body" && Va(n).position === "static") ? e : n || $te(t) || e } function d2(t) { return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y" } function yf(t, e, n) { return Kl(t, vg(e, n)) } function Ute(t, e, n) { var r = yf(t, e, n); return r > n ? n : r } function D_() { return { top: 0, right: 0, bottom: 0, left: 0 } } function R_(t) { return Object.assign({}, D_(), t) } function __(t, e) { return e.reduce(function (n, r) { return n[r] = t, n }, {}) } var Vte = function (e, n) { return e = typeof e == "function" ? e(Object.assign({}, n.rects, { placement: n.placement })) : e, R_(typeof e != "number" ? e : __(e, Ch)) }; function Hte(t) { var e, n = t.state, r = t.name, i = t.options, s = n.elements.arrow, a = n.modifiersData.popperOffsets, l = ea(n.placement), u = d2(l), f = [Ci, hs].indexOf(l) >= 0, p = f ? "height" : "width"; if (!(!s || !a)) { var g = Vte(i.padding, n), y = u2(s), v = u === "y" ? Si : Ci, b = u === "y" ? fs : hs, S = n.rects.reference[p] + n.rects.reference[u] - a[u] - n.rects.popper[p], C = a[u] - n.rects.reference[u], T = Th(s), A = T ? u === "y" ? T.clientHeight || 0 : T.clientWidth || 0 : 0, M = S / 2 - C / 2, O = g[v], E = A - y[p] - g[b], k = A / 2 - y[p] / 2 + M, z = yf(O, k, E), V = u; n.modifiersData[r] = (e = {}, e[V] = z, e.centerOffset = z - k, e) } } function qte(t) { var e = t.state, n = t.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r; i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i), !i) || M_(e.elements.popper, i) && (e.elements.arrow = i)) } const Kte = { name: "arrow", enabled: !0, phase: "main", fn: Hte, effect: qte, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }; function Tu(t) { return t.split("-")[1] } var Wte = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function Yte(t, e) { var n = t.x, r = t.y, i = e.devicePixelRatio || 1; return { x: Su(n * i) / i || 0, y: Su(r * i) / i || 0 } } function S4(t) { var e, n = t.popper, r = t.popperRect, i = t.placement, s = t.variation, a = t.offsets, l = t.position, u = t.gpuAcceleration, f = t.adaptive, p = t.roundOffsets, g = t.isFixed, y = a.x, v = y === void 0 ? 0 : y, b = a.y, S = b === void 0 ? 0 : b, C = typeof p == "function" ? p({ x: v, y: S }) : { x: v, y: S }; v = C.x, S = C.y; var T = a.hasOwnProperty("x"), A = a.hasOwnProperty("y"), M = Ci, O = Si, E = window; if (f) { var k = Th(n), z = "clientHeight", V = "clientWidth"; if (k === Ui(n) && (k = Zo(n), Va(k).position !== "static" && l === "absolute" && (z = "scrollHeight", V = "scrollWidth")), k = k, i === Si || (i === Ci || i === hs) && s === Zf) { O = fs; var q = g && k === E && E.visualViewport ? E.visualViewport.height : k[z]; S -= q - r.height, S *= u ? 1 : -1 } if (i === Ci || (i === Si || i === fs) && s === Zf) { M = hs; var ue = g && k === E && E.visualViewport ? E.visualViewport.width : k[V]; v -= ue - r.width, v *= u ? 1 : -1 } } var W = Object.assign({ position: l }, f && Wte), ne = p === !0 ? Yte({ x: v, y: S }, Ui(n)) : { x: v, y: S }; if (v = ne.x, S = ne.y, u) { var H; return Object.assign({}, W, (H = {}, H[O] = A ? "0" : "", H[M] = T ? "0" : "", H.transform = (E.devicePixelRatio || 1) <= 1 ? "translate(" + v + "px, " + S + "px)" : "translate3d(" + v + "px, " + S + "px, 0)", H)) } return Object.assign({}, W, (e = {}, e[O] = A ? S + "px" : "", e[M] = T ? v + "px" : "", e.transform = "", e)) } function Gte(t) { var e = t.state, n = t.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, s = n.adaptive, a = s === void 0 ? !0 : s, l = n.roundOffsets, u = l === void 0 ? !0 : l, f = { placement: ea(e.placement), variation: Tu(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: i, isFixed: e.options.strategy === "fixed" }; e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, S4(Object.assign({}, f, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a, roundOffsets: u })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, S4(Object.assign({}, f, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: u })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement }) } const Xte = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: Gte, data: {} }; var em = { passive: !0 }; function Qte(t) { var e = t.state, n = t.instance, r = t.options, i = r.scroll, s = i === void 0 ? !0 : i, a = r.resize, l = a === void 0 ? !0 : a, u = Ui(e.elements.popper), f = [].concat(e.scrollParents.reference, e.scrollParents.popper); return s && f.forEach(function (p) { p.addEventListener("scroll", n.update, em) }), l && u.addEventListener("resize", n.update, em), function () { s && f.forEach(function (p) { p.removeEventListener("scroll", n.update, em) }), l && u.removeEventListener("resize", n.update, em) } } const Jte = { name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: Qte, data: {} }; var Zte = { left: "right", right: "left", bottom: "top", top: "bottom" }; function Dm(t) { return t.replace(/left|right|bottom|top/g, function (e) { return Zte[e] }) } var ene = { start: "end", end: "start" }; function C4(t) { return t.replace(/start|end/g, function (e) { return ene[e] }) } function f2(t) { var e = Ui(t), n = e.pageXOffset, r = e.pageYOffset; return { scrollLeft: n, scrollTop: r } } function h2(t) { return Cu(Zo(t)).left + f2(t).scrollLeft } function tne(t, e) { var n = Ui(t), r = Zo(t), i = n.visualViewport, s = r.clientWidth, a = r.clientHeight, l = 0, u = 0; if (i) { s = i.width, a = i.height; var f = O_(); (f || !f && e === "fixed") && (l = i.offsetLeft, u = i.offsetTop) } return { width: s, height: a, x: l + h2(t), y: u } } function nne(t) { var e, n = Zo(t), r = f2(t), i = (e = t.ownerDocument) == null ? void 0 : e.body, s = Kl(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), a = Kl(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), l = -r.scrollLeft + h2(t), u = -r.scrollTop; return Va(i || n).direction === "rtl" && (l += Kl(n.clientWidth, i ? i.clientWidth : 0) - s), { width: s, height: a, x: l, y: u } } function p2(t) { var e = Va(t), n = e.overflow, r = e.overflowX, i = e.overflowY; return /auto|scroll|overlay|hidden/.test(n + i + r) } function L_(t) { return ["html", "body", "#document"].indexOf(sa(t)) >= 0 ? t.ownerDocument.body : us(t) && p2(t) ? t : L_(By(t)) } function vf(t, e) { var n; e === void 0 && (e = []); var r = L_(t), i = r === ((n = t.ownerDocument) == null ? void 0 : n.body), s = Ui(r), a = i ? [s].concat(s.visualViewport || [], p2(r) ? r : []) : r, l = e.concat(a); return i ? l : l.concat(vf(By(a))) } function F1(t) { return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height }) } function rne(t, e) { var n = Cu(t, !1, e === "fixed"); return n.top = n.top + t.clientTop, n.left = n.left + t.clientLeft, n.bottom = n.top + t.clientHeight, n.right = n.left + t.clientWidth, n.width = t.clientWidth, n.height = t.clientHeight, n.x = n.left, n.y = n.top, n } function T4(t, e, n) { return e === E_ ? F1(tne(t, n)) : ic(e) ? rne(e, n) : F1(nne(Zo(t))) } function ine(t) { var e = vf(By(t)), n = ["absolute", "fixed"].indexOf(Va(t).position) >= 0, r = n && us(t) ? Th(t) : t; return ic(r) ? e.filter(function (i) { return ic(i) && M_(i, r) && sa(i) !== "body" }) : [] } function sne(t, e, n, r) { var i = e === "clippingParents" ? ine(t) : [].concat(e), s = [].concat(i, [n]), a = s[0], l = s.reduce(function (u, f) { var p = T4(t, f, r); return u.top = Kl(p.top, u.top), u.right = vg(p.right, u.right), u.bottom = vg(p.bottom, u.bottom), u.left = Kl(p.left, u.left), u }, T4(t, a, r)); return l.width = l.right - l.left, l.height = l.bottom - l.top, l.x = l.left, l.y = l.top, l } function P_(t) { var e = t.reference, n = t.element, r = t.placement, i = r ? ea(r) : null, s = r ? Tu(r) : null, a = e.x + e.width / 2 - n.width / 2, l = e.y + e.height / 2 - n.height / 2, u; switch (i) { case Si: u = { x: a, y: e.y - n.height }; break; case fs: u = { x: a, y: e.y + e.height }; break; case hs: u = { x: e.x + e.width, y: l }; break; case Ci: u = { x: e.x - n.width, y: l }; break; default: u = { x: e.x, y: e.y } }var f = i ? d2(i) : null; if (f != null) { var p = f === "y" ? "height" : "width"; switch (s) { case wu: u[f] = u[f] - (e[p] / 2 - n[p] / 2); break; case Zf: u[f] = u[f] + (e[p] / 2 - n[p] / 2); break } } return u } function eh(t, e) { e === void 0 && (e = {}); var n = e, r = n.placement, i = r === void 0 ? t.placement : r, s = n.strategy, a = s === void 0 ? t.strategy : s, l = n.boundary, u = l === void 0 ? jte : l, f = n.rootBoundary, p = f === void 0 ? E_ : f, g = n.elementContext, y = g === void 0 ? Vd : g, v = n.altBoundary, b = v === void 0 ? !1 : v, S = n.padding, C = S === void 0 ? 0 : S, T = R_(typeof C != "number" ? C : __(C, Ch)), A = y === Vd ? Ete : Vd, M = t.rects.popper, O = t.elements[b ? A : y], E = sne(ic(O) ? O : O.contextElement || Zo(t.elements.popper), u, p, a), k = Cu(t.elements.reference), z = P_({ reference: k, element: M, placement: i }), V = F1(Object.assign({}, M, z)), q = y === Vd ? V : k, ue = { top: E.top - q.top + T.top, bottom: q.bottom - E.bottom + T.bottom, left: E.left - q.left + T.left, right: q.right - E.right + T.right }, W = t.modifiersData.offset; if (y === Vd && W) { var ne = W[i]; Object.keys(ue).forEach(function (H) { var we = [hs, fs].indexOf(H) >= 0 ? 1 : -1, xe = [Si, fs].indexOf(H) >= 0 ? "y" : "x"; ue[H] += ne[xe] * we }) } return ue } function ane(t, e) { e === void 0 && (e = {}); var n = e, r = n.placement, i = n.boundary, s = n.rootBoundary, a = n.padding, l = n.flipVariations, u = n.allowedAutoPlacements, f = u === void 0 ? A_ : u, p = Tu(r), g = p ? l ? b4 : b4.filter(function (b) { return Tu(b) === p }) : Ch, y = g.filter(function (b) { return f.indexOf(b) >= 0 }); y.length === 0 && (y = g); var v = y.reduce(function (b, S) { return b[S] = eh(t, { placement: S, boundary: i, rootBoundary: s, padding: a })[ea(S)], b }, {}); return Object.keys(v).sort(function (b, S) { return v[b] - v[S] }) } function one(t) { if (ea(t) === l2) return []; var e = Dm(t); return [C4(t), e, C4(e)] } function lne(t) { var e = t.state, n = t.options, r = t.name; if (!e.modifiersData[r]._skip) { for (var i = n.mainAxis, s = i === void 0 ? !0 : i, a = n.altAxis, l = a === void 0 ? !0 : a, u = n.fallbackPlacements, f = n.padding, p = n.boundary, g = n.rootBoundary, y = n.altBoundary, v = n.flipVariations, b = v === void 0 ? !0 : v, S = n.allowedAutoPlacements, C = e.options.placement, T = ea(C), A = T === C, M = u || (A || !b ? [Dm(C)] : one(C)), O = [C].concat(M).reduce(function (Ee, fe) { return Ee.concat(ea(fe) === l2 ? ane(e, { placement: fe, boundary: p, rootBoundary: g, padding: f, flipVariations: b, allowedAutoPlacements: S }) : fe) }, []), E = e.rects.reference, k = e.rects.popper, z = new Map, V = !0, q = O[0], ue = 0; ue < O.length; ue++) { var W = O[ue], ne = ea(W), H = Tu(W) === wu, we = [Si, fs].indexOf(ne) >= 0, xe = we ? "width" : "height", K = eh(e, { placement: W, boundary: p, rootBoundary: g, altBoundary: y, padding: f }), te = we ? H ? hs : Ci : H ? fs : Si; E[xe] > k[xe] && (te = Dm(te)); var ye = Dm(te), He = []; if (s && He.push(K[ne] <= 0), l && He.push(K[te] <= 0, K[ye] <= 0), He.every(function (Ee) { return Ee })) { q = W, V = !1; break } z.set(W, He) } if (V) for (var B = b ? 3 : 1, ie = function (fe) { var Oe = O.find(function (et) { var Xe = z.get(et); if (Xe) return Xe.slice(0, fe).every(function (De) { return De }) }); if (Oe) return q = Oe, "break" }, oe = B; oe > 0; oe--) { var pe = ie(oe); if (pe === "break") break } e.placement !== q && (e.modifiersData[r]._skip = !0, e.placement = q, e.reset = !0) } } const cne = { name: "flip", enabled: !0, phase: "main", fn: lne, requiresIfExists: ["offset"], data: { _skip: !1 } }; function N4(t, e, n) { return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x } } function j4(t) { return [Si, hs, fs, Ci].some(function (e) { return t[e] >= 0 }) } function une(t) { var e = t.state, n = t.name, r = e.rects.reference, i = e.rects.popper, s = e.modifiersData.preventOverflow, a = eh(e, { elementContext: "reference" }), l = eh(e, { altBoundary: !0 }), u = N4(a, r), f = N4(l, i, s), p = j4(u), g = j4(f); e.modifiersData[n] = { referenceClippingOffsets: u, popperEscapeOffsets: f, isReferenceHidden: p, hasPopperEscaped: g }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": p, "data-popper-escaped": g }) } const dne = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: une }; function fne(t, e, n) { var r = ea(t), i = [Ci, Si].indexOf(r) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, a = s[0], l = s[1]; return a = a || 0, l = (l || 0) * i, [Ci, hs].indexOf(r) >= 0 ? { x: l, y: a } : { x: a, y: l } } function hne(t) { var e = t.state, n = t.options, r = t.name, i = n.offset, s = i === void 0 ? [0, 0] : i, a = A_.reduce(function (p, g) { return p[g] = fne(g, e.rects, s), p }, {}), l = a[e.placement], u = l.x, f = l.y; e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += u, e.modifiersData.popperOffsets.y += f), e.modifiersData[r] = a } const pne = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: hne }; function mne(t) { var e = t.state, n = t.name; e.modifiersData[n] = P_({ reference: e.rects.reference, element: e.rects.popper, placement: e.placement }) } const gne = { name: "popperOffsets", enabled: !0, phase: "read", fn: mne, data: {} }; function yne(t) { return t === "x" ? "y" : "x" } function vne(t) { var e = t.state, n = t.options, r = t.name, i = n.mainAxis, s = i === void 0 ? !0 : i, a = n.altAxis, l = a === void 0 ? !1 : a, u = n.boundary, f = n.rootBoundary, p = n.altBoundary, g = n.padding, y = n.tether, v = y === void 0 ? !0 : y, b = n.tetherOffset, S = b === void 0 ? 0 : b, C = eh(e, { boundary: u, rootBoundary: f, padding: g, altBoundary: p }), T = ea(e.placement), A = Tu(e.placement), M = !A, O = d2(T), E = yne(O), k = e.modifiersData.popperOffsets, z = e.rects.reference, V = e.rects.popper, q = typeof S == "function" ? S(Object.assign({}, e.rects, { placement: e.placement })) : S, ue = typeof q == "number" ? { mainAxis: q, altAxis: q } : Object.assign({ mainAxis: 0, altAxis: 0 }, q), W = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, ne = { x: 0, y: 0 }; if (k) { if (s) { var H, we = O === "y" ? Si : Ci, xe = O === "y" ? fs : hs, K = O === "y" ? "height" : "width", te = k[O], ye = te + C[we], He = te - C[xe], B = v ? -V[K] / 2 : 0, ie = A === wu ? z[K] : V[K], oe = A === wu ? -V[K] : -z[K], pe = e.elements.arrow, Ee = v && pe ? u2(pe) : { width: 0, height: 0 }, fe = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : D_(), Oe = fe[we], et = fe[xe], Xe = yf(0, z[K], Ee[K]), De = M ? z[K] / 2 - B - Xe - Oe - ue.mainAxis : ie - Xe - Oe - ue.mainAxis, he = M ? -z[K] / 2 + B + Xe + et + ue.mainAxis : oe + Xe + et + ue.mainAxis, Be = e.elements.arrow && Th(e.elements.arrow), Y = Be ? O === "y" ? Be.clientTop || 0 : Be.clientLeft || 0 : 0, Je = (H = W?.[O]) != null ? H : 0, $e = te + De - Je - Y, $ = te + he - Je, U = yf(v ? vg(ye, $e) : ye, te, v ? Kl(He, $) : He); k[O] = U, ne[O] = U - te } if (l) { var be, Ie = O === "x" ? Si : Ci, it = O === "x" ? fs : hs, P = k[E], ee = E === "y" ? "height" : "width", _ = P + C[Ie], I = P - C[it], se = [Si, Ci].indexOf(T) !== -1, ae = (be = W?.[E]) != null ? be : 0, Ae = se ? _ : P - z[ee] - V[ee] - ae + ue.altAxis, qe = se ? P + z[ee] + V[ee] - ae - ue.altAxis : I, rt = v && se ? Ute(Ae, P, qe) : yf(v ? Ae : _, P, v ? qe : I); k[E] = rt, ne[E] = rt - P } e.modifiersData[r] = ne } } const xne = { name: "preventOverflow", enabled: !0, phase: "main", fn: vne, requiresIfExists: ["offset"] }; function bne(t) { return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop } } function wne(t) { return t === Ui(t) || !us(t) ? f2(t) : bne(t) } function Sne(t) { var e = t.getBoundingClientRect(), n = Su(e.width) / t.offsetWidth || 1, r = Su(e.height) / t.offsetHeight || 1; return n !== 1 || r !== 1 } function Cne(t, e, n) { n === void 0 && (n = !1); var r = us(e), i = us(e) && Sne(e), s = Zo(e), a = Cu(t, i, n), l = { scrollLeft: 0, scrollTop: 0 }, u = { x: 0, y: 0 }; return (r || !r && !n) && ((sa(e) !== "body" || p2(s)) && (l = wne(e)), us(e) ? (u = Cu(e, !0), u.x += e.clientLeft, u.y += e.clientTop) : s && (u.x = h2(s))), { x: a.left + l.scrollLeft - u.x, y: a.top + l.scrollTop - u.y, width: a.width, height: a.height } } function Tne(t) { var e = new Map, n = new Set, r = []; t.forEach(function (s) { e.set(s.name, s) }); function i(s) { n.add(s.name); var a = [].concat(s.requires || [], s.requiresIfExists || []); a.forEach(function (l) { if (!n.has(l)) { var u = e.get(l); u && i(u) } }), r.push(s) } return t.forEach(function (s) { n.has(s.name) || i(s) }), r } function Nne(t) { var e = Tne(t); return zte.reduce(function (n, r) { return n.concat(e.filter(function (i) { return i.phase === r })) }, []) } function jne(t) { var e; return function () { return e || (e = new Promise(function (n) { Promise.resolve().then(function () { e = void 0, n(t()) }) })), e } } function Ene(t) { var e = t.reduce(function (n, r) { var i = n[r.name]; return n[r.name] = i ? Object.assign({}, i, r, { options: Object.assign({}, i.options, r.options), data: Object.assign({}, i.data, r.data) }) : r, n }, {}); return Object.keys(e).map(function (n) { return e[n] }) } var E4 = { placement: "bottom", modifiers: [], strategy: "absolute" }; function A4() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return !e.some(function (r) { return !(r && typeof r.getBoundingClientRect == "function") }) } function Ane(t) { t === void 0 && (t = {}); var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, i = e.defaultOptions, s = i === void 0 ? E4 : i; return function (l, u, f) { f === void 0 && (f = s); var p = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, E4, s), modifiersData: {}, elements: { reference: l, popper: u }, attributes: {}, styles: {} }, g = [], y = !1, v = { state: p, setOptions: function (T) { var A = typeof T == "function" ? T(p.options) : T; S(), p.options = Object.assign({}, s, p.options, A), p.scrollParents = { reference: ic(l) ? vf(l) : l.contextElement ? vf(l.contextElement) : [], popper: vf(u) }; var M = Nne(Ene([].concat(r, p.options.modifiers))); return p.orderedModifiers = M.filter(function (O) { return O.enabled }), b(), v.update() }, forceUpdate: function () { if (!y) { var T = p.elements, A = T.reference, M = T.popper; if (A4(A, M)) { p.rects = { reference: Cne(A, Th(M), p.options.strategy === "fixed"), popper: u2(M) }, p.reset = !1, p.placement = p.options.placement, p.orderedModifiers.forEach(function (ue) { return p.modifiersData[ue.name] = Object.assign({}, ue.data) }); for (var O = 0; O < p.orderedModifiers.length; O++) { if (p.reset === !0) { p.reset = !1, O = -1; continue } var E = p.orderedModifiers[O], k = E.fn, z = E.options, V = z === void 0 ? {} : z, q = E.name; typeof k == "function" && (p = k({ state: p, options: V, name: q, instance: v }) || p) } } } }, update: jne(function () { return new Promise(function (C) { v.forceUpdate(), C(p) }) }), destroy: function () { S(), y = !0 } }; if (!A4(l, u)) return v; v.setOptions(f).then(function (C) { !y && f.onFirstUpdate && f.onFirstUpdate(C) }); function b() { p.orderedModifiers.forEach(function (C) { var T = C.name, A = C.options, M = A === void 0 ? {} : A, O = C.effect; if (typeof O == "function") { var E = O({ state: p, name: T, instance: v, options: M }), k = function () { }; g.push(E || k) } }) } function S() { g.forEach(function (C) { return C() }), g = [] } return v } } var kne = [Jte, gne, Xte, k_, pne, cne, xne, Kte, dne], One = Ane({ defaultModifiers: kne }), Mne = "tippy-box", z_ = "tippy-content", Dne = "tippy-backdrop", I_ = "tippy-arrow", F_ = "tippy-svg-arrow", Cl = { passive: !0, capture: !0 }, B_ = function () { return document.body }; function Qx(t, e, n) { if (Array.isArray(t)) { var r = t[e]; return r ?? (Array.isArray(n) ? n[e] : n) } return t } function m2(t, e) { var n = {}.toString.call(t); return n.indexOf("[object") === 0 && n.indexOf(e + "]") > -1 } function $_(t, e) { return typeof t == "function" ? t.apply(void 0, e) : t } function k4(t, e) { if (e === 0) return t; var n; return function (r) { clearTimeout(n), n = setTimeout(function () { t(r) }, e) } } function Rne(t) { return t.split(/\s+/).filter(Boolean) } function Zc(t) { return [].concat(t) } function O4(t, e) { t.indexOf(e) === -1 && t.push(e) } function _ne(t) { return t.filter(function (e, n) { return t.indexOf(e) === n }) } function Lne(t) { return t.split("-")[0] } function xg(t) { return [].slice.call(t) } function M4(t) { return Object.keys(t).reduce(function (e, n) { return t[n] !== void 0 && (e[n] = t[n]), e }, {}) } function xf() { return document.createElement("div") } function $y(t) { return ["Element", "Fragment"].some(function (e) { return m2(t, e) }) } function Pne(t) { return m2(t, "NodeList") } function zne(t) { return m2(t, "MouseEvent") } function Ine(t) { return !!(t && t._tippy && t._tippy.reference === t) } function Fne(t) { return $y(t) ? [t] : Pne(t) ? xg(t) : Array.isArray(t) ? t : xg(document.querySelectorAll(t)) } function Jx(t, e) { t.forEach(function (n) { n && (n.style.transitionDuration = e + "ms") }) } function D4(t, e) { t.forEach(function (n) { n && n.setAttribute("data-state", e) }) } function Bne(t) { var e, n = Zc(t), r = n[0]; return r != null && (e = r.ownerDocument) != null && e.body ? r.ownerDocument : document } function $ne(t, e) { var n = e.clientX, r = e.clientY; return t.every(function (i) { var s = i.popperRect, a = i.popperState, l = i.props, u = l.interactiveBorder, f = Lne(a.placement), p = a.modifiersData.offset; if (!p) return !0; var g = f === "bottom" ? p.top.y : 0, y = f === "top" ? p.bottom.y : 0, v = f === "right" ? p.left.x : 0, b = f === "left" ? p.right.x : 0, S = s.top - r + g > u, C = r - s.bottom - y > u, T = s.left - n + v > u, A = n - s.right - b > u; return S || C || T || A }) } function Zx(t, e, n) { var r = e + "EventListener";["transitionend", "webkitTransitionEnd"].forEach(function (i) { t[r](i, n) }) } function R4(t, e) { for (var n = e; n;) { var r; if (t.contains(n)) return !0; n = n.getRootNode == null || (r = n.getRootNode()) == null ? void 0 : r.host } return !1 } var Ws = { isTouch: !1 }, _4 = 0; function Une() { Ws.isTouch || (Ws.isTouch = !0, window.performance && document.addEventListener("mousemove", U_)) } function U_() { var t = performance.now(); t - _4 < 20 && (Ws.isTouch = !1, document.removeEventListener("mousemove", U_)), _4 = t } function Vne() { var t = document.activeElement; if (Ine(t)) { var e = t._tippy; t.blur && !e.state.isVisible && t.blur() } } function Hne() { document.addEventListener("touchstart", Une, Cl), window.addEventListener("blur", Vne) } var qne = typeof window < "u" && typeof document < "u", Kne = qne ? !!window.msCrypto : !1, Wne = { animateFill: !1, followCursor: !1, inlinePositioning: !1, sticky: !1 }, Yne = { allowHTML: !1, animation: "fade", arrow: !0, content: "", inertia: !1, maxWidth: 350, role: "tooltip", theme: "", zIndex: 9999 }, Ts = Object.assign({ appendTo: B_, aria: { content: "auto", expanded: "auto" }, delay: 0, duration: [300, 250], getReferenceClientRect: null, hideOnClick: !0, ignoreAttributes: !1, interactive: !1, interactiveBorder: 2, interactiveDebounce: 0, moveTransition: "", offset: [0, 10], onAfterUpdate: function () { }, onBeforeUpdate: function () { }, onCreate: function () { }, onDestroy: function () { }, onHidden: function () { }, onHide: function () { }, onMount: function () { }, onShow: function () { }, onShown: function () { }, onTrigger: function () { }, onUntrigger: function () { }, onClickOutside: function () { }, placement: "top", plugins: [], popperOptions: {}, render: null, showOnCreate: !1, touch: !0, trigger: "mouseenter focus", triggerTarget: null }, Wne, Yne), Gne = Object.keys(Ts), Xne = function (e) { var n = Object.keys(e); n.forEach(function (r) { Ts[r] = e[r] }) }; function V_(t) { var e = t.plugins || [], n = e.reduce(function (r, i) { var s = i.name, a = i.defaultValue; if (s) { var l; r[s] = t[s] !== void 0 ? t[s] : (l = Ts[s]) != null ? l : a } return r }, {}); return Object.assign({}, t, n) } function Qne(t, e) { var n = e ? Object.keys(V_(Object.assign({}, Ts, { plugins: e }))) : Gne, r = n.reduce(function (i, s) { var a = (t.getAttribute("data-tippy-" + s) || "").trim(); if (!a) return i; if (s === "content") i[s] = a; else try { i[s] = JSON.parse(a) } catch { i[s] = a } return i }, {}); return r } function L4(t, e) { var n = Object.assign({}, e, { content: $_(e.content, [t]) }, e.ignoreAttributes ? {} : Qne(t, e.plugins)); return n.aria = Object.assign({}, Ts.aria, n.aria), n.aria = { expanded: n.aria.expanded === "auto" ? e.interactive : n.aria.expanded, content: n.aria.content === "auto" ? e.interactive ? null : "describedby" : n.aria.content }, n } var Jne = function () { return "innerHTML" }; function B1(t, e) { t[Jne()] = e } function P4(t) { var e = xf(); return t === !0 ? e.className = I_ : (e.className = F_, $y(t) ? e.appendChild(t) : B1(e, t)), e } function z4(t, e) { $y(e.content) ? (B1(t, ""), t.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? B1(t, e.content) : t.textContent = e.content) } function $1(t) { var e = t.firstElementChild, n = xg(e.children); return { box: e, content: n.find(function (r) { return r.classList.contains(z_) }), arrow: n.find(function (r) { return r.classList.contains(I_) || r.classList.contains(F_) }), backdrop: n.find(function (r) { return r.classList.contains(Dne) }) } } function H_(t) { var e = xf(), n = xf(); n.className = Mne, n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1"); var r = xf(); r.className = z_, r.setAttribute("data-state", "hidden"), z4(r, t.props), e.appendChild(n), n.appendChild(r), i(t.props, t.props); function i(s, a) { var l = $1(e), u = l.box, f = l.content, p = l.arrow; a.theme ? u.setAttribute("data-theme", a.theme) : u.removeAttribute("data-theme"), typeof a.animation == "string" ? u.setAttribute("data-animation", a.animation) : u.removeAttribute("data-animation"), a.inertia ? u.setAttribute("data-inertia", "") : u.removeAttribute("data-inertia"), u.style.maxWidth = typeof a.maxWidth == "number" ? a.maxWidth + "px" : a.maxWidth, a.role ? u.setAttribute("role", a.role) : u.removeAttribute("role"), (s.content !== a.content || s.allowHTML !== a.allowHTML) && z4(f, t.props), a.arrow ? p ? s.arrow !== a.arrow && (u.removeChild(p), u.appendChild(P4(a.arrow))) : u.appendChild(P4(a.arrow)) : p && u.removeChild(p) } return { popper: e, onUpdate: i } } H_.$$tippy = !0; var Zne = 1, tm = [], eb = []; function ere(t, e) { var n = L4(t, Object.assign({}, Ts, V_(M4(e)))), r, i, s, a = !1, l = !1, u = !1, f = !1, p, g, y, v = [], b = k4($e, n.interactiveDebounce), S, C = Zne++, T = null, A = _ne(n.plugins), M = { isEnabled: !0, isVisible: !1, isDestroyed: !1, isMounted: !1, isShown: !1 }, O = { id: C, reference: t, popper: xf(), popperInstance: T, props: n, state: M, plugins: A, clearDelayTimeouts: Ae, setProps: qe, setContent: rt, show: Tt, hide: yn, hideWithInteractivity: Gt, enable: se, disable: ae, unmount: $n, destroy: cn }; if (!n.render) return O; var E = n.render(O), k = E.popper, z = E.onUpdate; k.setAttribute("data-tippy-root", ""), k.id = "tippy-" + O.id, O.popper = k, t._tippy = O, k._tippy = O; var V = A.map(function (je) { return je.fn(O) }), q = t.hasAttribute("aria-expanded"); return Be(), B(), te(), ye("onCreate", [O]), n.showOnCreate && _(), k.addEventListener("mouseenter", function () { O.props.interactive && O.state.isVisible && O.clearDelayTimeouts() }), k.addEventListener("mouseleave", function () { O.props.interactive && O.props.trigger.indexOf("mouseenter") >= 0 && we().addEventListener("mousemove", b) }), O; function ue() { var je = O.props.touch; return Array.isArray(je) ? je : [je, 0] } function W() { return ue()[0] === "hold" } function ne() { var je; return !!((je = O.props.render) != null && je.$$tippy) } function H() { return S || t } function we() { var je = H().parentNode; return je ? Bne(je) : document } function xe() { return $1(k) } function K(je) { return O.state.isMounted && !O.state.isVisible || Ws.isTouch || p && p.type === "focus" ? 0 : Qx(O.props.delay, je ? 0 : 1, Ts.delay) } function te(je) { je === void 0 && (je = !1), k.style.pointerEvents = O.props.interactive && !je ? "" : "none", k.style.zIndex = "" + O.props.zIndex } function ye(je, tt, lt) { if (lt === void 0 && (lt = !0), V.forEach(function (st) { st[je] && st[je].apply(st, tt) }), lt) { var le; (le = O.props)[je].apply(le, tt) } } function He() { var je = O.props.aria; if (je.content) { var tt = "aria-" + je.content, lt = k.id, le = Zc(O.props.triggerTarget || t); le.forEach(function (st) { var wt = st.getAttribute(tt); if (O.state.isVisible) st.setAttribute(tt, wt ? wt + " " + lt : lt); else { var Qe = wt && wt.replace(lt, "").trim(); Qe ? st.setAttribute(tt, Qe) : st.removeAttribute(tt) } }) } } function B() { if (!(q || !O.props.aria.expanded)) { var je = Zc(O.props.triggerTarget || t); je.forEach(function (tt) { O.props.interactive ? tt.setAttribute("aria-expanded", O.state.isVisible && tt === H() ? "true" : "false") : tt.removeAttribute("aria-expanded") }) } } function ie() { we().removeEventListener("mousemove", b), tm = tm.filter(function (je) { return je !== b }) } function oe(je) { if (!(Ws.isTouch && (u || je.type === "mousedown"))) { var tt = je.composedPath && je.composedPath()[0] || je.target; if (!(O.props.interactive && R4(k, tt))) { if (Zc(O.props.triggerTarget || t).some(function (lt) { return R4(lt, tt) })) { if (Ws.isTouch || O.state.isVisible && O.props.trigger.indexOf("click") >= 0) return } else ye("onClickOutside", [O, je]); O.props.hideOnClick === !0 && (O.clearDelayTimeouts(), O.hide(), l = !0, setTimeout(function () { l = !1 }), O.state.isMounted || Oe()) } } } function pe() { u = !0 } function Ee() { u = !1 } function fe() { var je = we(); je.addEventListener("mousedown", oe, !0), je.addEventListener("touchend", oe, Cl), je.addEventListener("touchstart", Ee, Cl), je.addEventListener("touchmove", pe, Cl) } function Oe() { var je = we(); je.removeEventListener("mousedown", oe, !0), je.removeEventListener("touchend", oe, Cl), je.removeEventListener("touchstart", Ee, Cl), je.removeEventListener("touchmove", pe, Cl) } function et(je, tt) { De(je, function () { !O.state.isVisible && k.parentNode && k.parentNode.contains(k) && tt() }) } function Xe(je, tt) { De(je, tt) } function De(je, tt) { var lt = xe().box; function le(st) { st.target === lt && (Zx(lt, "remove", le), tt()) } if (je === 0) return tt(); Zx(lt, "remove", g), Zx(lt, "add", le), g = le } function he(je, tt, lt) { lt === void 0 && (lt = !1); var le = Zc(O.props.triggerTarget || t); le.forEach(function (st) { st.addEventListener(je, tt, lt), v.push({ node: st, eventType: je, handler: tt, options: lt }) }) } function Be() { W() && (he("touchstart", Je, { passive: !0 }), he("touchend", $, { passive: !0 })), Rne(O.props.trigger).forEach(function (je) { if (je !== "manual") switch (he(je, Je), je) { case "mouseenter": he("mouseleave", $); break; case "focus": he(Kne ? "focusout" : "blur", U); break; case "focusin": he("focusout", U); break } }) } function Y() { v.forEach(function (je) { var tt = je.node, lt = je.eventType, le = je.handler, st = je.options; tt.removeEventListener(lt, le, st) }), v = [] } function Je(je) { var tt, lt = !1; if (!(!O.state.isEnabled || be(je) || l)) { var le = ((tt = p) == null ? void 0 : tt.type) === "focus"; p = je, S = je.currentTarget, B(), !O.state.isVisible && zne(je) && tm.forEach(function (st) { return st(je) }), je.type === "click" && (O.props.trigger.indexOf("mouseenter") < 0 || a) && O.props.hideOnClick !== !1 && O.state.isVisible ? lt = !0 : _(je), je.type === "click" && (a = !lt), lt && !le && I(je) } } function $e(je) { var tt = je.target, lt = H().contains(tt) || k.contains(tt); if (!(je.type === "mousemove" && lt)) { var le = ee().concat(k).map(function (st) { var wt, Qe = st._tippy, Te = (wt = Qe.popperInstance) == null ? void 0 : wt.state; return Te ? { popperRect: st.getBoundingClientRect(), popperState: Te, props: n } : null }).filter(Boolean); $ne(le, je) && (ie(), I(je)) } } function $(je) { var tt = be(je) || O.props.trigger.indexOf("click") >= 0 && a; if (!tt) { if (O.props.interactive) { O.hideWithInteractivity(je); return } I(je) } } function U(je) { O.props.trigger.indexOf("focusin") < 0 && je.target !== H() || O.props.interactive && je.relatedTarget && k.contains(je.relatedTarget) || I(je) } function be(je) { return Ws.isTouch ? W() !== je.type.indexOf("touch") >= 0 : !1 } function Ie() { it(); var je = O.props, tt = je.popperOptions, lt = je.placement, le = je.offset, st = je.getReferenceClientRect, wt = je.moveTransition, Qe = ne() ? $1(k).arrow : null, Te = st ? { getBoundingClientRect: st, contextElement: st.contextElement || H() } : t, Ze = { name: "$$tippy", enabled: !0, phase: "beforeWrite", requires: ["computeStyles"], fn: function (Nt) { var rn = Nt.state; if (ne()) { var Un = xe(), Z = Un.box;["placement", "reference-hidden", "escaped"].forEach(function (ce) { ce === "placement" ? Z.setAttribute("data-placement", rn.placement) : rn.attributes.popper["data-popper-" + ce] ? Z.setAttribute("data-" + ce, "") : Z.removeAttribute("data-" + ce) }), rn.attributes.popper = {} } } }, gt = [{ name: "offset", options: { offset: le } }, { name: "preventOverflow", options: { padding: { top: 2, bottom: 2, left: 5, right: 5 } } }, { name: "flip", options: { padding: 5 } }, { name: "computeStyles", options: { adaptive: !wt } }, Ze]; ne() && Qe && gt.push({ name: "arrow", options: { element: Qe, padding: 3 } }), gt.push.apply(gt, tt?.modifiers || []), O.popperInstance = One(Te, k, Object.assign({}, tt, { placement: lt, onFirstUpdate: y, modifiers: gt })) } function it() { O.popperInstance && (O.popperInstance.destroy(), O.popperInstance = null) } function P() { var je = O.props.appendTo, tt, lt = H(); O.props.interactive && je === B_ || je === "parent" ? tt = lt.parentNode : tt = $_(je, [lt]), tt.contains(k) || tt.appendChild(k), O.state.isMounted = !0, Ie() } function ee() { return xg(k.querySelectorAll("[data-tippy-root]")) } function _(je) { O.clearDelayTimeouts(), je && ye("onTrigger", [O, je]), fe(); var tt = K(!0), lt = ue(), le = lt[0], st = lt[1]; Ws.isTouch && le === "hold" && st && (tt = st), tt ? r = setTimeout(function () { O.show() }, tt) : O.show() } function I(je) { if (O.clearDelayTimeouts(), ye("onUntrigger", [O, je]), !O.state.isVisible) { Oe(); return } if (!(O.props.trigger.indexOf("mouseenter") >= 0 && O.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(je.type) >= 0 && a)) { var tt = K(!1); tt ? i = setTimeout(function () { O.state.isVisible && O.hide() }, tt) : s = requestAnimationFrame(function () { O.hide() }) } } function se() { O.state.isEnabled = !0 } function ae() { O.hide(), O.state.isEnabled = !1 } function Ae() { clearTimeout(r), clearTimeout(i), cancelAnimationFrame(s) } function qe(je) { if (!O.state.isDestroyed) { ye("onBeforeUpdate", [O, je]), Y(); var tt = O.props, lt = L4(t, Object.assign({}, tt, M4(je), { ignoreAttributes: !0 })); O.props = lt, Be(), tt.interactiveDebounce !== lt.interactiveDebounce && (ie(), b = k4($e, lt.interactiveDebounce)), tt.triggerTarget && !lt.triggerTarget ? Zc(tt.triggerTarget).forEach(function (le) { le.removeAttribute("aria-expanded") }) : lt.triggerTarget && t.removeAttribute("aria-expanded"), B(), te(), z && z(tt, lt), O.popperInstance && (Ie(), ee().forEach(function (le) { requestAnimationFrame(le._tippy.popperInstance.forceUpdate) })), ye("onAfterUpdate", [O, je]) } } function rt(je) { O.setProps({ content: je }) } function Tt() { var je = O.state.isVisible, tt = O.state.isDestroyed, lt = !O.state.isEnabled, le = Ws.isTouch && !O.props.touch, st = Qx(O.props.duration, 0, Ts.duration); if (!(je || tt || lt || le) && !H().hasAttribute("disabled") && (ye("onShow", [O], !1), O.props.onShow(O) !== !1)) { if (O.state.isVisible = !0, ne() && (k.style.visibility = "visible"), te(), fe(), O.state.isMounted || (k.style.transition = "none"), ne()) { var wt = xe(), Qe = wt.box, Te = wt.content; Jx([Qe, Te], 0) } y = function () { var gt; if (!(!O.state.isVisible || f)) { if (f = !0, k.offsetHeight, k.style.transition = O.props.moveTransition, ne() && O.props.animation) { var vt = xe(), Nt = vt.box, rn = vt.content; Jx([Nt, rn], st), D4([Nt, rn], "visible") } He(), B(), O4(eb, O), (gt = O.popperInstance) == null || gt.forceUpdate(), ye("onMount", [O]), O.props.animation && ne() && Xe(st, function () { O.state.isShown = !0, ye("onShown", [O]) }) } }, P() } } function yn() { var je = !O.state.isVisible, tt = O.state.isDestroyed, lt = !O.state.isEnabled, le = Qx(O.props.duration, 1, Ts.duration); if (!(je || tt || lt) && (ye("onHide", [O], !1), O.props.onHide(O) !== !1)) { if (O.state.isVisible = !1, O.state.isShown = !1, f = !1, a = !1, ne() && (k.style.visibility = "hidden"), ie(), Oe(), te(!0), ne()) { var st = xe(), wt = st.box, Qe = st.content; O.props.animation && (Jx([wt, Qe], le), D4([wt, Qe], "hidden")) } He(), B(), O.props.animation ? ne() && et(le, O.unmount) : O.unmount() } } function Gt(je) { we().addEventListener("mousemove", b), O4(tm, b), b(je) } function $n() { O.state.isVisible && O.hide(), O.state.isMounted && (it(), ee().forEach(function (je) { je._tippy.unmount() }), k.parentNode && k.parentNode.removeChild(k), eb = eb.filter(function (je) { return je !== O }), O.state.isMounted = !1, ye("onHidden", [O])) } function cn() { O.state.isDestroyed || (O.clearDelayTimeouts(), O.unmount(), Y(), delete t._tippy, O.state.isDestroyed = !0, ye("onDestroy", [O])) } } function Nh(t, e) { e === void 0 && (e = {}); var n = Ts.plugins.concat(e.plugins || []); Hne(); var r = Object.assign({}, e, { plugins: n }), i = Fne(t), s = i.reduce(function (a, l) { var u = l && ere(l, r); return u && a.push(u), a }, []); return $y(t) ? s[0] : s } Nh.defaultProps = Ts; Nh.setDefaultProps = Xne; Nh.currentInput = Ws; Object.assign({}, k_, { effect: function (e) { var n = e.state, r = { popper: { position: n.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; Object.assign(n.elements.popper.style, r.popper), n.styles = r, n.elements.arrow && Object.assign(n.elements.arrow.style, r.arrow) } }); Nh.setDefaultProps({ render: H_ }); class tre { constructor({ editor: e, element: n, view: r, tippyOptions: i = {}, updateDelay: s = 250, shouldShow: a }) { this.preventHide = !1, this.shouldShow = ({ view: l, state: u, from: f, to: p }) => { const { doc: g, selection: y } = u, { empty: v } = y, b = !g.textBetween(f, p).length && r2(u.selection), S = this.element.contains(document.activeElement); return !(!(l.hasFocus() || S) || v || b || !this.editor.isEditable) }, this.mousedownHandler = () => { this.preventHide = !0 }, this.dragstartHandler = () => { this.hide() }, this.focusHandler = () => { setTimeout(() => this.update(this.editor.view)) }, this.blurHandler = ({ event: l }) => { var u; if (this.preventHide) { this.preventHide = !1; return } l?.relatedTarget && (!((u = this.element.parentNode) === null || u === void 0) && u.contains(l.relatedTarget)) || l?.relatedTarget !== this.editor.view.dom && this.hide() }, this.tippyBlurHandler = l => { this.blurHandler({ event: l }) }, this.handleDebouncedUpdate = (l, u) => { const f = !u?.selection.eq(l.state.selection), p = !u?.doc.eq(l.state.doc); !f && !p || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => { this.updateHandler(l, f, p, u) }, this.updateDelay)) }, this.updateHandler = (l, u, f, p) => { var g, y, v; const { state: b, composing: S } = l, { selection: C } = b; if (S || !u && !f) return; this.createTooltip(); const { ranges: A } = C, M = Math.min(...A.map(k => k.$from.pos)), O = Math.max(...A.map(k => k.$to.pos)); if (!((g = this.shouldShow) === null || g === void 0 ? void 0 : g.call(this, { editor: this.editor, element: this.element, view: l, state: b, oldState: p, from: M, to: O }))) { this.hide(); return } (y = this.tippy) === null || y === void 0 || y.setProps({ getReferenceClientRect: ((v = this.tippyOptions) === null || v === void 0 ? void 0 : v.getReferenceClientRect) || (() => { if (N_(b.selection)) { let k = l.nodeDOM(M); if (k) { const z = k.dataset.nodeViewWrapper ? k : k.querySelector("[data-node-view-wrapper]"); if (z && (k = z.firstChild), k) return k.getBoundingClientRect() } } return Wee(l, M, O) }) }), this.show() }, this.editor = e, this.element = n, this.view = r, this.updateDelay = s, a && (this.shouldShow = a), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i, this.element.remove(), this.element.style.visibility = "visible" } createTooltip() { const { element: e } = this.editor.options, n = !!e.parentElement; this.element.tabIndex = 0, !(this.tippy || !n) && (this.tippy = Nh(e, { duration: 0, getReferenceClientRect: null, content: this.element, interactive: !0, trigger: "manual", placement: "top", hideOnClick: "toggle", ...this.tippyOptions }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler)) } update(e, n) { const { state: r } = e, i = r.selection.from !== r.selection.to; if (this.updateDelay > 0 && i) { this.handleDebouncedUpdate(e, n); return } const s = !n?.selection.eq(e.state.selection), a = !n?.doc.eq(e.state.doc); this.updateHandler(e, s, a, n) } show() { var e; (e = this.tippy) === null || e === void 0 || e.show() } hide() { var e; (e = this.tippy) === null || e === void 0 || e.hide() } destroy() { var e, n; !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler) } } const q_ = t => new hr({ key: typeof t.pluginKey == "string" ? new Br(t.pluginKey) : t.pluginKey, view: e => new tre({ view: e, ...t }) }); Fr.create({ name: "bubbleMenu", addOptions() { return { element: null, tippyOptions: {}, pluginKey: "bubbleMenu", updateDelay: void 0, shouldShow: null } }, addProseMirrorPlugins() { return this.options.element ? [q_({ pluginKey: this.options.pluginKey, editor: this.editor, element: this.options.element, tippyOptions: this.options.tippyOptions, updateDelay: this.options.updateDelay, shouldShow: this.options.shouldShow })] : [] } }); function nre(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var K_ = { exports: {} }, tb = {};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var I4; function rre() { if (I4) return tb; I4 = 1; var t = Pt; function e(g, y) { return g === y && (g !== 0 || 1 / g === 1 / y) || g !== g && y !== y } var n = typeof Object.is == "function" ? Object.is : e, r = t.useState, i = t.useEffect, s = t.useLayoutEffect, a = t.useDebugValue; function l(g, y) { var v = y(), b = r({ inst: { value: v, getSnapshot: y } }), S = b[0].inst, C = b[1]; return s(function () { S.value = v, S.getSnapshot = y, u(S) && C({ inst: S }) }, [g, v, y]), i(function () { return u(S) && C({ inst: S }), g(function () { u(S) && C({ inst: S }) }) }, [g]), a(v), v } function u(g) { var y = g.getSnapshot; g = g.value; try { var v = y(); return !n(g, v) } catch { return !0 } } function f(g, y) { return y() } var p = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? f : l; return tb.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : p, tb } K_.exports = rre(); var g2 = K_.exports; const ire = (...t) => e => { t.forEach(n => { typeof n == "function" ? n(e) : n && (n.current = e) }) }, sre = ({ contentComponent: t }) => { const e = g2.useSyncExternalStore(t.subscribe, t.getSnapshot, t.getServerSnapshot); return Pt.createElement(Pt.Fragment, null, Object.values(e)) }; function are() { const t = new Set; let e = {}; return { subscribe(n) { return t.add(n), () => { t.delete(n) } }, getSnapshot() { return e }, getServerSnapshot() { return e }, setRenderer(n, r) { e = { ...e, [n]: TO.createPortal(r.reactElement, r.element, n) }, t.forEach(i => i()) }, removeRenderer(n) { const r = { ...e }; delete r[n], e = r, t.forEach(i => i()) } } } class ore extends Pt.Component { constructor(e) { var n; super(e), this.editorContentRef = Pt.createRef(), this.initialized = !1, this.state = { hasContentComponentInitialized: !!(!((n = e.editor) === null || n === void 0) && n.contentComponent) } } componentDidMount() { this.init() } componentDidUpdate() { this.init() } init() { const e = this.props.editor; if (e && !e.isDestroyed && e.options.element) { if (e.contentComponent) return; const n = this.editorContentRef.current; n.append(...e.options.element.childNodes), e.setOptions({ element: n }), e.contentComponent = are(), this.state.hasContentComponentInitialized || (this.unsubscribeToContentComponent = e.contentComponent.subscribe(() => { this.setState(r => r.hasContentComponentInitialized ? r : { hasContentComponentInitialized: !0 }), this.unsubscribeToContentComponent && this.unsubscribeToContentComponent() })), e.createNodeViews(), this.initialized = !0 } } componentWillUnmount() { const e = this.props.editor; if (!e || (this.initialized = !1, e.isDestroyed || e.view.setProps({ nodeViews: {} }), this.unsubscribeToContentComponent && this.unsubscribeToContentComponent(), e.contentComponent = null, !e.options.element.firstChild)) return; const n = document.createElement("div"); n.append(...e.options.element.childNodes), e.setOptions({ element: n }) } render() { const { editor: e, innerRef: n, ...r } = this.props; return Pt.createElement(Pt.Fragment, null, Pt.createElement("div", { ref: ire(n, this.editorContentRef), ...r }), e?.contentComponent && Pt.createElement(sre, { contentComponent: e.contentComponent })) } } const lre = N.forwardRef((t, e) => { const n = Pt.useMemo(() => Math.floor(Math.random() * 4294967295).toString(), [t.editor]); return Pt.createElement(ore, { key: n, innerRef: e, ...t }) }), cre = Pt.memo(lre); var ure = function t(e, n) { if (e === n) return !0; if (e && n && typeof e == "object" && typeof n == "object") { if (e.constructor !== n.constructor) return !1; var r, i, s; if (Array.isArray(e)) { if (r = e.length, r != n.length) return !1; for (i = r; i-- !== 0;)if (!t(e[i], n[i])) return !1; return !0 } if (e instanceof Map && n instanceof Map) { if (e.size !== n.size) return !1; for (i of e.entries()) if (!n.has(i[0])) return !1; for (i of e.entries()) if (!t(i[1], n.get(i[0]))) return !1; return !0 } if (e instanceof Set && n instanceof Set) { if (e.size !== n.size) return !1; for (i of e.entries()) if (!n.has(i[0])) return !1; return !0 } if (ArrayBuffer.isView(e) && ArrayBuffer.isView(n)) { if (r = e.length, r != n.length) return !1; for (i = r; i-- !== 0;)if (e[i] !== n[i]) return !1; return !0 } if (e.constructor === RegExp) return e.source === n.source && e.flags === n.flags; if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === n.valueOf(); if (e.toString !== Object.prototype.toString) return e.toString() === n.toString(); if (s = Object.keys(e), r = s.length, r !== Object.keys(n).length) return !1; for (i = r; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(n, s[i])) return !1; for (i = r; i-- !== 0;) { var a = s[i]; if (!(a === "_owner" && e.$$typeof) && !t(e[a], n[a])) return !1 } return !0 } return e !== e && n !== n }, dre = nre(ure), W_ = { exports: {} }, nb = {};/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var F4; function fre() { if (F4) return nb; F4 = 1; var t = Pt, e = g2; function n(f, p) { return f === p && (f !== 0 || 1 / f === 1 / p) || f !== f && p !== p } var r = typeof Object.is == "function" ? Object.is : n, i = e.useSyncExternalStore, s = t.useRef, a = t.useEffect, l = t.useMemo, u = t.useDebugValue; return nb.useSyncExternalStoreWithSelector = function (f, p, g, y, v) { var b = s(null); if (b.current === null) { var S = { hasValue: !1, value: null }; b.current = S } else S = b.current; b = l(function () { function T(k) { if (!A) { if (A = !0, M = k, k = y(k), v !== void 0 && S.hasValue) { var z = S.value; if (v(z, k)) return O = z } return O = k } if (z = O, r(M, k)) return z; var V = y(k); return v !== void 0 && v(z, V) ? z : (M = k, O = V) } var A = !1, M, O, E = g === void 0 ? null : g; return [function () { return T(p()) }, E === null ? void 0 : function () { return T(E()) }] }, [p, g, y, v]); var C = i(f, b[0], b[1]); return a(function () { S.hasValue = !0, S.value = C }, [C]), u(C), C }, nb } W_.exports = fre(); var hre = W_.exports; const pre = typeof window < "u" ? N.useLayoutEffect : N.useEffect; class mre { constructor(e) { this.transactionNumber = 0, this.lastTransactionNumber = 0, this.subscribers = new Set, this.editor = e, this.lastSnapshot = { editor: e, transactionNumber: 0 }, this.getSnapshot = this.getSnapshot.bind(this), this.getServerSnapshot = this.getServerSnapshot.bind(this), this.watch = this.watch.bind(this), this.subscribe = this.subscribe.bind(this) } getSnapshot() { return this.transactionNumber === this.lastTransactionNumber ? this.lastSnapshot : (this.lastTransactionNumber = this.transactionNumber, this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber }, this.lastSnapshot) } getServerSnapshot() { return { editor: null, transactionNumber: 0 } } subscribe(e) { return this.subscribers.add(e), () => { this.subscribers.delete(e) } } watch(e) { if (this.editor = e, this.editor) { const n = () => { this.transactionNumber += 1, this.subscribers.forEach(i => i()) }, r = this.editor; return r.on("transaction", n), () => { r.off("transaction", n) } } } } function gre(t) { var e; const [n] = N.useState(() => new mre(t.editor)), r = hre.useSyncExternalStoreWithSelector(n.subscribe, n.getSnapshot, n.getServerSnapshot, t.selector, (e = t.equalityFn) !== null && e !== void 0 ? e : dre); return pre(() => n.watch(t.editor), [t.editor, n]), N.useDebugValue(r), r } const yre = !1, U1 = typeof window > "u", vre = U1 || !!(typeof window < "u" && window.next); class y2 { constructor(e) { this.editor = null, this.subscriptions = new Set, this.isComponentMounted = !1, this.previousDeps = null, this.instanceId = "", this.options = e, this.subscriptions = new Set, this.setEditor(this.getInitialEditor()), this.scheduleDestroy(), this.getEditor = this.getEditor.bind(this), this.getServerSnapshot = this.getServerSnapshot.bind(this), this.subscribe = this.subscribe.bind(this), this.refreshEditorInstance = this.refreshEditorInstance.bind(this), this.scheduleDestroy = this.scheduleDestroy.bind(this), this.onRender = this.onRender.bind(this), this.createEditor = this.createEditor.bind(this) } setEditor(e) { this.editor = e, this.instanceId = Math.random().toString(36).slice(2, 9), this.subscriptions.forEach(n => n()) } getInitialEditor() { return this.options.current.immediatelyRender === void 0 ? U1 || vre ? null : this.createEditor() : (this.options.current.immediatelyRender, this.options.current.immediatelyRender ? this.createEditor() : null) } createEditor() { const e = { ...this.options.current, onBeforeCreate: (...r) => { var i, s; return (s = (i = this.options.current).onBeforeCreate) === null || s === void 0 ? void 0 : s.call(i, ...r) }, onBlur: (...r) => { var i, s; return (s = (i = this.options.current).onBlur) === null || s === void 0 ? void 0 : s.call(i, ...r) }, onCreate: (...r) => { var i, s; return (s = (i = this.options.current).onCreate) === null || s === void 0 ? void 0 : s.call(i, ...r) }, onDestroy: (...r) => { var i, s; return (s = (i = this.options.current).onDestroy) === null || s === void 0 ? void 0 : s.call(i, ...r) }, onFocus: (...r) => { var i, s; return (s = (i = this.options.current).onFocus) === null || s === void 0 ? void 0 : s.call(i, ...r) }, onSelectionUpdate: (...r) => { var i, s; return (s = (i = this.options.current).onSelectionUpdate) === null || s === void 0 ? void 0 : s.call(i, ...r) }, onTransaction: (...r) => { var i, s; return (s = (i = this.options.current).onTransaction) === null || s === void 0 ? void 0 : s.call(i, ...r) }, onUpdate: (...r) => { var i, s; return (s = (i = this.options.current).onUpdate) === null || s === void 0 ? void 0 : s.call(i, ...r) }, onContentError: (...r) => { var i, s; return (s = (i = this.options.current).onContentError) === null || s === void 0 ? void 0 : s.call(i, ...r) }, onDrop: (...r) => { var i, s; return (s = (i = this.options.current).onDrop) === null || s === void 0 ? void 0 : s.call(i, ...r) }, onPaste: (...r) => { var i, s; return (s = (i = this.options.current).onPaste) === null || s === void 0 ? void 0 : s.call(i, ...r) } }; return new Tte(e) } getEditor() { return this.editor } getServerSnapshot() { return null } subscribe(e) { return this.subscriptions.add(e), () => { this.subscriptions.delete(e) } } static compareOptions(e, n) { return Object.keys(e).every(r => ["onCreate", "onBeforeCreate", "onDestroy", "onUpdate", "onTransaction", "onFocus", "onBlur", "onSelectionUpdate", "onContentError", "onDrop", "onPaste"].includes(r) ? !0 : r === "extensions" && e.extensions && n.extensions ? e.extensions.length !== n.extensions.length ? !1 : e.extensions.every((i, s) => { var a; return i === ((a = n.extensions) === null || a === void 0 ? void 0 : a[s]) }) : e[r] === n[r]) } onRender(e) { return () => (this.isComponentMounted = !0, clearTimeout(this.scheduledDestructionTimeout), this.editor && !this.editor.isDestroyed && e.length === 0 ? y2.compareOptions(this.options.current, this.editor.options) || this.editor.setOptions({ ...this.options.current, editable: this.editor.isEditable }) : this.refreshEditorInstance(e), () => { this.isComponentMounted = !1, this.scheduleDestroy() }) } refreshEditorInstance(e) { if (this.editor && !this.editor.isDestroyed) { if (this.previousDeps === null) { this.previousDeps = e; return } if (this.previousDeps.length === e.length && this.previousDeps.every((r, i) => r === e[i])) return } this.editor && !this.editor.isDestroyed && this.editor.destroy(), this.setEditor(this.createEditor()), this.previousDeps = e } scheduleDestroy() { const e = this.instanceId, n = this.editor; this.scheduledDestructionTimeout = setTimeout(() => { if (this.isComponentMounted && this.instanceId === e) { n && n.setOptions(this.options.current); return } n && !n.isDestroyed && (n.destroy(), this.instanceId === e && this.setEditor(null)) }, 1) } } function xre(t = {}, e = []) { const n = N.useRef(t); n.current = t; const [r] = N.useState(() => new y2(n)), i = g2.useSyncExternalStore(r.subscribe, r.getEditor, r.getServerSnapshot); return N.useDebugValue(i), N.useEffect(r.onRender(e)), gre({ editor: i, selector: ({ transactionNumber: s }) => t.shouldRerenderOnTransaction === !1 ? null : t.immediatelyRender && s === 0 ? 0 : s + 1 }), i } const v2 = N.createContext({ editor: null }), bre = v2.Consumer, jh = () => N.useContext(v2); function Y_({ children: t, slotAfter: e, slotBefore: n, editorContainerProps: r = {}, ...i }) { const s = xre(i); return s ? Pt.createElement(v2.Provider, { value: { editor: s } }, n, Pt.createElement(bre, null, ({ editor: a }) => Pt.createElement(cre, { editor: a, ...r })), t, e) : null } const G_ = t => { const [e, n] = N.useState(null), { editor: r } = jh(); return N.useEffect(() => { var i; if (!e || !((i = t.editor) === null || i === void 0) && i.isDestroyed || r?.isDestroyed) return; const { pluginKey: s = "bubbleMenu", editor: a, tippyOptions: l = {}, updateDelay: u, shouldShow: f = null } = t, p = a || r; if (!p) { console.warn("BubbleMenu component is not rendered inside of an editor component or does not have editor prop."); return } const g = q_({ updateDelay: u, editor: p, element: e, pluginKey: s, shouldShow: f, tippyOptions: l }); return p.registerPlugin(g), () => { p.unregisterPlugin(s) } }, [t.editor, r, e]), Pt.createElement("div", { ref: n, className: t.className, style: { visibility: "hidden" } }, t.children) }, wre = N.createContext({ onDragStart: void 0 }), Sre = () => N.useContext(wre); Pt.forwardRef((t, e) => { const { onDragStart: n } = Sre(), r = t.as || "div"; return Pt.createElement(r, { ...t, ref: e, "data-node-view-wrapper": "", onDragStart: n, style: { whiteSpace: "normal", ...t.style } }) }); const Cre = /^\s*>\s$/, Tre = Qn.create({ name: "blockquote", addOptions() { return { HTMLAttributes: {} } }, content: "block+", group: "block", defining: !0, parseHTML() { return [{ tag: "blockquote" }] }, renderHTML({ HTMLAttributes: t }) { return ["blockquote", Ln(this.options.HTMLAttributes, t), 0] }, addCommands() { return { setBlockquote: () => ({ commands: t }) => t.wrapIn(this.name), toggleBlockquote: () => ({ commands: t }) => t.toggleWrap(this.name), unsetBlockquote: () => ({ commands: t }) => t.lift(this.name) } }, addKeyboardShortcuts() { return { "Mod-Shift-b": () => this.editor.commands.toggleBlockquote() } }, addInputRules() { return [Jf({ find: Cre, type: this.type })] } }), Nre = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, jre = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, Ere = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, Are = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, kre = As.create({ name: "bold", addOptions() { return { HTMLAttributes: {} } }, parseHTML() { return [{ tag: "strong" }, { tag: "b", getAttrs: t => t.style.fontWeight !== "normal" && null }, { style: "font-weight=400", clearMark: t => t.type.name === this.name }, { style: "font-weight", getAttrs: t => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null }] }, renderHTML({ HTMLAttributes: t }) { return ["strong", Ln(this.options.HTMLAttributes, t), 0] }, addCommands() { return { setBold: () => ({ commands: t }) => t.setMark(this.name), toggleBold: () => ({ commands: t }) => t.toggleMark(this.name), unsetBold: () => ({ commands: t }) => t.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-b": () => this.editor.commands.toggleBold(), "Mod-B": () => this.editor.commands.toggleBold() } }, addInputRules() { return [bu({ find: Nre, type: this.type }), bu({ find: Ere, type: this.type })] }, addPasteRules() { return [rc({ find: jre, type: this.type }), rc({ find: Are, type: this.type })] } }), Ore = "listItem", B4 = "textStyle", $4 = /^\s*([-+*])\s$/, Mre = Qn.create({ name: "bulletList", addOptions() { return { itemTypeName: "listItem", HTMLAttributes: {}, keepMarks: !1, keepAttributes: !1 } }, group: "block list", content() { return `${this.options.itemTypeName}+` }, parseHTML() { return [{ tag: "ul" }] }, renderHTML({ HTMLAttributes: t }) { return ["ul", Ln(this.options.HTMLAttributes, t), 0] }, addCommands() { return { toggleBulletList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Ore, this.editor.getAttributes(B4)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks) } }, addKeyboardShortcuts() { return { "Mod-Shift-8": () => this.editor.commands.toggleBulletList() } }, addInputRules() { let t = Jf({ find: $4, type: this.type }); return (this.options.keepMarks || this.options.keepAttributes) && (t = Jf({ find: $4, type: this.type, keepMarks: this.options.keepMarks, keepAttributes: this.options.keepAttributes, getAttributes: () => this.editor.getAttributes(B4), editor: this.editor })), [t] } }), Dre = /(^|[^`])`([^`]+)`(?!`)/, Rre = /(^|[^`])`([^`]+)`(?!`)/g, _re = As.create({ name: "code", addOptions() { return { HTMLAttributes: {} } }, excludes: "_", code: !0, exitable: !0, parseHTML() { return [{ tag: "code" }] }, renderHTML({ HTMLAttributes: t }) { return ["code", Ln(this.options.HTMLAttributes, t), 0] }, addCommands() { return { setCode: () => ({ commands: t }) => t.setMark(this.name), toggleCode: () => ({ commands: t }) => t.toggleMark(this.name), unsetCode: () => ({ commands: t }) => t.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-e": () => this.editor.commands.toggleCode() } }, addInputRules() { return [bu({ find: Dre, type: this.type })] }, addPasteRules() { return [rc({ find: Rre, type: this.type })] } }), Lre = /^```([a-z]+)?[\s\n]$/, Pre = /^~~~([a-z]+)?[\s\n]$/, zre = Qn.create({
    name: "codeBlock", addOptions() { return { languageClassPrefix: "language-", exitOnTripleEnter: !0, exitOnArrowDown: !0, defaultLanguage: null, HTMLAttributes: {} } }, content: "text*", marks: "", group: "block", code: !0, defining: !0, addAttributes() { return { language: { default: this.options.defaultLanguage, parseHTML: t => { var e; const { languageClassPrefix: n } = this.options, s = [...((e = t.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter(a => a.startsWith(n)).map(a => a.replace(n, ""))[0]; return s || null }, rendered: !1 } } }, parseHTML() { return [{ tag: "pre", preserveWhitespace: "full" }] }, renderHTML({ node: t, HTMLAttributes: e }) { return ["pre", Ln(this.options.HTMLAttributes, e), ["code", { class: t.attrs.language ? this.options.languageClassPrefix + t.attrs.language : null }, 0]] }, addCommands() { return { setCodeBlock: t => ({ commands: e }) => e.setNode(this.name, t), toggleCodeBlock: t => ({ commands: e }) => e.toggleNode(this.name, "paragraph", t) } }, addKeyboardShortcuts() {
      return {
        "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(), Backspace: () => { const { empty: t, $anchor: e } = this.editor.state.selection, n = e.pos === 1; return !t || e.parent.type.name !== this.name ? !1 : n || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1 }, Enter: ({ editor: t }) => {
          if (!this.options.exitOnTripleEnter) return !1; const { state: e } = t, { selection: n } = e, { $from: r, empty: i } = n; if (!i || r.parent.type !== this.type) return !1; const s = r.parentOffset === r.parent.nodeSize - 2, a = r.parent.textContent.endsWith(`

`); return !s || !a ? !1 : t.chain().command(({ tr: l }) => (l.delete(r.pos - 2, r.pos), !0)).exitCode().run()
        }, ArrowDown: ({ editor: t }) => { if (!this.options.exitOnArrowDown) return !1; const { state: e } = t, { selection: n, doc: r } = e, { $from: i, empty: s } = n; if (!s || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2)) return !1; const l = i.after(); return l === void 0 ? !1 : r.nodeAt(l) ? t.commands.command(({ tr: f }) => (f.setSelection(Ot.near(r.resolve(l))), !0)) : t.commands.exitCode() }
      }
    }, addInputRules() { return [z1({ find: Lre, type: this.type, getAttributes: t => ({ language: t[1] }) }), z1({ find: Pre, type: this.type, getAttributes: t => ({ language: t[1] }) })] }, addProseMirrorPlugins() {
      return [new hr({
        key: new Br("codeBlockVSCodeHandler"), props: {
          handlePaste: (t, e) => {
            if (!e.clipboardData || this.editor.isActive(this.type.name)) return !1; const n = e.clipboardData.getData("text/plain"), r = e.clipboardData.getData("vscode-editor-data"), i = r ? JSON.parse(r) : void 0, s = i?.mode; if (!n || !s) return !1; const { tr: a, schema: l } = t.state, u = l.text(n.replace(/\r\n?/g, `
`)); return a.replaceSelectionWith(this.type.create({ language: s }, u)), a.selection.$from.parent.type !== this.type && a.setSelection(Et.near(a.doc.resolve(Math.max(0, a.selection.from - 2)))), a.setMeta("paste", !0), t.dispatch(a), !0
          }
        }
      })]
    }
  }), Ire = Qn.create({ name: "doc", topNode: !0, content: "block+" }); function Fre(t = {}) { return new hr({ view(e) { return new Bre(e, t) } }) } class Bre { constructor(e, n) { var r; this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = n.width) !== null && r !== void 0 ? r : 1, this.color = n.color === !1 ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(i => { let s = a => { this[i](a) }; return e.dom.addEventListener(i, s), { name: i, handler: s } }) } destroy() { this.handlers.forEach(({ name: e, handler: n }) => this.editorView.dom.removeEventListener(e, n)) } update(e, n) { this.cursorPos != null && n.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay()) } setCursor(e) { e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay()) } updateOverlay() { let e = this.editorView.state.doc.resolve(this.cursorPos), n = !e.parent.inlineContent, r, i = this.editorView.dom, s = i.getBoundingClientRect(), a = s.width / i.offsetWidth, l = s.height / i.offsetHeight; if (n) { let g = e.nodeBefore, y = e.nodeAfter; if (g || y) { let v = this.editorView.nodeDOM(this.cursorPos - (g ? g.nodeSize : 0)); if (v) { let b = v.getBoundingClientRect(), S = g ? b.bottom : b.top; g && y && (S = (S + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2); let C = this.width / 2 * l; r = { left: b.left, right: b.right, top: S - C, bottom: S + C } } } } if (!r) { let g = this.editorView.coordsAtPos(this.cursorPos), y = this.width / 2 * a; r = { left: g.left - y, right: g.left + y, top: g.top, bottom: g.bottom } } let u = this.editorView.dom.offsetParent; this.element || (this.element = u.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n); let f, p; if (!u || u == document.body && getComputedStyle(u).position == "static") f = -pageXOffset, p = -pageYOffset; else { let g = u.getBoundingClientRect(), y = g.width / u.offsetWidth, v = g.height / u.offsetHeight; f = g.left - u.scrollLeft * y, p = g.top - u.scrollTop * v } this.element.style.left = (r.left - f) / a + "px", this.element.style.top = (r.top - p) / l + "px", this.element.style.width = (r.right - r.left) / a + "px", this.element.style.height = (r.bottom - r.top) / l + "px" } scheduleRemoval(e) { clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e) } dragover(e) { if (!this.editorView.editable) return; let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), i = r && r.type.spec.disableDropCursor, s = typeof i == "function" ? i(this.editorView, n, e) : i; if (n && !s) { let a = n.pos; if (this.editorView.dragging && this.editorView.dragging.slice) { let l = p5(this.editorView.state.doc, a, this.editorView.dragging.slice); l != null && (a = l) } this.setCursor(a), this.scheduleRemoval(5e3) } } dragend() { this.scheduleRemoval(20) } drop() { this.scheduleRemoval(20) } dragleave(e) { this.editorView.dom.contains(e.relatedTarget) || this.setCursor(null) } } const $re = Fr.create({ name: "dropCursor", addOptions() { return { color: "currentColor", width: 1, class: void 0 } }, addProseMirrorPlugins() { return [Fre(this.options)] } }); class Gn extends Ot { constructor(e) { super(e, e) } map(e, n) { let r = e.resolve(n.map(this.head)); return Gn.valid(r) ? new Gn(r) : Ot.near(r) } content() { return nt.empty } eq(e) { return e instanceof Gn && e.head == this.head } toJSON() { return { type: "gapcursor", pos: this.head } } static fromJSON(e, n) { if (typeof n.pos != "number") throw new RangeError("Invalid input for GapCursor.fromJSON"); return new Gn(e.resolve(n.pos)) } getBookmark() { return new x2(this.anchor) } static valid(e) { let n = e.parent; if (n.isTextblock || !Ure(e) || !Vre(e)) return !1; let r = n.type.spec.allowGapCursor; if (r != null) return r; let i = n.contentMatchAt(e.index()).defaultType; return i && i.isTextblock } static findGapCursorFrom(e, n, r = !1) { e: for (; ;) { if (!r && Gn.valid(e)) return e; let i = e.pos, s = null; for (let a = e.depth; ; a--) { let l = e.node(a); if (n > 0 ? e.indexAfter(a) < l.childCount : e.index(a) > 0) { s = l.child(n > 0 ? e.indexAfter(a) : e.index(a) - 1); break } else if (a == 0) return null; i += n; let u = e.doc.resolve(i); if (Gn.valid(u)) return u } for (; ;) { let a = n > 0 ? s.firstChild : s.lastChild; if (!a) { if (s.isAtom && !s.isText && !Ct.isSelectable(s)) { e = e.doc.resolve(i + s.nodeSize * n), r = !1; continue e } break } s = a, i += n; let l = e.doc.resolve(i); if (Gn.valid(l)) return l } return null } } } Gn.prototype.visible = !1; Gn.findFrom = Gn.findGapCursorFrom; Ot.jsonID("gapcursor", Gn); class x2 { constructor(e) { this.pos = e } map(e) { return new x2(e.map(this.pos)) } resolve(e) { let n = e.resolve(this.pos); return Gn.valid(n) ? new Gn(n) : Ot.near(n) } } function Ure(t) { for (let e = t.depth; e >= 0; e--) { let n = t.index(e), r = t.node(e); if (n == 0) { if (r.type.spec.isolating) return !0; continue } for (let i = r.child(n - 1); ; i = i.lastChild) { if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating) return !0; if (i.inlineContent) return !1 } } return !0 } function Vre(t) { for (let e = t.depth; e >= 0; e--) { let n = t.indexAfter(e), r = t.node(e); if (n == r.childCount) { if (r.type.spec.isolating) return !0; continue } for (let i = r.child(n); ; i = i.firstChild) { if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating) return !0; if (i.inlineContent) return !1 } } return !0 } function Hre() { return new hr({ props: { decorations: Yre, createSelectionBetween(t, e, n) { return e.pos == n.pos && Gn.valid(n) ? new Gn(n) : null }, handleClick: Kre, handleKeyDown: qre, handleDOMEvents: { beforeinput: Wre } } }) } const qre = YS({ ArrowLeft: nm("horiz", -1), ArrowRight: nm("horiz", 1), ArrowUp: nm("vert", -1), ArrowDown: nm("vert", 1) }); function nm(t, e) { const n = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left"; return function (r, i, s) { let a = r.selection, l = e > 0 ? a.$to : a.$from, u = a.empty; if (a instanceof Et) { if (!s.endOfTextblock(n) || l.depth == 0) return !1; u = !1, l = r.doc.resolve(e > 0 ? l.after() : l.before()) } let f = Gn.findGapCursorFrom(l, e, u); return f ? (i && i(r.tr.setSelection(new Gn(f))), !0) : !1 } } function Kre(t, e, n) { if (!t || !t.editable) return !1; let r = t.state.doc.resolve(e); if (!Gn.valid(r)) return !1; let i = t.posAtCoords({ left: n.clientX, top: n.clientY }); return i && i.inside > -1 && Ct.isSelectable(t.state.doc.nodeAt(i.inside)) ? !1 : (t.dispatch(t.state.tr.setSelection(new Gn(r))), !0) } function Wre(t, e) { if (e.inputType != "insertCompositionText" || !(t.state.selection instanceof Gn)) return !1; let { $from: n } = t.state.selection, r = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text); if (!r) return !1; let i = Ue.empty; for (let a = r.length - 1; a >= 0; a--)i = Ue.from(r[a].createAndFill(null, i)); let s = t.state.tr.replace(n.pos, n.pos, new nt(i, 0, 0)); return s.setSelection(Et.near(s.doc.resolve(n.pos + 1))), t.dispatch(s), !1 } function Yre(t) { if (!(t.selection instanceof Gn)) return null; let e = document.createElement("div"); return e.className = "ProseMirror-gapcursor", Yn.create(t.doc, [si.widget(t.selection.head, e, { key: "gapcursor" })]) } const Gre = Fr.create({ name: "gapCursor", addProseMirrorPlugins() { return [Hre()] }, extendNodeSchema(t) { var e; const n = { name: t.name, options: t.options, storage: t.storage }; return { allowGapCursor: (e = Ut(pt(t, "allowGapCursor", n))) !== null && e !== void 0 ? e : null } } }), Xre = Qn.create({
    name: "hardBreak", addOptions() { return { keepMarks: !0, HTMLAttributes: {} } }, inline: !0, group: "inline", selectable: !1, linebreakReplacement: !0, parseHTML() { return [{ tag: "br" }] }, renderHTML({ HTMLAttributes: t }) { return ["br", Ln(this.options.HTMLAttributes, t)] }, renderText() {
      return `
`}, addCommands() { return { setHardBreak: () => ({ commands: t, chain: e, state: n, editor: r }) => t.first([() => t.exitCode(), () => t.command(() => { const { selection: i, storedMarks: s } = n; if (i.$from.parent.type.spec.isolating) return !1; const { keepMarks: a } = this.options, { splittableMarks: l } = r.extensionManager, u = s || i.$to.parentOffset && i.$from.marks(); return e().insertContent({ type: this.name }).command(({ tr: f, dispatch: p }) => { if (p && u && a) { const g = u.filter(y => l.includes(y.type.name)); f.ensureMarks(g) } return !0 }).run() })]) } }, addKeyboardShortcuts() { return { "Mod-Enter": () => this.editor.commands.setHardBreak(), "Shift-Enter": () => this.editor.commands.setHardBreak() } }
  }), X_ = Qn.create({ name: "heading", addOptions() { return { levels: [1, 2, 3, 4, 5, 6], HTMLAttributes: {} } }, content: "inline*", group: "block", defining: !0, addAttributes() { return { level: { default: 1, rendered: !1 } } }, parseHTML() { return this.options.levels.map(t => ({ tag: `h${t}`, attrs: { level: t } })) }, renderHTML({ node: t, HTMLAttributes: e }) { return [`h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`, Ln(this.options.HTMLAttributes, e), 0] }, addCommands() { return { setHeading: t => ({ commands: e }) => this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1, toggleHeading: t => ({ commands: e }) => this.options.levels.includes(t.level) ? e.toggleNode(this.name, "paragraph", t) : !1 } }, addKeyboardShortcuts() { return this.options.levels.reduce((t, e) => ({ ...t, [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e }) }), {}) }, addInputRules() { return this.options.levels.map(t => z1({ find: new RegExp(`^(#{${Math.min(...this.options.levels)},${t}})\\s$`), type: this.type, getAttributes: { level: t } })) } }); var bg = 200, kr = function () { }; kr.prototype.append = function (e) { return e.length ? (e = kr.from(e), !this.length && e || e.length < bg && this.leafAppend(e) || this.length < bg && e.leafPrepend(this) || this.appendInner(e)) : this }; kr.prototype.prepend = function (e) { return e.length ? kr.from(e).append(this) : this }; kr.prototype.appendInner = function (e) { return new Qre(this, e) }; kr.prototype.slice = function (e, n) { return e === void 0 && (e = 0), n === void 0 && (n = this.length), e >= n ? kr.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n)) }; kr.prototype.get = function (e) { if (!(e < 0 || e >= this.length)) return this.getInner(e) }; kr.prototype.forEach = function (e, n, r) { n === void 0 && (n = 0), r === void 0 && (r = this.length), n <= r ? this.forEachInner(e, n, r, 0) : this.forEachInvertedInner(e, n, r, 0) }; kr.prototype.map = function (e, n, r) { n === void 0 && (n = 0), r === void 0 && (r = this.length); var i = []; return this.forEach(function (s, a) { return i.push(e(s, a)) }, n, r), i }; kr.from = function (e) { return e instanceof kr ? e : e && e.length ? new Q_(e) : kr.empty }; var Q_ = function (t) { function e(r) { t.call(this), this.values = r } t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e; var n = { length: { configurable: !0 }, depth: { configurable: !0 } }; return e.prototype.flatten = function () { return this.values }, e.prototype.sliceInner = function (i, s) { return i == 0 && s == this.length ? this : new e(this.values.slice(i, s)) }, e.prototype.getInner = function (i) { return this.values[i] }, e.prototype.forEachInner = function (i, s, a, l) { for (var u = s; u < a; u++)if (i(this.values[u], l + u) === !1) return !1 }, e.prototype.forEachInvertedInner = function (i, s, a, l) { for (var u = s - 1; u >= a; u--)if (i(this.values[u], l + u) === !1) return !1 }, e.prototype.leafAppend = function (i) { if (this.length + i.length <= bg) return new e(this.values.concat(i.flatten())) }, e.prototype.leafPrepend = function (i) { if (this.length + i.length <= bg) return new e(i.flatten().concat(this.values)) }, n.length.get = function () { return this.values.length }, n.depth.get = function () { return 0 }, Object.defineProperties(e.prototype, n), e }(kr); kr.empty = new Q_([]); var Qre = function (t) { function e(n, r) { t.call(this), this.left = n, this.right = r, this.length = n.length + r.length, this.depth = Math.max(n.depth, r.depth) + 1 } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.flatten = function () { return this.left.flatten().concat(this.right.flatten()) }, e.prototype.getInner = function (r) { return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length) }, e.prototype.forEachInner = function (r, i, s, a) { var l = this.left.length; if (i < l && this.left.forEachInner(r, i, Math.min(s, l), a) === !1 || s > l && this.right.forEachInner(r, Math.max(i - l, 0), Math.min(this.length, s) - l, a + l) === !1) return !1 }, e.prototype.forEachInvertedInner = function (r, i, s, a) { var l = this.left.length; if (i > l && this.right.forEachInvertedInner(r, i - l, Math.max(s, l) - l, a + l) === !1 || s < l && this.left.forEachInvertedInner(r, Math.min(i, l), s, a) === !1) return !1 }, e.prototype.sliceInner = function (r, i) { if (r == 0 && i == this.length) return this; var s = this.left.length; return i <= s ? this.left.slice(r, i) : r >= s ? this.right.slice(r - s, i - s) : this.left.slice(r, s).append(this.right.slice(0, i - s)) }, e.prototype.leafAppend = function (r) { var i = this.right.leafAppend(r); if (i) return new e(this.left, i) }, e.prototype.leafPrepend = function (r) { var i = this.left.leafPrepend(r); if (i) return new e(i, this.right) }, e.prototype.appendInner = function (r) { return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r) }, e }(kr); const Jre = 500; class bs { constructor(e, n) { this.items = e, this.eventCount = n } popEvent(e, n) { if (this.eventCount == 0) return null; let r = this.items.length; for (; ; r--)if (this.items.get(r - 1).selection) { --r; break } let i, s; n && (i = this.remapping(r, this.items.length), s = i.maps.length); let a = e.tr, l, u, f = [], p = []; return this.items.forEach((g, y) => { if (!g.step) { i || (i = this.remapping(r, y + 1), s = i.maps.length), s--, p.push(g); return } if (i) { p.push(new Us(g.map)); let v = g.step.map(i.slice(s)), b; v && a.maybeStep(v).doc && (b = a.mapping.maps[a.mapping.maps.length - 1], f.push(new Us(b, void 0, void 0, f.length + p.length))), s--, b && i.appendMap(b, s) } else a.maybeStep(g.step); if (g.selection) return l = i ? g.selection.map(i.slice(s)) : g.selection, u = new bs(this.items.slice(0, r).append(p.reverse().concat(f)), this.eventCount - 1), !1 }, this.items.length, 0), { remaining: u, transform: a, selection: l } } addTransform(e, n, r, i) { let s = [], a = this.eventCount, l = this.items, u = !i && l.length ? l.get(l.length - 1) : null; for (let p = 0; p < e.steps.length; p++) { let g = e.steps[p].invert(e.docs[p]), y = new Us(e.mapping.maps[p], g, n), v; (v = u && u.merge(y)) && (y = v, p ? s.pop() : l = l.slice(0, l.length - 1)), s.push(y), n && (a++, n = void 0), i || (u = y) } let f = a - r.depth; return f > eie && (l = Zre(l, f), a -= f), new bs(l.append(s), a) } remapping(e, n) { let r = new qf; return this.items.forEach((i, s) => { let a = i.mirrorOffset != null && s - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0; r.appendMap(i.map, a) }, e, n), r } addMaps(e) { return this.eventCount == 0 ? this : new bs(this.items.append(e.map(n => new Us(n))), this.eventCount) } rebased(e, n) { if (!this.eventCount) return this; let r = [], i = Math.max(0, this.items.length - n), s = e.mapping, a = e.steps.length, l = this.eventCount; this.items.forEach(y => { y.selection && l-- }, i); let u = n; this.items.forEach(y => { let v = s.getMirror(--u); if (v == null) return; a = Math.min(a, v); let b = s.maps[v]; if (y.step) { let S = e.steps[v].invert(e.docs[v]), C = y.selection && y.selection.map(s.slice(u + 1, v)); C && l++, r.push(new Us(b, S, C)) } else r.push(new Us(b)) }, i); let f = []; for (let y = n; y < a; y++)f.push(new Us(s.maps[y])); let p = this.items.slice(0, i).append(f).append(r), g = new bs(p, l); return g.emptyItemCount() > Jre && (g = g.compress(this.items.length - r.length)), g } emptyItemCount() { let e = 0; return this.items.forEach(n => { n.step || e++ }), e } compress(e = this.items.length) { let n = this.remapping(0, e), r = n.maps.length, i = [], s = 0; return this.items.forEach((a, l) => { if (l >= e) i.push(a), a.selection && s++; else if (a.step) { let u = a.step.map(n.slice(r)), f = u && u.getMap(); if (r--, f && n.appendMap(f, r), u) { let p = a.selection && a.selection.map(n.slice(r)); p && s++; let g = new Us(f.invert(), u, p), y, v = i.length - 1; (y = i.length && i[v].merge(g)) ? i[v] = y : i.push(g) } } else a.map && r-- }, this.items.length, 0), new bs(kr.from(i.reverse()), s) } } bs.empty = new bs(kr.empty, 0); function Zre(t, e) { let n; return t.forEach((r, i) => { if (r.selection && e-- == 0) return n = i, !1 }), t.slice(n) } class Us { constructor(e, n, r, i) { this.map = e, this.step = n, this.selection = r, this.mirrorOffset = i } merge(e) { if (this.step && e.step && !e.selection) { let n = e.step.merge(this.step); if (n) return new Us(n.getMap().invert(), n, this.selection) } } } class wo { constructor(e, n, r, i, s) { this.done = e, this.undone = n, this.prevRanges = r, this.prevTime = i, this.prevComposition = s } } const eie = 20; function tie(t, e, n, r) { let i = n.getMeta(Wl), s; if (i) return i.historyState; n.getMeta(iie) && (t = new wo(t.done, t.undone, null, 0, -1)); let a = n.getMeta("appendedTransaction"); if (n.steps.length == 0) return t; if (a && a.getMeta(Wl)) return a.getMeta(Wl).redo ? new wo(t.done.addTransform(n, void 0, r, Rm(e)), t.undone, U4(n.mapping.maps), t.prevTime, t.prevComposition) : new wo(t.done, t.undone.addTransform(n, void 0, r, Rm(e)), null, t.prevTime, t.prevComposition); if (n.getMeta("addToHistory") !== !1 && !(a && a.getMeta("addToHistory") === !1)) { let l = n.getMeta("composition"), u = t.prevTime == 0 || !a && t.prevComposition != l && (t.prevTime < (n.time || 0) - r.newGroupDelay || !nie(n, t.prevRanges)), f = a ? rb(t.prevRanges, n.mapping) : U4(n.mapping.maps); return new wo(t.done.addTransform(n, u ? e.selection.getBookmark() : void 0, r, Rm(e)), bs.empty, f, n.time, l ?? t.prevComposition) } else return (s = n.getMeta("rebased")) ? new wo(t.done.rebased(n, s), t.undone.rebased(n, s), rb(t.prevRanges, n.mapping), t.prevTime, t.prevComposition) : new wo(t.done.addMaps(n.mapping.maps), t.undone.addMaps(n.mapping.maps), rb(t.prevRanges, n.mapping), t.prevTime, t.prevComposition) } function nie(t, e) { if (!e) return !1; if (!t.docChanged) return !0; let n = !1; return t.mapping.maps[0].forEach((r, i) => { for (let s = 0; s < e.length; s += 2)r <= e[s + 1] && i >= e[s] && (n = !0) }), n } function U4(t) { let e = []; for (let n = t.length - 1; n >= 0 && e.length == 0; n--)t[n].forEach((r, i, s, a) => e.push(s, a)); return e } function rb(t, e) { if (!t) return null; let n = []; for (let r = 0; r < t.length; r += 2) { let i = e.map(t[r], 1), s = e.map(t[r + 1], -1); i <= s && n.push(i, s) } return n } function rie(t, e, n) { let r = Rm(e), i = Wl.get(e).spec.config, s = (n ? t.undone : t.done).popEvent(e, r); if (!s) return null; let a = s.selection.resolve(s.transform.doc), l = (n ? t.done : t.undone).addTransform(s.transform, e.selection.getBookmark(), i, r), u = new wo(n ? l : s.remaining, n ? s.remaining : l, null, 0, -1); return s.transform.setSelection(a).setMeta(Wl, { redo: n, historyState: u }) } let ib = !1, V4 = null; function Rm(t) { let e = t.plugins; if (V4 != e) { ib = !1, V4 = e; for (let n = 0; n < e.length; n++)if (e[n].spec.historyPreserveItems) { ib = !0; break } } return ib } const Wl = new Br("history"), iie = new Br("closeHistory"); function sie(t = {}) { return t = { depth: t.depth || 100, newGroupDelay: t.newGroupDelay || 500 }, new hr({ key: Wl, state: { init() { return new wo(bs.empty, bs.empty, null, 0, -1) }, apply(e, n, r) { return tie(n, r, e, t) } }, config: t, props: { handleDOMEvents: { beforeinput(e, n) { let r = n.inputType, i = r == "historyUndo" ? Z_ : r == "historyRedo" ? e6 : null; return i ? (n.preventDefault(), i(e.state, e.dispatch)) : !1 } } } }) } function J_(t, e) { return (n, r) => { let i = Wl.getState(n); if (!i || (t ? i.undone : i.done).eventCount == 0) return !1; if (r) { let s = rie(i, n, t); s && r(e ? s.scrollIntoView() : s) } return !0 } } const Z_ = J_(!1, !0), e6 = J_(!0, !0), aie = Fr.create({ name: "history", addOptions() { return { depth: 100, newGroupDelay: 500 } }, addCommands() { return { undo: () => ({ state: t, dispatch: e }) => Z_(t, e), redo: () => ({ state: t, dispatch: e }) => e6(t, e) } }, addProseMirrorPlugins() { return [sie(this.options)] }, addKeyboardShortcuts() { return { "Mod-z": () => this.editor.commands.undo(), "Shift-Mod-z": () => this.editor.commands.redo(), "Mod-y": () => this.editor.commands.redo(), "Mod-": () => this.editor.commands.undo(), "Shift-Mod-": () => this.editor.commands.redo() } } }), oie = Qn.create({ name: "horizontalRule", addOptions() { return { HTMLAttributes: {} } }, group: "block", parseHTML() { return [{ tag: "hr" }] }, renderHTML({ HTMLAttributes: t }) { return ["hr", Ln(this.options.HTMLAttributes, t)] }, addCommands() { return { setHorizontalRule: () => ({ chain: t, state: e }) => { if (!Nte(e, e.schema.nodes[this.name])) return !1; const { selection: n } = e, { $from: r, $to: i } = n, s = t(); return r.parentOffset === 0 ? s.insertContentAt({ from: Math.max(r.pos - 1, 0), to: i.pos }, { type: this.name }) : N_(n) ? s.insertContentAt(i.pos, { type: this.name }) : s.insertContent({ type: this.name }), s.command(({ tr: a, dispatch: l }) => { var u; if (l) { const { $to: f } = a.selection, p = f.end(); if (f.nodeAfter) f.nodeAfter.isTextblock ? a.setSelection(Et.create(a.doc, f.pos + 1)) : f.nodeAfter.isBlock ? a.setSelection(Ct.create(a.doc, f.pos)) : a.setSelection(Et.create(a.doc, f.pos)); else { const g = (u = f.parent.type.contentMatch.defaultType) === null || u === void 0 ? void 0 : u.create(); g && (a.insert(p, g), a.setSelection(Et.create(a.doc, p + 1))) } a.scrollIntoView() } return !0 }).run() } } }, addInputRules() { return [j_({ find: /^(?:---|-|___\s|\*\*\*\s)$/, type: this.type })] } }), lie = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, cie = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, uie = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, die = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, fie = As.create({ name: "italic", addOptions() { return { HTMLAttributes: {} } }, parseHTML() { return [{ tag: "em" }, { tag: "i", getAttrs: t => t.style.fontStyle !== "normal" && null }, { style: "font-style=normal", clearMark: t => t.type.name === this.name }, { style: "font-style=italic" }] }, renderHTML({ HTMLAttributes: t }) { return ["em", Ln(this.options.HTMLAttributes, t), 0] }, addCommands() { return { setItalic: () => ({ commands: t }) => t.setMark(this.name), toggleItalic: () => ({ commands: t }) => t.toggleMark(this.name), unsetItalic: () => ({ commands: t }) => t.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-i": () => this.editor.commands.toggleItalic(), "Mod-I": () => this.editor.commands.toggleItalic() } }, addInputRules() { return [bu({ find: lie, type: this.type }), bu({ find: uie, type: this.type })] }, addPasteRules() { return [rc({ find: cie, type: this.type }), rc({ find: die, type: this.type })] } }), hie = Qn.create({ name: "listItem", addOptions() { return { HTMLAttributes: {}, bulletListTypeName: "bulletList", orderedListTypeName: "orderedList" } }, content: "paragraph block*", defining: !0, parseHTML() { return [{ tag: "li" }] }, renderHTML({ HTMLAttributes: t }) { return ["li", Ln(this.options.HTMLAttributes, t), 0] }, addKeyboardShortcuts() { return { Enter: () => this.editor.commands.splitListItem(this.name), Tab: () => this.editor.commands.sinkListItem(this.name), "Shift-Tab": () => this.editor.commands.liftListItem(this.name) } } }), pie = "listItem", H4 = "textStyle", q4 = /^(\d+)\.\s$/, mie = Qn.create({ name: "orderedList", addOptions() { return { itemTypeName: "listItem", HTMLAttributes: {}, keepMarks: !1, keepAttributes: !1 } }, group: "block list", content() { return `${this.options.itemTypeName}+` }, addAttributes() { return { start: { default: 1, parseHTML: t => t.hasAttribute("start") ? parseInt(t.getAttribute("start") || "", 10) : 1 }, type: { default: null, parseHTML: t => t.getAttribute("type") } } }, parseHTML() { return [{ tag: "ol" }] }, renderHTML({ HTMLAttributes: t }) { const { start: e, ...n } = t; return e === 1 ? ["ol", Ln(this.options.HTMLAttributes, n), 0] : ["ol", Ln(this.options.HTMLAttributes, t), 0] }, addCommands() { return { toggleOrderedList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(pie, this.editor.getAttributes(H4)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks) } }, addKeyboardShortcuts() { return { "Mod-Shift-7": () => this.editor.commands.toggleOrderedList() } }, addInputRules() { let t = Jf({ find: q4, type: this.type, getAttributes: e => ({ start: +e[1] }), joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1] }); return (this.options.keepMarks || this.options.keepAttributes) && (t = Jf({ find: q4, type: this.type, keepMarks: this.options.keepMarks, keepAttributes: this.options.keepAttributes, getAttributes: e => ({ start: +e[1], ...this.editor.getAttributes(H4) }), joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1], editor: this.editor })), [t] } }), gie = Qn.create({ name: "paragraph", priority: 1e3, addOptions() { return { HTMLAttributes: {} } }, group: "block", content: "inline*", parseHTML() { return [{ tag: "p" }] }, renderHTML({ HTMLAttributes: t }) { return ["p", Ln(this.options.HTMLAttributes, t), 0] }, addCommands() { return { setParagraph: () => ({ commands: t }) => t.setNode(this.name) } }, addKeyboardShortcuts() { return { "Mod-Alt-0": () => this.editor.commands.setParagraph() } } }), yie = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, vie = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, xie = As.create({ name: "strike", addOptions() { return { HTMLAttributes: {} } }, parseHTML() { return [{ tag: "s" }, { tag: "del" }, { tag: "strike" }, { style: "text-decoration", consuming: !1, getAttrs: t => t.includes("line-through") ? {} : !1 }] }, renderHTML({ HTMLAttributes: t }) { return ["s", Ln(this.options.HTMLAttributes, t), 0] }, addCommands() { return { setStrike: () => ({ commands: t }) => t.setMark(this.name), toggleStrike: () => ({ commands: t }) => t.toggleMark(this.name), unsetStrike: () => ({ commands: t }) => t.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-Shift-s": () => this.editor.commands.toggleStrike() } }, addInputRules() { return [bu({ find: yie, type: this.type })] }, addPasteRules() { return [rc({ find: vie, type: this.type })] } }), bie = Qn.create({ name: "text", group: "inline" }), t6 = Fr.create({ name: "starterKit", addExtensions() { const t = []; return this.options.bold !== !1 && t.push(kre.configure(this.options.bold)), this.options.blockquote !== !1 && t.push(Tre.configure(this.options.blockquote)), this.options.bulletList !== !1 && t.push(Mre.configure(this.options.bulletList)), this.options.code !== !1 && t.push(_re.configure(this.options.code)), this.options.codeBlock !== !1 && t.push(zre.configure(this.options.codeBlock)), this.options.document !== !1 && t.push(Ire.configure(this.options.document)), this.options.dropcursor !== !1 && t.push($re.configure(this.options.dropcursor)), this.options.gapcursor !== !1 && t.push(Gre.configure(this.options.gapcursor)), this.options.hardBreak !== !1 && t.push(Xre.configure(this.options.hardBreak)), this.options.heading !== !1 && t.push(X_.configure(this.options.heading)), this.options.history !== !1 && t.push(aie.configure(this.options.history)), this.options.horizontalRule !== !1 && t.push(oie.configure(this.options.horizontalRule)), this.options.italic !== !1 && t.push(fie.configure(this.options.italic)), this.options.listItem !== !1 && t.push(hie.configure(this.options.listItem)), this.options.orderedList !== !1 && t.push(mie.configure(this.options.orderedList)), this.options.paragraph !== !1 && t.push(gie.configure(this.options.paragraph)), this.options.strike !== !1 && t.push(xie.configure(this.options.strike)), this.options.text !== !1 && t.push(bie.configure(this.options.text)), t } }), n6 = Fr.create({ name: "textAlign", addOptions() { return { types: [], alignments: ["left", "center", "right", "justify"], defaultAlignment: null } }, addGlobalAttributes() { return [{ types: this.options.types, attributes: { textAlign: { default: this.options.defaultAlignment, parseHTML: t => { const e = t.style.textAlign; return this.options.alignments.includes(e) ? e : this.options.defaultAlignment }, renderHTML: t => t.textAlign ? { style: `text-align: ${t.textAlign}` } : {} } } }] }, addCommands() { return { setTextAlign: t => ({ commands: e }) => this.options.alignments.includes(t) ? this.options.types.map(n => e.updateAttributes(n, { textAlign: t })).every(n => n) : !1, unsetTextAlign: () => ({ commands: t }) => this.options.types.map(e => t.resetAttributes(e, "textAlign")).every(e => e), toggleTextAlign: t => ({ editor: e, commands: n }) => this.options.alignments.includes(t) ? e.isActive({ textAlign: t }) ? n.unsetTextAlign() : n.setTextAlign(t) : !1 } }, addKeyboardShortcuts() { return { "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"), "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"), "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"), "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify") } } }), wie = [t6.configure({ heading: { levels: [1, 2, 3] } }), n6.configure({ types: ["heading", "paragraph"] })], Sie = () => { const { editor: t } = jh(); return t ? d.jsxs("div", { className: "tiptap-toolbar single-line", children: [d.jsxs("div", { className: "toolbar-group", children: [d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().toggleBold().run() }, disabled: !t.can().chain().focus().toggleBold().run(), className: t.isActive("bold") ? "is-active" : "", title: "Bold", children: d.jsx(Kw, { size: 16 }) }), d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().toggleItalic().run() }, disabled: !t.can().chain().focus().toggleItalic().run(), className: t.isActive("italic") ? "is-active" : "", title: "Italic", children: d.jsx(Gw, { size: 16 }) }), d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().toggleStrike().run() }, disabled: !t.can().chain().focus().toggleStrike().run(), className: t.isActive("strike") ? "is-active" : "", title: "Strikethrough", children: d.jsx(aD, { size: 16 }) })] }), d.jsx("div", { className: "toolbar-divider" }), d.jsxs("div", { className: "toolbar-group", children: [d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().toggleHeading({ level: 1 }).run() }, className: t.isActive("heading", { level: 1 }) ? "is-active" : "", title: "Heading 1", children: d.jsx(eD, { size: 16 }) }), d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().toggleHeading({ level: 2 }).run() }, className: t.isActive("heading", { level: 2 }) ? "is-active" : "", title: "Heading 2", children: d.jsx(Ww, { size: 16 }) }), d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().toggleHeading({ level: 3 }).run() }, className: t.isActive("heading", { level: 3 }) ? "is-active" : "", title: "Heading 3", children: d.jsx(Yw, { size: 16 }) })] }), d.jsx("div", { className: "toolbar-divider" }), d.jsxs("div", { className: "toolbar-group", children: [d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().toggleBulletList().run() }, className: t.isActive("bulletList") ? "is-active" : "", title: "Bullet List", children: d.jsx(Qw, { size: 16 }) }), d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().toggleOrderedList().run() }, className: t.isActive("orderedList") ? "is-active" : "", title: "Numbered List", children: d.jsx(Xw, { size: 16 }) })] }), d.jsx("div", { className: "toolbar-divider" }), d.jsxs("div", { className: "toolbar-group", children: [d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().toggleBlockquote().run() }, className: t.isActive("blockquote") ? "is-active" : "", title: "Blockquote", children: d.jsx(iD, { size: 16 }) }), d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().toggleCodeBlock().run() }, className: t.isActive("codeBlock") ? "is-active" : "", title: "Code Block", children: d.jsx(ZM, { size: 16 }) }), d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().setHorizontalRule().run() }, title: "Horizontal Rule", children: d.jsx(rD, { size: 16 }) })] }), d.jsx("div", { className: "toolbar-divider" }), d.jsxs("div", { className: "toolbar-group", children: [d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().setTextAlign("left").run() }, className: t.isActive({ textAlign: "left" }) ? "is-active" : "", title: "Align Left", children: d.jsx(Gb, { size: 16 }) }), d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().setTextAlign("center").run() }, className: t.isActive({ textAlign: "center" }) ? "is-active" : "", title: "Align Center", children: d.jsx(Yb, { size: 16 }) }), d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().setTextAlign("right").run() }, className: t.isActive({ textAlign: "right" }) ? "is-active" : "", title: "Align Right", children: d.jsx(Xb, { size: 16 }) })] }), d.jsx("div", { className: "toolbar-divider" }), d.jsxs("div", { className: "toolbar-group", children: [d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().undo().run() }, disabled: !t.can().undo(), title: "Undo", children: d.jsx(oD, { size: 16 }) }), d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().redo().run() }, disabled: !t.can().redo(), title: "Redo", children: d.jsx(sD, { size: 16 }) })] })] }) : null }, Cie = () => { const { editor: t } = jh(); return t ? d.jsx(G_, { editor: t, tippyOptions: { duration: 100 }, children: d.jsxs("div", { className: "bubble-menu", children: [d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().toggleBold().run() }, className: t.isActive("bold") ? "is-active" : "", children: d.jsx(Kw, { size: 16 }) }), d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().toggleItalic().run() }, className: t.isActive("italic") ? "is-active" : "", children: d.jsx(Gw, { size: 16 }) }), d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().toggleHeading({ level: 1 }).run() }, className: t.isActive("heading", { level: 1 }) ? "is-active" : "", children: "H1" }), d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().toggleHeading({ level: 2 }).run() }, className: t.isActive("heading", { level: 2 }) ? "is-active" : "", title: "Heading 2", children: d.jsx(Ww, { size: 16 }) }), d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().toggleHeading({ level: 3 }).run() }, className: t.isActive("heading", { level: 3 }) ? "is-active" : "", title: "Heading 3", children: d.jsx(Yw, { size: 16 }) }), d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().toggleBulletList().run() }, className: t.isActive("bulletList") ? "is-active" : "", title: "Bullet List", children: d.jsx(Qw, { size: 16 }) }), d.jsx("button", { onClick: e => { e.preventDefault(), t.chain().focus().toggleOrderedList().run() }, className: t.isActive("orderedList") ? "is-active" : "", title: "Numbered List", children: d.jsx(Xw, { size: 16 }) })] }) }) : null }, r6 = ({ content: t = "", onUpdate: e }) => { const n = N.useCallback(({ editor: r }) => { if (e) { const i = r.getHTML(); e(i) } }, [e]); return d.jsx("div", { className: "tiptap-container", children: d.jsxs(Y_, { extensions: wie, content: t, onUpdate: n, children: [d.jsx(Sie, {}), d.jsx(Cie, {})] }) }) }; function Tie() { const [t, e] = N.useState(null), [n, r] = N.useState(!1), i = ln(), { data: s, isLoading: a } = Jt({ queryKey: ["currentUser"], queryFn: () => Ve.get("https://api.nexus.com/api/auth/me", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }), l = async () => { r(!0); try { const v = await Ve.post("https://api.nexus.com/api/admin/legal-documents/privacy-policy", { content: t }, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }); me.success("Privacy Policy saved successfully") } catch (v) { me.error(v.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }) } finally { r(!1) } }, { data: u, isLoading: f, refetch: p, error: g, isError: y } = Jt({ queryKey: ["privacy-policy"], queryFn: () => Ve.get("https://api.nexus.com/api/legal-documents/privacy-policy") }); return N.useEffect(() => { y && (g.response?.status == 401 && (localStorage.removeItem("userToken"), i("/login")), g.response?.status == 403 && (me.error("You are not authorized to view this page"), i("/home"))) }, [y]), N.useEffect(() => { u?.data?.data?.content && e(u?.data?.data?.content) }, [u?.data?.data]), d.jsxs("div", { className: "p-4", children: [d.jsx("h1", { className: "text-3xl font-bold text-gray-800 mb-8", children: "Privacy Policy" }), d.jsxs("div", { className: "border border-gray-200 rounded-lg shadow-sm p-6 bg-white", children: [t && d.jsx(r6, { content: t, onUpdate: e }, u?.data?.data?.content), d.jsx("div", { className: "flex gap-4 mt-6", children: s?.data?.data?.admin?.permissions?.includes("update_privacy_policy") && d.jsx("button", { onClick: l, disabled: n, className: `px-6 py-2 rounded-md font-medium text-white ${n ? "bg-blue-400" : "bg-blue-600 hover:bg-blue-700"} transition-colors`, children: n ? "Saving..." : "Save Changes" }) })] })] }) } function Nie() { const [t, e] = N.useState(null), [n, r] = N.useState(!1), i = ln(), { data: s, isLoading: a } = Jt({ queryKey: ["currentUser"], queryFn: () => Ve.get("https://api.nexus.com/api/auth/me", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }), l = async () => { r(!0); try { const v = await Ve.post("https://api.nexus.com/api/admin/legal-documents/terms-of-service", { content: t }, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }); me.success("Terms of Services saved successfully") } catch (v) { me.error(v.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }) } finally { r(!1) } }, { data: u, isLoading: f, refetch: p, error: g, isError: y } = Jt({ queryKey: ["terms-of-service"], queryFn: () => Ve.get("https://api.nexus.com/api/legal-documents/terms-of-service") }); return N.useEffect(() => { y && (g.response?.status == 401 && (localStorage.removeItem("userToken"), i("/login")), g.response?.status == 403 && (me.error("You are not authorized to view this page"), i("/home"))) }, [y]), N.useEffect(() => { u?.data?.data?.content && e(u?.data?.data?.content) }, [u?.data?.data]), d.jsxs("div", { className: "p-4", children: [d.jsx("h1", { className: "text-3xl font-bold text-gray-800 mb-8", children: "Terms of Services" }), d.jsxs("div", { className: "border border-gray-200 rounded-lg shadow-sm p-6 bg-white", children: [t && d.jsx(r6, { content: t, onUpdate: e }, u?.data?.data?.content), d.jsx("div", { className: "flex gap-4 mt-6", children: s?.data?.data?.admin?.permissions?.includes("update_terms_of_service") && d.jsx("button", { onClick: l, disabled: n, className: `px-6 py-2 rounded-md font-medium text-white ${n ? "bg-blue-400" : "bg-blue-600 hover:bg-blue-700"} transition-colors`, children: n ? "Saving..." : "Save Changes" }) })] })] }) } const jie = As.create({ name: "underline", addOptions() { return { HTMLAttributes: {} } }, parseHTML() { return [{ tag: "u" }, { style: "text-decoration", consuming: !1, getAttrs: t => t.includes("underline") ? {} : !1 }] }, renderHTML({ HTMLAttributes: t }) { return ["u", Ln(this.options.HTMLAttributes, t), 0] }, addCommands() { return { setUnderline: () => ({ commands: t }) => t.setMark(this.name), toggleUnderline: () => ({ commands: t }) => t.toggleMark(this.name), unsetUnderline: () => ({ commands: t }) => t.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-u": () => this.editor.commands.toggleUnderline(), "Mod-U": () => this.editor.commands.toggleUnderline() } } }), Eie = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, Aie = Qn.create({ name: "image", addOptions() { return { inline: !1, allowBase64: !1, HTMLAttributes: {} } }, inline() { return this.options.inline }, group() { return this.options.inline ? "inline" : "block" }, draggable: !0, addAttributes() { return { src: { default: null }, alt: { default: null }, title: { default: null } } }, parseHTML() { return [{ tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])' }] }, renderHTML({ HTMLAttributes: t }) { return ["img", Ln(this.options.HTMLAttributes, t)] }, addCommands() { return { setImage: t => ({ commands: e }) => e.insertContent({ type: this.name, attrs: t }) } }, addInputRules() { return [j_({ find: Eie, type: this.type, getAttributes: t => { const [, , e, n, r] = t; return { src: n, alt: e, title: r } } })] } }), kie = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", Oie = "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222", V1 = "numeric", H1 = "ascii", q1 = "alpha", bf = "asciinumeric", tf = "alphanumeric", K1 = "domain", i6 = "emoji", Mie = "scheme", Die = "slashscheme", sb = "whitespace"; function Rie(t, e) { return t in e || (e[t] = []), e[t] } function Ll(t, e, n) { e[V1] && (e[bf] = !0, e[tf] = !0), e[H1] && (e[bf] = !0, e[q1] = !0), e[bf] && (e[tf] = !0), e[q1] && (e[tf] = !0), e[tf] && (e[K1] = !0), e[i6] && (e[K1] = !0); for (const r in e) { const i = Rie(r, n); i.indexOf(t) < 0 && i.push(t) } } function _ie(t, e) { const n = {}; for (const r in e) e[r].indexOf(t) >= 0 && (n[r] = !0); return n } function yi(t = null) { this.j = {}, this.jr = [], this.jd = null, this.t = t } yi.groups = {}; yi.prototype = { accepts() { return !!this.t }, go(t) { const e = this, n = e.j[t]; if (n) return n; for (let r = 0; r < e.jr.length; r++) { const i = e.jr[r][0], s = e.jr[r][1]; if (s && i.test(t)) return s } return e.jd }, has(t, e = !1) { return e ? t in this.j : !!this.go(t) }, ta(t, e, n, r) { for (let i = 0; i < t.length; i++)this.tt(t[i], e, n, r) }, tr(t, e, n, r) { r = r || yi.groups; let i; return e && e.j ? i = e : (i = new yi(e), n && r && Ll(e, n, r)), this.jr.push([t, i]), i }, ts(t, e, n, r) { let i = this; const s = t.length; if (!s) return i; for (let a = 0; a < s - 1; a++)i = i.tt(t[a]); return i.tt(t[s - 1], e, n, r) }, tt(t, e, n, r) { r = r || yi.groups; const i = this; if (e && e.j) return i.j[t] = e, e; const s = e; let a, l = i.go(t); if (l ? (a = new yi, Object.assign(a.j, l.j), a.jr.push.apply(a.jr, l.jr), a.jd = l.jd, a.t = l.t) : a = new yi, s) { if (r) if (a.t && typeof a.t == "string") { const u = Object.assign(_ie(a.t, r), n); Ll(s, u, r) } else n && Ll(s, n, r); a.t = s } return i.j[t] = a, a } }; const $t = (t, e, n, r, i) => t.ta(e, n, r, i), Kn = (t, e, n, r, i) => t.tr(e, n, r, i), K4 = (t, e, n, r, i) => t.ts(e, n, r, i), Ye = (t, e, n, r, i) => t.tt(e, n, r, i), Oa = "WORD", W1 = "UWORD", s6 = "ASCIINUMERICAL", a6 = "ALPHANUMERICAL", th = "LOCALHOST", Y1 = "TLD", G1 = "UTLD", _m = "SCHEME", eu = "SLASH_SCHEME", b2 = "NUM", X1 = "WS", w2 = "NL", wf = "OPENBRACE", Sf = "CLOSEBRACE", wg = "OPENBRACKET", Sg = "CLOSEBRACKET", Cg = "OPENPAREN", Tg = "CLOSEPAREN", Ng = "OPENANGLEBRACKET", jg = "CLOSEANGLEBRACKET", Eg = "FULLWIDTHLEFTPAREN", Ag = "FULLWIDTHRIGHTPAREN", kg = "LEFTCORNERBRACKET", Og = "RIGHTCORNERBRACKET", Mg = "LEFTWHITECORNERBRACKET", Dg = "RIGHTWHITECORNERBRACKET", Rg = "FULLWIDTHLESSTHAN", _g = "FULLWIDTHGREATERTHAN", Lg = "AMPERSAND", Pg = "APOSTROPHE", zg = "ASTERISK", So = "AT", Ig = "BACKSLASH", Fg = "BACKTICK", Bg = "CARET", Eo = "COLON", S2 = "COMMA", $g = "DOLLAR", Vs = "DOT", Ug = "EQUALS", C2 = "EXCLAMATION", rs = "HYPHEN", Cf = "PERCENT", Vg = "PIPE", Hg = "PLUS", qg = "POUND", Tf = "QUERY", T2 = "QUOTE", o6 = "FULLWIDTHMIDDLEDOT", N2 = "SEMI", Hs = "SLASH", Nf = "TILDE", Kg = "UNDERSCORE", l6 = "EMOJI", Wg = "SYM"; var c6 = Object.freeze({ __proto__: null, ALPHANUMERICAL: a6, AMPERSAND: Lg, APOSTROPHE: Pg, ASCIINUMERICAL: s6, ASTERISK: zg, AT: So, BACKSLASH: Ig, BACKTICK: Fg, CARET: Bg, CLOSEANGLEBRACKET: jg, CLOSEBRACE: Sf, CLOSEBRACKET: Sg, CLOSEPAREN: Tg, COLON: Eo, COMMA: S2, DOLLAR: $g, DOT: Vs, EMOJI: l6, EQUALS: Ug, EXCLAMATION: C2, FULLWIDTHGREATERTHAN: _g, FULLWIDTHLEFTPAREN: Eg, FULLWIDTHLESSTHAN: Rg, FULLWIDTHMIDDLEDOT: o6, FULLWIDTHRIGHTPAREN: Ag, HYPHEN: rs, LEFTCORNERBRACKET: kg, LEFTWHITECORNERBRACKET: Mg, LOCALHOST: th, NL: w2, NUM: b2, OPENANGLEBRACKET: Ng, OPENBRACE: wf, OPENBRACKET: wg, OPENPAREN: Cg, PERCENT: Cf, PIPE: Vg, PLUS: Hg, POUND: qg, QUERY: Tf, QUOTE: T2, RIGHTCORNERBRACKET: Og, RIGHTWHITECORNERBRACKET: Dg, SCHEME: _m, SEMI: N2, SLASH: Hs, SLASH_SCHEME: eu, SYM: Wg, TILDE: Nf, TLD: Y1, UNDERSCORE: Kg, UTLD: G1, UWORD: W1, WORD: Oa, WS: X1 }); const ja = /[a-z]/, Hd = new RegExp("\\p{L}", "u"), ab = new RegExp("\\p{Emoji}", "u"), Ea = /\d/, ob = /\s/, W4 = "\r", lb = `
`, Lie = "", Pie = "", cb = ""; let rm = null, im = null; function zie(t = []) { const e = {}; yi.groups = e; const n = new yi; rm == null && (rm = Y4(kie)), im == null && (im = Y4(Oie)), Ye(n, "'", Pg), Ye(n, "{", wf), Ye(n, "}", Sf), Ye(n, "[", wg), Ye(n, "]", Sg), Ye(n, "(", Cg), Ye(n, ")", Tg), Ye(n, "<", Ng), Ye(n, ">", jg), Ye(n, "", Eg), Ye(n, "", Ag), Ye(n, "", kg), Ye(n, "", Og), Ye(n, "", Mg), Ye(n, "", Dg), Ye(n, "", Rg), Ye(n, "", _g), Ye(n, "&", Lg), Ye(n, "*", zg), Ye(n, "@", So), Ye(n, "`", Fg), Ye(n, "^", Bg), Ye(n, ":", Eo), Ye(n, ",", S2), Ye(n, "$", $g), Ye(n, ".", Vs), Ye(n, "=", Ug), Ye(n, "!", C2), Ye(n, "-", rs), Ye(n, "%", Cf), Ye(n, "|", Vg), Ye(n, "+", Hg), Ye(n, "#", qg), Ye(n, "?", Tf), Ye(n, '"', T2), Ye(n, "/", Hs), Ye(n, ";", N2), Ye(n, "~", Nf), Ye(n, "_", Kg), Ye(n, "\\", Ig), Ye(n, "", o6); const r = Kn(n, Ea, b2, { [V1]: !0 }); Kn(r, Ea, r); const i = Kn(r, ja, s6, { [bf]: !0 }), s = Kn(r, Hd, a6, { [tf]: !0 }), a = Kn(n, ja, Oa, { [H1]: !0 }); Kn(a, Ea, i), Kn(a, ja, a), Kn(i, Ea, i), Kn(i, ja, i); const l = Kn(n, Hd, W1, { [q1]: !0 }); Kn(l, ja), Kn(l, Ea, s), Kn(l, Hd, l), Kn(s, Ea, s), Kn(s, ja), Kn(s, Hd, s); const u = Ye(n, lb, w2, { [sb]: !0 }), f = Ye(n, W4, X1, { [sb]: !0 }), p = Kn(n, ob, X1, { [sb]: !0 }); Ye(n, cb, p), Ye(f, lb, u), Ye(f, cb, p), Kn(f, ob, p), Ye(p, W4), Ye(p, lb), Kn(p, ob, p), Ye(p, cb, p); const g = Kn(n, ab, l6, { [i6]: !0 }); Ye(g, "#"), Kn(g, ab, g), Ye(g, Lie, g); const y = Ye(g, Pie); Ye(y, "#"), Kn(y, ab, g); const v = [[ja, a], [Ea, i]], b = [[ja, null], [Hd, l], [Ea, s]]; for (let S = 0; S < rm.length; S++)go(n, rm[S], Y1, Oa, v); for (let S = 0; S < im.length; S++)go(n, im[S], G1, W1, b); Ll(Y1, { tld: !0, ascii: !0 }, e), Ll(G1, { utld: !0, alpha: !0 }, e), go(n, "file", _m, Oa, v), go(n, "mailto", _m, Oa, v), go(n, "http", eu, Oa, v), go(n, "https", eu, Oa, v), go(n, "ftp", eu, Oa, v), go(n, "ftps", eu, Oa, v), Ll(_m, { scheme: !0, ascii: !0 }, e), Ll(eu, { slashscheme: !0, ascii: !0 }, e), t = t.sort((S, C) => S[0] > C[0] ? 1 : -1); for (let S = 0; S < t.length; S++) { const C = t[S][0], A = t[S][1] ? { [Mie]: !0 } : { [Die]: !0 }; C.indexOf("-") >= 0 ? A[K1] = !0 : ja.test(C) ? Ea.test(C) ? A[bf] = !0 : A[H1] = !0 : A[V1] = !0, K4(n, C, C, A) } return K4(n, "localhost", th, { ascii: !0 }), n.jd = new yi(Wg), { start: n, tokens: Object.assign({ groups: e }, c6) } } function u6(t, e) { const n = Iie(e.replace(/[A-Z]/g, l => l.toLowerCase())), r = n.length, i = []; let s = 0, a = 0; for (; a < r;) { let l = t, u = null, f = 0, p = null, g = -1, y = -1; for (; a < r && (u = l.go(n[a]));)l = u, l.accepts() ? (g = 0, y = 0, p = l) : g >= 0 && (g += n[a].length, y++), f += n[a].length, s += n[a].length, a++; s -= g, a -= y, f -= g, i.push({ t: p.t, v: e.slice(s - f, s), s: s - f, e: s }) } return i } function Iie(t) { const e = [], n = t.length; let r = 0; for (; r < n;) { let i = t.charCodeAt(r), s, a = i < 55296 || i > 56319 || r + 1 === n || (s = t.charCodeAt(r + 1)) < 56320 || s > 57343 ? t[r] : t.slice(r, r + 2); e.push(a), r += a.length } return e } function go(t, e, n, r, i) { let s; const a = e.length; for (let l = 0; l < a - 1; l++) { const u = e[l]; t.j[u] ? s = t.j[u] : (s = new yi(r), s.jr = i.slice(), t.j[u] = s), t = s } return s = new yi(n), s.jr = i.slice(), t.j[e[a - 1]] = s, s } function Y4(t) { const e = [], n = []; let r = 0, i = "0123456789"; for (; r < t.length;) { let s = 0; for (; i.indexOf(t[r + s]) >= 0;)s++; if (s > 0) { e.push(n.join("")); for (let a = parseInt(t.substring(r, r + s), 10); a > 0; a--)n.pop(); r += s } else n.push(t[r]), r++ } return e } const nh = { defaultProtocol: "http", events: null, format: G4, formatHref: G4, nl2br: !1, tagName: "a", target: null, rel: null, validate: !0, truncate: 1 / 0, className: null, attributes: null, ignoreTags: [], render: null }; function j2(t, e = null) { let n = Object.assign({}, nh); t && (n = Object.assign(n, t instanceof j2 ? t.o : t)); const r = n.ignoreTags, i = []; for (let s = 0; s < r.length; s++)i.push(r[s].toUpperCase()); this.o = n, e && (this.defaultRender = e), this.ignoreTags = i } j2.prototype = { o: nh, ignoreTags: [], defaultRender(t) { return t }, check(t) { return this.get("validate", t.toString(), t) }, get(t, e, n) { const r = e != null; let i = this.o[t]; return i && (typeof i == "object" ? (i = n.t in i ? i[n.t] : nh[t], typeof i == "function" && r && (i = i(e, n))) : typeof i == "function" && r && (i = i(e, n.t, n)), i) }, getObj(t, e, n) { let r = this.o[t]; return typeof r == "function" && e != null && (r = r(e, n.t, n)), r }, render(t) { const e = t.render(this); return (this.get("render", null, t) || this.defaultRender)(e, t.t, t) } }; function G4(t) { return t } function d6(t, e) { this.t = "token", this.v = t, this.tk = e } d6.prototype = { isLink: !1, toString() { return this.v }, toHref(t) { return this.toString() }, toFormattedString(t) { const e = this.toString(), n = t.get("truncate", e, this), r = t.get("format", e, this); return n && r.length > n ? r.substring(0, n) + "" : r }, toFormattedHref(t) { return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this) }, startIndex() { return this.tk[0].s }, endIndex() { return this.tk[this.tk.length - 1].e }, toObject(t = nh.defaultProtocol) { return { type: this.t, value: this.toString(), isLink: this.isLink, href: this.toHref(t), start: this.startIndex(), end: this.endIndex() } }, toFormattedObject(t) { return { type: this.t, value: this.toFormattedString(t), isLink: this.isLink, href: this.toFormattedHref(t), start: this.startIndex(), end: this.endIndex() } }, validate(t) { return t.get("validate", this.toString(), this) }, render(t) { const e = this, n = this.toHref(t.get("defaultProtocol")), r = t.get("formatHref", n, this), i = t.get("tagName", n, e), s = this.toFormattedString(t), a = {}, l = t.get("className", n, e), u = t.get("target", n, e), f = t.get("rel", n, e), p = t.getObj("attributes", n, e), g = t.getObj("events", n, e); return a.href = r, l && (a.class = l), u && (a.target = u), f && (a.rel = f), p && Object.assign(a, p), { tagName: i, attributes: a, content: s, eventListeners: g } } }; function Uy(t, e) { class n extends d6 { constructor(i, s) { super(i, s), this.t = t } } for (const r in e) n.prototype[r] = e[r]; return n.t = t, n } const X4 = Uy("email", { isLink: !0, toHref() { return "mailto:" + this.toString() } }), Q4 = Uy("text"), Fie = Uy("nl"), sm = Uy("url", { isLink: !0, toHref(t = nh.defaultProtocol) { return this.hasProtocol() ? this.v : `${t}://${this.v}` }, hasProtocol() { const t = this.tk; return t.length >= 2 && t[0].t !== th && t[1].t === Eo } }), ts = t => new yi(t); function Bie({ groups: t }) { const e = t.domain.concat([Lg, zg, So, Ig, Fg, Bg, $g, Ug, rs, b2, Cf, Vg, Hg, qg, Hs, Wg, Nf, Kg]), n = [Pg, Eo, S2, Vs, C2, Cf, Tf, T2, N2, Ng, jg, wf, Sf, Sg, wg, Cg, Tg, Eg, Ag, kg, Og, Mg, Dg, Rg, _g], r = [Lg, Pg, zg, Ig, Fg, Bg, $g, Ug, rs, wf, Sf, Cf, Vg, Hg, qg, Tf, Hs, Wg, Nf, Kg], i = ts(), s = Ye(i, Nf); $t(s, r, s), $t(s, t.domain, s); const a = ts(), l = ts(), u = ts(); $t(i, t.domain, a), $t(i, t.scheme, l), $t(i, t.slashscheme, u), $t(a, r, s), $t(a, t.domain, a); const f = Ye(a, So); Ye(s, So, f), Ye(l, So, f), Ye(u, So, f); const p = Ye(s, Vs); $t(p, r, s), $t(p, t.domain, s); const g = ts(); $t(f, t.domain, g), $t(g, t.domain, g); const y = Ye(g, Vs); $t(y, t.domain, g); const v = ts(X4); $t(y, t.tld, v), $t(y, t.utld, v), Ye(f, th, v); const b = Ye(g, rs); Ye(b, rs, b), $t(b, t.domain, g), $t(v, t.domain, g), Ye(v, Vs, y), Ye(v, rs, b); const S = Ye(v, Eo); $t(S, t.numeric, X4); const C = Ye(a, rs), T = Ye(a, Vs); Ye(C, rs, C), $t(C, t.domain, a), $t(T, r, s), $t(T, t.domain, a); const A = ts(sm); $t(T, t.tld, A), $t(T, t.utld, A), $t(A, t.domain, a), $t(A, r, s), Ye(A, Vs, T), Ye(A, rs, C), Ye(A, So, f); const M = Ye(A, Eo), O = ts(sm); $t(M, t.numeric, O); const E = ts(sm), k = ts(); $t(E, e, E), $t(E, n, k), $t(k, e, E), $t(k, n, k), Ye(A, Hs, E), Ye(O, Hs, E); const z = Ye(l, Eo), V = Ye(u, Eo), q = Ye(V, Hs), ue = Ye(q, Hs); $t(l, t.domain, a), Ye(l, Vs, T), Ye(l, rs, C), $t(u, t.domain, a), Ye(u, Vs, T), Ye(u, rs, C), $t(z, t.domain, E), Ye(z, Hs, E), Ye(z, Tf, E), $t(ue, t.domain, E), $t(ue, e, E), Ye(ue, Hs, E); const W = [[wf, Sf], [wg, Sg], [Cg, Tg], [Ng, jg], [Eg, Ag], [kg, Og], [Mg, Dg], [Rg, _g]]; for (let ne = 0; ne < W.length; ne++) { const [H, we] = W[ne], xe = Ye(E, H); Ye(k, H, xe), Ye(xe, we, E); const K = ts(sm); $t(xe, e, K); const te = ts(); $t(xe, n), $t(K, e, K), $t(K, n, te), $t(te, e, K), $t(te, n, te), Ye(K, we, E), Ye(te, we, E) } return Ye(i, th, A), Ye(i, w2, Fie), { start: i, tokens: c6 } } function $ie(t, e, n) { let r = n.length, i = 0, s = [], a = []; for (; i < r;) { let l = t, u = null, f = null, p = 0, g = null, y = -1; for (; i < r && !(u = l.go(n[i].t));)a.push(n[i++]); for (; i < r && (f = u || l.go(n[i].t));)u = null, l = f, l.accepts() ? (y = 0, g = l) : y >= 0 && y++, i++, p++; if (y < 0) i -= p, i < r && (a.push(n[i]), i++); else { a.length > 0 && (s.push(ub(Q4, e, a)), a = []), i -= y, p -= y; const v = g.t, b = n.slice(i - p, i); s.push(ub(v, e, b)) } } return a.length > 0 && s.push(ub(Q4, e, a)), s } function ub(t, e, n) { const r = n[0].s, i = n[n.length - 1].e, s = e.slice(r, i); return new t(s, n) } const Uie = typeof console < "u" && console && console.warn || (() => { }), Vie = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", On = { scanner: null, parser: null, tokenQueue: [], pluginQueue: [], customSchemes: [], initialized: !1 }; function Hie() { return yi.groups = {}, On.scanner = null, On.parser = null, On.tokenQueue = [], On.pluginQueue = [], On.customSchemes = [], On.initialized = !1, On } function J4(t, e = !1) {
    if (On.initialized && Uie(`linkifyjs: already initialized - will not register custom scheme "${t}" ${Vie}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t)) throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`); On.customSchemes.push([t, e])
  } function qie() { On.scanner = zie(On.customSchemes); for (let t = 0; t < On.tokenQueue.length; t++)On.tokenQueue[t][1]({ scanner: On.scanner }); On.parser = Bie(On.scanner.tokens); for (let t = 0; t < On.pluginQueue.length; t++)On.pluginQueue[t][1]({ scanner: On.scanner, parser: On.parser }); return On.initialized = !0, On } function E2(t) { return On.initialized || qie(), $ie(On.parser.start, t, u6(On.scanner.start, t)) } E2.scan = u6; function f6(t, e = null, n = null) { if (e && typeof e == "object") { if (n) throw Error(`linkifyjs: Invalid link type ${e}; must be a string`); n = e, e = null } const r = new j2(n), i = E2(t), s = []; for (let a = 0; a < i.length; a++) { const l = i[a]; l.isLink && (!e || l.t === e) && r.check(l) && s.push(l.toFormattedObject(r)) } return s } const A2 = "[\0- -\u2029]", Kie = new RegExp(A2), Wie = new RegExp(`${A2}$`), Yie = new RegExp(A2, "g"); function Gie(t) { return t.length === 1 ? t[0].isLink : t.length === 3 && t[1].isLink ? ["()", "[]"].includes(t[0].value + t[2].value) : !1 } function Xie(t) { return new hr({ key: new Br("autolink"), appendTransaction: (e, n, r) => { const i = e.some(f => f.docChanged) && !n.doc.eq(r.doc), s = e.some(f => f.getMeta("preventAutolink")); if (!i || s) return; const { tr: a } = r, l = Iee(n.doc, [...e]); if (qee(l).forEach(({ newRange: f }) => { const p = Bee(r.doc, f, v => v.isTextblock); let g, y; if (p.length > 1) g = p[0], y = r.doc.textBetween(g.pos, g.pos + g.node.nodeSize, void 0, " "); else if (p.length) { const v = r.doc.textBetween(f.from, f.to, " ", " "); if (!Wie.test(v)) return; g = p[0], y = r.doc.textBetween(g.pos, f.to, void 0, " ") } if (g && y) { const v = y.split(Kie).filter(Boolean); if (v.length <= 0) return !1; const b = v[v.length - 1], S = g.pos + y.lastIndexOf(b); if (!b) return !1; const C = E2(b).map(T => T.toObject(t.defaultProtocol)); if (!Gie(C)) return !1; C.filter(T => T.isLink).map(T => ({ ...T, from: S + T.start + 1, to: S + T.end + 1 })).filter(T => r.schema.marks.code ? !r.doc.rangeHasMark(T.from, T.to, r.schema.marks.code) : !0).filter(T => t.validate(T.value)).filter(T => t.shouldAutoLink(T.value)).forEach(T => { a2(T.from, T.to, r.doc).some(A => A.mark.type === t.type) || a.addMark(T.from, T.to, t.type.create({ href: T.href })) }) } }), !!a.steps.length) return a } }) } function Qie(t) { return new hr({ key: new Br("handleClickLink"), props: { handleClick: (e, n, r) => { var i, s; if (r.button !== 0 || !e.editable) return !1; let a = r.target; const l = []; for (; a.nodeName !== "DIV";)l.push(a), a = a.parentNode; if (!l.find(y => y.nodeName === "A")) return !1; const u = T_(e.state, t.type.name), f = r.target, p = (i = f?.href) !== null && i !== void 0 ? i : u.href, g = (s = f?.target) !== null && s !== void 0 ? s : u.target; return f && p ? (window.open(p, g), !0) : !1 } } }) } function Jie(t) { return new hr({ key: new Br("handlePasteLink"), props: { handlePaste: (e, n, r) => { const { state: i } = e, { selection: s } = i, { empty: a } = s; if (a) return !1; let l = ""; r.content.forEach(f => { l += f.textContent }); const u = f6(l, { defaultProtocol: t.defaultProtocol }).find(f => f.isLink && f.value === l); return !l || !u ? !1 : t.editor.commands.setMark(t.type, { href: u.href }) } } }) } function xl(t, e) { const n = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"]; return e && e.forEach(r => { const i = typeof r == "string" ? r : r.scheme; i && n.push(i) }), !t || t.replace(Yie, "").match(new RegExp(`^(?:(?:${n.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`, "i")) } const Zie = As.create({ name: "link", priority: 1e3, keepOnSplit: !1, exitable: !0, onCreate() { this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach(t => { if (typeof t == "string") { J4(t); return } J4(t.scheme, t.optionalSlashes) }) }, onDestroy() { Hie() }, inclusive() { return this.options.autolink }, addOptions() { return { openOnClick: !0, linkOnPaste: !0, autolink: !0, protocols: [], defaultProtocol: "http", HTMLAttributes: { target: "_blank", rel: "noopener noreferrer nofollow", class: null }, isAllowedUri: (t, e) => !!xl(t, e.protocols), validate: t => !!t, shouldAutoLink: t => !!t } }, addAttributes() { return { href: { default: null, parseHTML(t) { return t.getAttribute("href") } }, target: { default: this.options.HTMLAttributes.target }, rel: { default: this.options.HTMLAttributes.rel }, class: { default: this.options.HTMLAttributes.class } } }, parseHTML() { return [{ tag: "a[href]", getAttrs: t => { const e = t.getAttribute("href"); return !e || !this.options.isAllowedUri(e, { defaultValidate: n => !!xl(n, this.options.protocols), protocols: this.options.protocols, defaultProtocol: this.options.defaultProtocol }) ? !1 : null } }] }, renderHTML({ HTMLAttributes: t }) { return this.options.isAllowedUri(t.href, { defaultValidate: e => !!xl(e, this.options.protocols), protocols: this.options.protocols, defaultProtocol: this.options.defaultProtocol }) ? ["a", Ln(this.options.HTMLAttributes, t), 0] : ["a", Ln(this.options.HTMLAttributes, { ...t, href: "" }), 0] }, addCommands() { return { setLink: t => ({ chain: e }) => { const { href: n } = t; return this.options.isAllowedUri(n, { defaultValidate: r => !!xl(r, this.options.protocols), protocols: this.options.protocols, defaultProtocol: this.options.defaultProtocol }) ? e().setMark(this.name, t).setMeta("preventAutolink", !0).run() : !1 }, toggleLink: t => ({ chain: e }) => { const { href: n } = t; return this.options.isAllowedUri(n, { defaultValidate: r => !!xl(r, this.options.protocols), protocols: this.options.protocols, defaultProtocol: this.options.defaultProtocol }) ? e().toggleMark(this.name, t, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run() : !1 }, unsetLink: () => ({ chain: t }) => t().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run() } }, addPasteRules() { return [rc({ find: t => { const e = []; if (t) { const { protocols: n, defaultProtocol: r } = this.options, i = f6(t).filter(s => s.isLink && this.options.isAllowedUri(s.value, { defaultValidate: a => !!xl(a, n), protocols: n, defaultProtocol: r })); i.length && i.forEach(s => e.push({ text: s.value, data: { href: s.href }, index: s.start })) } return e }, type: this.type, getAttributes: t => { var e; return { href: (e = t.data) === null || e === void 0 ? void 0 : e.href } } })] }, addProseMirrorPlugins() { const t = [], { protocols: e, defaultProtocol: n } = this.options; return this.options.autolink && t.push(Xie({ type: this.type, defaultProtocol: this.options.defaultProtocol, validate: r => this.options.isAllowedUri(r, { defaultValidate: i => !!xl(i, e), protocols: e, defaultProtocol: n }), shouldAutoLink: this.options.shouldAutoLink })), this.options.openOnClick === !0 && t.push(Qie({ type: this.type })), this.options.linkOnPaste && t.push(Jie({ editor: this.editor, defaultProtocol: this.options.defaultProtocol, type: this.type })), t } }); var Q1, J1; if (typeof WeakMap < "u") { let t = new WeakMap; Q1 = e => t.get(e), J1 = (e, n) => (t.set(e, n), n) } else { const t = []; let n = 0; Q1 = r => { for (let i = 0; i < t.length; i += 2)if (t[i] == r) return t[i + 1] }, J1 = (r, i) => (n == 10 && (n = 0), t[n++] = r, t[n++] = i) } var Xn = class { constructor(t, e, n, r) { this.width = t, this.height = e, this.map = n, this.problems = r } findCell(t) { for (let e = 0; e < this.map.length; e++) { const n = this.map[e]; if (n != t) continue; const r = e % this.width, i = e / this.width | 0; let s = r + 1, a = i + 1; for (let l = 1; s < this.width && this.map[e + l] == n; l++)s++; for (let l = 1; a < this.height && this.map[e + this.width * l] == n; l++)a++; return { left: r, top: i, right: s, bottom: a } } throw new RangeError(`No cell with offset ${t} found`) } colCount(t) { for (let e = 0; e < this.map.length; e++)if (this.map[e] == t) return e % this.width; throw new RangeError(`No cell with offset ${t} found`) } nextCell(t, e, n) { const { left: r, right: i, top: s, bottom: a } = this.findCell(t); return e == "horiz" ? (n < 0 ? r == 0 : i == this.width) ? null : this.map[s * this.width + (n < 0 ? r - 1 : i)] : (n < 0 ? s == 0 : a == this.height) ? null : this.map[r + this.width * (n < 0 ? s - 1 : a)] } rectBetween(t, e) { const { left: n, right: r, top: i, bottom: s } = this.findCell(t), { left: a, right: l, top: u, bottom: f } = this.findCell(e); return { left: Math.min(n, a), top: Math.min(i, u), right: Math.max(r, l), bottom: Math.max(s, f) } } cellsInRect(t) { const e = [], n = {}; for (let r = t.top; r < t.bottom; r++)for (let i = t.left; i < t.right; i++) { const s = r * this.width + i, a = this.map[s]; n[a] || (n[a] = !0, !(i == t.left && i && this.map[s - 1] == a || r == t.top && r && this.map[s - this.width] == a) && e.push(a)) } return e } positionAt(t, e, n) { for (let r = 0, i = 0; ; r++) { const s = i + n.child(r).nodeSize; if (r == t) { let a = e + t * this.width; const l = (t + 1) * this.width; for (; a < l && this.map[a] < i;)a++; return a == l ? s - 1 : this.map[a] } i = s } } static get(t) { return Q1(t) || J1(t, ese(t)) } }; function ese(t) { if (t.type.spec.tableRole != "table") throw new RangeError("Not a table node: " + t.type.name); const e = tse(t), n = t.childCount, r = []; let i = 0, s = null; const a = []; for (let f = 0, p = e * n; f < p; f++)r[f] = 0; for (let f = 0, p = 0; f < n; f++) { const g = t.child(f); p++; for (let b = 0; ; b++) { for (; i < r.length && r[i] != 0;)i++; if (b == g.childCount) break; const S = g.child(b), { colspan: C, rowspan: T, colwidth: A } = S.attrs; for (let M = 0; M < T; M++) { if (M + f >= n) { (s || (s = [])).push({ type: "overlong_rowspan", pos: p, n: T - M }); break } const O = i + M * e; for (let E = 0; E < C; E++) { r[O + E] == 0 ? r[O + E] = p : (s || (s = [])).push({ type: "collision", row: f, pos: p, n: C - E }); const k = A && A[E]; if (k) { const z = (O + E) % e * 2, V = a[z]; V == null || V != k && a[z + 1] == 1 ? (a[z] = k, a[z + 1] = 1) : V == k && a[z + 1]++ } } } i += C, p += S.nodeSize } const y = (f + 1) * e; let v = 0; for (; i < y;)r[i++] == 0 && v++; v && (s || (s = [])).push({ type: "missing", row: f, n: v }), p++ } (e === 0 || n === 0) && (s || (s = [])).push({ type: "zero_sized" }); const l = new Xn(e, n, r, s); let u = !1; for (let f = 0; !u && f < a.length; f += 2)a[f] != null && a[f + 1] < n && (u = !0); return u && nse(l, a, t), l } function tse(t) { let e = -1, n = !1; for (let r = 0; r < t.childCount; r++) { const i = t.child(r); let s = 0; if (n) for (let a = 0; a < r; a++) { const l = t.child(a); for (let u = 0; u < l.childCount; u++) { const f = l.child(u); a + f.attrs.rowspan > r && (s += f.attrs.colspan) } } for (let a = 0; a < i.childCount; a++) { const l = i.child(a); s += l.attrs.colspan, l.attrs.rowspan > 1 && (n = !0) } e == -1 ? e = s : e != s && (e = Math.max(e, s)) } return e } function nse(t, e, n) { t.problems || (t.problems = []); const r = {}; for (let i = 0; i < t.map.length; i++) { const s = t.map[i]; if (r[s]) continue; r[s] = !0; const a = n.nodeAt(s); if (!a) throw new RangeError(`No cell with offset ${s} found`); let l = null; const u = a.attrs; for (let f = 0; f < u.colspan; f++) { const p = (i + f) % t.width, g = e[p * 2]; g != null && (!u.colwidth || u.colwidth[f] != g) && ((l || (l = rse(u)))[f] = g) } l && t.problems.unshift({ type: "colwidth mismatch", pos: s, colwidth: l }) } } function rse(t) { if (t.colwidth) return t.colwidth.slice(); const e = []; for (let n = 0; n < t.colspan; n++)e.push(0); return e } function Xr(t) { let e = t.cached.tableNodeTypes; if (!e) { e = t.cached.tableNodeTypes = {}; for (const n in t.nodes) { const r = t.nodes[n], i = r.spec.tableRole; i && (e[i] = r) } } return e } var Ao = new Br("selectingCells"); function Lu(t) { for (let e = t.depth - 1; e > 0; e--)if (t.node(e).type.spec.tableRole == "row") return t.node(0).resolve(t.before(e + 1)); return null } function ise(t) { for (let e = t.depth; e > 0; e--) { const n = t.node(e).type.spec.tableRole; if (n === "cell" || n === "header_cell") return t.node(e) } return null } function _s(t) { const e = t.selection.$head; for (let n = e.depth; n > 0; n--)if (e.node(n).type.spec.tableRole == "row") return !0; return !1 } function Vy(t) { const e = t.selection; if ("$anchorCell" in e && e.$anchorCell) return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell; if ("node" in e && e.node && e.node.type.spec.tableRole == "cell") return e.$anchor; const n = Lu(e.$head) || sse(e.$head); if (n) return n; throw new RangeError(`No cell found around position ${e.head}`) } function sse(t) { for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) { const r = e.type.spec.tableRole; if (r == "cell" || r == "header_cell") return t.doc.resolve(n) } for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) { const r = e.type.spec.tableRole; if (r == "cell" || r == "header_cell") return t.doc.resolve(n - e.nodeSize) } } function Z1(t) { return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter } function ase(t) { return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize) } function k2(t, e) { return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1) } function h6(t, e, n) { const r = t.node(-1), i = Xn.get(r), s = t.start(-1), a = i.nextCell(t.pos - s, e, n); return a == null ? null : t.node(0).resolve(s + a) } function sc(t, e, n = 1) { const r = { ...t, colspan: t.colspan - n }; return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, n), r.colwidth.some(i => i > 0) || (r.colwidth = null)), r } function p6(t, e, n = 1) { const r = { ...t, colspan: t.colspan + n }; if (r.colwidth) { r.colwidth = r.colwidth.slice(); for (let i = 0; i < n; i++)r.colwidth.splice(e, 0, 0) } return r } function ose(t, e, n) { const r = Xr(e.type.schema).header_cell; for (let i = 0; i < t.height; i++)if (e.nodeAt(t.map[n + i * t.width]).type != r) return !1; return !0 } var An = class Ma extends Ot { constructor(e, n = e) { const r = e.node(-1), i = Xn.get(r), s = e.start(-1), a = i.rectBetween(e.pos - s, n.pos - s), l = e.node(0), u = i.cellsInRect(a).filter(p => p != n.pos - s); u.unshift(n.pos - s); const f = u.map(p => { const g = r.nodeAt(p); if (!g) throw RangeError(`No cell with offset ${p} found`); const y = s + p + 1; return new x5(l.resolve(y), l.resolve(y + g.content.size)) }); super(f[0].$from, f[0].$to, f), this.$anchorCell = e, this.$headCell = n } map(e, n) { const r = e.resolve(n.map(this.$anchorCell.pos)), i = e.resolve(n.map(this.$headCell.pos)); if (Z1(r) && Z1(i) && k2(r, i)) { const s = this.$anchorCell.node(-1) != r.node(-1); return s && this.isRowSelection() ? Ma.rowSelection(r, i) : s && this.isColSelection() ? Ma.colSelection(r, i) : new Ma(r, i) } return Et.between(r, i) } content() { const e = this.$anchorCell.node(-1), n = Xn.get(e), r = this.$anchorCell.start(-1), i = n.rectBetween(this.$anchorCell.pos - r, this.$headCell.pos - r), s = {}, a = []; for (let u = i.top; u < i.bottom; u++) { const f = []; for (let p = u * n.width + i.left, g = i.left; g < i.right; g++, p++) { const y = n.map[p]; if (s[y]) continue; s[y] = !0; const v = n.findCell(y); let b = e.nodeAt(y); if (!b) throw RangeError(`No cell with offset ${y} found`); const S = i.left - v.left, C = v.right - i.right; if (S > 0 || C > 0) { let T = b.attrs; if (S > 0 && (T = sc(T, 0, S)), C > 0 && (T = sc(T, T.colspan - C, C)), v.left < i.left) { if (b = b.type.createAndFill(T), !b) throw RangeError(`Could not create cell with attrs ${JSON.stringify(T)}`) } else b = b.type.create(T, b.content) } if (v.top < i.top || v.bottom > i.bottom) { const T = { ...b.attrs, rowspan: Math.min(v.bottom, i.bottom) - Math.max(v.top, i.top) }; v.top < i.top ? b = b.type.createAndFill(T) : b = b.type.create(T, b.content) } f.push(b) } a.push(e.child(u).copy(Ue.from(f))) } const l = this.isColSelection() && this.isRowSelection() ? e : a; return new nt(Ue.from(l), 1, 1) } replace(e, n = nt.empty) { const r = e.steps.length, i = this.ranges; for (let a = 0; a < i.length; a++) { const { $from: l, $to: u } = i[a], f = e.mapping.slice(r); e.replace(f.map(l.pos), f.map(u.pos), a ? nt.empty : n) } const s = Ot.findFrom(e.doc.resolve(e.mapping.slice(r).map(this.to)), -1); s && e.setSelection(s) } replaceWith(e, n) { this.replace(e, new nt(Ue.from(n), 0, 0)) } forEachCell(e) { const n = this.$anchorCell.node(-1), r = Xn.get(n), i = this.$anchorCell.start(-1), s = r.cellsInRect(r.rectBetween(this.$anchorCell.pos - i, this.$headCell.pos - i)); for (let a = 0; a < s.length; a++)e(n.nodeAt(s[a]), i + s[a]) } isColSelection() { const e = this.$anchorCell.index(-1), n = this.$headCell.index(-1); if (Math.min(e, n) > 0) return !1; const r = e + this.$anchorCell.nodeAfter.attrs.rowspan, i = n + this.$headCell.nodeAfter.attrs.rowspan; return Math.max(r, i) == this.$headCell.node(-1).childCount } static colSelection(e, n = e) { const r = e.node(-1), i = Xn.get(r), s = e.start(-1), a = i.findCell(e.pos - s), l = i.findCell(n.pos - s), u = e.node(0); return a.top <= l.top ? (a.top > 0 && (e = u.resolve(s + i.map[a.left])), l.bottom < i.height && (n = u.resolve(s + i.map[i.width * (i.height - 1) + l.right - 1]))) : (l.top > 0 && (n = u.resolve(s + i.map[l.left])), a.bottom < i.height && (e = u.resolve(s + i.map[i.width * (i.height - 1) + a.right - 1]))), new Ma(e, n) } isRowSelection() { const e = this.$anchorCell.node(-1), n = Xn.get(e), r = this.$anchorCell.start(-1), i = n.colCount(this.$anchorCell.pos - r), s = n.colCount(this.$headCell.pos - r); if (Math.min(i, s) > 0) return !1; const a = i + this.$anchorCell.nodeAfter.attrs.colspan, l = s + this.$headCell.nodeAfter.attrs.colspan; return Math.max(a, l) == n.width } eq(e) { return e instanceof Ma && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos } static rowSelection(e, n = e) { const r = e.node(-1), i = Xn.get(r), s = e.start(-1), a = i.findCell(e.pos - s), l = i.findCell(n.pos - s), u = e.node(0); return a.left <= l.left ? (a.left > 0 && (e = u.resolve(s + i.map[a.top * i.width])), l.right < i.width && (n = u.resolve(s + i.map[i.width * (l.top + 1) - 1]))) : (l.left > 0 && (n = u.resolve(s + i.map[l.top * i.width])), a.right < i.width && (e = u.resolve(s + i.map[i.width * (a.top + 1) - 1]))), new Ma(e, n) } toJSON() { return { type: "cell", anchor: this.$anchorCell.pos, head: this.$headCell.pos } } static fromJSON(e, n) { return new Ma(e.resolve(n.anchor), e.resolve(n.head)) } static create(e, n, r = n) { return new Ma(e.resolve(n), e.resolve(r)) } getBookmark() { return new lse(this.$anchorCell.pos, this.$headCell.pos) } }; An.prototype.visible = !1; Ot.jsonID("cell", An); var lse = class m6 { constructor(e, n) { this.anchor = e, this.head = n } map(e) { return new m6(e.map(this.anchor), e.map(this.head)) } resolve(e) { const n = e.resolve(this.anchor), r = e.resolve(this.head); return n.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && n.index() < n.parent.childCount && r.index() < r.parent.childCount && k2(n, r) ? new An(n, r) : Ot.near(r, 1) } }; function cse(t) { if (!(t.selection instanceof An)) return null; const e = []; return t.selection.forEachCell((n, r) => { e.push(si.node(r, r + n.nodeSize, { class: "selectedCell" })) }), Yn.create(t.doc, e) } function use({ $from: t, $to: e }) { if (t.pos == e.pos || t.pos < e.pos - 6) return !1; let n = t.pos, r = e.pos, i = t.depth; for (; i >= 0 && !(t.after(i + 1) < t.end(i)); i--, n++); for (let s = e.depth; s >= 0 && !(e.before(s + 1) > e.start(s)); s--, r--); return n == r && /row|table/.test(t.node(i).type.spec.tableRole) } function dse({ $from: t, $to: e }) { let n, r; for (let i = t.depth; i > 0; i--) { const s = t.node(i); if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") { n = s; break } } for (let i = e.depth; i > 0; i--) { const s = e.node(i); if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") { r = s; break } } return n !== r && e.parentOffset === 0 } function fse(t, e, n) { const r = (e || t).selection, i = (e || t).doc; let s, a; if (r instanceof Ct && (a = r.node.type.spec.tableRole)) { if (a == "cell" || a == "header_cell") s = An.create(i, r.from); else if (a == "row") { const l = i.resolve(r.from + 1); s = An.rowSelection(l, l) } else if (!n) { const l = Xn.get(r.node), u = r.from + 1, f = u + l.map[l.width * l.height - 1]; s = An.create(i, u + 1, f) } } else r instanceof Et && use(r) ? s = Et.create(i, r.from) : r instanceof Et && dse(r) && (s = Et.create(i, r.$from.start(), r.$from.end())); return s && (e || (e = t.tr)).setSelection(s), e } var hse = new Br("fix-tables"); function g6(t, e, n, r) { const i = t.childCount, s = e.childCount; e: for (let a = 0, l = 0; a < s; a++) { const u = e.child(a); for (let f = l, p = Math.min(i, a + 3); f < p; f++)if (t.child(f) == u) { l = f + 1, n += u.nodeSize; continue e } r(u, n), l < i && t.child(l).sameMarkup(u) ? g6(t.child(l), u, n + 1, r) : u.nodesBetween(0, u.content.size, r, n + 1), n += u.nodeSize } } function y6(t, e) { let n; const r = (i, s) => { i.type.spec.tableRole == "table" && (n = pse(t, i, s, n)) }; return e ? e.doc != t.doc && g6(e.doc, t.doc, 0, r) : t.doc.descendants(r), n } function pse(t, e, n, r) { const i = Xn.get(e); if (!i.problems) return r; r || (r = t.tr); const s = []; for (let u = 0; u < i.height; u++)s.push(0); for (let u = 0; u < i.problems.length; u++) { const f = i.problems[u]; if (f.type == "collision") { const p = e.nodeAt(f.pos); if (!p) continue; const g = p.attrs; for (let y = 0; y < g.rowspan; y++)s[f.row + y] += f.n; r.setNodeMarkup(r.mapping.map(n + 1 + f.pos), null, sc(g, g.colspan - f.n, f.n)) } else if (f.type == "missing") s[f.row] += f.n; else if (f.type == "overlong_rowspan") { const p = e.nodeAt(f.pos); if (!p) continue; r.setNodeMarkup(r.mapping.map(n + 1 + f.pos), null, { ...p.attrs, rowspan: p.attrs.rowspan - f.n }) } else if (f.type == "colwidth mismatch") { const p = e.nodeAt(f.pos); if (!p) continue; r.setNodeMarkup(r.mapping.map(n + 1 + f.pos), null, { ...p.attrs, colwidth: f.colwidth }) } else if (f.type == "zero_sized") { const p = r.mapping.map(n); r.delete(p, p + e.nodeSize) } } let a, l; for (let u = 0; u < s.length; u++)s[u] && (a == null && (a = u), l = u); for (let u = 0, f = n + 1; u < i.height; u++) { const p = e.child(u), g = f + p.nodeSize, y = s[u]; if (y > 0) { let v = "cell"; p.firstChild && (v = p.firstChild.type.spec.tableRole); const b = []; for (let C = 0; C < y; C++) { const T = Xr(t.schema)[v].createAndFill(); T && b.push(T) } const S = (u == 0 || a == u - 1) && l == u ? f + 1 : g - 1; r.insert(r.mapping.map(S), b) } f = g } return r.setMeta(hse, { fixTables: !0 }) } function oa(t) { const e = t.selection, n = Vy(t), r = n.node(-1), i = n.start(-1), s = Xn.get(r); return { ...e instanceof An ? s.rectBetween(e.$anchorCell.pos - i, e.$headCell.pos - i) : s.findCell(n.pos - i), tableStart: i, map: s, table: r } } function v6(t, { map: e, tableStart: n, table: r }, i) { let s = i > 0 ? -1 : 0; ose(e, r, i + s) && (s = i == 0 || i == e.width ? null : 0); for (let a = 0; a < e.height; a++) { const l = a * e.width + i; if (i > 0 && i < e.width && e.map[l - 1] == e.map[l]) { const u = e.map[l], f = r.nodeAt(u); t.setNodeMarkup(t.mapping.map(n + u), null, p6(f.attrs, i - e.colCount(u))), a += f.attrs.rowspan - 1 } else { const u = s == null ? Xr(r.type.schema).cell : r.nodeAt(e.map[l + s]).type, f = e.positionAt(a, i, r); t.insert(t.mapping.map(n + f), u.createAndFill()) } } return t } function mse(t, e) { if (!_s(t)) return !1; if (e) { const n = oa(t); e(v6(t.tr, n, n.left)) } return !0 } function gse(t, e) { if (!_s(t)) return !1; if (e) { const n = oa(t); e(v6(t.tr, n, n.right)) } return !0 } function yse(t, { map: e, table: n, tableStart: r }, i) { const s = t.mapping.maps.length; for (let a = 0; a < e.height;) { const l = a * e.width + i, u = e.map[l], f = n.nodeAt(u), p = f.attrs; if (i > 0 && e.map[l - 1] == u || i < e.width - 1 && e.map[l + 1] == u) t.setNodeMarkup(t.mapping.slice(s).map(r + u), null, sc(p, i - e.colCount(u))); else { const g = t.mapping.slice(s).map(r + u); t.delete(g, g + f.nodeSize) } a += p.rowspan } } function vse(t, e) { if (!_s(t)) return !1; if (e) { const n = oa(t), r = t.tr; if (n.left == 0 && n.right == n.map.width) return !1; for (let i = n.right - 1; yse(r, n, i), i != n.left; i--) { const s = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc; if (!s) throw RangeError("No table found"); n.table = s, n.map = Xn.get(s) } e(r) } return !0 } function xse(t, e, n) { var r; const i = Xr(e.type.schema).header_cell; for (let s = 0; s < t.width; s++)if (((r = e.nodeAt(t.map[s + n * t.width])) == null ? void 0 : r.type) != i) return !1; return !0 } function x6(t, { map: e, tableStart: n, table: r }, i) { var s; let a = n; for (let f = 0; f < i; f++)a += r.child(f).nodeSize; const l = []; let u = i > 0 ? -1 : 0; xse(e, r, i + u) && (u = i == 0 || i == e.height ? null : 0); for (let f = 0, p = e.width * i; f < e.width; f++, p++)if (i > 0 && i < e.height && e.map[p] == e.map[p - e.width]) { const g = e.map[p], y = r.nodeAt(g).attrs; t.setNodeMarkup(n + g, null, { ...y, rowspan: y.rowspan + 1 }), f += y.colspan - 1 } else { const g = u == null ? Xr(r.type.schema).cell : (s = r.nodeAt(e.map[p + u * e.width])) == null ? void 0 : s.type, y = g?.createAndFill(); y && l.push(y) } return t.insert(a, Xr(r.type.schema).row.create(null, l)), t } function bse(t, e) { if (!_s(t)) return !1; if (e) { const n = oa(t); e(x6(t.tr, n, n.top)) } return !0 } function wse(t, e) { if (!_s(t)) return !1; if (e) { const n = oa(t); e(x6(t.tr, n, n.bottom)) } return !0 } function Sse(t, { map: e, table: n, tableStart: r }, i) { let s = 0; for (let f = 0; f < i; f++)s += n.child(f).nodeSize; const a = s + n.child(i).nodeSize, l = t.mapping.maps.length; t.delete(s + r, a + r); const u = new Set; for (let f = 0, p = i * e.width; f < e.width; f++, p++) { const g = e.map[p]; if (!u.has(g)) { if (u.add(g), i > 0 && g == e.map[p - e.width]) { const y = n.nodeAt(g).attrs; t.setNodeMarkup(t.mapping.slice(l).map(g + r), null, { ...y, rowspan: y.rowspan - 1 }), f += y.colspan - 1 } else if (i < e.height && g == e.map[p + e.width]) { const y = n.nodeAt(g), v = y.attrs, b = y.type.create({ ...v, rowspan: y.attrs.rowspan - 1 }, y.content), S = e.positionAt(i + 1, f, n); t.insert(t.mapping.slice(l).map(r + S), b), f += v.colspan - 1 } } } } function Cse(t, e) { if (!_s(t)) return !1; if (e) { const n = oa(t), r = t.tr; if (n.top == 0 && n.bottom == n.map.height) return !1; for (let i = n.bottom - 1; Sse(r, n, i), i != n.top; i--) { const s = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc; if (!s) throw RangeError("No table found"); n.table = s, n.map = Xn.get(n.table) } e(r) } return !0 } function Z4(t) { const e = t.content; return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0 } function Tse({ width: t, height: e, map: n }, r) { let i = r.top * t + r.left, s = i, a = (r.bottom - 1) * t + r.left, l = i + (r.right - r.left - 1); for (let u = r.top; u < r.bottom; u++) { if (r.left > 0 && n[s] == n[s - 1] || r.right < t && n[l] == n[l + 1]) return !0; s += t, l += t } for (let u = r.left; u < r.right; u++) { if (r.top > 0 && n[i] == n[i - t] || r.bottom < e && n[a] == n[a + t]) return !0; i++, a++ } return !1 } function e3(t, e) { const n = t.selection; if (!(n instanceof An) || n.$anchorCell.pos == n.$headCell.pos) return !1; const r = oa(t), { map: i } = r; if (Tse(i, r)) return !1; if (e) { const s = t.tr, a = {}; let l = Ue.empty, u, f; for (let p = r.top; p < r.bottom; p++)for (let g = r.left; g < r.right; g++) { const y = i.map[p * i.width + g], v = r.table.nodeAt(y); if (!(a[y] || !v)) if (a[y] = !0, u == null) u = y, f = v; else { Z4(v) || (l = l.append(v.content)); const b = s.mapping.map(y + r.tableStart); s.delete(b, b + v.nodeSize) } } if (u == null || f == null) return !0; if (s.setNodeMarkup(u + r.tableStart, null, { ...p6(f.attrs, f.attrs.colspan, r.right - r.left - f.attrs.colspan), rowspan: r.bottom - r.top }), l.size) { const p = u + 1 + f.content.size, g = Z4(f) ? u + 1 : p; s.replaceWith(g + r.tableStart, p + r.tableStart, l) } s.setSelection(new An(s.doc.resolve(u + r.tableStart))), e(s) } return !0 } function t3(t, e) { const n = Xr(t.schema); return Nse(({ node: r }) => n[r.type.spec.tableRole])(t, e) } function Nse(t) { return (e, n) => { var r; const i = e.selection; let s, a; if (i instanceof An) { if (i.$anchorCell.pos != i.$headCell.pos) return !1; s = i.$anchorCell.nodeAfter, a = i.$anchorCell.pos } else { if (s = ise(i.$from), !s) return !1; a = (r = Lu(i.$from)) == null ? void 0 : r.pos } if (s == null || a == null || s.attrs.colspan == 1 && s.attrs.rowspan == 1) return !1; if (n) { let l = s.attrs; const u = [], f = l.colwidth; l.rowspan > 1 && (l = { ...l, rowspan: 1 }), l.colspan > 1 && (l = { ...l, colspan: 1 }); const p = oa(e), g = e.tr; for (let v = 0; v < p.right - p.left; v++)u.push(f ? { ...l, colwidth: f && f[v] ? [f[v]] : null } : l); let y; for (let v = p.top; v < p.bottom; v++) { let b = p.map.positionAt(v, p.left, p.table); v == p.top && (b += s.nodeSize); for (let S = p.left, C = 0; S < p.right; S++, C++)S == p.left && v == p.top || g.insert(y = g.mapping.map(b + p.tableStart, 1), t({ node: s, row: v, col: S }).createAndFill(u[C])) } g.setNodeMarkup(a, t({ node: s, row: p.top, col: p.left }), u[0]), i instanceof An && g.setSelection(new An(g.doc.resolve(i.$anchorCell.pos), y ? g.doc.resolve(y) : void 0)), n(g) } return !0 } } function jse(t, e) { return function (n, r) { if (!_s(n)) return !1; const i = Vy(n); if (i.nodeAfter.attrs[t] === e) return !1; if (r) { const s = n.tr; n.selection instanceof An ? n.selection.forEachCell((a, l) => { a.attrs[t] !== e && s.setNodeMarkup(l, null, { ...a.attrs, [t]: e }) }) : s.setNodeMarkup(i.pos, null, { ...i.nodeAfter.attrs, [t]: e }), r(s) } return !0 } } function Ese(t) { return function (e, n) { if (!_s(e)) return !1; if (n) { const r = Xr(e.schema), i = oa(e), s = e.tr, a = i.map.cellsInRect(t == "column" ? { left: i.left, top: 0, right: i.right, bottom: i.map.height } : t == "row" ? { left: 0, top: i.top, right: i.map.width, bottom: i.bottom } : i), l = a.map(u => i.table.nodeAt(u)); for (let u = 0; u < a.length; u++)l[u].type == r.header_cell && s.setNodeMarkup(i.tableStart + a[u], r.cell, l[u].attrs); if (s.steps.length == 0) for (let u = 0; u < a.length; u++)s.setNodeMarkup(i.tableStart + a[u], r.header_cell, l[u].attrs); n(s) } return !0 } } function n3(t, e, n) { const r = e.map.cellsInRect({ left: 0, top: 0, right: t == "row" ? e.map.width : 1, bottom: t == "column" ? e.map.height : 1 }); for (let i = 0; i < r.length; i++) { const s = e.table.nodeAt(r[i]); if (s && s.type !== n.header_cell) return !1 } return !0 } function rh(t, e) { return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? Ese(t) : function (n, r) { if (!_s(n)) return !1; if (r) { const i = Xr(n.schema), s = oa(n), a = n.tr, l = n3("row", s, i), u = n3("column", s, i), p = (t === "column" ? l : t === "row" ? u : !1) ? 1 : 0, g = t == "column" ? { left: 0, top: p, right: 1, bottom: s.map.height } : t == "row" ? { left: p, top: 0, right: s.map.width, bottom: 1 } : s, y = t == "column" ? u ? i.cell : i.header_cell : t == "row" ? l ? i.cell : i.header_cell : i.cell; s.map.cellsInRect(g).forEach(v => { const b = v + s.tableStart, S = a.doc.nodeAt(b); S && a.setNodeMarkup(b, y, S.attrs) }), r(a) } return !0 } } rh("row", { useDeprecatedLogic: !0 }); rh("column", { useDeprecatedLogic: !0 }); var Ase = rh("cell", { useDeprecatedLogic: !0 }); function kse(t, e) { if (e < 0) { const n = t.nodeBefore; if (n) return t.pos - n.nodeSize; for (let r = t.index(-1) - 1, i = t.before(); r >= 0; r--) { const s = t.node(-1).child(r), a = s.lastChild; if (a) return i - 1 - a.nodeSize; i -= s.nodeSize } } else { if (t.index() < t.parent.childCount - 1) return t.pos + t.nodeAfter.nodeSize; const n = t.node(-1); for (let r = t.indexAfter(-1), i = t.after(); r < n.childCount; r++) { const s = n.child(r); if (s.childCount) return i + 1; i += s.nodeSize } } return null } function r3(t) { return function (e, n) { if (!_s(e)) return !1; const r = kse(Vy(e), t); if (r == null) return !1; if (n) { const i = e.doc.resolve(r); n(e.tr.setSelection(Et.between(i, ase(i))).scrollIntoView()) } return !0 } } function Ose(t, e) { const n = t.selection.$anchor; for (let r = n.depth; r > 0; r--)if (n.node(r).type.spec.tableRole == "table") return e && e(t.tr.delete(n.before(r), n.after(r)).scrollIntoView()), !0; return !1 } function am(t, e) { const n = t.selection; if (!(n instanceof An)) return !1; if (e) { const r = t.tr, i = Xr(t.schema).cell.createAndFill().content; n.forEachCell((s, a) => { s.content.eq(i) || r.replace(r.mapping.map(a + 1), r.mapping.map(a + s.nodeSize - 1), new nt(i, 0, 0)) }), r.docChanged && e(r) } return !0 } function Mse(t) { if (!t.size) return null; let { content: e, openStart: n, openEnd: r } = t; for (; e.childCount == 1 && (n > 0 && r > 0 || e.child(0).type.spec.tableRole == "table");)n--, r--, e = e.child(0).content; const i = e.child(0), s = i.type.spec.tableRole, a = i.type.schema, l = []; if (s == "row") for (let u = 0; u < e.childCount; u++) { let f = e.child(u).content; const p = u ? 0 : Math.max(0, n - 1), g = u < e.childCount - 1 ? 0 : Math.max(0, r - 1); (p || g) && (f = ew(Xr(a).row, new nt(f, p, g)).content), l.push(f) } else if (s == "cell" || s == "header_cell") l.push(n || r ? ew(Xr(a).row, new nt(e, n, r)).content : e); else return null; return Dse(a, l) } function Dse(t, e) { const n = []; for (let i = 0; i < e.length; i++) { const s = e[i]; for (let a = s.childCount - 1; a >= 0; a--) { const { rowspan: l, colspan: u } = s.child(a).attrs; for (let f = i; f < i + l; f++)n[f] = (n[f] || 0) + u } } let r = 0; for (let i = 0; i < n.length; i++)r = Math.max(r, n[i]); for (let i = 0; i < n.length; i++)if (i >= e.length && e.push(Ue.empty), n[i] < r) { const s = Xr(t).cell.createAndFill(), a = []; for (let l = n[i]; l < r; l++)a.push(s); e[i] = e[i].append(Ue.from(a)) } return { height: e.length, width: r, rows: e } } function ew(t, e) { const n = t.createAndFill(); return new zS(n).replace(0, n.content.size, e).doc } function Rse({ width: t, height: e, rows: n }, r, i) { if (t != r) { const s = [], a = []; for (let l = 0; l < n.length; l++) { const u = n[l], f = []; for (let p = s[l] || 0, g = 0; p < r; g++) { let y = u.child(g % u.childCount); p + y.attrs.colspan > r && (y = y.type.createChecked(sc(y.attrs, y.attrs.colspan, p + y.attrs.colspan - r), y.content)), f.push(y), p += y.attrs.colspan; for (let v = 1; v < y.attrs.rowspan; v++)s[l + v] = (s[l + v] || 0) + y.attrs.colspan } a.push(Ue.from(f)) } n = a, t = r } if (e != i) { const s = []; for (let a = 0, l = 0; a < i; a++, l++) { const u = [], f = n[l % e]; for (let p = 0; p < f.childCount; p++) { let g = f.child(p); a + g.attrs.rowspan > i && (g = g.type.create({ ...g.attrs, rowspan: Math.max(1, i - g.attrs.rowspan) }, g.content)), u.push(g) } s.push(Ue.from(u)) } n = s, e = i } return { width: t, height: e, rows: n } } function _se(t, e, n, r, i, s, a) { const l = t.doc.type.schema, u = Xr(l); let f, p; if (i > e.width) for (let g = 0, y = 0; g < e.height; g++) { const v = n.child(g); y += v.nodeSize; const b = []; let S; v.lastChild == null || v.lastChild.type == u.cell ? S = f || (f = u.cell.createAndFill()) : S = p || (p = u.header_cell.createAndFill()); for (let C = e.width; C < i; C++)b.push(S); t.insert(t.mapping.slice(a).map(y - 1 + r), b) } if (s > e.height) { const g = []; for (let b = 0, S = (e.height - 1) * e.width; b < Math.max(e.width, i); b++) { const C = b >= e.width ? !1 : n.nodeAt(e.map[S + b]).type == u.header_cell; g.push(C ? p || (p = u.header_cell.createAndFill()) : f || (f = u.cell.createAndFill())) } const y = u.row.create(null, Ue.from(g)), v = []; for (let b = e.height; b < s; b++)v.push(y); t.insert(t.mapping.slice(a).map(r + n.nodeSize - 2), v) } return !!(f || p) } function i3(t, e, n, r, i, s, a, l) { if (a == 0 || a == e.height) return !1; let u = !1; for (let f = i; f < s; f++) { const p = a * e.width + f, g = e.map[p]; if (e.map[p - e.width] == g) { u = !0; const y = n.nodeAt(g), { top: v, left: b } = e.findCell(g); t.setNodeMarkup(t.mapping.slice(l).map(g + r), null, { ...y.attrs, rowspan: a - v }), t.insert(t.mapping.slice(l).map(e.positionAt(a, b, n)), y.type.createAndFill({ ...y.attrs, rowspan: v + y.attrs.rowspan - a })), f += y.attrs.colspan - 1 } } return u } function s3(t, e, n, r, i, s, a, l) { if (a == 0 || a == e.width) return !1; let u = !1; for (let f = i; f < s; f++) { const p = f * e.width + a, g = e.map[p]; if (e.map[p - 1] == g) { u = !0; const y = n.nodeAt(g), v = e.colCount(g), b = t.mapping.slice(l).map(g + r); t.setNodeMarkup(b, null, sc(y.attrs, a - v, y.attrs.colspan - (a - v))), t.insert(b + y.nodeSize, y.type.createAndFill(sc(y.attrs, 0, a - v))), f += y.attrs.rowspan - 1 } } return u } function a3(t, e, n, r, i) { let s = n ? t.doc.nodeAt(n - 1) : t.doc; if (!s) throw new Error("No table found"); let a = Xn.get(s); const { top: l, left: u } = r, f = u + i.width, p = l + i.height, g = t.tr; let y = 0; function v() { if (s = n ? g.doc.nodeAt(n - 1) : g.doc, !s) throw new Error("No table found"); a = Xn.get(s), y = g.mapping.maps.length } _se(g, a, s, n, f, p, y) && v(), i3(g, a, s, n, u, f, l, y) && v(), i3(g, a, s, n, u, f, p, y) && v(), s3(g, a, s, n, l, p, u, y) && v(), s3(g, a, s, n, l, p, f, y) && v(); for (let b = l; b < p; b++) { const S = a.positionAt(b, u, s), C = a.positionAt(b, f, s); g.replace(g.mapping.slice(y).map(S + n), g.mapping.slice(y).map(C + n), new nt(i.rows[b - l], 0, 0)) } v(), g.setSelection(new An(g.doc.resolve(n + a.positionAt(l, u, s)), g.doc.resolve(n + a.positionAt(p - 1, f - 1, s)))), e(g) } var Lse = YS({ ArrowLeft: om("horiz", -1), ArrowRight: om("horiz", 1), ArrowUp: om("vert", -1), ArrowDown: om("vert", 1), "Shift-ArrowLeft": lm("horiz", -1), "Shift-ArrowRight": lm("horiz", 1), "Shift-ArrowUp": lm("vert", -1), "Shift-ArrowDown": lm("vert", 1), Backspace: am, "Mod-Backspace": am, Delete: am, "Mod-Delete": am }); function Lm(t, e, n) { return n.eq(t.selection) ? !1 : (e && e(t.tr.setSelection(n).scrollIntoView()), !0) } function om(t, e) { return (n, r, i) => { if (!i) return !1; const s = n.selection; if (s instanceof An) return Lm(n, r, Ot.near(s.$headCell, e)); if (t != "horiz" && !s.empty) return !1; const a = b6(i, t, e); if (a == null) return !1; if (t == "horiz") return Lm(n, r, Ot.near(n.doc.resolve(s.head + e), e)); { const l = n.doc.resolve(a), u = h6(l, t, e); let f; return u ? f = Ot.near(u, 1) : e < 0 ? f = Ot.near(n.doc.resolve(l.before(-1)), -1) : f = Ot.near(n.doc.resolve(l.after(-1)), 1), Lm(n, r, f) } } } function lm(t, e) { return (n, r, i) => { if (!i) return !1; const s = n.selection; let a; if (s instanceof An) a = s; else { const u = b6(i, t, e); if (u == null) return !1; a = new An(n.doc.resolve(u)) } const l = h6(a.$headCell, t, e); return l ? Lm(n, r, new An(a.$anchorCell, l)) : !1 } } function Pse(t, e) { const n = t.state.doc, r = Lu(n.resolve(e)); return r ? (t.dispatch(t.state.tr.setSelection(new An(r))), !0) : !1 } function zse(t, e, n) { if (!_s(t.state)) return !1; let r = Mse(n); const i = t.state.selection; if (i instanceof An) { r || (r = { width: 1, height: 1, rows: [Ue.from(ew(Xr(t.state.schema).cell, n))] }); const s = i.$anchorCell.node(-1), a = i.$anchorCell.start(-1), l = Xn.get(s).rectBetween(i.$anchorCell.pos - a, i.$headCell.pos - a); return r = Rse(r, l.right - l.left, l.bottom - l.top), a3(t.state, t.dispatch, a, l, r), !0 } else if (r) { const s = Vy(t.state), a = s.start(-1); return a3(t.state, t.dispatch, a, Xn.get(s.node(-1)).findCell(s.pos - a), r), !0 } else return !1 } function Ise(t, e) { var n; if (e.ctrlKey || e.metaKey) return; const r = o3(t, e.target); let i; if (e.shiftKey && t.state.selection instanceof An) s(t.state.selection.$anchorCell, e), e.preventDefault(); else if (e.shiftKey && r && (i = Lu(t.state.selection.$anchor)) != null && ((n = db(t, e)) == null ? void 0 : n.pos) != i.pos) s(i, e), e.preventDefault(); else if (!r) return; function s(u, f) { let p = db(t, f); const g = Ao.getState(t.state) == null; if (!p || !k2(u, p)) if (g) p = u; else return; const y = new An(u, p); if (g || !t.state.selection.eq(y)) { const v = t.state.tr.setSelection(y); g && v.setMeta(Ao, u.pos), t.dispatch(v) } } function a() { t.root.removeEventListener("mouseup", a), t.root.removeEventListener("dragstart", a), t.root.removeEventListener("mousemove", l), Ao.getState(t.state) != null && t.dispatch(t.state.tr.setMeta(Ao, -1)) } function l(u) { const f = u, p = Ao.getState(t.state); let g; if (p != null) g = t.state.doc.resolve(p); else if (o3(t, f.target) != r && (g = db(t, e), !g)) return a(); g && s(g, f) } t.root.addEventListener("mouseup", a), t.root.addEventListener("dragstart", a), t.root.addEventListener("mousemove", l) } function b6(t, e, n) { if (!(t.state.selection instanceof Et)) return null; const { $head: r } = t.state.selection; for (let i = r.depth - 1; i >= 0; i--) { const s = r.node(i); if ((n < 0 ? r.index(i) : r.indexAfter(i)) != (n < 0 ? 0 : s.childCount)) return null; if (s.type.spec.tableRole == "cell" || s.type.spec.tableRole == "header_cell") { const l = r.before(i), u = e == "vert" ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left"; return t.endOfTextblock(u) ? l : null } } return null } function o3(t, e) { for (; e && e != t.dom; e = e.parentNode)if (e.nodeName == "TD" || e.nodeName == "TH") return e; return null } function db(t, e) { const n = t.posAtCoords({ left: e.clientX, top: e.clientY }); return n && n ? Lu(t.state.doc.resolve(n.pos)) : null } var Fse = class { constructor(e, n) { this.node = e, this.defaultCellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty("--default-cell-min-width", `${n}px`), this.colgroup = this.table.appendChild(document.createElement("colgroup")), tw(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody")) } update(e) { return e.type != this.node.type ? !1 : (this.node = e, tw(e, this.colgroup, this.table, this.defaultCellMinWidth), !0) } ignoreMutation(e) { return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target)) } }; function tw(t, e, n, r, i, s) { var a; let l = 0, u = !0, f = e.firstChild; const p = t.firstChild; if (p) { for (let g = 0, y = 0; g < p.childCount; g++) { const { colspan: v, colwidth: b } = p.child(g).attrs; for (let S = 0; S < v; S++, y++) { const C = i == y ? s : b && b[S], T = C ? C + "px" : ""; if (l += C || r, C || (u = !1), f) f.style.width != T && (f.style.width = T), f = f.nextSibling; else { const A = document.createElement("col"); A.style.width = T, e.appendChild(A) } } } for (; f;) { const g = f.nextSibling; (a = f.parentNode) == null || a.removeChild(f), f = g } u ? (n.style.width = l + "px", n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = l + "px") } } var Ii = new Br("tableColumnResizing"); function Bse({ handleWidth: t = 5, cellMinWidth: e = 25, defaultCellMinWidth: n = 100, View: r = Fse, lastColumnResizable: i = !0 } = {}) { const s = new hr({ key: Ii, state: { init(a, l) { var u, f; const p = (f = (u = s.spec) == null ? void 0 : u.props) == null ? void 0 : f.nodeViews, g = Xr(l.schema).table.name; return r && p && (p[g] = (y, v) => new r(y, n, v)), new $se(-1, !1) }, apply(a, l) { return l.apply(a) } }, props: { attributes: a => { const l = Ii.getState(a); return l && l.activeHandle > -1 ? { class: "resize-cursor" } : {} }, handleDOMEvents: { mousemove: (a, l) => { Use(a, l, t, i) }, mouseleave: a => { Vse(a) }, mousedown: (a, l) => { Hse(a, l, e, n) } }, decorations: a => { const l = Ii.getState(a); if (l && l.activeHandle > -1) return Gse(a, l.activeHandle) }, nodeViews: {} } }); return s } var $se = class Pm { constructor(e, n) { this.activeHandle = e, this.dragging = n } apply(e) { const n = this, r = e.getMeta(Ii); if (r && r.setHandle != null) return new Pm(r.setHandle, !1); if (r && r.setDragging !== void 0) return new Pm(n.activeHandle, r.setDragging); if (n.activeHandle > -1 && e.docChanged) { let i = e.mapping.map(n.activeHandle, -1); return Z1(e.doc.resolve(i)) || (i = -1), new Pm(i, n.dragging) } return n } }; function Use(t, e, n, r) { if (!t.editable) return; const i = Ii.getState(t.state); if (i && !i.dragging) { const s = Kse(e.target); let a = -1; if (s) { const { left: l, right: u } = s.getBoundingClientRect(); e.clientX - l <= n ? a = l3(t, e, "left", n) : u - e.clientX <= n && (a = l3(t, e, "right", n)) } if (a != i.activeHandle) { if (!r && a !== -1) { const l = t.state.doc.resolve(a), u = l.node(-1), f = Xn.get(u), p = l.start(-1); if (f.colCount(l.pos - p) + l.nodeAfter.attrs.colspan - 1 == f.width - 1) return } w6(t, a) } } } function Vse(t) { if (!t.editable) return; const e = Ii.getState(t.state); e && e.activeHandle > -1 && !e.dragging && w6(t, -1) } function Hse(t, e, n, r) { var i; if (!t.editable) return !1; const s = (i = t.dom.ownerDocument.defaultView) != null ? i : window, a = Ii.getState(t.state); if (!a || a.activeHandle == -1 || a.dragging) return !1; const l = t.state.doc.nodeAt(a.activeHandle), u = qse(t, a.activeHandle, l.attrs); t.dispatch(t.state.tr.setMeta(Ii, { setDragging: { startX: e.clientX, startWidth: u } })); function f(g) { s.removeEventListener("mouseup", f), s.removeEventListener("mousemove", p); const y = Ii.getState(t.state); y?.dragging && (Wse(t, y.activeHandle, c3(y.dragging, g, n)), t.dispatch(t.state.tr.setMeta(Ii, { setDragging: null }))) } function p(g) { if (!g.which) return f(g); const y = Ii.getState(t.state); if (y && y.dragging) { const v = c3(y.dragging, g, n); u3(t, y.activeHandle, v, r) } } return u3(t, a.activeHandle, u, r), s.addEventListener("mouseup", f), s.addEventListener("mousemove", p), e.preventDefault(), !0 } function qse(t, e, { colspan: n, colwidth: r }) { const i = r && r[r.length - 1]; if (i) return i; const s = t.domAtPos(e); let l = s.node.childNodes[s.offset].offsetWidth, u = n; if (r) for (let f = 0; f < n; f++)r[f] && (l -= r[f], u--); return l / u } function Kse(t) { for (; t && t.nodeName != "TD" && t.nodeName != "TH";)t = t.classList && t.classList.contains("ProseMirror") ? null : t.parentNode; return t } function l3(t, e, n, r) { const i = n == "right" ? -r : r, s = t.posAtCoords({ left: e.clientX + i, top: e.clientY }); if (!s) return -1; const { pos: a } = s, l = Lu(t.state.doc.resolve(a)); if (!l) return -1; if (n == "right") return l.pos; const u = Xn.get(l.node(-1)), f = l.start(-1), p = u.map.indexOf(l.pos - f); return p % u.width == 0 ? -1 : f + u.map[p - 1] } function c3(t, e, n) { const r = e.clientX - t.startX; return Math.max(n, t.startWidth + r) } function w6(t, e) { t.dispatch(t.state.tr.setMeta(Ii, { setHandle: e })) } function Wse(t, e, n) { const r = t.state.doc.resolve(e), i = r.node(-1), s = Xn.get(i), a = r.start(-1), l = s.colCount(r.pos - a) + r.nodeAfter.attrs.colspan - 1, u = t.state.tr; for (let f = 0; f < s.height; f++) { const p = f * s.width + l; if (f && s.map[p] == s.map[p - s.width]) continue; const g = s.map[p], y = i.nodeAt(g).attrs, v = y.colspan == 1 ? 0 : l - s.colCount(g); if (y.colwidth && y.colwidth[v] == n) continue; const b = y.colwidth ? y.colwidth.slice() : Yse(y.colspan); b[v] = n, u.setNodeMarkup(a + g, null, { ...y, colwidth: b }) } u.docChanged && t.dispatch(u) } function u3(t, e, n, r) { const i = t.state.doc.resolve(e), s = i.node(-1), a = i.start(-1), l = Xn.get(s).colCount(i.pos - a) + i.nodeAfter.attrs.colspan - 1; let u = t.domAtPos(i.start(-1)).node; for (; u && u.nodeName != "TABLE";)u = u.parentNode; u && tw(s, u.firstChild, u, r, l, n) } function Yse(t) { return Array(t).fill(0) } function Gse(t, e) { var n; const r = [], i = t.doc.resolve(e), s = i.node(-1); if (!s) return Yn.empty; const a = Xn.get(s), l = i.start(-1), u = a.colCount(i.pos - l) + i.nodeAfter.attrs.colspan - 1; for (let f = 0; f < a.height; f++) { const p = u + f * a.width; if ((u == a.width - 1 || a.map[p] != a.map[p + 1]) && (f == 0 || a.map[p] != a.map[p - a.width])) { const g = a.map[p], y = l + g + s.nodeAt(g).nodeSize - 1, v = document.createElement("div"); v.className = "column-resize-handle", (n = Ii.getState(t)) != null && n.dragging && r.push(si.node(l + g, l + g + s.nodeAt(g).nodeSize, { class: "column-resize-dragging" })), r.push(si.widget(y, v)) } } return Yn.create(t.doc, r) } function Xse({ allowTableNodeSelection: t = !1 } = {}) { return new hr({ key: Ao, state: { init() { return null }, apply(e, n) { const r = e.getMeta(Ao); if (r != null) return r == -1 ? null : r; if (n == null || !e.docChanged) return n; const { deleted: i, pos: s } = e.mapping.mapResult(n); return i ? null : s } }, props: { decorations: cse, handleDOMEvents: { mousedown: Ise }, createSelectionBetween(e) { return Ao.getState(e.state) != null ? e.state.selection : null }, handleTripleClick: Pse, handleKeyDown: Lse, handlePaste: zse }, appendTransaction(e, n, r) { return fse(r, y6(r, n), t) } }) } function nw(t, e) { return e ? ["width", `${Math.max(e, t)}px`] : ["min-width", `${t}px`] } function d3(t, e, n, r, i, s) { var a; let l = 0, u = !0, f = e.firstChild; const p = t.firstChild; if (p !== null) for (let g = 0, y = 0; g < p.childCount; g += 1) { const { colspan: v, colwidth: b } = p.child(g).attrs; for (let S = 0; S < v; S += 1, y += 1) { const C = i === y ? s : b && b[S], T = C ? `${C}px` : ""; if (l += C || r, C || (u = !1), f) { if (f.style.width !== T) { const [A, M] = nw(r, C); f.style.setProperty(A, M) } f = f.nextSibling } else { const A = document.createElement("col"), [M, O] = nw(r, C); A.style.setProperty(M, O), e.appendChild(A) } } } for (; f;) { const g = f.nextSibling; (a = f.parentNode) === null || a === void 0 || a.removeChild(f), f = g } u ? (n.style.width = `${l}px`, n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = `${l}px`) } class Qse { constructor(e, n) { this.node = e, this.cellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), d3(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody")) } update(e) { return e.type !== this.node.type ? !1 : (this.node = e, d3(e, this.colgroup, this.table, this.cellMinWidth), !0) } ignoreMutation(e) { return e.type === "attributes" && (e.target === this.table || this.colgroup.contains(e.target)) } } function Jse(t, e, n, r) { let i = 0, s = !0; const a = [], l = t.firstChild; if (!l) return {}; for (let g = 0, y = 0; g < l.childCount; g += 1) { const { colspan: v, colwidth: b } = l.child(g).attrs; for (let S = 0; S < v; S += 1, y += 1) { const C = n === y ? r : b && b[S]; i += C || e, C || (s = !1); const [T, A] = nw(e, C); a.push(["col", { style: `${T}: ${A}` }]) } } const u = s ? `${i}px` : "", f = s ? "" : `${i}px`; return { colgroup: ["colgroup", {}, ...a], tableWidth: u, tableMinWidth: f } } function f3(t, e) { return t.createAndFill() } function Zse(t) { if (t.cached.tableNodeTypes) return t.cached.tableNodeTypes; const e = {}; return Object.keys(t.nodes).forEach(n => { const r = t.nodes[n]; r.spec.tableRole && (e[r.spec.tableRole] = r) }), t.cached.tableNodeTypes = e, e } function eae(t, e, n, r, i) { const s = Zse(t), a = [], l = []; for (let f = 0; f < n; f += 1) { const p = f3(s.cell); if (p && l.push(p), r) { const g = f3(s.header_cell); g && a.push(g) } } const u = []; for (let f = 0; f < e; f += 1)u.push(s.row.createChecked(null, r && f === 0 ? a : l)); return s.table.createChecked(null, u) } function tae(t) { return t instanceof An } const cm = ({ editor: t }) => { const { selection: e } = t.state; if (!tae(e)) return !1; let n = 0; const r = C_(e.ranges[0].$from, s => s.type.name === "table"); return r?.node.descendants(s => { if (s.type.name === "table") return !1;["tableCell", "tableHeader"].includes(s.type.name) && (n += 1) }), n === e.ranges.length ? (t.commands.deleteTable(), !0) : !1 }, nae = Qn.create({ name: "table", addOptions() { return { HTMLAttributes: {}, resizable: !1, handleWidth: 5, cellMinWidth: 25, View: Qse, lastColumnResizable: !0, allowTableNodeSelection: !1 } }, content: "tableRow+", tableRole: "table", isolating: !0, group: "block", parseHTML() { return [{ tag: "table" }] }, renderHTML({ node: t, HTMLAttributes: e }) { const { colgroup: n, tableWidth: r, tableMinWidth: i } = Jse(t, this.options.cellMinWidth); return ["table", Ln(this.options.HTMLAttributes, e, { style: r ? `width: ${r}` : `min-width: ${i}` }), n, ["tbody", 0]] }, addCommands() { return { insertTable: ({ rows: t = 3, cols: e = 3, withHeaderRow: n = !0 } = {}) => ({ tr: r, dispatch: i, editor: s }) => { const a = eae(s.schema, t, e, n); if (i) { const l = r.selection.from + 1; r.replaceSelectionWith(a).scrollIntoView().setSelection(Et.near(r.doc.resolve(l))) } return !0 }, addColumnBefore: () => ({ state: t, dispatch: e }) => mse(t, e), addColumnAfter: () => ({ state: t, dispatch: e }) => gse(t, e), deleteColumn: () => ({ state: t, dispatch: e }) => vse(t, e), addRowBefore: () => ({ state: t, dispatch: e }) => bse(t, e), addRowAfter: () => ({ state: t, dispatch: e }) => wse(t, e), deleteRow: () => ({ state: t, dispatch: e }) => Cse(t, e), deleteTable: () => ({ state: t, dispatch: e }) => Ose(t, e), mergeCells: () => ({ state: t, dispatch: e }) => e3(t, e), splitCell: () => ({ state: t, dispatch: e }) => t3(t, e), toggleHeaderColumn: () => ({ state: t, dispatch: e }) => rh("column")(t, e), toggleHeaderRow: () => ({ state: t, dispatch: e }) => rh("row")(t, e), toggleHeaderCell: () => ({ state: t, dispatch: e }) => Ase(t, e), mergeOrSplit: () => ({ state: t, dispatch: e }) => e3(t, e) ? !0 : t3(t, e), setCellAttribute: (t, e) => ({ state: n, dispatch: r }) => jse(t, e)(n, r), goToNextCell: () => ({ state: t, dispatch: e }) => r3(1)(t, e), goToPreviousCell: () => ({ state: t, dispatch: e }) => r3(-1)(t, e), fixTables: () => ({ state: t, dispatch: e }) => (e && y6(t), !0), setCellSelection: t => ({ tr: e, dispatch: n }) => { if (n) { const r = An.create(e.doc, t.anchorCell, t.headCell); e.setSelection(r) } return !0 } } }, addKeyboardShortcuts() { return { Tab: () => this.editor.commands.goToNextCell() ? !0 : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : !1, "Shift-Tab": () => this.editor.commands.goToPreviousCell(), Backspace: cm, "Mod-Backspace": cm, Delete: cm, "Mod-Delete": cm } }, addProseMirrorPlugins() { return [...this.options.resizable && this.editor.isEditable ? [Bse({ handleWidth: this.options.handleWidth, cellMinWidth: this.options.cellMinWidth, defaultCellMinWidth: this.options.cellMinWidth, View: this.options.View, lastColumnResizable: this.options.lastColumnResizable })] : [], Xse({ allowTableNodeSelection: this.options.allowTableNodeSelection })] }, extendNodeSchema(t) { const e = { name: t.name, options: t.options, storage: t.storage }; return { tableRole: Ut(pt(t, "tableRole", e)) } } }), rae = Qn.create({ name: "tableRow", addOptions() { return { HTMLAttributes: {} } }, content: "(tableCell | tableHeader)*", tableRole: "row", parseHTML() { return [{ tag: "tr" }] }, renderHTML({ HTMLAttributes: t }) { return ["tr", Ln(this.options.HTMLAttributes, t), 0] } }), iae = Qn.create({ name: "tableCell", addOptions() { return { HTMLAttributes: {} } }, content: "block+", addAttributes() { return { colspan: { default: 1 }, rowspan: { default: 1 }, colwidth: { default: null, parseHTML: t => { const e = t.getAttribute("colwidth"); return e ? e.split(",").map(r => parseInt(r, 10)) : null } } } }, tableRole: "cell", isolating: !0, parseHTML() { return [{ tag: "td" }] }, renderHTML({ HTMLAttributes: t }) { return ["td", Ln(this.options.HTMLAttributes, t), 0] } }), sae = Qn.create({ name: "tableHeader", addOptions() { return { HTMLAttributes: {} } }, content: "block+", addAttributes() { return { colspan: { default: 1 }, rowspan: { default: 1 }, colwidth: { default: null, parseHTML: t => { const e = t.getAttribute("colwidth"); return e ? e.split(",").map(r => parseInt(r, 10)) : null } } } }, tableRole: "header_cell", isolating: !0, parseHTML() { return [{ tag: "th" }] }, renderHTML({ HTMLAttributes: t }) { return ["th", Ln(this.options.HTMLAttributes, t), 0] } }), aae = iae.extend({ addAttributes() { return { ...this.parent?.(), style: { default: null, parseHTML: t => t.getAttribute("style"), renderHTML: t => ({ style: t.style }) }, "data-colwidth": { default: null, parseHTML: t => t.getAttribute("data-colwidth"), renderHTML: t => ({ "data-colwidth": t["data-colwidth"] }) }, "data-colindex": { default: null, parseHTML: t => t.getAttribute("data-colindex"), renderHTML: t => ({ "data-colindex": t["data-colindex"] }) } } }, renderHTML({ node: t, HTMLAttributes: e }) { return ["td", { ...e, class: "tiptap-table-cell", "data-colwidth": t.attrs.colwidth ? t.attrs.colwidth.join(",") : null, "data-colindex": t.attrs["data-colindex"] || null }, 0] }, addNodeView() { return ({ node: t, getPos: e, editor: n }) => { const { view: r } = n, i = document.createElement("td"), s = document.createElement("div"), a = document.createElement("div"); s.contentEditable = "true", i.appendChild(s), a.classList.add("column-resize-handle"), i.appendChild(a); const l = Array.from(i.parentElement?.children || []).indexOf(i); l !== -1 && i.setAttribute("data-colindex", l); let u, f, p = !1; const g = b => { b.button === 0 && (b.preventDefault(), b.stopPropagation(), p = !0, u = b.clientX, f = i.offsetWidth, document.addEventListener("mousemove", y), document.addEventListener("mouseup", v), document.body.style.cursor = "col-resize", document.body.style.userSelect = "none", a.classList.add("is-resizing")) }, y = b => { if (!p) return; const S = b.clientX - u, C = Math.max(50, f + S), T = i.closest("table"); if (T) { const A = Array.from(i.parentElement.children).indexOf(i); T.querySelectorAll("tr").forEach(O => { const E = O.querySelectorAll("td, th"); E[A] && (E[A].style.width = `${C}px`, E[A].style.minWidth = `${C}px`) }) } }, v = () => { if (p && (p = !1, document.body.style.cursor = "", document.body.style.userSelect = "", a.classList.remove("is-resizing"), document.removeEventListener("mousemove", y), document.removeEventListener("mouseup", v), typeof e == "function")) { const b = e(), S = Array.from(i.parentElement.children).indexOf(i), C = i.offsetWidth, T = r.state.tr, A = r.state.doc.resolve(b), M = A.node(-1), O = A.start(-1); M.descendants((E, k) => { (E.type.name === "tableCell" || E.type.name === "tableHeader") && (E.attrs.colspan > 1 ? k - 1 : E.attrs["data-colindex"] || 0) === S && T.setNodeMarkup(O + k, null, { ...E.attrs, style: `width: ${C}px; min-width: ${C}px;`, "data-colindex": S }) }), T.steps.length > 0 && r.dispatch(T) } }; return a.addEventListener("mousedown", g), { dom: i, contentDOM: s, destroy: () => { a.removeEventListener("mousedown", g), document.removeEventListener("mousemove", y), document.removeEventListener("mouseup", v) } } } } }), O2 = t => t.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, ""), oae = X_.extend({ addAttributes() { return { ...this.parent?.(), id: { default: null, parseHTML: t => t.getAttribute("id"), renderHTML: t => t.id ? { id: t.id } : {} } } }, addCommands() { return { ...this.parent?.(), setHeadingWithId: t => ({ commands: e }) => e.setNode(this.name, t) } } }), lae = Aie.extend({ addAttributes() { return { ...this.parent?.(), alt: { default: "", parseHTML: t => t.getAttribute("alt"), renderHTML: t => t.alt ? { alt: t.alt } : {} }, title: { default: "", parseHTML: t => t.getAttribute("title"), renderHTML: t => t.title ? { title: t.title } : {} }, content: { default: "", parseHTML: t => t.getAttribute("data-content"), renderHTML: t => t.content ? { "data-content": t.content } : {} } } } }), cae = Qn.create({ name: "infoBox", group: "block", content: "inline*", defining: !0, addAttributes() { return { class: { default: "info-box" } } }, parseHTML() { return [{ tag: 'div[class*="info-box"]' }] }, renderHTML({ HTMLAttributes: t }) { return ["div", Ln(t, { class: "info-box" }), 0] }, addCommands() { return { setInfoBox: () => ({ commands: t }) => t.setNode("infoBox") } } }), uae = As.create({ name: "dynamicDate", inclusive() { return !1 }, parseHTML() { return [{ tag: "span.dynamic-date" }] }, renderHTML() { return ["span", { class: "dynamic-date" }, 0] }, addCommands() { return { toggleDynamicDate: () => ({ commands: t }) => t.toggleMark(this.name) } } }), dae = Qn.create({ name: "video", group: "block", atom: !0, inline: !1, addAttributes() { return { src: { default: null }, alt: { default: "" }, title: { default: "" }, description: { default: "" }, type: { default: "local" }, youtubeId: { default: null }, width: { default: "100%" }, height: { default: "auto" } } }, parseHTML() { return [{ tag: "video", getAttrs: t => ({ src: t.getAttribute("src"), alt: t.getAttribute("alt"), title: t.getAttribute("title"), description: t.getAttribute("data-description"), type: t.getAttribute("data-type") || "local", youtubeId: t.getAttribute("data-youtube-id"), width: t.getAttribute("width") || "100%", height: t.getAttribute("height") || "auto" }) }, { tag: "div[data-video]", getAttrs: t => ({ src: t.getAttribute("data-src"), alt: t.getAttribute("data-alt"), title: t.getAttribute("data-title"), description: t.getAttribute("data-description"), type: t.getAttribute("data-type") || "local", youtubeId: t.getAttribute("data-youtube-id"), width: t.getAttribute("width") || "100%", height: t.getAttribute("height") || "auto" }) }] }, renderHTML({ HTMLAttributes: t }) { const { src: e, alt: n, title: r, description: i, type: s, youtubeId: a, width: l, height: u } = t; return s === "youtube" && a ? ["div", { class: "video-container youtube-video", "data-video": !0, "data-type": "youtube", "data-youtube-id": a, "data-alt": n, "data-title": r, "data-description": i, "data-width": l, "data-height": u }, ["iframe", { src: `https://www.youtube.com/embed/${a}`, width: l, height: u === "auto" ? "315" : u, frameborder: "0", allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture", allowfullscreen: !0, title: r || n }]] : ["video", { src: e, alt: n, title: r, "data-description": i, "data-type": "local", width: l, height: u, controls: !0, preload: "metadata", class: "help-center-video" }] }, addCommands() { return { setVideo: t => ({ commands: e }) => e.insertContent({ type: this.name, attrs: t }) } } }), fae = Qn.create({ name: "youtubeVideo", group: "block", atom: !0, inline: !1, defining: !0, content: "", addAttributes() { return { videoId: { default: null }, alt: { default: "" }, title: { default: "" }, description: { default: "" }, width: { default: "100%" }, height: { default: "400" } } }, parseHTML() { return [{ tag: "div[data-youtube-video]", getAttrs: t => ({ videoId: t.getAttribute("data-video-id"), alt: t.getAttribute("data-alt"), title: t.getAttribute("data-title"), description: t.getAttribute("data-description"), width: t.getAttribute("data-width") || "100%", height: t.getAttribute("data-height") || "400" }) }] }, renderHTML({ HTMLAttributes: t }) { const { videoId: e, alt: n, title: r, description: i, width: s, height: a } = t; return ["div", { "data-youtube-video": !0, "data-video-id": e, "data-alt": n, "data-title": r, "data-description": i, "data-width": s, "data-height": a, class: "youtube-video-container" }, ["iframe", { src: `https://www.youtube.com/embed/${e}`, title: r || "YouTube video player", alt: n, width: s, height: a, frameborder: "0", allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share", referrerPolicy: "strict-origin-when-cross-origin", allowfullscreen: !0, class: "youtube-iframe" }]] }, addCommands() { return { setYouTubeVideo: t => ({ commands: e }) => e.insertContent({ type: this.name, attrs: t }) } } }), hae = [t6.configure({ heading: !1, paragraph: !0, blockquote: !0, codeBlock: !0 }), cae, oae.configure({ levels: [1, 2, 3, 4, 5, 6], HTMLAttributes: { class: "heading-with-id" } }), n6.configure({ types: ["heading", "paragraph"], alignments: ["left", "center", "right", "justify"] }), jie, uae, lae.configure({ inline: !0, allowBase64: !1, HTMLAttributes: { class: "help-center-image" } }), Zie.configure({ openOnClick: !1, HTMLAttributes: { class: "custom-link", rel: "noopener noreferrer" } }), nae.extend({ content: "tableRow+", tableRole: "table", isolating: !0, group: "block", parseHTML() { return [{ tag: "table" }] }, renderHTML({ HTMLAttributes: t }) { return ["div", { class: "table-wrapper" }, ["table", { ...t, class: "tiptap-table" }, ["tbody", 0]]] }, addKeyboardShortcuts() { return { "Mod-Alt-0": () => this.editor.commands.insertTable({ rows: 3, cols: 3, withHeaderRow: !0 }) } } }).configure({ resizable: !0, lastColumnResizable: !0, allowTableNodeSelection: !0, HTMLAttributes: { class: "tiptap-table" } }), rae, sae, aae.configure({ HTMLAttributes: { class: "tiptap-table-cell" } }), dae, fae], pae = ({ uploadImgUrl: t = "", uploadVideoUrl: e = "https://api.nexus.com/api/admin/blog-media/upload-video", processYoutubeUrl: n = "https://api.nexus.com/api/admin/blog-media/process-youtube" }) => { const { editor: r } = jh(), i = N.useRef(null), s = N.useRef(null), [a, l] = N.useState(!1), [u, f] = N.useState(!1), [p, g] = N.useState(!1), [y, v] = N.useState(""), [b, S] = N.useState(!1), [C, T] = N.useState(""), [A, M] = N.useState(""), [O, E] = N.useState(""), [k, z] = N.useState(null), [V, q] = N.useState(!1), [ue, W] = N.useState(""), [ne, H] = N.useState(""), [we, xe] = N.useState(""), [K, te] = N.useState(null), [ye, He] = N.useState(!1), [B, ie] = N.useState(""), [oe, pe] = N.useState(!1), [Ee, fe] = N.useState(3), [Oe, et] = N.useState(3), Xe = N.useRef(null), De = N.useRef(null), he = N.useRef(null), Be = N.useRef(null); if (!r) return null; const Y = async le => { const st = le.target.files[0]; if (st) { l(!0); try { const wt = new FormData; wt.append("image", st); const Qe = await Ve.post(t, wt, { headers: { "Content-Type": "multipart/form-data", Authorization: `Bearer ${localStorage.getItem("userToken")}` } }); if (Qe.data.success && Qe.data.data?.url) { const Te = Qe.data.data.url; r.chain().focus().setImage({ src: Te }).run(); const { state: Ze } = r, { selection: gt } = Ze, vt = gt.$anchor.pos - 1; z(vt), T(""), M(""), E(""), S(!0), setTimeout(() => { De.current?.focus() }, 100) } else throw new Error("Invalid response format") } catch (wt) { console.error("Image upload failed:", wt), me.error("Failed to upload image. Please try again.") } finally { l(!1), le.target.value = "" } } }, Je = async le => { const st = le.target.files[0]; if (!st) return; if (st.size > 100 * 1024 * 1024) { me.error("Video file size must be less than 100MB"); return } if (!["video/mp4", "video/mov", "video/avi", "video/wmv", "video/webm"].includes(st.type)) { me.error("Please select a valid video file (MP4, MOV, AVI, WMV, WebM)"); return } f(!0); try { const Qe = new FormData; Qe.append("video", st); const Te = await Ve.post(e, Qe, { headers: { "Content-Type": "multipart/form-data", Authorization: `Bearer ${localStorage.getItem("userToken")}` } }); if (Te.data.success && Te.data.data?.url) { const Ze = Te.data.data.url; r.chain().focus().setVideo({ src: Ze, type: "local" }).run(); const { state: gt } = r, { selection: vt } = gt, Nt = vt.$anchor.pos - 1; te(Nt), W(""), H(""), xe(""), q(!0), setTimeout(() => { he.current?.focus() }, 100) } else throw new Error("Invalid response format") } catch (Qe) { console.error("Video upload failed:", Qe), me.error("Failed to upload video. Please try again.") } finally { f(!1), le.target.value = "" } }, $e = async le => { if (le.preventDefault(), !B.trim()) { me.error("Please enter a YouTube URL"); return } let st = null; const wt = B.trim(); if (wt.includes("youtube.com/watch?v=") ? st = wt.split("v=")[1]?.split("&")[0] : wt.includes("youtu.be/") ? st = wt.split("youtu.be/")[1]?.split("?")[0] : wt.includes("youtube.com/embed/") && (st = wt.split("embed/")[1]?.split("?")[0]), !st) { me.error("Invalid YouTube URL. Please enter a valid YouTube video URL."); return } try { console.log("Inserting YouTube video for video ID:", st), r.chain().focus().setYouTubeVideo({ videoId: st, alt: "", title: "YouTube video player", description: "", width: "100%", height: "400" }).run(), console.log("YouTube video inserted successfully"), setTimeout(() => { const gt = r.getHTML(); console.log("Current editor content after insertion:", gt) }, 100) } catch (gt) { console.error("Error inserting YouTube video:", gt), r.chain().focus().insertContent(`[YouTube Video: ${st}]`).run(), me.error("Failed to embed YouTube video. Please try again.") } const { state: Qe } = r, { selection: Te } = Qe, Ze = Te.$anchor.pos - 1; te(Ze), W(""), H(""), xe(""), q(!0), setTimeout(() => { he.current?.focus() }, 100), ie(""), He(!1) }, $ = le => { if (le.preventDefault(), !k) return; const { state: st } = r, wt = st.doc.nodeAt(k); wt && wt.type.name === "image" && r.chain().focus().command(({ tr: Qe }) => { const Te = { ...wt.attrs, alt: C, title: A, content: O }; return Qe.setNodeMarkup(k, void 0, Te), !0 }).run(), S(!1), T(""), M(""), E(""), z(null) }, U = le => { if (le.preventDefault(), !K) return; const { state: st } = r, wt = st.doc.nodeAt(K); wt && wt.type.name === "video" && r.chain().focus().command(({ tr: Te }) => { const Ze = { ...wt.attrs, alt: ue, title: ne, description: we }; return Te.setNodeMarkup(K, void 0, Ze), !0 }).run(); const Qe = r.getHTML(); if (Qe.includes("data-youtube-video")) { let Te = Qe; Te = Te.replace(/<div([^>]*data-youtube-video[^>]*)>/g, (Ze, gt) => { let vt = gt.replace(/data-alt="[^"]*"/g, "").replace(/data-title="[^"]*"/g, "").replace(/data-description="[^"]*"/g, ""); return ue && (vt += ` data-alt="${ue}"`), ne && (vt += ` data-title="${ne}"`), we && (vt += ` data-description="${we}"`), `<div${vt}>` }), r.commands.setContent(Te) } q(!1), W(""), H(""), xe(""), te(null) }, be = () => { q(!1), W(""), H(""), xe(""), te(null), r.chain().focus().run() }, Ie = () => { S(!1), T(""), M(""), E(""), z(null), r.chain().focus().run() }, it = le => { le.preventDefault(); const { from: st, to: wt } = r.state.selection; if (r.state.doc.textBetween(st, wt, " ").trim() === "") { me.error("Please select some text first"); return } if (r.isActive("link")) { const Te = r.getAttributes("link").href || ""; v(Te) } else v(""); g(!0), setTimeout(() => { Xe.current?.focus() }, 100) }, P = le => { if (le.preventDefault(), y.trim() === "") { g(!1); return } let st = y.trim(); !st.startsWith("http://") && !st.startsWith("https://") && (st = "https://" + st), r.chain().focus().setLink({ href: st }).run(), g(!1), v("") }, ee = () => { g(!1), v(""), r.chain().focus().run() }, _ = le => { le.preventDefault(), r.chain().focus().unsetLink().run() }, I = le => { le.preventDefault(), pe(!oe) }, se = le => { le.preventDefault(), r.chain().focus().insertTable({ rows: Ee, cols: Oe, withHeaderRow: !0 }).run(), pe(!1) }, ae = le => { le.preventDefault(), r.chain().focus().addRowAfter().run() }, Ae = le => { le.preventDefault(), r.chain().focus().addColumnAfter().run() }, qe = le => { le.preventDefault(), r.chain().focus().deleteRow().run() }, rt = le => { le.preventDefault(), r.chain().focus().deleteColumn().run() }, Tt = le => { le.preventDefault(), r.chain().focus().deleteTable().run() }, yn = le => { le.preventDefault(), r.chain().focus().mergeCells().run() }, Gt = le => { le.preventDefault(), r.chain().focus().splitCell().run() }, $n = le => { le.preventDefault(), r.chain().focus().toggleHeaderRow().run() }, cn = le => { le.preventDefault(), r.chain().focus().toggleHeaderColumn().run() }, je = le => { le.preventDefault(), r.chain().focus().setCellAttribute("textAlign", "left").run() }, tt = le => { le.preventDefault(), r.chain().focus().setCellAttribute("textAlign", "center").run() }, lt = le => { le.preventDefault(), r.chain().focus().setCellAttribute("textAlign", "right").run() }; return d.jsxs("div", { className: "tiptap-toolbar single-line", children: [d.jsxs("div", { className: "toolbar-group", children: [d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().toggleBold().run() }, disabled: !r.can().chain().focus().toggleBold().run(), className: r.isActive("bold") ? "is-active" : "", title: "Bold", children: d.jsx(Kw, { size: 16 }) }), d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().toggleItalic().run() }, disabled: !r.can().chain().focus().toggleItalic().run(), className: r.isActive("italic") ? "is-active" : "", title: "Italic", children: d.jsx(Gw, { size: 16 }) }), d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().toggleStrike().run() }, disabled: !r.can().chain().focus().toggleStrike().run(), className: r.isActive("strike") ? "is-active" : "", title: "Strikethrough", children: d.jsx(aD, { size: 16 }) }), d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().toggleUnderline().run() }, disabled: !r.can().chain().focus().toggleUnderline().run(), className: r.isActive("underline") ? "is-active" : "", title: "Underline", children: d.jsx(gq, { size: 16 }) }), d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().toggleDynamicDate().run() }, disabled: !r.can().chain().focus().toggleDynamicDate().run(), className: r.isActive("dynamicDate") ? "is-active" : "", title: "Dynamic Date", children: d.jsx(PH, { size: 16 }) })] }), d.jsx("div", { className: "toolbar-divider" }), d.jsxs("div", { className: "toolbar-group", children: [d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().toggleHeading({ level: 1 }).run() }, className: r.isActive("heading", { level: 1 }) ? "is-active" : "", title: "Heading 1", children: d.jsx(eD, { size: 16 }) }), d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().toggleHeading({ level: 2 }).run() }, className: r.isActive("heading", { level: 2 }) ? "is-active" : "", title: "Heading 2", children: d.jsx(Ww, { size: 16 }) }), d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().toggleHeading({ level: 3 }).run() }, className: r.isActive("heading", { level: 3 }) ? "is-active" : "", title: "Heading 3", children: d.jsx(Yw, { size: 16 }) }), d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().toggleHeading({ level: 4 }).run() }, className: r.isActive("heading", { level: 4 }) ? "is-active" : "", title: "Heading 4", children: d.jsx(qH, { size: 16 }) }), d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().toggleHeading({ level: 5 }).run() }, className: r.isActive("heading", { level: 5 }) ? "is-active" : "", title: "Heading 5", children: d.jsx(WH, { size: 16 }) }), d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().toggleHeading({ level: 6 }).run() }, className: r.isActive("heading", { level: 6 }) ? "is-active" : "", title: "Heading 6", children: d.jsx(GH, { size: 16 }) })] }), d.jsx("div", { className: "toolbar-divider" }), d.jsxs("div", { className: "toolbar-group", children: [d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().toggleBulletList().run() }, className: r.isActive("bulletList") ? "is-active" : "", title: "Bullet List", children: d.jsx(Qw, { size: 16 }) }), d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().toggleOrderedList().run() }, className: r.isActive("orderedList") ? "is-active" : "", title: "Numbered List", children: d.jsx(Xw, { size: 16 }) })] }), d.jsx("div", { className: "toolbar-divider" }), d.jsxs("div", { className: "toolbar-group", children: [d.jsx("button", { onClick: le => { le.preventDefault(), r.isActive("blockquote") ? r.chain().focus().toggleBlockquote().run() : r.chain().focus().toggleBlockquote().updateAttributes("blockquote", { class: "" }).run() }, className: r.isActive("blockquote") && r.getAttributes("blockquote").class !== "info-box" ? "is-active" : "", title: "Blockquote", children: d.jsx(iD, { size: 16 }) }), d.jsx("button", { onClick: le => { le.preventDefault(), r.isActive("infoBox") ? r.chain().focus().setParagraph().run() : r.chain().focus().setInfoBox().run() }, className: r.isActive("infoBox") ? "is-active" : "", title: "Info Box", children: d.jsx(JH, { size: 16 }) }), d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().toggleCodeBlock().run() }, className: r.isActive("codeBlock") ? "is-active" : "", title: "Code Block", children: d.jsx(ZM, { size: 16 }) }), d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().setHorizontalRule().run() }, title: "Horizontal Rule", children: d.jsx(rD, { size: 16 }) })] }), d.jsx("div", { className: "toolbar-divider" }), d.jsxs("div", { className: "toolbar-group", children: [d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().setTextAlign("left").run() }, className: r.isActive({ textAlign: "left" }) ? "is-active" : "", title: "Align Left", children: d.jsx(Gb, { size: 16 }) }), d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().setTextAlign("center").run() }, className: r.isActive({ textAlign: "center" }) ? "is-active" : "", title: "Align Center", children: d.jsx(Yb, { size: 16 }) }), d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().setTextAlign("right").run() }, className: r.isActive({ textAlign: "right" }) ? "is-active" : "", title: "Align Right", children: d.jsx(Xb, { size: 16 }) }), d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().setTextAlign("justify").run() }, className: r.isActive({ textAlign: "justify" }) ? "is-active" : "", title: "Justify", children: d.jsx(MH, { size: 16 }) })] }), d.jsx("div", { className: "toolbar-divider" }), d.jsxs("div", { className: "toolbar-group", children: [d.jsx("button", { onClick: it, className: r.isActive("link") ? "is-active" : "", title: "Add/Edit Link", children: d.jsx(nD, { size: 16 }) }), r.isActive("link") && d.jsx("button", { onClick: _, title: "Remove Link", children: d.jsx(lD, { size: 16 }) })] }), d.jsx("div", { className: "toolbar-divider" }), d.jsxs("div", { className: "toolbar-group", children: [d.jsx("input", { type: "file", ref: i, onChange: Y, accept: "image/*", style: { display: "none" }, disabled: a }), d.jsx("button", { onClick: le => { le.preventDefault(), i.current.click() }, title: "Upload Image", disabled: a, className: a ? "is-uploading" : "", children: a ? "Uploading..." : d.jsx(tD, { size: 16 }) })] }), d.jsx("div", { className: "toolbar-divider" }), d.jsxs("div", { className: "toolbar-group", children: [d.jsx("input", { type: "file", ref: s, onChange: Je, accept: "video/*", style: { display: "none" }, disabled: u }), d.jsx("button", { onClick: le => { le.preventDefault(), s.current.click() }, title: "Upload Video", disabled: u, className: u ? "is-uploading" : "", children: u ? "Uploading..." : d.jsx(cD, { size: 16 }) }), d.jsx("button", { onClick: le => { le.preventDefault(), He(!0), setTimeout(() => { Be.current?.focus() }, 100) }, title: "Add YouTube Video", children: d.jsx(Sq, { size: 16 }) })] }), d.jsx("div", { className: "toolbar-divider" }), d.jsx("div", { className: "toolbar-group", children: d.jsx("button", { onClick: I, className: r.isActive("table") ? "is-active" : "", title: "Table", children: d.jsx(hq, { size: 16 }) }) }), d.jsx("div", { className: "toolbar-divider" }), d.jsxs("div", { className: "toolbar-group", children: [d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().undo().run() }, disabled: !r.can().undo(), title: "Undo", children: d.jsx(oD, { size: 16 }) }), d.jsx("button", { onClick: le => { le.preventDefault(), r.chain().focus().redo().run() }, disabled: !r.can().redo(), title: "Redo", children: d.jsx(sD, { size: 16 }) })] }), oe && d.jsxs("div", { className: "table-controls-modal", children: [d.jsx("div", { className: "table-controls-overlay", onClick: () => pe(!1) }), d.jsxs("div", { className: "table-controls-container", children: [d.jsx("h4", { children: "Create Table" }), d.jsxs("div", { className: "table-controls-grid", children: [d.jsxs("div", { className: "table-control-row", children: [d.jsx("label", { children: "Rows:" }), d.jsx("input", { type: "number", min: "1", max: "10", value: Ee, onChange: le => fe(parseInt(le.target.value) || 1) })] }), d.jsxs("div", { className: "table-control-row", children: [d.jsx("label", { children: "Columns:" }), d.jsx("input", { type: "number", min: "1", max: "10", value: Oe, onChange: le => et(parseInt(le.target.value) || 1) })] })] }), d.jsxs("div", { className: "table-controls-buttons", children: [d.jsx("button", { onClick: se, className: "table-create-btn", children: "Create Table" }), d.jsx("button", { onClick: () => pe(!1), className: "table-cancel-btn", children: "Cancel" })] })] })] }), r?.isActive("table") && d.jsxs("div", { className: "table-edit-controls", children: [d.jsxs("div", { className: "table-controls-group", children: [d.jsx("button", { onClick: ae, title: "Add Row", children: d.jsx(ZE, { size: 14 }) }), d.jsx("button", { onClick: Ae, title: "Add Column", children: d.jsx(ZE, { size: 14, style: { transform: "rotate(90deg)" } }) }), d.jsx("button", { onClick: qe, title: "Delete Row", children: d.jsx(xx, { size: 14 }) }), d.jsx("button", { onClick: rt, title: "Delete Column", children: d.jsx(xx, { size: 14, style: { transform: "rotate(90deg)" } }) })] }), d.jsx("div", { className: "table-controls-divider" }), d.jsxs("div", { className: "table-controls-group", children: [d.jsx("button", { onClick: yn, title: "Merge Cells", children: d.jsx(iq, { size: 14 }) }), d.jsx("button", { onClick: Gt, title: "Split Cell", children: d.jsx(uq, { size: 14 }) })] }), d.jsx("div", { className: "table-controls-divider" }), d.jsxs("div", { className: "table-controls-group", children: [d.jsx("button", { onClick: je, title: "Align Left", children: d.jsx(Gb, { size: 14 }) }), d.jsx("button", { onClick: tt, title: "Align Center", children: d.jsx(Yb, { size: 14 }) }), d.jsx("button", { onClick: lt, title: "Align Right", children: d.jsx(Xb, { size: 14 }) })] }), d.jsx("div", { className: "table-controls-divider" }), d.jsxs("div", { className: "table-controls-group", children: [d.jsx("button", { onClick: $n, title: "Toggle Header Row", children: "H" }), d.jsx("button", { onClick: cn, title: "Toggle Header Column", children: "H|" }), d.jsx("button", { onClick: Tt, title: "Delete Table", children: d.jsx(xx, { size: 14, color: "#ef4444" }) })] })] }), p && d.jsxs("div", { className: "link-input-modal", children: [d.jsx("div", { className: "link-input-overlay", onClick: ee }), d.jsx("div", { className: "link-input-container", children: d.jsxs("div", { children: [d.jsx("input", { ref: Xe, type: "text", value: y, onChange: le => v(le.target.value), placeholder: "Enter URL (e.g., https://example.com)", className: "link-input", onKeyDown: le => { le.key === "Enter" && (le.preventDefault(), P(le)), le.key === "Escape" && ee() } }), d.jsxs("div", { className: "link-input-buttons", children: [d.jsxs("button", { type: "button", onClick: P, className: "link-submit-btn", children: [r.isActive("link") ? "Update" : "Add", " Link"] }), d.jsx("button", { type: "button", onClick: ee, className: "link-cancel-btn", children: "Cancel" })] })] }) })] }), b && d.jsxs("div", { className: "link-input-modal", children: [d.jsx("div", { className: "link-input-overlay", onClick: Ie }), d.jsx("div", { className: "link-input-container", children: d.jsxs("div", { className: "image-meta-form", children: [d.jsxs("div", { className: "form-group", children: [d.jsx("label", { children: "Alt Text" }), d.jsx("input", { ref: De, type: "text", value: C, onChange: le => T(le.target.value), placeholder: "Enter alt text for accessibility", className: "link-input" })] }), d.jsxs("div", { className: "form-group", children: [d.jsx("label", { children: "Title" }), d.jsx("input", { type: "text", value: A, onChange: le => M(le.target.value), placeholder: "Enter title text (shown on hover)", className: "link-input" })] }), d.jsxs("div", { className: "form-group", children: [d.jsx("label", { children: "Content" }), d.jsx("textarea", { value: O, onChange: le => E(le.target.value), placeholder: "Enter additional content or description", className: "link-input textarea", rows: 3 })] }), d.jsxs("div", { className: "link-input-buttons", children: [d.jsx("button", { type: "button", onClick: $, className: "link-submit-btn", children: "Save Image Details" }), d.jsx("button", { type: "button", onClick: Ie, className: "link-cancel-btn", children: "Cancel" })] })] }) })] }), V && d.jsxs("div", { className: "link-input-modal", children: [d.jsx("div", { className: "link-input-overlay", onClick: be }), d.jsx("div", { className: "link-input-container", children: d.jsxs("div", { className: "image-meta-form", children: [d.jsxs("div", { className: "form-group", children: [d.jsx("label", { children: "Alt Text" }), d.jsx("input", { ref: he, type: "text", value: ue, onChange: le => W(le.target.value), placeholder: "Enter alt text for accessibility", className: "link-input" })] }), d.jsxs("div", { className: "form-group", children: [d.jsx("label", { children: "Title" }), d.jsx("input", { type: "text", value: ne, onChange: le => H(le.target.value), placeholder: "Enter title text (shown on hover)", className: "link-input" })] }), d.jsxs("div", { className: "form-group", children: [d.jsx("label", { children: "Description" }), d.jsx("textarea", { value: we, onChange: le => xe(le.target.value), placeholder: "Enter video description", className: "link-input textarea", rows: 3 })] }), d.jsxs("div", { className: "link-input-buttons", children: [d.jsx("button", { type: "button", onClick: U, className: "link-submit-btn", children: "Save Video Details" }), d.jsx("button", { type: "button", onClick: be, className: "link-cancel-btn", children: "Cancel" })] })] }) })] }), ye && d.jsxs("div", { className: "link-input-modal", children: [d.jsx("div", { className: "link-input-overlay", onClick: () => He(!1) }), d.jsx("div", { className: "link-input-container", children: d.jsxs("div", { children: [d.jsx("h4", { children: "Add YouTube Video" }), d.jsx("p", { className: "text-sm text-gray-600 mb-3", children: "Enter a YouTube URL to embed the video directly in your content." }), d.jsx("input", { ref: Be, type: "text", value: B, onChange: le => ie(le.target.value), placeholder: "Enter YouTube URL (e.g., https://www.youtube.com/watch?v=VIDEO_ID)", className: "link-input", onKeyDown: le => { le.key === "Enter" && (le.preventDefault(), $e(le)), le.key === "Escape" && He(!1) } }), d.jsxs("div", { className: "link-input-buttons", children: [d.jsx("button", { type: "button", onClick: $e, className: "link-submit-btn", children: "Embed Video" }), d.jsx("button", { type: "button", onClick: () => He(!1), className: "link-cancel-btn", children: "Cancel" })] })] }) })] })] }) }, mae = () => { const { editor: t } = jh(), [e, n] = N.useState(!1), [r, i] = N.useState(""), [s, a] = N.useState(!1), [l, u] = N.useState(""), [f, p] = N.useState(""), [g, y] = N.useState(""), [v, b] = N.useState(null), [S, C] = N.useState(!1), [T, A] = N.useState(""), [M, O] = N.useState(""), [E, k] = N.useState(""), [z, V] = N.useState(null), q = N.useRef(null), ue = N.useRef(null), W = N.useRef(null); if (!t) return null; const ne = oe => { if (oe.preventDefault(), t.isActive("link")) { const pe = t.getAttributes("link").href || ""; i(pe) } else i(""); n(!0), setTimeout(() => { q.current?.focus() }, 100) }, H = oe => { if (oe.preventDefault(), r.trim() === "") { n(!1); return } let pe = r.trim(); !pe.startsWith("http://") && !pe.startsWith("https://") && (pe = "https://" + pe), t.chain().focus().setLink({ href: pe }).run(), n(!1), i("") }, we = () => { n(!1), i(""), t.chain().focus().run() }, xe = oe => { oe.preventDefault(), t.chain().focus().unsetLink().run() }, K = oe => { oe.preventDefault(); const { state: pe } = t, { from: Ee, to: fe } = pe.selection; pe.doc.nodesBetween(Ee, fe, (Oe, et) => { if (Oe.type.name === "image") return b(et), u(Oe.attrs.alt || ""), p(Oe.attrs.title || ""), y(Oe.attrs.content || ""), a(!0), setTimeout(() => { ue.current?.focus() }, 100), !1 }) }, te = oe => { oe.preventDefault(), v !== null && (t.chain().focus().command(({ tr: pe }) => { const Ee = pe.doc.nodeAt(v); return Ee && Ee.type.name === "image" && pe.setNodeMarkup(v, void 0, { ...Ee.attrs, alt: l, title: f, content: g }), !0 }).run(), a(!1), u(""), p(""), y(""), b(null)) }, ye = () => { a(!1), u(""), p(""), y(""), b(null), t.chain().focus().run() }, He = oe => { oe.preventDefault(); const { state: pe } = t, { from: Ee, to: fe } = pe.selection; pe.doc.nodesBetween(Ee, fe, (et, Xe) => { if (et.type.name === "video") return V(Xe), A(et.attrs.alt || ""), O(et.attrs.title || ""), k(et.attrs.description || ""), C(!0), setTimeout(() => { W.current?.focus() }, 100), !1 }); const Oe = t.getHTML(); if (Oe.includes("data-youtube-video")) { const et = Oe.match(/<div[^>]*data-youtube-video[^>]*>/); if (et) { const Xe = et[0], De = Xe.match(/data-title="([^"]*)"/), he = Xe.match(/data-alt="([^"]*)"/), Be = Xe.match(/data-description="([^"]*)"/); V(Ee), A(he ? he[1] : ""), O(De ? De[1] : ""), k(Be ? Be[1] : ""), C(!0), setTimeout(() => { W.current?.focus() }, 100) } } }, B = oe => { if (oe.preventDefault(), z === null) return; t.chain().focus().command(({ tr: Ee }) => { const fe = Ee.doc.nodeAt(z); return fe && fe.type.name === "video" ? (Ee.setNodeMarkup(z, void 0, { ...fe.attrs, alt: T, title: M, description: E }), !0) : !1 }).run(); const pe = t.getHTML(); if (pe.includes("data-youtube-video")) { let Ee = pe; Ee = Ee.replace(/<div([^>]*data-youtube-video[^>]*)>/g, (fe, Oe) => { let et = Oe.replace(/data-alt="[^"]*"/g, "").replace(/data-title="[^"]*"/g, "").replace(/data-description="[^"]*"/g, ""); return T && (et += ` data-alt="${T}"`), M && (et += ` data-title="${M}"`), E && (et += ` data-description="${E}"`), `<div${et}>` }), t.commands.setContent(Ee) } C(!1), A(""), O(""), k(""), V(null) }, ie = () => { C(!1), A(""), O(""), k(""), V(null), t.chain().focus().run() }; return d.jsx(G_, { editor: t, tippyOptions: { duration: 100, onHidden: () => { n(!1), a(!1), C(!1), i(""), u(""), p(""), y(""), b(null), A(""), O(""), k(""), V(null) } }, children: d.jsxs("div", { className: "bubble-menu", children: [d.jsxs("div", { className: "flex", children: [d.jsx("button", { onClick: ne, className: t.isActive("link") ? "is-active" : "", title: "Add/Edit Link", children: d.jsx(nD, { size: 14 }) }), t.isActive("link") && d.jsx("button", { onClick: xe, title: "Remove Link", children: d.jsx(lD, { size: 14 }) }), t.isActive("image") && d.jsx("button", { onClick: K, title: "Edit Image Details", children: d.jsx(tD, { size: 14 }) }), (t.isActive("video") || t.getHTML().includes("data-youtube-video")) && d.jsx("button", { onClick: He, title: "Edit Video Details", children: d.jsx(cD, { size: 14 }) })] }), s && d.jsx("div", { className: "bubble-link-input", children: d.jsxs("div", { className: "image-meta-form", children: [d.jsxs("div", { className: "form-group", children: [d.jsx("label", { children: "Alt:" }), d.jsx("input", { ref: ue, type: "text", value: l, onChange: oe => u(oe.target.value), placeholder: "Alt text", className: "bubble-link-field !w-full" })] }), d.jsxs("div", { className: "form-group", children: [d.jsx("label", { children: "Title:" }), d.jsx("input", { type: "text", value: f, onChange: oe => p(oe.target.value), placeholder: "Title", className: "bubble-link-field !w-full" })] }), d.jsxs("div", { className: "form-group", children: [d.jsx("label", { children: "Content:" }), d.jsx("textarea", { value: g, onChange: oe => y(oe.target.value), placeholder: "Content", className: "bubble-link-field textarea", rows: 2 })] }), d.jsxs("div", { className: "form-buttons", children: [d.jsx("button", { type: "button", onClick: te, className: "bubble-link-submit", children: d.jsx(JE, { size: 16, color: "green" }) }), d.jsx("button", { type: "button", onClick: ye, className: "bubble-link-cancel", children: d.jsx(eA, { size: 16, color: "red" }) })] })] }) }), e && d.jsx("div", { className: "bubble-link-input", children: d.jsxs("div", { children: [d.jsx("input", { ref: q, type: "text", value: r, onChange: oe => i(oe.target.value), placeholder: "Enter URL", className: "bubble-link-field", onKeyDown: oe => { oe.key === "Enter" && (oe.preventDefault(), H(oe)), oe.key === "Escape" && we() } }), d.jsx("button", { type: "button", onClick: H, className: "bubble-link-submit", children: "" }), d.jsx("button", { type: "button", onClick: we, className: "bubble-link-cancel", children: "" })] }) }), S && d.jsx("div", { className: "bubble-link-input", children: d.jsxs("div", { className: "image-meta-form", children: [d.jsxs("div", { className: "form-group", children: [d.jsx("label", { children: "Alt:" }), d.jsx("input", { ref: W, type: "text", value: T, onChange: oe => A(oe.target.value), placeholder: "Alt text", className: "bubble-link-field !w-full" })] }), d.jsxs("div", { className: "form-group", children: [d.jsx("label", { children: "Title:" }), d.jsx("input", { type: "text", value: M, onChange: oe => O(oe.target.value), placeholder: "Title", className: "bubble-link-field !w-full" })] }), d.jsxs("div", { className: "form-group", children: [d.jsx("label", { children: "Desc:" }), d.jsx("textarea", { value: E, onChange: oe => k(oe.target.value), placeholder: "Description", className: "bubble-link-field textarea", rows: 2 })] }), d.jsxs("div", { className: "form-buttons", children: [d.jsx("button", { type: "button", onClick: B, className: "bubble-link-submit", children: d.jsx(JE, { size: 16, color: "green" }) }), d.jsx("button", { type: "button", onClick: ie, className: "bubble-link-cancel", children: d.jsx(eA, { size: 16, color: "red" }) })] })] }) })] }) }) }, gae = t => { const r = new DOMParser().parseFromString(t, "text/html").querySelectorAll("h1, h2, h3, h4, h5, h6"); return Array.from(r).map(i => { const s = i.textContent.trim(), a = i.id, l = O2(s); return { id: a || l, text: s, level: parseInt(i.tagName.substring(1)), tag: i.tagName.toLowerCase() } }) }, yae = t => { const n = new DOMParser().parseFromString(t, "text/html"), r = n.querySelectorAll("h1, h2, h3, h4, h5, h6"); let i = !1; return r.forEach(s => { const a = s.textContent.trim(); a && !s.id && (s.id = O2(a), i = !0) }), i ? n.body.innerHTML : t }, Yg = ({ content: t = "", onUpdate: e, onHeadingsUpdate: n, uploadImgUrl: r = "https://api.nexus.com/api/admin/blogs/images/upload", uploadVideoUrl: i = "https://api.nexus.com/api/admin/blog-media/upload-video", processYoutubeUrl: s = "https://api.nexus.com/api/admin/blog-media/process-youtube" }) => { const [a, l] = N.useState(!1), [u, f] = N.useState(null), p = N.useRef(null), g = N.useCallback(b => { !b || !a || (p.current && clearTimeout(p.current), p.current = setTimeout(() => { const { state: S } = b, { tr: C } = S; let T = !1; S.doc.descendants((A, M) => { if (A.type.name === "heading" && A.textContent) { const O = A.attrs.id, E = O2(A.textContent); O !== E && (C.setNodeMarkup(M, void 0, { ...A.attrs, id: E }), T = !0) } }), T && b.view.dispatch(C) }, 500)) }, [a]), y = N.useCallback(({ editor: b }) => { if (a) { let S = b.getHTML(); S = yae(S); const C = gae(S); e && e(S), n && n(C), g(b) } }, [e, n, a, g]), v = N.useCallback(({ editor: b }) => { f(b) }, []); return N.useEffect(() => (l(!0), () => { p.current && clearTimeout(p.current) }), []), d.jsx("div", { className: "tiptap-container", children: d.jsxs(Y_, { extensions: hae, content: t, onUpdate: y, onCreate: v, children: [d.jsx(pae, { uploadImgUrl: r, uploadVideoUrl: i, processYoutubeUrl: s }), d.jsx(mae, {})] }) }) }; function vae({ onDateChange: t, initialRange: e }) { const [n, r] = N.useState(e?.startDate || null), [i, s] = N.useState(e?.endDate || null), [a, l] = N.useState(!1), u = N.useRef(null), f = N.useRef(null), [p, g] = N.useState({ top: 0, left: 0, width: 256 }); N.useEffect(() => { (e?.startDate || e?.startDate === null) && r(e.startDate || null), (e?.endDate || e?.endDate === null) && s(e.endDate || null) }, [e?.startDate, e?.endDate]), N.useEffect(() => { const T = A => { u.current && !u.current.contains(A.target) && f.current && !f.current.contains(A.target) && l(!1) }; return a && document.addEventListener("mousedown", T), () => document.removeEventListener("mousedown", T) }, [a]); const y = () => { const T = f.current; if (!T) return; const A = T.getBoundingClientRect(), M = 4, O = 256; let E = A.left; E + O > window.innerWidth - M && (E = window.innerWidth - M - O), E < M && (E = M); const k = A.bottom + M; g({ top: k, left: E, width: O }) }; N.useLayoutEffect(() => { if (a) { y(); const T = () => y(), A = () => y(); return window.addEventListener("scroll", T, !0), window.addEventListener("resize", A), () => { window.removeEventListener("scroll", T, !0), window.removeEventListener("resize", A) } } }, [a]); const v = T => { if (!(T instanceof Date) || isNaN(T)) return ""; const A = T.getFullYear(), M = String(T.getMonth() + 1).padStart(2, "0"), O = String(T.getDate()).padStart(2, "0"); return `${A}-${M}-${O}` }, b = () => { const T = v(n), A = v(i); return !T && !A ? "Select date range" : T && !A ? `${T}  ...` : !T && A ? `...  ${A}` : `${T}  ${A}` }, S = () => { t?.({ startDate: n, endDate: i }), l(!1) }, C = () => { r(null), s(null), t?.({ startDate: null, endDate: null }), l(!1) }; return d.jsxs("div", { className: "relative", children: [d.jsx("button", { type: "button", ref: f, className: "w-full text-left text-xs p-1.5 border rounded hover:bg-gray-50", onClick: () => l(T => !T), title: "Filter by created date range", children: b() }), a && jw.createPortal(d.jsx("div", { ref: u, className: "bg-white border rounded shadow p-3", style: { position: "fixed", top: p.top, left: p.left, width: p.width, zIndex: 9999 }, children: d.jsxs("div", { className: "flex flex-col gap-2", children: [d.jsx("label", { className: "text-[10px] text-gray-500", children: "From" }), d.jsx("input", { type: "date", value: v(n), onChange: T => r(T.target.value ? new Date(`${T.target.value}T00:00:00`) : null), className: "text-xs p-1 border rounded w-full" }), d.jsx("label", { className: "text-[10px] text-gray-500", children: "To" }), d.jsx("input", { type: "date", value: v(i), onChange: T => s(T.target.value ? new Date(`${T.target.value}T00:00:00`) : null), className: "text-xs p-1 border rounded w-full" }), d.jsxs("div", { className: "flex justify-between gap-2 pt-1", children: [d.jsx("button", { type: "button", className: "px-2 py-1 text-xs bg-gray-100 rounded", onClick: C, children: "Clear" }), d.jsx("button", { type: "button", className: "px-2 py-1 text-xs bg-primary text-white rounded", onClick: S, children: "Apply" })] })] }) }), document.body)] }) } var xae = {}; function bae(t) { if (Array.isArray(t)) return t } function wae(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var r, i, s, a, l = [], u = !0, f = !1; try { if (s = (n = n.call(t)).next, e !== 0) for (; !(u = (r = s.call(n)).done) && (l.push(r.value), l.length !== e); u = !0); } catch (p) { f = !0, i = p } finally { try { if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return } finally { if (f) throw i } } return l } } function rw(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = Array(e); n < e; n++)r[n] = t[n]; return r } function S6(t, e) { if (t) { if (typeof t == "string") return rw(t, e); var n = {}.toString.call(t).slice(8, -1); return n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set" ? Array.from(t) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? rw(t, e) : void 0 } } function Sae() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  } function zm(t, e) { return bae(t) || wae(t, e) || S6(t, e) || Sae() } function En(t) { "@babel/helpers - typeof"; return En = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, En(t) } function ta() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; if (e) { for (var r = [], i = 0; i < e.length; i++) { var s = e[i]; if (s) { var a = En(s); if (a === "string" || a === "number") r.push(s); else if (a === "object") { var l = Array.isArray(s) ? s : Object.entries(s).map(function (u) { var f = zm(u, 2), p = f[0], g = f[1]; return g ? p : null }); r = l.length ? r.concat(l.filter(function (u) { return !!u })) : r } } } return r.join(" ").trim() } } function Cae(t) { if (Array.isArray(t)) return rw(t) } function Tae(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function Nae() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  } function Gg(t) { return Cae(t) || Tae(t) || S6(t) || Nae() } function M2(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function jae(t, e) { if (En(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (En(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(t) } function C6(t) { var e = jae(t, "string"); return En(e) == "symbol" ? e : e + "" } function Eae(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, C6(r.key), r) } } function D2(t, e, n) { return n && Eae(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t } function Hy(t, e, n) { return (e = C6(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function fb(t, e) {
    var n = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (!n) {
      if (Array.isArray(t) || (n = Aae(t)) || e) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (f) { throw f }, f: i } } throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    } var s, a = !0, l = !1; return { s: function () { n = n.call(t) }, n: function () { var f = n.next(); return a = f.done, f }, e: function (f) { l = !0, s = f }, f: function () { try { a || n.return == null || n.return() } finally { if (l) throw s } } }
  } function Aae(t, e) { if (t) { if (typeof t == "string") return h3(t, e); var n = {}.toString.call(t).slice(8, -1); return n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set" ? Array.from(t) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? h3(t, e) : void 0 } } function h3(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = Array(e); n < e; n++)r[n] = t[n]; return r } var nn = function () {
    function t() { M2(this, t) } return D2(t, null, [{ key: "innerWidth", value: function (n) { if (n) { var r = n.offsetWidth, i = getComputedStyle(n); return r = r + (parseFloat(i.paddingLeft) + parseFloat(i.paddingRight)), r } return 0 } }, { key: "width", value: function (n) { if (n) { var r = n.offsetWidth, i = getComputedStyle(n); return r = r - (parseFloat(i.paddingLeft) + parseFloat(i.paddingRight)), r } return 0 } }, { key: "getBrowserLanguage", value: function () { return navigator.userLanguage || navigator.languages && navigator.languages.length && navigator.languages[0] || navigator.language || navigator.browserLanguage || navigator.systemLanguage || "en" } }, { key: "getWindowScrollTop", value: function () { var n = document.documentElement; return (window.pageYOffset || n.scrollTop) - (n.clientTop || 0) } }, { key: "getWindowScrollLeft", value: function () { var n = document.documentElement; return (window.pageXOffset || n.scrollLeft) - (n.clientLeft || 0) } }, { key: "getOuterWidth", value: function (n, r) { if (n) { var i = n.getBoundingClientRect().width || n.offsetWidth; if (r) { var s = getComputedStyle(n); i = i + (parseFloat(s.marginLeft) + parseFloat(s.marginRight)) } return i } return 0 } }, { key: "getOuterHeight", value: function (n, r) { if (n) { var i = n.getBoundingClientRect().height || n.offsetHeight; if (r) { var s = getComputedStyle(n); i = i + (parseFloat(s.marginTop) + parseFloat(s.marginBottom)) } return i } return 0 } }, { key: "getClientHeight", value: function (n, r) { if (n) { var i = n.clientHeight; if (r) { var s = getComputedStyle(n); i = i + (parseFloat(s.marginTop) + parseFloat(s.marginBottom)) } return i } return 0 } }, { key: "getClientWidth", value: function (n, r) { if (n) { var i = n.clientWidth; if (r) { var s = getComputedStyle(n); i = i + (parseFloat(s.marginLeft) + parseFloat(s.marginRight)) } return i } return 0 } }, { key: "getViewport", value: function () { var n = window, r = document, i = r.documentElement, s = r.getElementsByTagName("body")[0], a = n.innerWidth || i.clientWidth || s.clientWidth, l = n.innerHeight || i.clientHeight || s.clientHeight; return { width: a, height: l } } }, { key: "getOffset", value: function (n) { if (n) { var r = n.getBoundingClientRect(); return { top: r.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0), left: r.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0) } } return { top: "auto", left: "auto" } } }, { key: "index", value: function (n) { if (n) for (var r = n.parentNode.childNodes, i = 0, s = 0; s < r.length; s++) { if (r[s] === n) return i; r[s].nodeType === 1 && i++ } return -1 } }, { key: "addMultipleClasses", value: function (n, r) { if (n && r) if (n.classList) for (var i = r.split(" "), s = 0; s < i.length; s++)n.classList.add(i[s]); else for (var a = r.split(" "), l = 0; l < a.length; l++)n.className = n.className + (" " + a[l]) } }, { key: "removeMultipleClasses", value: function (n, r) { if (n && r) if (n.classList) for (var i = r.split(" "), s = 0; s < i.length; s++)n.classList.remove(i[s]); else for (var a = r.split(" "), l = 0; l < a.length; l++)n.className = n.className.replace(new RegExp("(^|\\b)" + a[l].split(" ").join("|") + "(\\b|$)", "gi"), " ") } }, { key: "addClass", value: function (n, r) { n && r && (n.classList ? n.classList.add(r) : n.className = n.className + (" " + r)) } }, { key: "removeClass", value: function (n, r) { n && r && (n.classList ? n.classList.remove(r) : n.className = n.className.replace(new RegExp("(^|\\b)" + r.split(" ").join("|") + "(\\b|$)", "gi"), " ")) } }, { key: "hasClass", value: function (n, r) { return n ? n.classList ? n.classList.contains(r) : new RegExp("(^| )" + r + "( |$)", "gi").test(n.className) : !1 } }, { key: "addStyles", value: function (n) { var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; n && Object.entries(r).forEach(function (i) { var s = zm(i, 2), a = s[0], l = s[1]; return n.style[a] = l }) } }, { key: "find", value: function (n, r) { return n ? Array.from(n.querySelectorAll(r)) : [] } }, { key: "findSingle", value: function (n, r) { return n ? n.querySelector(r) : null } }, { key: "setAttributes", value: function (n) { var r = this, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; if (n) { var s = function (l, u) { var f, p, g = n != null && (f = n.$attrs) !== null && f !== void 0 && f[l] ? [n == null || (p = n.$attrs) === null || p === void 0 ? void 0 : p[l]] : []; return [u].flat().reduce(function (y, v) { if (v != null) { var b = En(v); if (b === "string" || b === "number") y.push(v); else if (b === "object") { var S = Array.isArray(v) ? s(l, v) : Object.entries(v).map(function (C) { var T = zm(C, 2), A = T[0], M = T[1]; return l === "style" && (M || M === 0) ? "".concat(A.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), ":").concat(M) : M ? A : void 0 }); y = S.length ? y.concat(S.filter(function (C) { return !!C })) : y } } return y }, g) }; Object.entries(i).forEach(function (a) { var l = zm(a, 2), u = l[0], f = l[1]; if (f != null) { var p = u.match(/^on(.+)/); p ? n.addEventListener(p[1].toLowerCase(), f) : u === "p-bind" ? r.setAttributes(n, f) : (f = u === "class" ? Gg(new Set(s("class", f))).join(" ").trim() : u === "style" ? s("style", f).join(";").trim() : f, (n.$attrs = n.$attrs || {}) && (n.$attrs[u] = f), n.setAttribute(u, f)) } }) } } }, { key: "getAttribute", value: function (n, r) { if (n) { var i = n.getAttribute(r); return isNaN(i) ? i === "true" || i === "false" ? i === "true" : i : +i } } }, { key: "isAttributeEquals", value: function (n, r, i) { return n ? this.getAttribute(n, r) === i : !1 } }, { key: "isAttributeNotEquals", value: function (n, r, i) { return !this.isAttributeEquals(n, r, i) } }, { key: "getHeight", value: function (n) { if (n) { var r = n.offsetHeight, i = getComputedStyle(n); return r = r - (parseFloat(i.paddingTop) + parseFloat(i.paddingBottom) + parseFloat(i.borderTopWidth) + parseFloat(i.borderBottomWidth)), r } return 0 } }, { key: "getWidth", value: function (n) { if (n) { var r = n.offsetWidth, i = getComputedStyle(n); return r = r - (parseFloat(i.paddingLeft) + parseFloat(i.paddingRight) + parseFloat(i.borderLeftWidth) + parseFloat(i.borderRightWidth)), r } return 0 } }, { key: "alignOverlay", value: function (n, r, i) { var s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0; n && r && (i === "self" ? this.relativePosition(n, r) : (s && (n.style.minWidth = t.getOuterWidth(r) + "px"), this.absolutePosition(n, r))) } }, { key: "absolutePosition", value: function (n, r) { var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "left"; if (n && r) { var s = n.offsetParent ? { width: n.offsetWidth, height: n.offsetHeight } : this.getHiddenElementDimensions(n), a = s.height, l = s.width, u = r.offsetHeight, f = r.offsetWidth, p = r.getBoundingClientRect(), g = this.getWindowScrollTop(), y = this.getWindowScrollLeft(), v = this.getViewport(), b, S; p.top + u + a > v.height ? (b = p.top + g - a, b < 0 && (b = g), n.style.transformOrigin = "bottom") : (b = u + p.top + g, n.style.transformOrigin = "top"); var C = p.left; i === "left" ? C + l > v.width ? S = Math.max(0, C + y + f - l) : S = C + y : C + f - l < 0 ? S = y : S = C + f - l + y, n.style.top = b + "px", n.style.left = S + "px" } } }, { key: "relativePosition", value: function (n, r) { if (n && r) { var i = n.offsetParent ? { width: n.offsetWidth, height: n.offsetHeight } : this.getHiddenElementDimensions(n), s = r.offsetHeight, a = r.getBoundingClientRect(), l = this.getViewport(), u, f; a.top + s + i.height > l.height ? (u = -1 * i.height, a.top + u < 0 && (u = -1 * a.top), n.style.transformOrigin = "bottom") : (u = s, n.style.transformOrigin = "top"), i.width > l.width ? f = a.left * -1 : a.left + i.width > l.width ? f = (a.left + i.width - l.width) * -1 : f = 0, n.style.top = u + "px", n.style.left = f + "px" } } }, { key: "flipfitCollision", value: function (n, r) { var i = this, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "left top", a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "left bottom", l = arguments.length > 4 ? arguments[4] : void 0; if (n && r) { var u = r.getBoundingClientRect(), f = this.getViewport(), p = s.split(" "), g = a.split(" "), y = function (T, A) { return A ? +T.substring(T.search(/(\+|-)/g)) || 0 : T.substring(0, T.search(/(\+|-)/g)) || T }, v = { my: { x: y(p[0]), y: y(p[1] || p[0]), offsetX: y(p[0], !0), offsetY: y(p[1] || p[0], !0) }, at: { x: y(g[0]), y: y(g[1] || g[0]), offsetX: y(g[0], !0), offsetY: y(g[1] || g[0], !0) } }, b = { left: function () { var T = v.my.offsetX + v.at.offsetX; return T + u.left + (v.my.x === "left" ? 0 : -1 * (v.my.x === "center" ? i.getOuterWidth(n) / 2 : i.getOuterWidth(n))) }, top: function () { var T = v.my.offsetY + v.at.offsetY; return T + u.top + (v.my.y === "top" ? 0 : -1 * (v.my.y === "center" ? i.getOuterHeight(n) / 2 : i.getOuterHeight(n))) } }, S = { count: { x: 0, y: 0 }, left: function () { var T = b.left(), A = t.getWindowScrollLeft(); n.style.left = T + A + "px", this.count.x === 2 ? (n.style.left = A + "px", this.count.x = 0) : T < 0 && (this.count.x++, v.my.x = "left", v.at.x = "right", v.my.offsetX *= -1, v.at.offsetX *= -1, this.right()) }, right: function () { var T = b.left() + t.getOuterWidth(r), A = t.getWindowScrollLeft(); n.style.left = T + A + "px", this.count.x === 2 ? (n.style.left = f.width - t.getOuterWidth(n) + A + "px", this.count.x = 0) : T + t.getOuterWidth(n) > f.width && (this.count.x++, v.my.x = "right", v.at.x = "left", v.my.offsetX *= -1, v.at.offsetX *= -1, this.left()) }, top: function () { var T = b.top(), A = t.getWindowScrollTop(); n.style.top = T + A + "px", this.count.y === 2 ? (n.style.left = A + "px", this.count.y = 0) : T < 0 && (this.count.y++, v.my.y = "top", v.at.y = "bottom", v.my.offsetY *= -1, v.at.offsetY *= -1, this.bottom()) }, bottom: function () { var T = b.top() + t.getOuterHeight(r), A = t.getWindowScrollTop(); n.style.top = T + A + "px", this.count.y === 2 ? (n.style.left = f.height - t.getOuterHeight(n) + A + "px", this.count.y = 0) : T + t.getOuterHeight(r) > f.height && (this.count.y++, v.my.y = "bottom", v.at.y = "top", v.my.offsetY *= -1, v.at.offsetY *= -1, this.top()) }, center: function (T) { if (T === "y") { var A = b.top() + t.getOuterHeight(r) / 2; n.style.top = A + t.getWindowScrollTop() + "px", A < 0 ? this.bottom() : A + t.getOuterHeight(r) > f.height && this.top() } else { var M = b.left() + t.getOuterWidth(r) / 2; n.style.left = M + t.getWindowScrollLeft() + "px", M < 0 ? this.left() : M + t.getOuterWidth(n) > f.width && this.right() } } }; S[v.at.x]("x"), S[v.at.y]("y"), this.isFunction(l) && l(v) } } }, { key: "findCollisionPosition", value: function (n) { if (n) { var r = n === "top" || n === "bottom", i = n === "left" ? "right" : "left", s = n === "top" ? "bottom" : "top"; return r ? { axis: "y", my: "center ".concat(s), at: "center ".concat(n) } : { axis: "x", my: "".concat(i, " center"), at: "".concat(n, " center") } } } }, { key: "getParents", value: function (n) { var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []; return n.parentNode === null ? r : this.getParents(n.parentNode, r.concat([n.parentNode])) } }, { key: "getScrollableParents", value: function (n) { var r = this, i = []; if (n) { var s = this.getParents(n), a = /(auto|scroll)/, l = function (O) { var E = O ? getComputedStyle(O) : null; return E && (a.test(E.getPropertyValue("overflow")) || a.test(E.getPropertyValue("overflow-x")) || a.test(E.getPropertyValue("overflow-y"))) }, u = function (O) { i.push(O.nodeName === "BODY" || O.nodeName === "HTML" || r.isDocument(O) ? window : O) }, f = fb(s), p; try { for (f.s(); !(p = f.n()).done;) { var g, y = p.value, v = y.nodeType === 1 && ((g = y.dataset) === null || g === void 0 ? void 0 : g.scrollselectors); if (v) { var b = v.split(","), S = fb(b), C; try { for (S.s(); !(C = S.n()).done;) { var T = C.value, A = this.findSingle(y, T); A && l(A) && u(A) } } catch (M) { S.e(M) } finally { S.f() } } y.nodeType === 1 && l(y) && u(y) } } catch (M) { f.e(M) } finally { f.f() } } return i } }, { key: "getHiddenElementOuterHeight", value: function (n) { if (n) { n.style.visibility = "hidden", n.style.display = "block"; var r = n.offsetHeight; return n.style.display = "none", n.style.visibility = "visible", r } return 0 } }, { key: "getHiddenElementOuterWidth", value: function (n) { if (n) { n.style.visibility = "hidden", n.style.display = "block"; var r = n.offsetWidth; return n.style.display = "none", n.style.visibility = "visible", r } return 0 } }, { key: "getHiddenElementDimensions", value: function (n) { var r = {}; return n && (n.style.visibility = "hidden", n.style.display = "block", r.width = n.offsetWidth, r.height = n.offsetHeight, n.style.display = "none", n.style.visibility = "visible"), r } }, { key: "fadeIn", value: function (n, r) { if (n) { n.style.opacity = 0; var i = +new Date, s = 0, a = function () { s = +n.style.opacity + (new Date().getTime() - i) / r, n.style.opacity = s, i = +new Date, +s < 1 && (window.requestAnimationFrame && requestAnimationFrame(a) || setTimeout(a, 16)) }; a() } } }, { key: "fadeOut", value: function (n, r) { if (n) var i = 1, s = 50, a = s / r, l = setInterval(function () { i = i - a, i <= 0 && (i = 0, clearInterval(l)), n.style.opacity = i }, s) } }, { key: "getUserAgent", value: function () { return navigator.userAgent } }, { key: "isIOS", value: function () { return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream } }, { key: "isAndroid", value: function () { return /(android)/i.test(navigator.userAgent) } }, { key: "isChrome", value: function () { return /(chrome)/i.test(navigator.userAgent) } }, { key: "isClient", value: function () { return !!(typeof window < "u" && window.document && window.document.createElement) } }, { key: "isTouchDevice", value: function () { return "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 } }, { key: "isFunction", value: function (n) { return !!(n && n.constructor && n.call && n.apply) } }, { key: "appendChild", value: function (n, r) { if (this.isElement(r)) r.appendChild(n); else if (r.el && r.el.nativeElement) r.el.nativeElement.appendChild(n); else throw new Error("Cannot append " + r + " to " + n) } }, { key: "removeChild", value: function (n, r) { if (this.isElement(r)) r.removeChild(n); else if (r.el && r.el.nativeElement) r.el.nativeElement.removeChild(n); else throw new Error("Cannot remove " + n + " from " + r) } }, { key: "isElement", value: function (n) { return (typeof HTMLElement > "u" ? "undefined" : En(HTMLElement)) === "object" ? n instanceof HTMLElement : n && En(n) === "object" && n !== null && n.nodeType === 1 && typeof n.nodeName == "string" } }, { key: "isDocument", value: function (n) { return (typeof Document > "u" ? "undefined" : En(Document)) === "object" ? n instanceof Document : n && En(n) === "object" && n !== null && n.nodeType === 9 } }, { key: "scrollInView", value: function (n, r) { var i = getComputedStyle(n).getPropertyValue("border-top-width"), s = i ? parseFloat(i) : 0, a = getComputedStyle(n).getPropertyValue("padding-top"), l = a ? parseFloat(a) : 0, u = n.getBoundingClientRect(), f = r.getBoundingClientRect(), p = f.top + document.body.scrollTop - (u.top + document.body.scrollTop) - s - l, g = n.scrollTop, y = n.clientHeight, v = this.getOuterHeight(r); p < 0 ? n.scrollTop = g + p : p + v > y && (n.scrollTop = g + p - y + v) } }, { key: "clearSelection", value: function () { if (window.getSelection) window.getSelection().empty ? window.getSelection().empty() : window.getSelection().removeAllRanges && window.getSelection().rangeCount > 0 && window.getSelection().getRangeAt(0).getClientRects().length > 0 && window.getSelection().removeAllRanges(); else if (document.selection && document.selection.empty) try { document.selection.empty() } catch { } } }, { key: "calculateScrollbarWidth", value: function (n) { if (n) { var r = getComputedStyle(n); return n.offsetWidth - n.clientWidth - parseFloat(r.borderLeftWidth) - parseFloat(r.borderRightWidth) } if (this.calculatedScrollbarWidth != null) return this.calculatedScrollbarWidth; var i = document.createElement("div"); i.className = "p-scrollbar-measure", document.body.appendChild(i); var s = i.offsetWidth - i.clientWidth; return document.body.removeChild(i), this.calculatedScrollbarWidth = s, s } }, { key: "calculateBodyScrollbarWidth", value: function () { return window.innerWidth - document.documentElement.offsetWidth } }, { key: "getBrowser", value: function () { if (!this.browser) { var n = this.resolveUserAgent(); this.browser = {}, n.browser && (this.browser[n.browser] = !0, this.browser.version = n.version), this.browser.chrome ? this.browser.webkit = !0 : this.browser.webkit && (this.browser.safari = !0) } return this.browser } }, { key: "resolveUserAgent", value: function () { var n = navigator.userAgent.toLowerCase(), r = /(chrome)[ ]([\w.]+)/.exec(n) || /(webkit)[ ]([\w.]+)/.exec(n) || /(opera)(?:.*version|)[ ]([\w.]+)/.exec(n) || /(msie) ([\w.]+)/.exec(n) || n.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(n) || []; return { browser: r[1] || "", version: r[2] || "0" } } }, { key: "blockBodyScroll", value: function () { var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "p-overflow-hidden", r = !!document.body.style.getPropertyValue("--scrollbar-width"); !r && document.body.style.setProperty("--scrollbar-width", this.calculateBodyScrollbarWidth() + "px"), this.addClass(document.body, n) } }, { key: "unblockBodyScroll", value: function () { var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "p-overflow-hidden"; document.body.style.removeProperty("--scrollbar-width"), this.removeClass(document.body, n) } }, { key: "isVisible", value: function (n) { return n && (n.clientHeight !== 0 || n.getClientRects().length !== 0 || getComputedStyle(n).display !== "none") } }, { key: "isExist", value: function (n) { return !!(n !== null && typeof n < "u" && n.nodeName && n.parentNode) } }, {
      key: "getFocusableElements", value: function (n) {
        var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", i = t.find(n, 'button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])'.concat(r, `,
                [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`).concat(r, `,
                input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`).concat(r, `,
                select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`).concat(r, `,
                textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`).concat(r, `,
                [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`).concat(r, `,
                [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden])`).concat(r)), s = [], a = fb(i), l; try { for (a.s(); !(l = a.n()).done;) { var u = l.value; getComputedStyle(u).display !== "none" && getComputedStyle(u).visibility !== "hidden" && s.push(u) } } catch (f) { a.e(f) } finally { a.f() } return s
      }
    }, { key: "getFirstFocusableElement", value: function (n, r) { var i = t.getFocusableElements(n, r); return i.length > 0 ? i[0] : null } }, { key: "getLastFocusableElement", value: function (n, r) { var i = t.getFocusableElements(n, r); return i.length > 0 ? i[i.length - 1] : null } }, { key: "focus", value: function (n, r) { var i = r === void 0 ? !0 : !r; n && document.activeElement !== n && n.focus({ preventScroll: i }) } }, { key: "focusFirstElement", value: function (n, r) { if (n) { var i = t.getFirstFocusableElement(n); return i && t.focus(i, r), i } } }, { key: "getCursorOffset", value: function (n, r, i, s) { if (n) { var a = getComputedStyle(n), l = document.createElement("div"); l.style.position = "absolute", l.style.top = "0px", l.style.left = "0px", l.style.visibility = "hidden", l.style.pointerEvents = "none", l.style.overflow = a.overflow, l.style.width = a.width, l.style.height = a.height, l.style.padding = a.padding, l.style.border = a.border, l.style.overflowWrap = a.overflowWrap, l.style.whiteSpace = a.whiteSpace, l.style.lineHeight = a.lineHeight, l.innerHTML = r.replace(/\r\n|\r|\n/g, "<br />"); var u = document.createElement("span"); u.textContent = s, l.appendChild(u); var f = document.createTextNode(i); l.appendChild(f), document.body.appendChild(l); var p = u.offsetLeft, g = u.offsetTop, y = u.clientHeight; return document.body.removeChild(l), { left: Math.abs(p - n.scrollLeft), top: Math.abs(g - n.scrollTop) + y } } return { top: "auto", left: "auto" } } }, { key: "invokeElementMethod", value: function (n, r, i) { n[r].apply(n, i) } }, { key: "isClickable", value: function (n) { var r = n.nodeName, i = n.parentElement && n.parentElement.nodeName; return r === "INPUT" || r === "TEXTAREA" || r === "BUTTON" || r === "A" || i === "INPUT" || i === "TEXTAREA" || i === "BUTTON" || i === "A" || this.hasClass(n, "p-button") || this.hasClass(n.parentElement, "p-button") || this.hasClass(n.parentElement, "p-checkbox") || this.hasClass(n.parentElement, "p-radiobutton") } }, { key: "applyStyle", value: function (n, r) { if (typeof r == "string") n.style.cssText = r; else for (var i in r) n.style[i] = r[i] } }, { key: "exportCSV", value: function (n, r) { var i = new Blob([n], { type: "application/csv;charset=utf-8;" }); if (window.navigator.msSaveOrOpenBlob) navigator.msSaveOrOpenBlob(i, r + ".csv"); else { var s = t.saveAs({ name: r + ".csv", src: URL.createObjectURL(i) }); s || (n = "data:text/csv;charset=utf-8," + n, window.open(encodeURI(n))) } } }, { key: "saveAs", value: function (n) { if (n) { var r = document.createElement("a"); if (r.download !== void 0) { var i = n.name, s = n.src; return r.setAttribute("href", s), r.setAttribute("download", i), r.style.display = "none", document.body.appendChild(r), r.click(), document.body.removeChild(r), !0 } } return !1 } }, { key: "createInlineStyle", value: function (n, r) { var i = document.createElement("style"); return t.addNonce(i, n), r || (r = document.head), r.appendChild(i), i } }, { key: "removeInlineStyle", value: function (n) { if (this.isExist(n)) { try { n.parentNode.removeChild(n) } catch { } n = null } return n } }, { key: "addNonce", value: function (n, r) { try { r || (r = xae.REACT_APP_CSS_NONCE) } catch { } r && n.setAttribute("nonce", r) } }, { key: "getTargetElement", value: function (n) { if (!n) return null; if (n === "document") return document; if (n === "window") return window; if (En(n) === "object" && n.hasOwnProperty("current")) return this.isExist(n.current) ? n.current : null; var r = function (a) { return !!(a && a.constructor && a.call && a.apply) }, i = r(n) ? n() : n; return this.isDocument(i) || this.isExist(i) ? i : null } }, { key: "getAttributeNames", value: function (n) { var r, i, s; for (i = [], s = n.attributes, r = 0; r < s.length; ++r)i.push(s[r].nodeName); return i.sort(), i } }, { key: "isEqualElement", value: function (n, r) { var i, s, a, l, u; if (i = t.getAttributeNames(n), s = t.getAttributeNames(r), i.join(",") !== s.join(",")) return !1; for (var f = 0; f < i.length; ++f)if (a = i[f], a === "style") for (var p = n.style, g = r.style, y = /^\d+$/, v = 0, b = Object.keys(p); v < b.length; v++) { var S = b[v]; if (!y.test(S) && p[S] !== g[S]) return !1 } else if (n.getAttribute(a) !== r.getAttribute(a)) return !1; for (l = n.firstChild, u = r.firstChild; l && u; l = l.nextSibling, u = u.nextSibling) { if (l.nodeType !== u.nodeType) return !1; if (l.nodeType === 1) { if (!t.isEqualElement(l, u)) return !1 } else if (l.nodeValue !== u.nodeValue) return !1 } return !(l || u) } }, { key: "hasCSSAnimation", value: function (n) { if (n) { var r = getComputedStyle(n), i = parseFloat(r.getPropertyValue("animation-duration") || "0"); return i > 0 } return !1 } }, { key: "hasCSSTransition", value: function (n) { if (n) { var r = getComputedStyle(n), i = parseFloat(r.getPropertyValue("transition-duration") || "0"); return i > 0 } return !1 } }])
  }(); Hy(nn, "DATA_PROPS", ["data-"]); Hy(nn, "ARIA_PROPS", ["aria", "focus-target"]); function iw() { return iw = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, iw.apply(null, arguments) } function p3(t, e) {
    var n = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (!n) {
      if (Array.isArray(t) || (n = kae(t)) || e) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (f) { throw f }, f: i } } throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    } var s, a = !0, l = !1; return { s: function () { n = n.call(t) }, n: function () { var f = n.next(); return a = f.done, f }, e: function (f) { l = !0, s = f }, f: function () { try { a || n.return == null || n.return() } finally { if (l) throw s } } }
  } function kae(t, e) { if (t) { if (typeof t == "string") return m3(t, e); var n = {}.toString.call(t).slice(8, -1); return n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set" ? Array.from(t) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? m3(t, e) : void 0 } } function m3(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = Array(e); n < e; n++)r[n] = t[n]; return r } var Kt = function () { function t() { M2(this, t) } return D2(t, null, [{ key: "equals", value: function (n, r, i) { return i && n && En(n) === "object" && r && En(r) === "object" ? this.deepEquals(this.resolveFieldData(n, i), this.resolveFieldData(r, i)) : this.deepEquals(n, r) } }, { key: "deepEquals", value: function (n, r) { if (n === r) return !0; if (n && r && En(n) === "object" && En(r) === "object") { var i = Array.isArray(n), s = Array.isArray(r), a, l, u; if (i && s) { if (l = n.length, l !== r.length) return !1; for (a = l; a-- !== 0;)if (!this.deepEquals(n[a], r[a])) return !1; return !0 } if (i !== s) return !1; var f = n instanceof Date, p = r instanceof Date; if (f !== p) return !1; if (f && p) return n.getTime() === r.getTime(); var g = n instanceof RegExp, y = r instanceof RegExp; if (g !== y) return !1; if (g && y) return n.toString() === r.toString(); var v = Object.keys(n); if (l = v.length, l !== Object.keys(r).length) return !1; for (a = l; a-- !== 0;)if (!Object.prototype.hasOwnProperty.call(r, v[a])) return !1; for (a = l; a-- !== 0;)if (u = v[a], !this.deepEquals(n[u], r[u])) return !1; return !0 } return n !== n && r !== r } }, { key: "resolveFieldData", value: function (n, r) { if (!n || !r) return null; try { var i = n[r]; if (this.isNotEmpty(i)) return i } catch { } if (Object.keys(n).length) { if (this.isFunction(r)) return r(n); if (this.isNotEmpty(n[r])) return n[r]; if (r.indexOf(".") === -1) return n[r]; for (var s = r.split("."), a = n, l = 0, u = s.length; l < u; ++l) { if (a == null) return null; a = a[s[l]] } return a } return null } }, { key: "findDiffKeys", value: function (n, r) { return !n || !r ? {} : Object.keys(n).filter(function (i) { return !r.hasOwnProperty(i) }).reduce(function (i, s) { return i[s] = n[s], i }, {}) } }, { key: "reduceKeys", value: function (n, r) { var i = {}; return !n || !r || r.length === 0 || Object.keys(n).filter(function (s) { return r.some(function (a) { return s.startsWith(a) }) }).forEach(function (s) { i[s] = n[s], delete n[s] }), i } }, { key: "reorderArray", value: function (n, r, i) { n && r !== i && (i >= n.length && (i = i % n.length, r = r % n.length), n.splice(i, 0, n.splice(r, 1)[0])) } }, { key: "findIndexInList", value: function (n, r, i) { var s = this; return r ? i ? r.findIndex(function (a) { return s.equals(a, n, i) }) : r.findIndex(function (a) { return a === n }) : -1 } }, { key: "getJSXElement", value: function (n) { for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), s = 1; s < r; s++)i[s - 1] = arguments[s]; return this.isFunction(n) ? n.apply(void 0, i) : n } }, { key: "getItemValue", value: function (n) { for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), s = 1; s < r; s++)i[s - 1] = arguments[s]; return this.isFunction(n) ? n.apply(void 0, i) : n } }, { key: "getProp", value: function (n) { var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = n ? n[r] : void 0; return s === void 0 ? i[r] : s } }, { key: "getPropCaseInsensitive", value: function (n, r) { var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = this.toFlatCase(r); for (var a in n) if (n.hasOwnProperty(a) && this.toFlatCase(a) === s) return n[a]; for (var l in i) if (i.hasOwnProperty(l) && this.toFlatCase(l) === s) return i[l] } }, { key: "getMergedProps", value: function (n, r) { return Object.assign({}, r, n) } }, { key: "getDiffProps", value: function (n, r) { return this.findDiffKeys(n, r) } }, { key: "getPropValue", value: function (n) { if (!this.isFunction(n)) return n; for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), s = 1; s < r; s++)i[s - 1] = arguments[s]; if (i.length === 1) { var a = i[0]; return n(Array.isArray(a) ? a[0] : a) } return n.apply(void 0, i) } }, { key: "getComponentProp", value: function (n) { var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}; return this.isNotEmpty(n) ? this.getProp(n.props, r, i) : void 0 } }, { key: "getComponentProps", value: function (n, r) { return this.isNotEmpty(n) ? this.getMergedProps(n.props, r) : void 0 } }, { key: "getComponentDiffProps", value: function (n, r) { return this.isNotEmpty(n) ? this.getDiffProps(n.props, r) : void 0 } }, { key: "isValidChild", value: function (n, r, i) { if (n) { var s, a = this.getComponentProp(n, "__TYPE") || (n.type ? n.type.displayName : void 0); !a && n !== null && n !== void 0 && (s = n.type) !== null && s !== void 0 && (s = s._payload) !== null && s !== void 0 && s.value && (a = n.type._payload.value.find(function (f) { return f === r })); var l = a === r; try { var u } catch { } return l } return !1 } }, { key: "getRefElement", value: function (n) { return n ? En(n) === "object" && n.hasOwnProperty("current") ? n.current : n : null } }, { key: "combinedRefs", value: function (n, r) { n && r && (typeof r == "function" ? r(n.current) : r.current = n.current) } }, { key: "removeAccents", value: function (n) { return n && n.search(/[\xC0-\xFF]/g) > -1 && (n = n.replace(/[\xC0-\xC5]/g, "A").replace(/[\xC6]/g, "AE").replace(/[\xC7]/g, "C").replace(/[\xC8-\xCB]/g, "E").replace(/[\xCC-\xCF]/g, "I").replace(/[\xD0]/g, "D").replace(/[\xD1]/g, "N").replace(/[\xD2-\xD6\xD8]/g, "O").replace(/[\xD9-\xDC]/g, "U").replace(/[\xDD]/g, "Y").replace(/[\xDE]/g, "P").replace(/[\xE0-\xE5]/g, "a").replace(/[\xE6]/g, "ae").replace(/[\xE7]/g, "c").replace(/[\xE8-\xEB]/g, "e").replace(/[\xEC-\xEF]/g, "i").replace(/[\xF1]/g, "n").replace(/[\xF2-\xF6\xF8]/g, "o").replace(/[\xF9-\xFC]/g, "u").replace(/[\xFE]/g, "p").replace(/[\xFD\xFF]/g, "y")), n } }, { key: "toFlatCase", value: function (n) { return this.isNotEmpty(n) && this.isString(n) ? n.replace(/(-|_)/g, "").toLowerCase() : n } }, { key: "toCapitalCase", value: function (n) { return this.isNotEmpty(n) && this.isString(n) ? n[0].toUpperCase() + n.slice(1) : n } }, { key: "trim", value: function (n) { return this.isNotEmpty(n) && this.isString(n) ? n.trim() : n } }, { key: "isEmpty", value: function (n) { return n == null || n === "" || Array.isArray(n) && n.length === 0 || !(n instanceof Date) && En(n) === "object" && Object.keys(n).length === 0 } }, { key: "isNotEmpty", value: function (n) { return !this.isEmpty(n) } }, { key: "isFunction", value: function (n) { return !!(n && n.constructor && n.call && n.apply) } }, { key: "isObject", value: function (n) { return n !== null && n instanceof Object && n.constructor === Object } }, { key: "isDate", value: function (n) { return n !== null && n instanceof Date && n.constructor === Date } }, { key: "isArray", value: function (n) { return n !== null && Array.isArray(n) } }, { key: "isString", value: function (n) { return n !== null && typeof n == "string" } }, { key: "isPrintableCharacter", value: function () { var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ""; return this.isNotEmpty(n) && n.length === 1 && n.match(/\S| /) } }, { key: "isLetter", value: function (n) { return /^[a-zA-Z\u00C0-\u017F]$/.test(n) } }, { key: "isScalar", value: function (n) { return n != null && (typeof n == "string" || typeof n == "number" || typeof n == "bigint" || typeof n == "boolean") } }, { key: "findLast", value: function (n, r) { var i; if (this.isNotEmpty(n)) try { i = n.findLast(r) } catch { i = Gg(n).reverse().find(r) } return i } }, { key: "findLastIndex", value: function (n, r) { var i = -1; if (this.isNotEmpty(n)) try { i = n.findLastIndex(r) } catch { i = n.lastIndexOf(Gg(n).reverse().find(r)) } return i } }, { key: "sort", value: function (n, r) { var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, s = arguments.length > 3 ? arguments[3] : void 0, a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1, l = this.compare(n, r, s, i), u = i; return (this.isEmpty(n) || this.isEmpty(r)) && (u = a === 1 ? i : a), u * l } }, { key: "compare", value: function (n, r, i) { var s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1, a = -1, l = this.isEmpty(n), u = this.isEmpty(r); return l && u ? a = 0 : l ? a = s : u ? a = -s : typeof n == "string" && typeof r == "string" ? a = i(n, r) : a = n < r ? -1 : n > r ? 1 : 0, a } }, { key: "localeComparator", value: function (n) { return new Intl.Collator(n, { numeric: !0 }).compare } }, { key: "findChildrenByKey", value: function (n, r) { var i = p3(n), s; try { for (i.s(); !(s = i.n()).done;) { var a = s.value; if (a.key === r) return a.children || []; if (a.children) { var l = this.findChildrenByKey(a.children, r); if (l.length > 0) return l } } } catch (u) { i.e(u) } finally { i.f() } return [] } }, { key: "mutateFieldData", value: function (n, r, i) { if (!(En(n) !== "object" || typeof r != "string")) for (var s = r.split("."), a = n, l = 0, u = s.length; l < u; ++l) { if (l + 1 - u === 0) { a[s[l]] = i; break } a[s[l]] || (a[s[l]] = {}), a = a[s[l]] } } }, { key: "getNestedValue", value: function (n, r) { return r.split(".").reduce(function (i, s) { return i && i[s] !== void 0 ? i[s] : void 0 }, n) } }, { key: "absoluteCompare", value: function (n, r) { var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0; if (!n || !r || s > i) return !0; if (En(n) !== En(r)) return !1; var a = Object.keys(n), l = Object.keys(r); if (a.length !== l.length) return !1; for (var u = 0, f = a; u < f.length; u++) { var p = f[u], g = n[p], y = r[p], v = t.isObject(g) && t.isObject(y), b = t.isFunction(g) && t.isFunction(y); if ((v || b) && !this.absoluteCompare(g, y, i, s + 1) || !v && g !== y) return !1 } return !0 } }, { key: "selectiveCompare", value: function (n, r, i) { var s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1; if (n === r) return !0; if (!n || !r || En(n) !== "object" || En(r) !== "object") return !1; if (!i) return this.absoluteCompare(n, r, 1); var a = p3(i), l; try { for (a.s(); !(l = a.n()).done;) { var u = l.value, f = this.getNestedValue(n, u), p = this.getNestedValue(r, u), g = En(f) === "object" && f !== null && En(p) === "object" && p !== null; if (g && !this.absoluteCompare(f, p, s) || !g && f !== p) return !1 } } catch (y) { a.e(y) } finally { a.f() } return !0 } }]) }(), g3 = 0; function T6() { var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "pr_id_"; return g3++, "".concat(t).concat(g3) } function y3(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Oae(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? y3(Object(n), !0).forEach(function (r) { Hy(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : y3(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } var Mae = function () { function t() { M2(this, t) } return D2(t, null, [{ key: "getJSXIcon", value: function (n) { var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = null; if (n !== null) { var a = En(n), l = ta(r.className, a === "string" && n); if (s = N.createElement("span", iw({}, r, { className: l, key: T6("icon") })), a !== "string") { var u = Oae({ iconProps: r, element: s }, i); return Kt.getJSXElement(n, u) } } return s } }]) }(); function v3(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function x3(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? v3(Object(n), !0).forEach(function (r) { Hy(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : v3(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } function Xg(t) { var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; if (t) { var n = function (a) { return typeof a == "function" }, r = e.classNameMergeFunction, i = n(r); return t.reduce(function (s, a) { if (!a) return s; var l = function () { var p = a[u]; if (u === "style") s.style = x3(x3({}, s.style), a.style); else if (u === "className") { var g = ""; i ? g = r(s.className, a.className) : g = [s.className, a.className].join(" ").trim(), s.className = g || void 0 } else if (n(p)) { var y = s[u]; s[u] = y ? function () { y.apply(void 0, arguments), p.apply(void 0, arguments) } : p } else s[u] = p }; for (var u in a) l(); return s }, {}) } } function Dae() { var t = [], e = function (l, u) { var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 999, p = i(l, u, f), g = p.value + (p.key === l ? 0 : f) + 1; return t.push({ key: l, value: g }), g }, n = function (l) { t = t.filter(function (u) { return u.value !== l }) }, r = function (l, u) { return i(l, u).value }, i = function (l, u) { var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0; return Gg(t).reverse().find(function (p) { return u ? !0 : p.key === l }) || { key: l, value: f } }, s = function (l) { return l && parseInt(l.style.zIndex, 10) || 0 }; return { get: s, set: function (l, u, f, p) { u && (u.style.zIndex = String(e(l, f, p))) }, clear: function (l) { l && (n(nf.get(l)), l.style.zIndex = "") }, getCurrent: function (l, u) { return r(l, u) } } } var nf = Dae(), qr = Object.freeze({ STARTS_WITH: "startsWith", CONTAINS: "contains", NOT_CONTAINS: "notContains", ENDS_WITH: "endsWith", EQUALS: "equals", NOT_EQUALS: "notEquals", IN: "in", NOT_IN: "notIn", LESS_THAN: "lt", LESS_THAN_OR_EQUAL_TO: "lte", GREATER_THAN: "gt", GREATER_THAN_OR_EQUAL_TO: "gte", BETWEEN: "between", DATE_IS: "dateIs", DATE_IS_NOT: "dateIsNot", DATE_BEFORE: "dateBefore", DATE_AFTER: "dateAfter", CUSTOM: "custom" }); function ih(t) { "@babel/helpers - typeof"; return ih = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, ih(t) } function Rae(t, e) { if (ih(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (ih(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function _ae(t) { var e = Rae(t, "string"); return ih(e) == "symbol" ? e : e + "" } function Vi(t, e, n) { return (e = _ae(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Lae(t, e, n) { return Object.defineProperty(t, "prototype", { writable: !1 }), t } function Pae(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } var Ti = Lae(function t() { Pae(this, t) }); Vi(Ti, "ripple", !1); Vi(Ti, "inputStyle", "outlined"); Vi(Ti, "locale", "en"); Vi(Ti, "appendTo", null); Vi(Ti, "cssTransition", !0); Vi(Ti, "autoZIndex", !0); Vi(Ti, "hideOverlaysOnDocumentScrolling", !1); Vi(Ti, "nonce", null); Vi(Ti, "nullSortOrder", 1); Vi(Ti, "zIndex", { modal: 1100, overlay: 1e3, menu: 1e3, tooltip: 1100, toast: 1200 }); Vi(Ti, "pt", void 0); Vi(Ti, "filterMatchModeOptions", { text: [qr.STARTS_WITH, qr.CONTAINS, qr.NOT_CONTAINS, qr.ENDS_WITH, qr.EQUALS, qr.NOT_EQUALS], numeric: [qr.EQUALS, qr.NOT_EQUALS, qr.LESS_THAN, qr.LESS_THAN_OR_EQUAL_TO, qr.GREATER_THAN, qr.GREATER_THAN_OR_EQUAL_TO], date: [qr.DATE_IS, qr.DATE_IS_NOT, qr.DATE_BEFORE, qr.DATE_AFTER] }); Vi(Ti, "changeTheme", function (t, e, n, r) { var i, s = document.getElementById(n); if (!s) throw Error("Element with id ".concat(n, " not found.")); var a = s.getAttribute("href").replace(t, e), l = document.createElement("link"); l.setAttribute("rel", "stylesheet"), l.setAttribute("id", n), l.setAttribute("href", a), l.addEventListener("load", function () { r && r() }), (i = s.parentNode) === null || i === void 0 || i.replaceChild(l, s) }); var Pu = Pt.createContext(), Ho = Ti; function zae(t) { if (Array.isArray(t)) return t } function Iae(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var r, i, s, a, l = [], u = !0, f = !1; try { if (s = (n = n.call(t)).next, e === 0) { if (Object(n) !== n) return; u = !1 } else for (; !(u = (r = s.call(n)).done) && (l.push(r.value), l.length !== e); u = !0); } catch (p) { f = !0, i = p } finally { try { if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return } finally { if (f) throw i } } return l } } function sw(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = Array(e); n < e; n++)r[n] = t[n]; return r } function N6(t, e) { if (t) { if (typeof t == "string") return sw(t, e); var n = {}.toString.call(t).slice(8, -1); return n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set" ? Array.from(t) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? sw(t, e) : void 0 } } function Fae() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  } function Qg(t, e) { return zae(t) || Iae(t, e) || N6(t, e) || Fae() } var Jg = function (e) { var n = N.useRef(null); return N.useEffect(function () { return n.current = e, function () { n.current = null } }, [e]), n.current }, Eh = function (e) { return N.useEffect(function () { return e }, []) }, Bae = function (e) { var n = e.target, r = n === void 0 ? "document" : n, i = e.type, s = e.listener, a = e.options, l = e.when, u = l === void 0 ? !0 : l, f = N.useRef(null), p = N.useRef(null), g = Jg(s), y = Jg(a), v = function () { var A = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, M = A.target; Kt.isNotEmpty(M) && (b(), (A.when || u) && (f.current = nn.getTargetElement(M))), !p.current && f.current && (p.current = function (O) { return s && s(O) }, f.current.addEventListener(i, p.current, a)) }, b = function () { p.current && (f.current.removeEventListener(i, p.current, a), p.current = null) }, S = function () { b(), g = null, y = null }, C = N.useCallback(function () { u ? f.current = nn.getTargetElement(r) : (b(), f.current = null) }, [r, u]); return N.useEffect(function () { C() }, [C]), N.useEffect(function () { var T = "".concat(g) !== "".concat(s), A = y !== a, M = p.current; M && (T || A) ? (b(), u && v()) : M || S() }, [s, a, u]), Eh(function () { S() }), [v, b] }, bl = {}, $ae = function (e) { var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, r = N.useState(function () { return T6() }), i = Qg(r, 1), s = i[0], a = N.useState(0), l = Qg(a, 2), u = l[0], f = l[1]; return N.useEffect(function () { if (n) { bl[e] || (bl[e] = []); var p = bl[e].push(s); return f(p), function () { delete bl[e][p - 1]; var g = bl[e].length - 1, y = Kt.findLastIndex(bl[e], function (v) { return v !== void 0 }); y !== g && bl[e].splice(y + 1), f(void 0) } } }, [e, s, n]), u }; function Uae(t) { if (Array.isArray(t)) return sw(t) } function Vae(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function Hae() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  } function b3(t) { return Uae(t) || Vae(t) || N6(t) || Hae() } var qae = { TOOLTIP: 1200 }, j6 = { escKeyListeners: new Map, onGlobalKeyDown: function (e) { if (e.code === "Escape") { var n = j6.escKeyListeners, r = Math.max.apply(Math, b3(n.keys())), i = n.get(r), s = Math.max.apply(Math, b3(i.keys())), a = i.get(s); a(e) } }, refreshGlobalKeyDownListener: function () { var e = nn.getTargetElement("document"); this.escKeyListeners.size > 0 ? e.addEventListener("keydown", this.onGlobalKeyDown) : e.removeEventListener("keydown", this.onGlobalKeyDown) }, addListener: function (e, n) { var r = this, i = Qg(n, 2), s = i[0], a = i[1], l = this.escKeyListeners; l.has(s) || l.set(s, new Map); var u = l.get(s); if (u.has(a)) throw new Error("Unexpected: global esc key listener with priority [".concat(s, ", ").concat(a, "] already exists.")); return u.set(a, e), this.refreshGlobalKeyDownListener(), function () { u.delete(a), u.size === 0 && l.delete(s), r.refreshGlobalKeyDownListener() } } }, Kae = function (e) { var n = e.callback, r = e.when, i = e.priority; N.useEffect(function () { if (r) return j6.addListener(n, i) }, [n, r, i]) }, E6 = function () { var e = N.useContext(Pu); return function () { for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)r[i] = arguments[i]; return Xg(r, e?.ptOptions) } }, qy = function (e) { var n = N.useRef(!1); return N.useEffect(function () { if (!n.current) return n.current = !0, e && e() }, []) }, Wae = function (e) { var n = e.target, r = e.listener, i = e.options, s = e.when, a = s === void 0 ? !0 : s, l = N.useContext(Pu), u = N.useRef(null), f = N.useRef(null), p = N.useRef([]), g = Jg(r), y = Jg(i), v = function () { var A = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; if (Kt.isNotEmpty(A.target) && (b(), (A.when || a) && (u.current = nn.getTargetElement(A.target))), !f.current && u.current) { var M = l ? l.hideOverlaysOnDocumentScrolling : Ho.hideOverlaysOnDocumentScrolling, O = p.current = nn.getScrollableParents(u.current); O.some(function (E) { return E === document.body || E === window }) || O.push(M ? window : document.body), f.current = function (E) { return r && r(E) }, O.forEach(function (E) { return E.addEventListener("scroll", f.current, i) }) } }, b = function () { if (f.current) { var A = p.current; A.forEach(function (M) { return M.removeEventListener("scroll", f.current, i) }), f.current = null } }, S = function () { b(), p.current = null, g = null, y = null }, C = N.useCallback(function () { a ? u.current = nn.getTargetElement(n) : (b(), u.current = null) }, [n, a]); return N.useEffect(function () { C() }, [C]), N.useEffect(function () { var T = "".concat(g) !== "".concat(r), A = y !== i, M = f.current; M && (T || A) ? (b(), a && v()) : M || S() }, [r, i, a]), Eh(function () { S() }), [v, b] }, Yae = function (e) { var n = e.listener, r = e.when, i = r === void 0 ? !0 : r; return Bae({ target: "window", type: "resize", listener: n, when: i }) }, Gae = 0, um = function (e) { var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = N.useState(!1), i = Qg(r, 2), s = i[0], a = i[1], l = N.useRef(null), u = N.useContext(Pu), f = nn.isClient() ? window.document : void 0, p = n.document, g = p === void 0 ? f : p, y = n.manual, v = y === void 0 ? !1 : y, b = n.name, S = b === void 0 ? "style_".concat(++Gae) : b, C = n.id, T = C === void 0 ? void 0 : C, A = n.media, M = A === void 0 ? void 0 : A, O = function (q) { var ue = q.querySelector('style[data-primereact-style-id="'.concat(S, '"]')); if (ue) return ue; if (T !== void 0) { var W = g.getElementById(T); if (W) return W } return g.createElement("style") }, E = function (q) { s && e !== q && (l.current.textContent = q) }, k = function () { if (!(!g || s)) { var q = u?.styleContainer || g.head; l.current = O(q), l.current.isConnected || (l.current.type = "text/css", T && (l.current.id = T), M && (l.current.media = M), nn.addNonce(l.current, u && u.nonce || Ho.nonce), q.appendChild(l.current), S && l.current.setAttribute("data-primereact-style-id", S)), l.current.textContent = e, a(!0) } }, z = function () { !g || !l.current || (nn.removeInlineStyle(l.current), a(!1)) }; return N.useEffect(function () { v || k() }, [v]), { id: T, name: S, update: E, unload: z, load: k, isLoaded: s } }, jf = function (e, n) { var r = N.useRef(!1); return N.useEffect(function () { if (!r.current) { r.current = !0; return } return e && e() }, n) }; function aw(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = Array(e); n < e; n++)r[n] = t[n]; return r } function Xae(t) { if (Array.isArray(t)) return aw(t) } function Qae(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function Jae(t, e) { if (t) { if (typeof t == "string") return aw(t, e); var n = {}.toString.call(t).slice(8, -1); return n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set" ? Array.from(t) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? aw(t, e) : void 0 } } function Zae() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  } function w3(t) { return Xae(t) || Qae(t) || Jae(t) || Zae() } function sh(t) { "@babel/helpers - typeof"; return sh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, sh(t) } function eoe(t, e) { if (sh(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (sh(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function toe(t) { var e = eoe(t, "string"); return sh(e) == "symbol" ? e : e + "" } function ow(t, e, n) { return (e = toe(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function S3(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Nr(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? S3(Object(n), !0).forEach(function (r) { ow(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : S3(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } var noe = `
.p-hidden-accessible {
    border: 0;
    clip: rect(0 0 0 0);
    height: 1px;
    margin: -1px;
    opacity: 0;
    overflow: hidden;
    padding: 0;
    pointer-events: none;
    position: absolute;
    white-space: nowrap;
    width: 1px;
}

.p-overflow-hidden {
    overflow: hidden;
    padding-right: var(--scrollbar-width);
}
`, roe = `
.p-button {
    margin: 0;
    display: inline-flex;
    cursor: pointer;
    user-select: none;
    align-items: center;
    vertical-align: bottom;
    text-align: center;
    overflow: hidden;
    position: relative;
}

.p-button-label {
    flex: 1 1 auto;
}

.p-button-icon-right {
    order: 1;
}

.p-button:disabled {
    cursor: default;
}

.p-button-icon-only {
    justify-content: center;
}

.p-button-icon-only .p-button-label {
    visibility: hidden;
    width: 0;
    flex: 0 0 auto;
}

.p-button-vertical {
    flex-direction: column;
}

.p-button-icon-bottom {
    order: 2;
}

.p-button-group .p-button {
    margin: 0;
}

.p-button-group .p-button:not(:last-child) {
    border-right: 0 none;
}

.p-button-group .p-button:not(:first-of-type):not(:last-of-type) {
    border-radius: 0;
}

.p-button-group .p-button:first-of-type {
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
}

.p-button-group .p-button:last-of-type {
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
}

.p-button-group .p-button:focus {
    position: relative;
    z-index: 1;
}

.p-button-group-single .p-button:first-of-type {
    border-top-right-radius: var(--border-radius) !important;
    border-bottom-right-radius: var(--border-radius) !important;
}

.p-button-group-single .p-button:last-of-type {
    border-top-left-radius: var(--border-radius) !important;
    border-bottom-left-radius: var(--border-radius) !important;
}
`, ioe = `
.p-inputtext {
    margin: 0;
}

.p-fluid .p-inputtext {
    width: 100%;
}

/* InputGroup */
.p-inputgroup {
    display: flex;
    align-items: stretch;
    width: 100%;
}

.p-inputgroup-addon {
    display: flex;
    align-items: center;
    justify-content: center;
}

.p-inputgroup .p-float-label {
    display: flex;
    align-items: stretch;
    width: 100%;
}

.p-inputgroup .p-inputtext,
.p-fluid .p-inputgroup .p-inputtext,
.p-inputgroup .p-inputwrapper,
.p-fluid .p-inputgroup .p-input {
    flex: 1 1 auto;
    width: 1%;
}

/* Floating Label */
.p-float-label {
    display: block;
    position: relative;
}

.p-float-label label {
    position: absolute;
    pointer-events: none;
    top: 50%;
    margin-top: -0.5rem;
    transition-property: all;
    transition-timing-function: ease;
    line-height: 1;
}

.p-float-label textarea ~ label,
.p-float-label .p-mention ~ label {
    top: 1rem;
}

.p-float-label input:focus ~ label,
.p-float-label input:-webkit-autofill ~ label,
.p-float-label input.p-filled ~ label,
.p-float-label textarea:focus ~ label,
.p-float-label textarea.p-filled ~ label,
.p-float-label .p-inputwrapper-focus ~ label,
.p-float-label .p-inputwrapper-filled ~ label,
.p-float-label .p-tooltip-target-wrapper ~ label {
    top: -0.75rem;
    font-size: 12px;
}

.p-float-label .p-placeholder,
.p-float-label input::placeholder,
.p-float-label .p-inputtext::placeholder {
    opacity: 0;
    transition-property: all;
    transition-timing-function: ease;
}

.p-float-label .p-focus .p-placeholder,
.p-float-label input:focus::placeholder,
.p-float-label .p-inputtext:focus::placeholder {
    opacity: 1;
    transition-property: all;
    transition-timing-function: ease;
}

.p-input-icon-left,
.p-input-icon-right {
    position: relative;
    display: inline-block;
}

.p-input-icon-left > i,
.p-input-icon-right > i,
.p-input-icon-left > svg,
.p-input-icon-right > svg,
.p-input-icon-left > .p-input-prefix,
.p-input-icon-right > .p-input-suffix {
    position: absolute;
    top: 50%;
    margin-top: -0.5rem;
}

.p-fluid .p-input-icon-left,
.p-fluid .p-input-icon-right {
    display: block;
    width: 100%;
}
`, soe = `
.p-icon {
    display: inline-block;
}

.p-icon-spin {
    -webkit-animation: p-icon-spin 2s infinite linear;
    animation: p-icon-spin 2s infinite linear;
}

svg.p-icon {
    pointer-events: auto;
}

svg.p-icon g,
.p-disabled svg.p-icon {
    pointer-events: none;
}

@-webkit-keyframes p-icon-spin {
    0% {
        -webkit-transform: rotate(0deg);
        transform: rotate(0deg);
    }
    100% {
        -webkit-transform: rotate(359deg);
        transform: rotate(359deg);
    }
}

@keyframes p-icon-spin {
    0% {
        -webkit-transform: rotate(0deg);
        transform: rotate(0deg);
    }
    100% {
        -webkit-transform: rotate(359deg);
        transform: rotate(359deg);
    }
}
`, aoe = `
@layer primereact {
    .p-component, .p-component * {
        box-sizing: border-box;
    }

    .p-hidden {
        display: none;
    }

    .p-hidden-space {
        visibility: hidden;
    }

    .p-reset {
        margin: 0;
        padding: 0;
        border: 0;
        outline: 0;
        text-decoration: none;
        font-size: 100%;
        list-style: none;
    }

    .p-disabled, .p-disabled * {
        cursor: default;
        pointer-events: none;
        user-select: none;
    }

    .p-component-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }

    .p-unselectable-text {
        user-select: none;
    }

    .p-scrollbar-measure {
        width: 100px;
        height: 100px;
        overflow: scroll;
        position: absolute;
        top: -9999px;
    }

    @-webkit-keyframes p-fadein {
      0%   { opacity: 0; }
      100% { opacity: 1; }
    }
    @keyframes p-fadein {
      0%   { opacity: 0; }
      100% { opacity: 1; }
    }

    .p-link {
        text-align: left;
        background-color: transparent;
        margin: 0;
        padding: 0;
        border: none;
        cursor: pointer;
        user-select: none;
    }

    .p-link:disabled {
        cursor: default;
    }

    /* Non react overlay animations */
    .p-connected-overlay {
        opacity: 0;
        transform: scaleY(0.8);
        transition: transform .12s cubic-bezier(0, 0, 0.2, 1), opacity .12s cubic-bezier(0, 0, 0.2, 1);
    }

    .p-connected-overlay-visible {
        opacity: 1;
        transform: scaleY(1);
    }

    .p-connected-overlay-hidden {
        opacity: 0;
        transform: scaleY(1);
        transition: opacity .1s linear;
    }

    /* React based overlay animations */
    .p-connected-overlay-enter {
        opacity: 0;
        transform: scaleY(0.8);
    }

    .p-connected-overlay-enter-active {
        opacity: 1;
        transform: scaleY(1);
        transition: transform .12s cubic-bezier(0, 0, 0.2, 1), opacity .12s cubic-bezier(0, 0, 0.2, 1);
    }

    .p-connected-overlay-enter-done {
        transform: none;
    }

    .p-connected-overlay-exit {
        opacity: 1;
    }

    .p-connected-overlay-exit-active {
        opacity: 0;
        transition: opacity .1s linear;
    }

    /* Toggleable Content */
    .p-toggleable-content-enter {
        max-height: 0;
    }

    .p-toggleable-content-enter-active {
        overflow: hidden;
        max-height: 1000px;
        transition: max-height 1s ease-in-out;
    }

    .p-toggleable-content-enter-done {
        transform: none;
    }

    .p-toggleable-content-exit {
        max-height: 1000px;
    }

    .p-toggleable-content-exit-active {
        overflow: hidden;
        max-height: 0;
        transition: max-height 0.45s cubic-bezier(0, 1, 0, 1);
    }

    /* @todo Refactor */
    .p-menu .p-menuitem-link {
        cursor: pointer;
        display: flex;
        align-items: center;
        text-decoration: none;
        overflow: hidden;
        position: relative;
    }

    `.concat(roe, `
    `).concat(ioe, `
    `).concat(soe, `
}
`), nr = { cProps: void 0, cParams: void 0, cName: void 0, defaultProps: { pt: void 0, ptOptions: void 0, unstyled: !1 }, context: {}, globalCSS: void 0, classes: {}, styles: "", extend: function () { var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = e.css, r = Nr(Nr({}, e.defaultProps), nr.defaultProps), i = {}, s = function (p) { var g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; return nr.context = g, nr.cProps = p, Kt.getMergedProps(p, r) }, a = function (p) { return Kt.getDiffProps(p, r) }, l = function () { var p, g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, b = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0; g.hasOwnProperty("pt") && g.pt !== void 0 && (g = g.pt); var S = y, C = /./g.test(S) && !!v[S.split(".")[0]], T = C ? Kt.toFlatCase(S.split(".")[1]) : Kt.toFlatCase(S), A = v.hostName && Kt.toFlatCase(v.hostName), M = A || v.props && v.props.__TYPE && Kt.toFlatCase(v.props.__TYPE) || "", O = T === "transition", E = "data-pc-", k = function (ye) { return ye != null && ye.props ? ye.hostName ? ye.props.__TYPE === ye.hostName ? ye.props : k(ye.parent) : ye.parent : void 0 }, z = function (ye) { var He, B; return ((He = v.props) === null || He === void 0 ? void 0 : He[ye]) || ((B = k(v)) === null || B === void 0 ? void 0 : B[ye]) }; nr.cParams = v, nr.cName = M; var V = z("ptOptions") || nr.context.ptOptions || {}, q = V.mergeSections, ue = q === void 0 ? !0 : q, W = V.mergeProps, ne = W === void 0 ? !1 : W, H = function () { var ye = Pa.apply(void 0, arguments); return Array.isArray(ye) ? { className: ta.apply(void 0, w3(ye)) } : Kt.isString(ye) ? { className: ye } : ye != null && ye.hasOwnProperty("className") && Array.isArray(ye.className) ? { className: ta.apply(void 0, w3(ye.className)) } : ye }, we = b ? C ? A6(H, S, v) : k6(H, S, v) : void 0, xe = C ? void 0 : Wy(Ky(g, M), H, S, v), K = !O && Nr(Nr({}, T === "root" && ow({}, "".concat(E, "name"), v.props && v.props.__parentMetadata ? Kt.toFlatCase(v.props.__TYPE) : M)), {}, ow({}, "".concat(E, "section"), T)); return ue || !ue && xe ? ne ? Xg([we, xe, Object.keys(K).length ? K : {}], { classNameMergeFunction: (p = nr.context.ptOptions) === null || p === void 0 ? void 0 : p.classNameMergeFunction }) : Nr(Nr(Nr({}, we), xe), Object.keys(K).length ? K : {}) : Nr(Nr({}, xe), Object.keys(K).length ? K : {}) }, u = function () { var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g = p.props, y = p.state, v = function () { var M = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", O = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; return l((g || {}).pt, M, Nr(Nr({}, p), O)) }, b = function () { var M = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, O = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}; return l(M, O, E, !1) }, S = function () { return nr.context.unstyled || Ho.unstyled || g.unstyled }, C = function () { var M = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", O = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; return S() ? void 0 : Pa(n && n.classes, M, Nr({ props: g, state: y }, O)) }, T = function () { var M = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", O = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0; if (E) { var k, z = Pa(n && n.inlineStyles, M, Nr({ props: g, state: y }, O)), V = Pa(i, M, Nr({ props: g, state: y }, O)); return Xg([V, z], { classNameMergeFunction: (k = nr.context.ptOptions) === null || k === void 0 ? void 0 : k.classNameMergeFunction }) } }; return { ptm: v, ptmo: b, sx: T, cx: C, isUnstyled: S } }; return Nr(Nr({ getProps: s, getOtherProps: a, setMetaData: u }, e), {}, { defaultProps: r }) } }, Pa = function (e) { var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = String(Kt.toFlatCase(n)).split("."), s = i.shift(), a = Kt.isNotEmpty(e) ? Object.keys(e).find(function (l) { return Kt.toFlatCase(l) === s }) : ""; return s ? Kt.isObject(e) ? Pa(Kt.getItemValue(e[a], r), i.join("."), r) : void 0 : Kt.getItemValue(e, r) }, Ky = function (e) { var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", r = arguments.length > 2 ? arguments[2] : void 0, i = e?._usept, s = function (l) { var u, f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, p = r ? r(l) : l, g = Kt.toFlatCase(n); return (u = f ? g !== nr.cName ? p?.[g] : void 0 : p?.[g]) !== null && u !== void 0 ? u : p }; return Kt.isNotEmpty(i) ? { _usept: i, originalValue: s(e.originalValue), value: s(e.value) } : s(e, !0) }, Wy = function (e, n, r, i) { var s = function (S) { return n(S, r, i) }; if (e != null && e.hasOwnProperty("_usept")) { var a = e._usept || nr.context.ptOptions || {}, l = a.mergeSections, u = l === void 0 ? !0 : l, f = a.mergeProps, p = f === void 0 ? !1 : f, g = a.classNameMergeFunction, y = s(e.originalValue), v = s(e.value); return y === void 0 && v === void 0 ? void 0 : Kt.isString(v) ? v : Kt.isString(y) ? y : u || !u && v ? p ? Xg([y, v], { classNameMergeFunction: g }) : Nr(Nr({}, y), v) : v } return s(e) }, ooe = function () { return Ky(nr.context.pt || Ho.pt, void 0, function (e) { return Kt.getItemValue(e, nr.cParams) }) }, loe = function () { return Ky(nr.context.pt || Ho.pt, void 0, function (e) { return Pa(e, nr.cName, nr.cParams) || Kt.getItemValue(e, nr.cParams) }) }, A6 = function (e, n, r) { return Wy(ooe(), e, n, r) }, k6 = function (e, n, r) { return Wy(loe(), e, n, r) }, O6 = function (e) { var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function () { }, r = arguments.length > 2 ? arguments[2] : void 0, i = r.name, s = r.styled, a = s === void 0 ? !1 : s, l = r.hostName, u = l === void 0 ? "" : l, f = A6(Pa, "global.css", nr.cParams), p = Kt.toFlatCase(i), g = um(noe, { name: "base", manual: !0 }), y = g.load, v = um(aoe, { name: "common", manual: !0 }), b = v.load, S = um(f, { name: "global", manual: !0 }), C = S.load, T = um(e, { name: i, manual: !0 }), A = T.load, M = function (E) { if (!u) { var k = Wy(Ky((nr.cProps || {}).pt, p), Pa, "hooks.".concat(E)), z = k6(Pa, "hooks.".concat(E)); k?.(), z?.() } }; M("useMountEffect"), qy(function () { y(), C(), n() || (b(), a || A()) }), jf(function () { M("useUpdateEffect") }), Eh(function () { M("useUnmountEffect") }) }, Im = { defaultProps: { __TYPE: "IconBase", className: null, label: null, spin: !1 }, getProps: function (e) { return Kt.getMergedProps(e, Im.defaultProps) }, getOtherProps: function (e) { return Kt.getDiffProps(e, Im.defaultProps) }, getPTI: function (e) { var n = Kt.isEmpty(e.label), r = Im.getOtherProps(e), i = { className: ta("p-icon", { "p-icon-spin": e.spin }, e.className), role: n ? void 0 : "img", "aria-label": n ? void 0 : e.label, "aria-hidden": e.label ? n : void 0 }; return Kt.getMergedProps(r, i) } }; function lw() { return lw = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, lw.apply(null, arguments) } var M6 = N.memo(N.forwardRef(function (t, e) { var n = Im.getPTI(t); return N.createElement("svg", lw({ ref: e, width: "14", height: "14", viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, n), N.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7 14C5.61553 14 4.26215 13.5895 3.11101 12.8203C1.95987 12.0511 1.06266 10.9579 0.532846 9.67879C0.00303296 8.3997 -0.13559 6.99224 0.134506 5.63437C0.404603 4.2765 1.07129 3.02922 2.05026 2.05026C3.02922 1.07129 4.2765 0.404603 5.63437 0.134506C6.99224 -0.13559 8.3997 0.00303296 9.67879 0.532846C10.9579 1.06266 12.0511 1.95987 12.8203 3.11101C13.5895 4.26215 14 5.61553 14 7C14 8.85652 13.2625 10.637 11.9497 11.9497C10.637 13.2625 8.85652 14 7 14ZM7 1.16667C5.84628 1.16667 4.71846 1.50879 3.75918 2.14976C2.79989 2.79074 2.05222 3.70178 1.61071 4.76768C1.16919 5.83358 1.05367 7.00647 1.27876 8.13803C1.50384 9.26958 2.05941 10.309 2.87521 11.1248C3.69102 11.9406 4.73042 12.4962 5.86198 12.7212C6.99353 12.9463 8.16642 12.8308 9.23232 12.3893C10.2982 11.9478 11.2093 11.2001 11.8502 10.2408C12.4912 9.28154 12.8333 8.15373 12.8333 7C12.8333 5.45291 12.2188 3.96918 11.1248 2.87521C10.0308 1.78125 8.5471 1.16667 7 1.16667ZM4.66662 9.91668C4.58998 9.91704 4.51404 9.90209 4.44325 9.87271C4.37246 9.84333 4.30826 9.8001 4.2544 9.74557C4.14516 9.6362 4.0838 9.48793 4.0838 9.33335C4.0838 9.17876 4.14516 9.0305 4.2544 8.92113L6.17553 7L4.25443 5.07891C4.15139 4.96832 4.09529 4.82207 4.09796 4.67094C4.10063 4.51982 4.16185 4.37563 4.26872 4.26876C4.3756 4.16188 4.51979 4.10066 4.67091 4.09799C4.82204 4.09532 4.96829 4.15142 5.07887 4.25446L6.99997 6.17556L8.92106 4.25446C9.03164 4.15142 9.1779 4.09532 9.32903 4.09799C9.48015 4.10066 9.62434 4.16188 9.73121 4.26876C9.83809 4.37563 9.89931 4.51982 9.90198 4.67094C9.90464 4.82207 9.84855 4.96832 9.74551 5.07891L7.82441 7L9.74554 8.92113C9.85478 9.0305 9.91614 9.17876 9.91614 9.33335C9.91614 9.48793 9.85478 9.6362 9.74554 9.74557C9.69168 9.8001 9.62748 9.84333 9.55669 9.87271C9.4859 9.90209 9.40996 9.91704 9.33332 9.91668C9.25668 9.91704 9.18073 9.90209 9.10995 9.87271C9.03916 9.84333 8.97495 9.8001 8.9211 9.74557L6.99997 7.82444L5.07884 9.74557C5.02499 9.8001 4.96078 9.84333 4.88999 9.87271C4.81921 9.90209 4.74326 9.91704 4.66662 9.91668Z", fill: "currentColor" })) })); M6.displayName = "TimesCircleIcon"; function cw(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = Array(e); n < e; n++)r[n] = t[n]; return r } function coe(t) { if (Array.isArray(t)) return cw(t) } function uoe(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function doe(t, e) { if (t) { if (typeof t == "string") return cw(t, e); var n = {}.toString.call(t).slice(8, -1); return n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set" ? Array.from(t) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? cw(t, e) : void 0 } } function foe() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  } function hoe(t) { return coe(t) || uoe(t) || doe(t) || foe() } var Zg = { DEFAULT_MASKS: { pint: /[\d]/, int: /[\d\-]/, pnum: /[\d\.]/, money: /[\d\.\s,]/, num: /[\d\-\.]/, hex: /[0-9a-f]/i, email: /[a-z0-9_\.\-@]/i, alpha: /[a-z_]/i, alphanum: /[a-z0-9_]/i }, getRegex: function (e) { return Zg.DEFAULT_MASKS[e] ? Zg.DEFAULT_MASKS[e] : e }, onBeforeInput: function (e, n, r) { r || !nn.isAndroid() || this.validateKey(e, e.data, n) }, onKeyPress: function (e, n, r) { r || nn.isAndroid() || e.ctrlKey || e.altKey || e.metaKey || this.validateKey(e, e.key, n) }, onPaste: function (e, n, r) { if (!r) { var i = this.getRegex(n), s = e.clipboardData.getData("text"); hoe(s).forEach(function (a) { if (!i.test(a)) return e.preventDefault(), !1 }) } }, validateKey: function (e, n, r) { if (n != null) { var i = n.length <= 2; if (i) { var s = this.getRegex(r); s.test(n) || e.preventDefault() } } }, validate: function (e, n) { var r = e.target.value, i = !0, s = this.getRegex(n); return r && !s.test(r) && (i = !1), i } }; function poe(t) { if (Array.isArray(t)) return t } function moe(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var r, i, s, a, l = [], u = !0, f = !1; try { if (s = (n = n.call(t)).next, e !== 0) for (; !(u = (r = s.call(n)).done) && (l.push(r.value), l.length !== e); u = !0); } catch (p) { f = !0, i = p } finally { try { if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return } finally { if (f) throw i } } return l } } function C3(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = Array(e); n < e; n++)r[n] = t[n]; return r } function goe(t, e) { if (t) { if (typeof t == "string") return C3(t, e); var n = {}.toString.call(t).slice(8, -1); return n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set" ? Array.from(t) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? C3(t, e) : void 0 } } function yoe() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  } function voe(t, e) { return poe(t) || moe(t, e) || goe(t, e) || yoe() } var uw = { defaultProps: { __TYPE: "Portal", element: null, appendTo: null, visible: !1, onMounted: null, onUnmounted: null, children: void 0 }, getProps: function (e) { return Kt.getMergedProps(e, uw.defaultProps) }, getOtherProps: function (e) { return Kt.getDiffProps(e, uw.defaultProps) } }, D6 = N.memo(function (t) { var e = uw.getProps(t), n = N.useContext(Pu), r = N.useState(e.visible && nn.isClient()), i = voe(r, 2), s = i[0], a = i[1]; qy(function () { nn.isClient() && !s && (a(!0), e.onMounted && e.onMounted()) }), jf(function () { e.onMounted && e.onMounted() }, [s]), Eh(function () { e.onUnmounted && e.onUnmounted() }); var l = e.element || e.children; if (l && s) { var u = e.appendTo || n && n.appendTo || Ho.appendTo; return Kt.isFunction(u) && (u = u()), u || (u = document.body), u === "self" ? l : TO.createPortal(l, u) } return null }); D6.displayName = "Portal"; function ey() { return ey = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, ey.apply(null, arguments) } function ah(t) { "@babel/helpers - typeof"; return ah = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, ah(t) } function xoe(t, e) { if (ah(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (ah(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function boe(t) { var e = xoe(t, "string"); return ah(e) == "symbol" ? e : e + "" } function R6(t, e, n) { return (e = boe(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function dw(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = Array(e); n < e; n++)r[n] = t[n]; return r } function woe(t) { if (Array.isArray(t)) return dw(t) } function Soe(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function _6(t, e) { if (t) { if (typeof t == "string") return dw(t, e); var n = {}.toString.call(t).slice(8, -1); return n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set" ? Array.from(t) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? dw(t, e) : void 0 } } function Coe() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  } function Toe(t) { return woe(t) || Soe(t) || _6(t) || Coe() } function Noe(t) { if (Array.isArray(t)) return t } function joe(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var r, i, s, a, l = [], u = !0, f = !1; try { if (s = (n = n.call(t)).next, e !== 0) for (; !(u = (r = s.call(n)).done) && (l.push(r.value), l.length !== e); u = !0); } catch (p) { f = !0, i = p } finally { try { if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return } finally { if (f) throw i } } return l } } function Eoe() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  } function Wc(t, e) { return Noe(t) || joe(t, e) || _6(t, e) || Eoe() } var Aoe = { root: function (e) { var n = e.positionState, r = e.classNameState; return ta("p-tooltip p-component", R6({}, "p-tooltip-".concat(n), !0), r) }, arrow: "p-tooltip-arrow", text: "p-tooltip-text" }, koe = { arrow: function (e) { var n = e.context; return { top: n.bottom ? "0" : n.right || n.left || !n.right && !n.left && !n.top && !n.bottom ? "50%" : null, bottom: n.top ? "0" : null, left: n.right || !n.right && !n.left && !n.top && !n.bottom ? "0" : n.top || n.bottom ? "50%" : null, right: n.left ? "0" : null } } }, Ooe = `
@layer primereact {
    .p-tooltip {
        position: absolute;
        padding: .25em .5rem;
        /* #3687: Tooltip prevent scrollbar flickering */
        top: -9999px;
        left: -9999px;
    }
    
    .p-tooltip.p-tooltip-right,
    .p-tooltip.p-tooltip-left {
        padding: 0 .25rem;
    }
    
    .p-tooltip.p-tooltip-top,
    .p-tooltip.p-tooltip-bottom {
        padding:.25em 0;
    }
    
    .p-tooltip .p-tooltip-text {
       white-space: pre-line;
       word-break: break-word;
    }
    
    .p-tooltip-arrow {
        position: absolute;
        width: 0;
        height: 0;
        border-color: transparent;
        border-style: solid;
    }
    
    .p-tooltip-right .p-tooltip-arrow {
        top: 50%;
        left: 0;
        margin-top: -.25rem;
        border-width: .25em .25em .25em 0;
    }
    
    .p-tooltip-left .p-tooltip-arrow {
        top: 50%;
        right: 0;
        margin-top: -.25rem;
        border-width: .25em 0 .25em .25rem;
    }
    
    .p-tooltip.p-tooltip-top {
        padding: .25em 0;
    }
    
    .p-tooltip-top .p-tooltip-arrow {
        bottom: 0;
        left: 50%;
        margin-left: -.25rem;
        border-width: .25em .25em 0;
    }
    
    .p-tooltip-bottom .p-tooltip-arrow {
        top: 0;
        left: 50%;
        margin-left: -.25rem;
        border-width: 0 .25em .25rem;
    }

    .p-tooltip-target-wrapper {
        display: inline-flex;
    }
}
`, dm = nr.extend({ defaultProps: { __TYPE: "Tooltip", appendTo: null, at: null, autoHide: !0, autoZIndex: !0, baseZIndex: 0, className: null, closeOnEscape: !1, content: null, disabled: !1, event: null, hideDelay: 0, hideEvent: "mouseleave", id: null, mouseTrack: !1, mouseTrackLeft: 5, mouseTrackTop: 5, my: null, onBeforeHide: null, onBeforeShow: null, onHide: null, onShow: null, position: "right", showDelay: 0, showEvent: "mouseenter", showOnDisabled: !1, style: null, target: null, updateDelay: 0, children: void 0 }, css: { classes: Aoe, styles: Ooe, inlineStyles: koe } }); function T3(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function Moe(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? T3(Object(n), !0).forEach(function (r) { R6(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : T3(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } var L6 = N.memo(N.forwardRef(function (t, e) { var n = E6(), r = N.useContext(Pu), i = dm.getProps(t, r), s = N.useState(!1), a = Wc(s, 2), l = a[0], u = a[1], f = N.useState(i.position || "right"), p = Wc(f, 2), g = p[0], y = p[1], v = N.useState(""), b = Wc(v, 2), S = b[0], C = b[1], T = N.useState(!1), A = Wc(T, 2), M = A[0], O = A[1], E = l && i.closeOnEscape, k = $ae("tooltip", E), z = { props: i, state: { visible: l, position: g, className: S }, context: { right: g === "right", left: g === "left", top: g === "top", bottom: g === "bottom" } }, V = dm.setMetaData(z), q = V.ptm, ue = V.cx, W = V.sx, ne = V.isUnstyled; O6(dm.css.styles, ne, { name: "tooltip" }), Kae({ callback: function () { _() }, when: E, priority: [qae.TOOLTIP, k] }); var H = N.useRef(null), we = N.useRef(null), xe = N.useRef(null), K = N.useRef(null), te = N.useRef(!0), ye = N.useRef({}), He = N.useRef(null), B = Yae({ listener: function (Te) { !nn.isTouchDevice() && _(Te) } }), ie = Wc(B, 2), oe = ie[0], pe = ie[1], Ee = Wae({ target: xe.current, listener: function (Te) { _(Te) }, when: l }), fe = Wc(Ee, 2), Oe = fe[0], et = fe[1], Xe = function (Te) { return !(i.content || $e(Te, "tooltip")) }, De = function (Te) { return !(i.content || $e(Te, "tooltip") || i.children) }, he = function (Te) { return $e(Te, "mousetrack") || i.mouseTrack }, Be = function (Te) { return $e(Te, "disabled") === "true" || $(Te, "disabled") || i.disabled }, Y = function (Te) { return $e(Te, "showondisabled") || i.showOnDisabled }, Je = function () { return $e(xe.current, "autohide") || i.autoHide }, $e = function (Te, Ze) { return $(Te, "data-pr-".concat(Ze)) ? Te.getAttribute("data-pr-".concat(Ze)) : null }, $ = function (Te, Ze) { return Te && Te.hasAttribute(Ze) }, U = function (Te) { var Ze = [$e(Te, "showevent") || i.showEvent], gt = [$e(Te, "hideevent") || i.hideEvent]; if (he(Te)) Ze = ["mousemove"], gt = ["mouseleave"]; else { var vt = $e(Te, "event") || i.event; vt === "focus" && (Ze = ["focus"], gt = ["blur"]), vt === "both" && (Ze = ["focus", "mouseenter"], gt = M ? ["blur"] : ["mouseleave", "blur"]) } return { showEvents: Ze, hideEvents: gt } }, be = function (Te) { return $e(Te, "position") || g }, Ie = function (Te) { var Ze = $e(Te, "mousetracktop") || i.mouseTrackTop, gt = $e(Te, "mousetrackleft") || i.mouseTrackLeft; return { top: Ze, left: gt } }, it = function (Te, Ze) { if (we.current) { var gt = $e(Te, "tooltip") || i.content; gt ? (we.current.innerHTML = "", we.current.appendChild(document.createTextNode(gt)), Ze()) : i.children && Ze() } }, P = function (Te) { it(xe.current, function () { var Ze = He.current, gt = Ze.pageX, vt = Ze.pageY; i.autoZIndex && !nf.get(H.current) && nf.set("tooltip", H.current, r && r.autoZIndex || Ho.autoZIndex, i.baseZIndex || r && r.zIndex.tooltip || Ho.zIndex.tooltip), H.current.style.left = "", H.current.style.top = "", Je() && (H.current.style.pointerEvents = "none"); var Nt = he(xe.current) || Te === "mouse"; (Nt && !K.current || Nt) && (K.current = { width: nn.getOuterWidth(H.current), height: nn.getOuterHeight(H.current) }), I(xe.current, { x: gt, y: vt }, Te) }) }, ee = function (Te) { Te.type && Te.type === "focus" && O(!0), xe.current = Te.currentTarget; var Ze = Be(xe.current), gt = De(Y(xe.current) && Ze ? xe.current.firstChild : xe.current); if (!(gt || Ze)) if (He.current = Te, l) yn("updateDelay", P); else { var vt = Gt(i.onBeforeShow, { originalEvent: Te, target: xe.current }); vt && yn("showDelay", function () { u(!0), Gt(i.onShow, { originalEvent: Te, target: xe.current }) }) } }, _ = function (Te) { if (Te && Te.type === "blur" && O(!1), $n(), l) { var Ze = Gt(i.onBeforeHide, { originalEvent: Te, target: xe.current }); Ze && yn("hideDelay", function () { !Je() && te.current === !1 || (nf.clear(H.current), nn.removeClass(H.current, "p-tooltip-active"), u(!1), Gt(i.onHide, { originalEvent: Te, target: xe.current })) }) } else !i.onBeforeHide && !Tt("hideDelay") && u(!1) }, I = function (Te, Ze, gt) { var vt = 0, Nt = 0, rn = gt || g; if ((he(Te) || rn == "mouse") && Ze) { var Un = { width: nn.getOuterWidth(H.current), height: nn.getOuterHeight(H.current) }; vt = Ze.x, Nt = Ze.y; var Z = Ie(Te), ce = Z.top, Se = Z.left; switch (rn) { case "left": vt = vt - (Un.width + Se), Nt = Nt - (Un.height / 2 - ce); break; case "right": case "mouse": vt = vt + Se, Nt = Nt - (Un.height / 2 - ce); break; case "top": vt = vt - (Un.width / 2 - Se), Nt = Nt - (Un.height + ce); break; case "bottom": vt = vt - (Un.width / 2 - Se), Nt = Nt + ce; break }vt <= 0 || K.current.width > Un.width ? (H.current.style.left = "0px", H.current.style.right = window.innerWidth - Un.width - vt + "px") : (H.current.style.right = "", H.current.style.left = vt + "px"), H.current.style.top = Nt + "px", nn.addClass(H.current, "p-tooltip-active") } else { var Le = nn.findCollisionPosition(rn), We = $e(Te, "my") || i.my || Le.my, ct = $e(Te, "at") || i.at || Le.at; H.current.style.padding = "0px", nn.flipfitCollision(H.current, Te, We, ct, function (xt) { var at = xt.at, dt = at.x, ut = at.y, jt = xt.my.x, St = i.at ? dt !== "center" && dt !== jt ? dt : ut : xt.at["".concat(Le.axis)]; H.current.style.padding = "", y(St), se(St), nn.addClass(H.current, "p-tooltip-active") }) } }, se = function (Te) { if (H.current) { var Ze = getComputedStyle(H.current); Te === "left" ? H.current.style.left = parseFloat(Ze.left) - parseFloat(Ze.paddingLeft) * 2 + "px" : Te === "top" && (H.current.style.top = parseFloat(Ze.top) - parseFloat(Ze.paddingTop) * 2 + "px") } }, ae = function () { Je() || (te.current = !1) }, Ae = function (Te) { Je() || (te.current = !0, _(Te)) }, qe = function (Te) { if (Te) { var Ze = U(Te), gt = Ze.showEvents, vt = Ze.hideEvents, Nt = cn(Te); gt.forEach(function (rn) { return Nt?.addEventListener(rn, ee) }), vt.forEach(function (rn) { return Nt?.addEventListener(rn, _) }) } }, rt = function (Te) { if (Te) { var Ze = U(Te), gt = Ze.showEvents, vt = Ze.hideEvents, Nt = cn(Te); gt.forEach(function (rn) { return Nt?.removeEventListener(rn, ee) }), vt.forEach(function (rn) { return Nt?.removeEventListener(rn, _) }) } }, Tt = function (Te) { return $e(xe.current, Te.toLowerCase()) || i[Te] }, yn = function (Te, Ze) { $n(); var gt = Tt(Te); gt ? ye.current["".concat(Te)] = setTimeout(function () { return Ze() }, gt) : Ze() }, Gt = function (Te) { if (Te) { for (var Ze = arguments.length, gt = new Array(Ze > 1 ? Ze - 1 : 0), vt = 1; vt < Ze; vt++)gt[vt - 1] = arguments[vt]; var Nt = Te.apply(void 0, gt); return Nt === void 0 && (Nt = !0), Nt } return !0 }, $n = function () { Object.values(ye.current).forEach(function (Te) { return clearTimeout(Te) }) }, cn = function (Te) { if (Te) { if (Y(Te)) { if (!Te.hasWrapper) { var Ze = document.createElement("div"), gt = Te.nodeName === "INPUT"; return gt ? nn.addMultipleClasses(Ze, "p-tooltip-target-wrapper p-inputwrapper") : nn.addClass(Ze, "p-tooltip-target-wrapper"), Te.parentNode.insertBefore(Ze, Te), Ze.appendChild(Te), Te.hasWrapper = !0, Ze } return Te.parentElement } else if (Te.hasWrapper) { var vt; (vt = Te.parentElement).replaceWith.apply(vt, Toe(Te.parentElement.childNodes)), delete Te.hasWrapper } return Te } return null }, je = function (Te) { lt(Te), tt(Te) }, tt = function (Te) { le(Te || i.target, qe) }, lt = function (Te) { le(Te || i.target, rt) }, le = function (Te, Ze) { if (Te = Kt.getRefElement(Te), Te) if (nn.isElement(Te)) Ze(Te); else { var gt = function (Nt) { var rn = nn.find(document, Nt); rn.forEach(function (Un) { Ze(Un) }) }; Te instanceof Array ? Te.forEach(function (vt) { gt(vt) }) : gt(Te) } }; qy(function () { l && xe.current && Be(xe.current) && _() }), jf(function () { return tt(), function () { lt() } }, [ee, _, i.target]), jf(function () { if (l) { var Qe = be(xe.current), Te = $e(xe.current, "classname"); y(Qe), C(Te), P(Qe), oe(), Oe() } else y(i.position || "right"), C(""), xe.current = null, K.current = null, te.current = !0; return function () { pe(), et() } }, [l]), jf(function () { var Qe = be(xe.current); l && Qe !== "mouse" && yn("updateDelay", function () { it(xe.current, function () { I(xe.current) }) }) }, [i.content]), Eh(function () { _(), nf.clear(H.current) }), N.useImperativeHandle(e, function () { return { props: i, updateTargetEvents: je, loadTargetEvents: tt, unloadTargetEvents: lt, show: ee, hide: _, getElement: function () { return H.current }, getTarget: function () { return xe.current } } }); var st = function () { var Te = Xe(xe.current), Ze = n({ id: i.id, className: ta(i.className, ue("root", { positionState: g, classNameState: S })), style: i.style, role: "tooltip", "aria-hidden": l, onMouseEnter: function (rn) { return ae() }, onMouseLeave: function (rn) { return Ae(rn) } }, dm.getOtherProps(i), q("root")), gt = n({ className: ue("arrow"), style: W("arrow", Moe({}, z)) }, q("arrow")), vt = n({ className: ue("text") }, q("text")); return N.createElement("div", ey({ ref: H }, Ze), N.createElement("div", gt), N.createElement("div", ey({ ref: we }, vt), Te && i.children)) }; if (l) { var wt = st(); return N.createElement(D6, { element: wt, appendTo: i.appendTo, visible: !0 }) } return null })); L6.displayName = "Tooltip"; function oh(t) { "@babel/helpers - typeof"; return oh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, oh(t) } function Doe(t, e) { if (oh(t) != "object" || !t) return t; var n = t[Symbol.toPrimitive]; if (n !== void 0) { var r = n.call(t, e); if (oh(r) != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(t) } function Roe(t) { var e = Doe(t, "string"); return oh(e) == "symbol" ? e : e + "" } function _oe(t, e, n) { return (e = Roe(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function Co() { return Co = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, Co.apply(null, arguments) } function fw(t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = Array(e); n < e; n++)r[n] = t[n]; return r } function Loe(t) { if (Array.isArray(t)) return fw(t) } function Poe(t) { if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t) } function P6(t, e) { if (t) { if (typeof t == "string") return fw(t, e); var n = {}.toString.call(t).slice(8, -1); return n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set" ? Array.from(t) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? fw(t, e) : void 0 } } function zoe() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  } function fm(t) { return Loe(t) || Poe(t) || P6(t) || zoe() } function Ioe(t) { if (Array.isArray(t)) return t } function Foe(t, e) { var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]; if (n != null) { var r, i, s, a, l = [], u = !0, f = !1; try { if (s = (n = n.call(t)).next, e !== 0) for (; !(u = (r = s.call(n)).done) && (l.push(r.value), l.length !== e); u = !0); } catch (p) { f = !0, i = p } finally { try { if (!u && n.return != null && (a = n.return(), Object(a) !== a)) return } finally { if (f) throw i } } return l } } function Boe() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  } function N3(t, e) { return Ioe(t) || Foe(t, e) || P6(t, e) || Boe() } var $oe = `
@layer primereact {
    .p-chips {
        display: inline-flex;
    }
    
    .p-chips-multiple-container {
        margin: 0;
        padding: 0;
        list-style-type: none;
        cursor: text;
        overflow: hidden;
        display: flex;
        align-items: center;
        flex-wrap: wrap;
    }
    
    .p-chips-token {
        cursor: default;
        display: inline-flex;
        align-items: center;
        flex: 0 0 auto;
    }
    
    .p-chips-input-token {
        flex: 1 1 auto;
        display: inline-flex;
    }
    
    .p-chips-token-icon {
        cursor: pointer;
    }
    
    .p-chips-input-token input {
        border: 0 none;
        outline: 0 none;
        background-color: transparent;
        margin: 0;
        padding: 0;
        box-shadow: none;
        border-radius: 0;
        width: 100%;
    }
    
    .p-fluid .p-chips {
        display: flex;
    }
    
    .p-chips-icon-left,
    .p-chips-icon-right {
        position: relative;
        display: inline-block;
    }
    
    .p-chips-icon-left > i,
    .p-chips-icon-right > i,
    .p-chips-icon-left > svg,
    .p-chips-icon-right > svg,
    .p-chips-icon-left > .p-chips-prefix,
    .p-chips-icon-right > .p-chips-suffix {
        position: absolute;
        top: 50%;
        margin-top: -0.5rem;
    }
    
    .p-fluid .p-chips-icon-left,
    .p-fluid .p-chips-icon-right {
        display: block;
        width: 100%;
    }
}
`, Uoe = { removeTokenIcon: "p-chips-token-icon", label: "p-chips-token-label", token: function (e) { var n = e.focusedIndex, r = e.index; return ta("p-chips-token", { "p-focus": n === r }) }, inputToken: "p-chips-input-token", container: function (e) { var n = e.props, r = e.context; return ta("p-inputtext p-chips-multiple-container", { "p-variant-filled": n.variant ? n.variant === "filled" : r && r.inputStyle === "filled" }) }, root: function (e) { var n = e.isFilled, r = e.focusedState, i = e.disabled, s = e.invalid; return ta("p-chips p-component p-inputwrapper", { "p-inputwrapper-filled": n, "p-inputwrapper-focus": r, "p-disabled": i, "p-invalid": s, "p-focus": r }) } }, hm = nr.extend({ defaultProps: { __TYPE: "Chips", addOnBlur: null, allowDuplicate: !0, ariaLabelledBy: null, autoFocus: !1, className: null, disabled: null, id: null, inputId: null, inputRef: null, invalid: !1, variant: null, itemTemplate: null, keyfilter: null, max: null, name: null, onAdd: null, onBlur: null, onChange: null, onFocus: null, onKeyDown: null, onRemove: null, placeholder: null, readOnly: !1, removable: !0, removeIcon: null, separator: null, style: null, tooltip: null, tooltipOptions: null, value: null, children: void 0 }, css: { classes: Uoe, styles: $oe } }); function j3(t, e) { var n = Object.keys(t); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(t); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(t, i).enumerable })), n.push.apply(n, r) } return n } function E3(t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e] != null ? arguments[e] : {}; e % 2 ? j3(Object(n), !0).forEach(function (r) { _oe(t, r, n[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : j3(Object(n)).forEach(function (r) { Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r)) }) } return t } var hw = N.memo(N.forwardRef(function (t, e) {
    var n = E6(), r = N.useContext(Pu), i = hm.getProps(t, r), s = N.useState(!1), a = N3(s, 2), l = a[0], u = a[1], f = N.useState(null), p = N3(f, 2), g = p[0], y = p[1], v = hm.setMetaData({ props: i, state: { focused: l } }), b = v.ptm, S = v.cx, C = v.isUnstyled; O6(hm.css.styles, C, { name: "chips" }); var T = N.useRef(null), A = N.useRef(null), M = N.useRef(i.inputRef), O = function ($, U) { if (!(i.disabled || i.readOnly)) { var be = fm(i.value), Ie = be.splice(U, 1)[0]; oe(Ie, U) && (i.onRemove && i.onRemove({ originalEvent: $, value: Ie }), i.onChange && i.onChange({ originalEvent: $, value: be, stopPropagation: function () { $?.stopPropagation() }, preventDefault: function () { $?.preventDefault() }, target: { name: i.name, id: i.id, value: be } })) } }, E = function ($, U, be) { if (U && U.trim().length) { var Ie = i.value ? fm(i.value) : []; if (i.allowDuplicate || Ie.indexOf(U) === -1) { var it = !0; i.onAdd && (it = i.onAdd({ originalEvent: $, value: U })), it !== !1 && Ie.push(U) } ne($, Ie, be) } }, k = function () { nn.focus(M.current) }, z = function ($) { switch ($.code) { case "ArrowLeft": V(); break; case "ArrowRight": q(); break; case "Backspace": ue($); break } }, V = function () { var $ = g; M.current.value.length === 0 && i.value && i.value.length > 0 && ($ = $ === null ? i.value.length - 1 : $ - 1, $ < 0 && ($ = 0)), y($) }, q = function () { var $ = g; M.current.value.length === 0 && i.value && i.value.length > 0 && ($ === i.value.length - 1 ? ($ = null, M.current.focus()) : $++), y($) }, ue = function ($) { g !== null && O($, g) }, W = function ($) { var U = $.target.value, be = i.value || []; if (i.onKeyDown && i.onKeyDown($), !$.defaultPrevented) switch ($.key) { case "Backspace": U.length === 0 && be.length > 0 && O($, be.length - 1); break; case "Enter": U && U.trim().length && (!i.max || i.max > be.length) && E($, U, !0); break; case "ArrowLeft": U.length === 0 && be && be.length > 0 && nn.focus(A.current); break; case "ArrowRight": $.stopPropagation(); break; default: i.keyfilter && Zg.onKeyPress($, i.keyfilter), He() && $.preventDefault(); break } }, ne = function ($, U, be) { i.onChange && i.onChange({ originalEvent: $, value: U, stopPropagation: function () { $?.stopPropagation() }, preventDefault: function () { $?.preventDefault() }, target: { name: i.name, id: i.id, value: U } }), M.current.value = "", be && $.preventDefault() }, H = function ($) { var U, be = (U = $.target.value) === null || U === void 0 ? void 0 : U.trim(); if (be === i.separator) { M.current.value = ""; return } if (i.separator && be.endsWith(i.separator)) { var Ie = be.slice(0, -1); E($, Ie) } }, we = function ($) {
      if (i.separator) {
        var U = i.separator.replace("\\n", `
`).replace("\\r", "\r").replace("\\t", "	"), be = ($.clipboardData || window.clipboardData).getData("Text"); if (i.keyfilter && Zg.onPaste($, i.keyfilter), be) { var Ie = i.value || [], it = be.split(U); it = it.filter(function (P) { return (i.allowDuplicate || Ie.indexOf(P) === -1) && P.trim().length }), Ie = [].concat(fm(Ie), fm(it)), ne($, Ie, !0) }
      }
    }, xe = function () { u(!0) }, K = function () { y(-1), u(!1) }, te = function ($) { u(!0), y(null), i.onFocus && i.onFocus($) }, ye = function ($) { if (i.addOnBlur) { var U = $.target.value, be = i.value || []; U && U.trim().length && (!i.max || i.max > be.length) && E($, U, !0) } u(!1), i.onBlur && i.onBlur($) }, He = function () { return i.max && i.value && i.max === i.value.length }, B = M.current && M.current.value, ie = N.useMemo(function () { return Kt.isNotEmpty(i.value) || Kt.isNotEmpty(B) }, [i.value, B]), oe = function ($, U) { return Kt.getPropValue(i.removable, { value: $, index: U, props: i }) }; N.useImperativeHandle(e, function () { return { props: i, focus: function () { return nn.focus(M.current) }, getElement: function () { return T.current }, getInput: function () { return M.current } } }), N.useEffect(function () { Kt.combinedRefs(M, i.inputRef) }, [M, i.inputRef]), qy(function () { i.autoFocus && nn.focus(M.current, i.autoFocus) }); var pe = function () { return g !== null ? "".concat(i.inputId, "_chips_item_").concat(g) : null }, Ee = function ($, U) { if (!i.disabled && !i.readOnly && oe($, U)) { var be = n({ className: S("removeTokenIcon"), onClick: function (ee) { return O(ee, U) }, "aria-hidden": "true" }, b("removeTokenIcon")), Ie = i.removeIcon || N.createElement(M6, Co({}, be, { key: "".concat(U, "_icon") })), it = Mae.getJSXIcon(Ie, E3({}, be), { props: i }); return it } return null }, fe = function ($, U) { var be = i.itemTemplate ? i.itemTemplate($) : $, Ie = n({ className: S("label") }, b("label")), it = N.createElement("span", Co({}, Ie, { key: "".concat(U, "_").concat($, "_span") }), be), P = Ee($, U), ee = n({ id: i.inputId + "_chips_item_" + U, role: "option", "aria-label": $, className: S("token", { focusedIndex: g, index: U }), "aria-selected": !0, "aria-setsize": i.value.length, "aria-posinset": U + 1, "data-p-highlight": !0, "data-p-focused": g === U }, b("token")); return N.createElement("li", Co({}, ee, { key: "".concat(U, "_").concat($) }), it, P) }, Oe = function () { var $ = n({ className: S("inputToken") }, b("inputToken")), U = n(E3({ id: i.inputId, ref: M, placeholder: i.placeholder, type: "text", enterKeyHint: "enter", name: i.name, disabled: i.disabled || He(), onKeyDown: function (Ie) { return W(Ie) }, onChange: function (Ie) { return H(Ie) }, onPaste: function (Ie) { return we(Ie) }, onFocus: function (Ie) { return te(Ie) }, onBlur: function (Ie) { return ye(Ie) }, readOnly: i.readOnly }, Be), b("input")); return N.createElement("li", Co({}, $, { key: i.inputId + "_chips_input" }), N.createElement("input", U)) }, et = function () { return i.value ? i.value.map(fe) : null }, Xe = function () { var $ = et(), U = Oe(), be = n({ ref: A, className: S("container", { context: r }), onClick: function (it) { return k() }, onKeyDown: function (it) { return z(it) }, tabIndex: -1, role: "listbox", "aria-orientation": "horizontal", "aria-labelledby": i.ariaLabelledby, "aria-label": i.ariaLabel, "aria-activedescendant": l ? pe() : void 0, "data-p-disabled": i.disabled, "data-p-focus": l, onFocus: xe, onBlur: K }, b("container")); return N.createElement("ul", be, $, U) }, De = Kt.isNotEmpty(i.tooltip), he = hm.getOtherProps(i), Be = Kt.reduceKeys(he, nn.ARIA_PROPS), Y = Xe(), Je = n({ id: i.id, ref: T, className: ta(i.className, S("root", { isFilled: ie, focusedState: l, disabled: i.disabled, invalid: i.invalid })), style: i.style }, b("root")); return N.createElement(N.Fragment, null, N.createElement("div", Co({}, Je, { key: "chips" }), Y), De && N.createElement(L6, Co({ target: M, content: i.tooltip, pt: b("tooltip") }, i.tooltipOptions)))
  })); hw.displayName = "Chips"; function pm(t) { throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.') } var hb = { exports: {} };/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/var A3; function Voe() { return A3 || (A3 = 1, function (t, e) { (function (n) { t.exports = n() })(function () { return function n(r, i, s) { function a(f, p) { if (!i[f]) { if (!r[f]) { var g = typeof pm == "function" && pm; if (!p && g) return g(f, !0); if (l) return l(f, !0); var y = new Error("Cannot find module '" + f + "'"); throw y.code = "MODULE_NOT_FOUND", y } var v = i[f] = { exports: {} }; r[f][0].call(v.exports, function (b) { var S = r[f][1][b]; return a(S || b) }, v, v.exports, n, r, i, s) } return i[f].exports } for (var l = typeof pm == "function" && pm, u = 0; u < s.length; u++)a(s[u]); return a }({ 1: [function (n, r, i) { (function (s) { var a = s.MutationObserver || s.WebKitMutationObserver, l; if (a) { var u = 0, f = new a(b), p = s.document.createTextNode(""); f.observe(p, { characterData: !0 }), l = function () { p.data = u = ++u % 2 } } else if (!s.setImmediate && typeof s.MessageChannel < "u") { var g = new s.MessageChannel; g.port1.onmessage = b, l = function () { g.port2.postMessage(0) } } else "document" in s && "onreadystatechange" in s.document.createElement("script") ? l = function () { var C = s.document.createElement("script"); C.onreadystatechange = function () { b(), C.onreadystatechange = null, C.parentNode.removeChild(C), C = null }, s.document.documentElement.appendChild(C) } : l = function () { setTimeout(b, 0) }; var y, v = []; function b() { y = !0; for (var C, T, A = v.length; A;) { for (T = v, v = [], C = -1; ++C < A;)T[C](); A = v.length } y = !1 } r.exports = S; function S(C) { v.push(C) === 1 && !y && l() } }).call(this, typeof _p < "u" ? _p : typeof self < "u" ? self : typeof window < "u" ? window : {}) }, {}], 2: [function (n, r, i) { var s = n(1); function a() { } var l = {}, u = ["REJECTED"], f = ["FULFILLED"], p = ["PENDING"]; r.exports = g; function g(E) { if (typeof E != "function") throw new TypeError("resolver must be a function"); this.state = p, this.queue = [], this.outcome = void 0, E !== a && S(this, E) } g.prototype.catch = function (E) { return this.then(null, E) }, g.prototype.then = function (E, k) { if (typeof E != "function" && this.state === f || typeof k != "function" && this.state === u) return this; var z = new this.constructor(a); if (this.state !== p) { var V = this.state === f ? E : k; v(z, V, this.outcome) } else this.queue.push(new y(z, E, k)); return z }; function y(E, k, z) { this.promise = E, typeof k == "function" && (this.onFulfilled = k, this.callFulfilled = this.otherCallFulfilled), typeof z == "function" && (this.onRejected = z, this.callRejected = this.otherCallRejected) } y.prototype.callFulfilled = function (E) { l.resolve(this.promise, E) }, y.prototype.otherCallFulfilled = function (E) { v(this.promise, this.onFulfilled, E) }, y.prototype.callRejected = function (E) { l.reject(this.promise, E) }, y.prototype.otherCallRejected = function (E) { v(this.promise, this.onRejected, E) }; function v(E, k, z) { s(function () { var V; try { V = k(z) } catch (q) { return l.reject(E, q) } V === E ? l.reject(E, new TypeError("Cannot resolve promise with itself")) : l.resolve(E, V) }) } l.resolve = function (E, k) { var z = C(b, k); if (z.status === "error") return l.reject(E, z.value); var V = z.value; if (V) S(E, V); else { E.state = f, E.outcome = k; for (var q = -1, ue = E.queue.length; ++q < ue;)E.queue[q].callFulfilled(k) } return E }, l.reject = function (E, k) { E.state = u, E.outcome = k; for (var z = -1, V = E.queue.length; ++z < V;)E.queue[z].callRejected(k); return E }; function b(E) { var k = E && E.then; if (E && (typeof E == "object" || typeof E == "function") && typeof k == "function") return function () { k.apply(E, arguments) } } function S(E, k) { var z = !1; function V(ne) { z || (z = !0, l.reject(E, ne)) } function q(ne) { z || (z = !0, l.resolve(E, ne)) } function ue() { k(q, V) } var W = C(ue); W.status === "error" && V(W.value) } function C(E, k) { var z = {}; try { z.value = E(k), z.status = "success" } catch (V) { z.status = "error", z.value = V } return z } g.resolve = T; function T(E) { return E instanceof this ? E : l.resolve(new this(a), E) } g.reject = A; function A(E) { var k = new this(a); return l.reject(k, E) } g.all = M; function M(E) { var k = this; if (Object.prototype.toString.call(E) !== "[object Array]") return this.reject(new TypeError("must be an array")); var z = E.length, V = !1; if (!z) return this.resolve([]); for (var q = new Array(z), ue = 0, W = -1, ne = new this(a); ++W < z;)H(E[W], W); return ne; function H(we, xe) { k.resolve(we).then(K, function (te) { V || (V = !0, l.reject(ne, te)) }); function K(te) { q[xe] = te, ++ue === z && !V && (V = !0, l.resolve(ne, q)) } } } g.race = O; function O(E) { var k = this; if (Object.prototype.toString.call(E) !== "[object Array]") return this.reject(new TypeError("must be an array")); var z = E.length, V = !1; if (!z) return this.resolve([]); for (var q = -1, ue = new this(a); ++q < z;)W(E[q]); return ue; function W(ne) { k.resolve(ne).then(function (H) { V || (V = !0, l.resolve(ue, H)) }, function (H) { V || (V = !0, l.reject(ue, H)) }) } } }, { 1: 1 }], 3: [function (n, r, i) { (function (s) { typeof s.Promise != "function" && (s.Promise = n(2)) }).call(this, typeof _p < "u" ? _p : typeof self < "u" ? self : typeof window < "u" ? window : {}) }, { 2: 2 }], 4: [function (n, r, i) { var s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (L) { return typeof L } : function (L) { return L && typeof Symbol == "function" && L.constructor === Symbol && L !== Symbol.prototype ? "symbol" : typeof L }; function a(L, Q) { if (!(L instanceof Q)) throw new TypeError("Cannot call a class as a function") } function l() { try { if (typeof indexedDB < "u") return indexedDB; if (typeof webkitIndexedDB < "u") return webkitIndexedDB; if (typeof mozIndexedDB < "u") return mozIndexedDB; if (typeof OIndexedDB < "u") return OIndexedDB; if (typeof msIndexedDB < "u") return msIndexedDB } catch { return } } var u = l(); function f() { try { if (!u || !u.open) return !1; var L = typeof openDatabase < "u" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), Q = typeof fetch == "function" && fetch.toString().indexOf("[native code") !== -1; return (!L || Q) && typeof indexedDB < "u" && typeof IDBKeyRange < "u" } catch { return !1 } } function p(L, Q) { L = L || [], Q = Q || {}; try { return new Blob(L, Q) } catch (X) { if (X.name !== "TypeError") throw X; for (var j = typeof BlobBuilder < "u" ? BlobBuilder : typeof MSBlobBuilder < "u" ? MSBlobBuilder : typeof MozBlobBuilder < "u" ? MozBlobBuilder : WebKitBlobBuilder, F = new j, J = 0; J < L.length; J += 1)F.append(L[J]); return F.getBlob(Q.type) } } typeof Promise > "u" && n(3); var g = Promise; function y(L, Q) { Q && L.then(function (j) { Q(null, j) }, function (j) { Q(j) }) } function v(L, Q, j) { typeof Q == "function" && L.then(Q), typeof j == "function" && L.catch(j) } function b(L) { return typeof L != "string" && (console.warn(L + " used as a key, but it is not a string."), L = String(L)), L } function S() { if (arguments.length && typeof arguments[arguments.length - 1] == "function") return arguments[arguments.length - 1] } var C = "local-forage-detect-blob-support", T = void 0, A = {}, M = Object.prototype.toString, O = "readonly", E = "readwrite"; function k(L) { for (var Q = L.length, j = new ArrayBuffer(Q), F = new Uint8Array(j), J = 0; J < Q; J++)F[J] = L.charCodeAt(J); return j } function z(L) { return new g(function (Q) { var j = L.transaction(C, E), F = p([""]); j.objectStore(C).put(F, "key"), j.onabort = function (J) { J.preventDefault(), J.stopPropagation(), Q(!1) }, j.oncomplete = function () { var J = navigator.userAgent.match(/Chrome\/(\d+)/), X = navigator.userAgent.match(/Edge\//); Q(X || !J || parseInt(J[1], 10) >= 43) } }).catch(function () { return !1 }) } function V(L) { return typeof T == "boolean" ? g.resolve(T) : z(L).then(function (Q) { return T = Q, T }) } function q(L) { var Q = A[L.name], j = {}; j.promise = new g(function (F, J) { j.resolve = F, j.reject = J }), Q.deferredOperations.push(j), Q.dbReady ? Q.dbReady = Q.dbReady.then(function () { return j.promise }) : Q.dbReady = j.promise } function ue(L) { var Q = A[L.name], j = Q.deferredOperations.pop(); if (j) return j.resolve(), j.promise } function W(L, Q) { var j = A[L.name], F = j.deferredOperations.pop(); if (F) return F.reject(Q), F.promise } function ne(L, Q) { return new g(function (j, F) { if (A[L.name] = A[L.name] || oe(), L.db) if (Q) q(L), L.db.close(); else return j(L.db); var J = [L.name]; Q && J.push(L.version); var X = u.open.apply(u, J); Q && (X.onupgradeneeded = function (Me) { var Pe = X.result; try { Pe.createObjectStore(L.storeName), Me.oldVersion <= 1 && Pe.createObjectStore(C) } catch (Re) { if (Re.name === "ConstraintError") console.warn('The database "' + L.name + '" has been upgraded from version ' + Me.oldVersion + " to version " + Me.newVersion + ', but the storage "' + L.storeName + '" already exists.'); else throw Re } }), X.onerror = function (Me) { Me.preventDefault(), F(X.error) }, X.onsuccess = function () { var Me = X.result; Me.onversionchange = function (Pe) { Pe.target.close() }, j(Me), ue(L) } }) } function H(L) { return ne(L, !1) } function we(L) { return ne(L, !0) } function xe(L, Q) { if (!L.db) return !0; var j = !L.db.objectStoreNames.contains(L.storeName), F = L.version < L.db.version, J = L.version > L.db.version; if (F && (L.version !== Q && console.warn('The database "' + L.name + `" can't be downgraded from version ` + L.db.version + " to version " + L.version + "."), L.version = L.db.version), J || j) { if (j) { var X = L.db.version + 1; X > L.version && (L.version = X) } return !0 } return !1 } function K(L) { return new g(function (Q, j) { var F = new FileReader; F.onerror = j, F.onloadend = function (J) { var X = btoa(J.target.result || ""); Q({ __local_forage_encoded_blob: !0, data: X, type: L.type }) }, F.readAsBinaryString(L) }) } function te(L) { var Q = k(atob(L.data)); return p([Q], { type: L.type }) } function ye(L) { return L && L.__local_forage_encoded_blob } function He(L) { var Q = this, j = Q._initReady().then(function () { var F = A[Q._dbInfo.name]; if (F && F.dbReady) return F.dbReady }); return v(j, L, L), j } function B(L) { q(L); for (var Q = A[L.name], j = Q.forages, F = 0; F < j.length; F++) { var J = j[F]; J._dbInfo.db && (J._dbInfo.db.close(), J._dbInfo.db = null) } return L.db = null, H(L).then(function (X) { return L.db = X, xe(L) ? we(L) : X }).then(function (X) { L.db = Q.db = X; for (var Me = 0; Me < j.length; Me++)j[Me]._dbInfo.db = X }).catch(function (X) { throw W(L, X), X }) } function ie(L, Q, j, F) { F === void 0 && (F = 1); try { var J = L.db.transaction(L.storeName, Q); j(null, J) } catch (X) { if (F > 0 && (!L.db || X.name === "InvalidStateError" || X.name === "NotFoundError")) return g.resolve().then(function () { if (!L.db || X.name === "NotFoundError" && !L.db.objectStoreNames.contains(L.storeName) && L.version <= L.db.version) return L.db && (L.version = L.db.version + 1), we(L) }).then(function () { return B(L).then(function () { ie(L, Q, j, F - 1) }) }).catch(j); j(X) } } function oe() { return { forages: [], db: null, dbReady: null, deferredOperations: [] } } function pe(L) { var Q = this, j = { db: null }; if (L) for (var F in L) j[F] = L[F]; var J = A[j.name]; J || (J = oe(), A[j.name] = J), J.forages.push(Q), Q._initReady || (Q._initReady = Q.ready, Q.ready = He); var X = []; function Me() { return g.resolve() } for (var Pe = 0; Pe < J.forages.length; Pe++) { var Re = J.forages[Pe]; Re !== Q && X.push(Re._initReady().catch(Me)) } var Ke = J.forages.slice(0); return g.all(X).then(function () { return j.db = J.db, H(j) }).then(function (Ge) { return j.db = Ge, xe(j, Q._defaultConfig.version) ? we(j) : Ge }).then(function (Ge) { j.db = J.db = Ge, Q._dbInfo = j; for (var ft = 0; ft < Ke.length; ft++) { var Lt = Ke[ft]; Lt !== Q && (Lt._dbInfo.db = j.db, Lt._dbInfo.version = j.version) } }) } function Ee(L, Q) { var j = this; L = b(L); var F = new g(function (J, X) { j.ready().then(function () { ie(j._dbInfo, O, function (Me, Pe) { if (Me) return X(Me); try { var Re = Pe.objectStore(j._dbInfo.storeName), Ke = Re.get(L); Ke.onsuccess = function () { var Ge = Ke.result; Ge === void 0 && (Ge = null), ye(Ge) && (Ge = te(Ge)), J(Ge) }, Ke.onerror = function () { X(Ke.error) } } catch (Ge) { X(Ge) } }) }).catch(X) }); return y(F, Q), F } function fe(L, Q) { var j = this, F = new g(function (J, X) { j.ready().then(function () { ie(j._dbInfo, O, function (Me, Pe) { if (Me) return X(Me); try { var Re = Pe.objectStore(j._dbInfo.storeName), Ke = Re.openCursor(), Ge = 1; Ke.onsuccess = function () { var ft = Ke.result; if (ft) { var Lt = ft.value; ye(Lt) && (Lt = te(Lt)); var sn = L(Lt, ft.key, Ge++); sn !== void 0 ? J(sn) : ft.continue() } else J() }, Ke.onerror = function () { X(Ke.error) } } catch (ft) { X(ft) } }) }).catch(X) }); return y(F, Q), F } function Oe(L, Q, j) { var F = this; L = b(L); var J = new g(function (X, Me) { var Pe; F.ready().then(function () { return Pe = F._dbInfo, M.call(Q) === "[object Blob]" ? V(Pe.db).then(function (Re) { return Re ? Q : K(Q) }) : Q }).then(function (Re) { ie(F._dbInfo, E, function (Ke, Ge) { if (Ke) return Me(Ke); try { var ft = Ge.objectStore(F._dbInfo.storeName); Re === null && (Re = void 0); var Lt = ft.put(Re, L); Ge.oncomplete = function () { Re === void 0 && (Re = null), X(Re) }, Ge.onabort = Ge.onerror = function () { var sn = Lt.error ? Lt.error : Lt.transaction.error; Me(sn) } } catch (sn) { Me(sn) } }) }).catch(Me) }); return y(J, j), J } function et(L, Q) { var j = this; L = b(L); var F = new g(function (J, X) { j.ready().then(function () { ie(j._dbInfo, E, function (Me, Pe) { if (Me) return X(Me); try { var Re = Pe.objectStore(j._dbInfo.storeName), Ke = Re.delete(L); Pe.oncomplete = function () { J() }, Pe.onerror = function () { X(Ke.error) }, Pe.onabort = function () { var Ge = Ke.error ? Ke.error : Ke.transaction.error; X(Ge) } } catch (Ge) { X(Ge) } }) }).catch(X) }); return y(F, Q), F } function Xe(L) { var Q = this, j = new g(function (F, J) { Q.ready().then(function () { ie(Q._dbInfo, E, function (X, Me) { if (X) return J(X); try { var Pe = Me.objectStore(Q._dbInfo.storeName), Re = Pe.clear(); Me.oncomplete = function () { F() }, Me.onabort = Me.onerror = function () { var Ke = Re.error ? Re.error : Re.transaction.error; J(Ke) } } catch (Ke) { J(Ke) } }) }).catch(J) }); return y(j, L), j } function De(L) { var Q = this, j = new g(function (F, J) { Q.ready().then(function () { ie(Q._dbInfo, O, function (X, Me) { if (X) return J(X); try { var Pe = Me.objectStore(Q._dbInfo.storeName), Re = Pe.count(); Re.onsuccess = function () { F(Re.result) }, Re.onerror = function () { J(Re.error) } } catch (Ke) { J(Ke) } }) }).catch(J) }); return y(j, L), j } function he(L, Q) { var j = this, F = new g(function (J, X) { if (L < 0) { J(null); return } j.ready().then(function () { ie(j._dbInfo, O, function (Me, Pe) { if (Me) return X(Me); try { var Re = Pe.objectStore(j._dbInfo.storeName), Ke = !1, Ge = Re.openKeyCursor(); Ge.onsuccess = function () { var ft = Ge.result; if (!ft) { J(null); return } L === 0 || Ke ? J(ft.key) : (Ke = !0, ft.advance(L)) }, Ge.onerror = function () { X(Ge.error) } } catch (ft) { X(ft) } }) }).catch(X) }); return y(F, Q), F } function Be(L) { var Q = this, j = new g(function (F, J) { Q.ready().then(function () { ie(Q._dbInfo, O, function (X, Me) { if (X) return J(X); try { var Pe = Me.objectStore(Q._dbInfo.storeName), Re = Pe.openKeyCursor(), Ke = []; Re.onsuccess = function () { var Ge = Re.result; if (!Ge) { F(Ke); return } Ke.push(Ge.key), Ge.continue() }, Re.onerror = function () { J(Re.error) } } catch (Ge) { J(Ge) } }) }).catch(J) }); return y(j, L), j } function Y(L, Q) { Q = S.apply(this, arguments); var j = this.config(); L = typeof L != "function" && L || {}, L.name || (L.name = L.name || j.name, L.storeName = L.storeName || j.storeName); var F = this, J; if (!L.name) J = g.reject("Invalid arguments"); else { var X = L.name === j.name && F._dbInfo.db, Me = X ? g.resolve(F._dbInfo.db) : H(L).then(function (Pe) { var Re = A[L.name], Ke = Re.forages; Re.db = Pe; for (var Ge = 0; Ge < Ke.length; Ge++)Ke[Ge]._dbInfo.db = Pe; return Pe }); L.storeName ? J = Me.then(function (Pe) { if (Pe.objectStoreNames.contains(L.storeName)) { var Re = Pe.version + 1; q(L); var Ke = A[L.name], Ge = Ke.forages; Pe.close(); for (var ft = 0; ft < Ge.length; ft++) { var Lt = Ge[ft]; Lt._dbInfo.db = null, Lt._dbInfo.version = Re } var sn = new g(function (an, wn) { var zn = u.open(L.name, Re); zn.onerror = function (ei) { var Ka = zn.result; Ka.close(), wn(ei) }, zn.onupgradeneeded = function () { var ei = zn.result; ei.deleteObjectStore(L.storeName) }, zn.onsuccess = function () { var ei = zn.result; ei.close(), an(ei) } }); return sn.then(function (an) { Ke.db = an; for (var wn = 0; wn < Ge.length; wn++) { var zn = Ge[wn]; zn._dbInfo.db = an, ue(zn._dbInfo) } }).catch(function (an) { throw (W(L, an) || g.resolve()).catch(function () { }), an }) } }) : J = Me.then(function (Pe) { q(L); var Re = A[L.name], Ke = Re.forages; Pe.close(); for (var Ge = 0; Ge < Ke.length; Ge++) { var ft = Ke[Ge]; ft._dbInfo.db = null } var Lt = new g(function (sn, an) { var wn = u.deleteDatabase(L.name); wn.onerror = function () { var zn = wn.result; zn && zn.close(), an(wn.error) }, wn.onblocked = function () { console.warn('dropInstance blocked for database "' + L.name + '" until all open connections are closed') }, wn.onsuccess = function () { var zn = wn.result; zn && zn.close(), sn(zn) } }); return Lt.then(function (sn) { Re.db = sn; for (var an = 0; an < Ke.length; an++) { var wn = Ke[an]; ue(wn._dbInfo) } }).catch(function (sn) { throw (W(L, sn) || g.resolve()).catch(function () { }), sn }) }) } return y(J, Q), J } var Je = { _driver: "asyncStorage", _initStorage: pe, _support: f(), iterate: fe, getItem: Ee, setItem: Oe, removeItem: et, clear: Xe, length: De, key: he, keys: Be, dropInstance: Y }; function $e() { return typeof openDatabase == "function" } var $ = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", U = "~~local_forage_type~", be = /^~~local_forage_type~([^~]+)~/, Ie = "__lfsc__:", it = Ie.length, P = "arbf", ee = "blob", _ = "si08", I = "ui08", se = "uic8", ae = "si16", Ae = "si32", qe = "ur16", rt = "ui32", Tt = "fl32", yn = "fl64", Gt = it + P.length, $n = Object.prototype.toString; function cn(L) { var Q = L.length * .75, j = L.length, F, J = 0, X, Me, Pe, Re; L[L.length - 1] === "=" && (Q--, L[L.length - 2] === "=" && Q--); var Ke = new ArrayBuffer(Q), Ge = new Uint8Array(Ke); for (F = 0; F < j; F += 4)X = $.indexOf(L[F]), Me = $.indexOf(L[F + 1]), Pe = $.indexOf(L[F + 2]), Re = $.indexOf(L[F + 3]), Ge[J++] = X << 2 | Me >> 4, Ge[J++] = (Me & 15) << 4 | Pe >> 2, Ge[J++] = (Pe & 3) << 6 | Re & 63; return Ke } function je(L) { var Q = new Uint8Array(L), j = "", F; for (F = 0; F < Q.length; F += 3)j += $[Q[F] >> 2], j += $[(Q[F] & 3) << 4 | Q[F + 1] >> 4], j += $[(Q[F + 1] & 15) << 2 | Q[F + 2] >> 6], j += $[Q[F + 2] & 63]; return Q.length % 3 === 2 ? j = j.substring(0, j.length - 1) + "=" : Q.length % 3 === 1 && (j = j.substring(0, j.length - 2) + "=="), j } function tt(L, Q) { var j = ""; if (L && (j = $n.call(L)), L && (j === "[object ArrayBuffer]" || L.buffer && $n.call(L.buffer) === "[object ArrayBuffer]")) { var F, J = Ie; L instanceof ArrayBuffer ? (F = L, J += P) : (F = L.buffer, j === "[object Int8Array]" ? J += _ : j === "[object Uint8Array]" ? J += I : j === "[object Uint8ClampedArray]" ? J += se : j === "[object Int16Array]" ? J += ae : j === "[object Uint16Array]" ? J += qe : j === "[object Int32Array]" ? J += Ae : j === "[object Uint32Array]" ? J += rt : j === "[object Float32Array]" ? J += Tt : j === "[object Float64Array]" ? J += yn : Q(new Error("Failed to get type for BinaryArray"))), Q(J + je(F)) } else if (j === "[object Blob]") { var X = new FileReader; X.onload = function () { var Me = U + L.type + "~" + je(this.result); Q(Ie + ee + Me) }, X.readAsArrayBuffer(L) } else try { Q(JSON.stringify(L)) } catch (Me) { console.error("Couldn't convert value into a JSON string: ", L), Q(null, Me) } } function lt(L) { if (L.substring(0, it) !== Ie) return JSON.parse(L); var Q = L.substring(Gt), j = L.substring(it, Gt), F; if (j === ee && be.test(Q)) { var J = Q.match(be); F = J[1], Q = Q.substring(J[0].length) } var X = cn(Q); switch (j) { case P: return X; case ee: return p([X], { type: F }); case _: return new Int8Array(X); case I: return new Uint8Array(X); case se: return new Uint8ClampedArray(X); case ae: return new Int16Array(X); case qe: return new Uint16Array(X); case Ae: return new Int32Array(X); case rt: return new Uint32Array(X); case Tt: return new Float32Array(X); case yn: return new Float64Array(X); default: throw new Error("Unkown type: " + j) } } var le = { serialize: tt, deserialize: lt, stringToBuffer: cn, bufferToString: je }; function st(L, Q, j, F) { L.executeSql("CREATE TABLE IF NOT EXISTS " + Q.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], j, F) } function wt(L) { var Q = this, j = { db: null }; if (L) for (var F in L) j[F] = typeof L[F] != "string" ? L[F].toString() : L[F]; var J = new g(function (X, Me) { try { j.db = openDatabase(j.name, String(j.version), j.description, j.size) } catch (Pe) { return Me(Pe) } j.db.transaction(function (Pe) { st(Pe, j, function () { Q._dbInfo = j, X() }, function (Re, Ke) { Me(Ke) }) }, Me) }); return j.serializer = le, J } function Qe(L, Q, j, F, J, X) { L.executeSql(j, F, J, function (Me, Pe) { Pe.code === Pe.SYNTAX_ERR ? Me.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [Q.storeName], function (Re, Ke) { Ke.rows.length ? X(Re, Pe) : st(Re, Q, function () { Re.executeSql(j, F, J, X) }, X) }, X) : X(Me, Pe) }, X) } function Te(L, Q) { var j = this; L = b(L); var F = new g(function (J, X) { j.ready().then(function () { var Me = j._dbInfo; Me.db.transaction(function (Pe) { Qe(Pe, Me, "SELECT * FROM " + Me.storeName + " WHERE key = ? LIMIT 1", [L], function (Re, Ke) { var Ge = Ke.rows.length ? Ke.rows.item(0).value : null; Ge && (Ge = Me.serializer.deserialize(Ge)), J(Ge) }, function (Re, Ke) { X(Ke) }) }) }).catch(X) }); return y(F, Q), F } function Ze(L, Q) { var j = this, F = new g(function (J, X) { j.ready().then(function () { var Me = j._dbInfo; Me.db.transaction(function (Pe) { Qe(Pe, Me, "SELECT * FROM " + Me.storeName, [], function (Re, Ke) { for (var Ge = Ke.rows, ft = Ge.length, Lt = 0; Lt < ft; Lt++) { var sn = Ge.item(Lt), an = sn.value; if (an && (an = Me.serializer.deserialize(an)), an = L(an, sn.key, Lt + 1), an !== void 0) { J(an); return } } J() }, function (Re, Ke) { X(Ke) }) }) }).catch(X) }); return y(F, Q), F } function gt(L, Q, j, F) { var J = this; L = b(L); var X = new g(function (Me, Pe) { J.ready().then(function () { Q === void 0 && (Q = null); var Re = Q, Ke = J._dbInfo; Ke.serializer.serialize(Q, function (Ge, ft) { ft ? Pe(ft) : Ke.db.transaction(function (Lt) { Qe(Lt, Ke, "INSERT OR REPLACE INTO " + Ke.storeName + " (key, value) VALUES (?, ?)", [L, Ge], function () { Me(Re) }, function (sn, an) { Pe(an) }) }, function (Lt) { if (Lt.code === Lt.QUOTA_ERR) { if (F > 0) { Me(gt.apply(J, [L, Re, j, F - 1])); return } Pe(Lt) } }) }) }).catch(Pe) }); return y(X, j), X } function vt(L, Q, j) { return gt.apply(this, [L, Q, j, 1]) } function Nt(L, Q) { var j = this; L = b(L); var F = new g(function (J, X) { j.ready().then(function () { var Me = j._dbInfo; Me.db.transaction(function (Pe) { Qe(Pe, Me, "DELETE FROM " + Me.storeName + " WHERE key = ?", [L], function () { J() }, function (Re, Ke) { X(Ke) }) }) }).catch(X) }); return y(F, Q), F } function rn(L) { var Q = this, j = new g(function (F, J) { Q.ready().then(function () { var X = Q._dbInfo; X.db.transaction(function (Me) { Qe(Me, X, "DELETE FROM " + X.storeName, [], function () { F() }, function (Pe, Re) { J(Re) }) }) }).catch(J) }); return y(j, L), j } function Un(L) { var Q = this, j = new g(function (F, J) { Q.ready().then(function () { var X = Q._dbInfo; X.db.transaction(function (Me) { Qe(Me, X, "SELECT COUNT(key) as c FROM " + X.storeName, [], function (Pe, Re) { var Ke = Re.rows.item(0).c; F(Ke) }, function (Pe, Re) { J(Re) }) }) }).catch(J) }); return y(j, L), j } function Z(L, Q) { var j = this, F = new g(function (J, X) { j.ready().then(function () { var Me = j._dbInfo; Me.db.transaction(function (Pe) { Qe(Pe, Me, "SELECT key FROM " + Me.storeName + " WHERE id = ? LIMIT 1", [L + 1], function (Re, Ke) { var Ge = Ke.rows.length ? Ke.rows.item(0).key : null; J(Ge) }, function (Re, Ke) { X(Ke) }) }) }).catch(X) }); return y(F, Q), F } function ce(L) { var Q = this, j = new g(function (F, J) { Q.ready().then(function () { var X = Q._dbInfo; X.db.transaction(function (Me) { Qe(Me, X, "SELECT key FROM " + X.storeName, [], function (Pe, Re) { for (var Ke = [], Ge = 0; Ge < Re.rows.length; Ge++)Ke.push(Re.rows.item(Ge).key); F(Ke) }, function (Pe, Re) { J(Re) }) }) }).catch(J) }); return y(j, L), j } function Se(L) { return new g(function (Q, j) { L.transaction(function (F) { F.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (J, X) { for (var Me = [], Pe = 0; Pe < X.rows.length; Pe++)Me.push(X.rows.item(Pe).name); Q({ db: L, storeNames: Me }) }, function (J, X) { j(X) }) }, function (F) { j(F) }) }) } function Le(L, Q) { Q = S.apply(this, arguments); var j = this.config(); L = typeof L != "function" && L || {}, L.name || (L.name = L.name || j.name, L.storeName = L.storeName || j.storeName); var F = this, J; return L.name ? J = new g(function (X) { var Me; L.name === j.name ? Me = F._dbInfo.db : Me = openDatabase(L.name, "", "", 0), L.storeName ? X({ db: Me, storeNames: [L.storeName] }) : X(Se(Me)) }).then(function (X) { return new g(function (Me, Pe) { X.db.transaction(function (Re) { function Ke(sn) { return new g(function (an, wn) { Re.executeSql("DROP TABLE IF EXISTS " + sn, [], function () { an() }, function (zn, ei) { wn(ei) }) }) } for (var Ge = [], ft = 0, Lt = X.storeNames.length; ft < Lt; ft++)Ge.push(Ke(X.storeNames[ft])); g.all(Ge).then(function () { Me() }).catch(function (sn) { Pe(sn) }) }, function (Re) { Pe(Re) }) }) }) : J = g.reject("Invalid arguments"), y(J, Q), J } var We = { _driver: "webSQLStorage", _initStorage: wt, _support: $e(), iterate: Ze, getItem: Te, setItem: vt, removeItem: Nt, clear: rn, length: Un, key: Z, keys: ce, dropInstance: Le }; function ct() { try { return typeof localStorage < "u" && "setItem" in localStorage && !!localStorage.setItem } catch { return !1 } } function xt(L, Q) { var j = L.name + "/"; return L.storeName !== Q.storeName && (j += L.storeName + "/"), j } function at() { var L = "_localforage_support_test"; try { return localStorage.setItem(L, !0), localStorage.removeItem(L), !1 } catch { return !0 } } function dt() { return !at() || localStorage.length > 0 } function ut(L) { var Q = this, j = {}; if (L) for (var F in L) j[F] = L[F]; return j.keyPrefix = xt(L, Q._defaultConfig), dt() ? (Q._dbInfo = j, j.serializer = le, g.resolve()) : g.reject() } function jt(L) { var Q = this, j = Q.ready().then(function () { for (var F = Q._dbInfo.keyPrefix, J = localStorage.length - 1; J >= 0; J--) { var X = localStorage.key(J); X.indexOf(F) === 0 && localStorage.removeItem(X) } }); return y(j, L), j } function St(L, Q) { var j = this; L = b(L); var F = j.ready().then(function () { var J = j._dbInfo, X = localStorage.getItem(J.keyPrefix + L); return X && (X = J.serializer.deserialize(X)), X }); return y(F, Q), F } function Mt(L, Q) { var j = this, F = j.ready().then(function () { for (var J = j._dbInfo, X = J.keyPrefix, Me = X.length, Pe = localStorage.length, Re = 1, Ke = 0; Ke < Pe; Ke++) { var Ge = localStorage.key(Ke); if (Ge.indexOf(X) === 0) { var ft = localStorage.getItem(Ge); if (ft && (ft = J.serializer.deserialize(ft)), ft = L(ft, Ge.substring(Me), Re++), ft !== void 0) return ft } } }); return y(F, Q), F } function zt(L, Q) { var j = this, F = j.ready().then(function () { var J = j._dbInfo, X; try { X = localStorage.key(L) } catch { X = null } return X && (X = X.substring(J.keyPrefix.length)), X }); return y(F, Q), F } function hn(L) { var Q = this, j = Q.ready().then(function () { for (var F = Q._dbInfo, J = localStorage.length, X = [], Me = 0; Me < J; Me++) { var Pe = localStorage.key(Me); Pe.indexOf(F.keyPrefix) === 0 && X.push(Pe.substring(F.keyPrefix.length)) } return X }); return y(j, L), j } function pn(L) { var Q = this, j = Q.keys().then(function (F) { return F.length }); return y(j, L), j } function Zt(L, Q) { var j = this; L = b(L); var F = j.ready().then(function () { var J = j._dbInfo; localStorage.removeItem(J.keyPrefix + L) }); return y(F, Q), F } function Ht(L, Q, j) { var F = this; L = b(L); var J = F.ready().then(function () { Q === void 0 && (Q = null); var X = Q; return new g(function (Me, Pe) { var Re = F._dbInfo; Re.serializer.serialize(Q, function (Ke, Ge) { if (Ge) Pe(Ge); else try { localStorage.setItem(Re.keyPrefix + L, Ke), Me(X) } catch (ft) { (ft.name === "QuotaExceededError" || ft.name === "NS_ERROR_DOM_QUOTA_REACHED") && Pe(ft), Pe(ft) } }) }) }); return y(J, j), J } function Hi(L, Q) { if (Q = S.apply(this, arguments), L = typeof L != "function" && L || {}, !L.name) { var j = this.config(); L.name = L.name || j.name, L.storeName = L.storeName || j.storeName } var F = this, J; return L.name ? J = new g(function (X) { L.storeName ? X(xt(L, F._defaultConfig)) : X(L.name + "/") }).then(function (X) { for (var Me = localStorage.length - 1; Me >= 0; Me--) { var Pe = localStorage.key(Me); Pe.indexOf(X) === 0 && localStorage.removeItem(Pe) } }) : J = g.reject("Invalid arguments"), y(J, Q), J } var pr = { _driver: "localStorageWrapper", _initStorage: ut, _support: ct(), iterate: Mt, getItem: St, setItem: Ht, removeItem: Zt, clear: jt, length: pn, key: zt, keys: hn, dropInstance: Hi }, $r = function (Q, j) { return Q === j || typeof Q == "number" && typeof j == "number" && isNaN(Q) && isNaN(j) }, Pn = function (Q, j) { for (var F = Q.length, J = 0; J < F;) { if ($r(Q[J], j)) return !0; J++ } return !1 }, Ur = Array.isArray || function (L) { return Object.prototype.toString.call(L) === "[object Array]" }, Mr = {}, Ls = {}, Jn = { INDEXEDDB: Je, WEBSQL: We, LOCALSTORAGE: pr }, Ni = [Jn.INDEXEDDB._driver, Jn.WEBSQL._driver, Jn.LOCALSTORAGE._driver], _t = ["dropInstance"], Vn = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(_t), Jr = { description: "", driver: Ni.slice(), name: "localforage", size: 4980736, storeName: "keyvaluepairs", version: 1 }; function Zr(L, Q) { L[Q] = function () { var j = arguments; return L.ready().then(function () { return L[Q].apply(L, j) }) } } function ji() { for (var L = 1; L < arguments.length; L++) { var Q = arguments[L]; if (Q) for (var j in Q) Q.hasOwnProperty(j) && (Ur(Q[j]) ? arguments[0][j] = Q[j].slice() : arguments[0][j] = Q[j]) } return arguments[0] } var un = function () { function L(Q) { a(this, L); for (var j in Jn) if (Jn.hasOwnProperty(j)) { var F = Jn[j], J = F._driver; this[j] = J, Mr[J] || this.defineDriver(F) } this._defaultConfig = ji({}, Jr), this._config = ji({}, this._defaultConfig, Q), this._driverSet = null, this._initDriver = null, this._ready = !1, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function () { }) } return L.prototype.config = function (j) { if ((typeof j > "u" ? "undefined" : s(j)) === "object") { if (this._ready) return new Error("Can't call config() after localforage has been used."); for (var F in j) { if (F === "storeName" && (j[F] = j[F].replace(/\W/g, "_")), F === "version" && typeof j[F] != "number") return new Error("Database version must be a number."); this._config[F] = j[F] } return "driver" in j && j.driver ? this.setDriver(this._config.driver) : !0 } else return typeof j == "string" ? this._config[j] : this._config }, L.prototype.defineDriver = function (j, F, J) { var X = new g(function (Me, Pe) { try { var Re = j._driver, Ke = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver"); if (!j._driver) { Pe(Ke); return } for (var Ge = Vn.concat("_initStorage"), ft = 0, Lt = Ge.length; ft < Lt; ft++) { var sn = Ge[ft], an = !Pn(_t, sn); if ((an || j[sn]) && typeof j[sn] != "function") { Pe(Ke); return } } var wn = function () { for (var Ka = function (Fu) { return function () { var Bu = new Error("Method " + Fu + " is not implemented by the current driver"), la = g.reject(Bu); return y(la, arguments[arguments.length - 1]), la } }, el = 0, Gy = _t.length; el < Gy; el++) { var zu = _t[el]; j[zu] || (j[zu] = Ka(zu)) } }; wn(); var zn = function (Ka) { Mr[Re] && console.info("Redefining LocalForage driver: " + Re), Mr[Re] = j, Ls[Re] = Ka, Me() }; "_support" in j ? j._support && typeof j._support == "function" ? j._support().then(zn, Pe) : zn(!!j._support) : zn(!0) } catch (ei) { Pe(ei) } }); return v(X, F, J), X }, L.prototype.driver = function () { return this._driver || null }, L.prototype.getDriver = function (j, F, J) { var X = Mr[j] ? g.resolve(Mr[j]) : g.reject(new Error("Driver not found.")); return v(X, F, J), X }, L.prototype.getSerializer = function (j) { var F = g.resolve(le); return v(F, j), F }, L.prototype.ready = function (j) { var F = this, J = F._driverSet.then(function () { return F._ready === null && (F._ready = F._initDriver()), F._ready }); return v(J, j, j), J }, L.prototype.setDriver = function (j, F, J) { var X = this; Ur(j) || (j = [j]); var Me = this._getSupportedDrivers(j); function Pe() { X._config.driver = X.driver() } function Re(ft) { return X._extend(ft), Pe(), X._ready = X._initStorage(X._config), X._ready } function Ke(ft) { return function () { var Lt = 0; function sn() { for (; Lt < ft.length;) { var an = ft[Lt]; return Lt++, X._dbInfo = null, X._ready = null, X.getDriver(an).then(Re).catch(sn) } Pe(); var wn = new Error("No available storage method found."); return X._driverSet = g.reject(wn), X._driverSet } return sn() } } var Ge = this._driverSet !== null ? this._driverSet.catch(function () { return g.resolve() }) : g.resolve(); return this._driverSet = Ge.then(function () { var ft = Me[0]; return X._dbInfo = null, X._ready = null, X.getDriver(ft).then(function (Lt) { X._driver = Lt._driver, Pe(), X._wrapLibraryMethodsWithReady(), X._initDriver = Ke(Me) }) }).catch(function () { Pe(); var ft = new Error("No available storage method found."); return X._driverSet = g.reject(ft), X._driverSet }), v(this._driverSet, F, J), this._driverSet }, L.prototype.supports = function (j) { return !!Ls[j] }, L.prototype._extend = function (j) { ji(this, j) }, L.prototype._getSupportedDrivers = function (j) { for (var F = [], J = 0, X = j.length; J < X; J++) { var Me = j[J]; this.supports(Me) && F.push(Me) } return F }, L.prototype._wrapLibraryMethodsWithReady = function () { for (var j = 0, F = Vn.length; j < F; j++)Zr(this, Vn[j]) }, L.prototype.createInstance = function (j) { return new L(j) }, L }(), qi = new un; r.exports = qi }, { 3: 3 }] }, {}, [4])(4) }) }(hb)), hb.exports } var Hoe = Voe(); const k3 = Ha(Hoe); function qoe({ blogs: t, loading: e, refetch: n }) { const r = ln(); Ou(); const [i, s] = N.useState([]), [a, l] = N.useState(!1), [u, f] = N.useState(!1), [p, g] = N.useState({ global: "", title: "", category: "", status: "", author: "", created_from: "", created_to: "" }), [y, v] = N.useState(1), [b] = N.useState(10), [S, C] = N.useState(null), [T, A] = N.useState(null), [M, O] = N.useState(!1), [E, k] = N.useState(!1), [z, V] = N.useState(!1), [q, ue] = N.useState(null), [W, ne] = N.useState(!1), [H, we] = N.useState([]), [xe, K] = N.useState([]), [te, ye] = N.useState(!1), [He, B] = N.useState(!1), [ie, oe] = N.useState(!1), [pe, Ee] = N.useState(null), [fe, Oe] = N.useState({ question: "", answer: "", order: "" }), [et, Xe] = N.useState(null), [De, he] = N.useState(!1), [Be, Y] = N.useState(null), [Je, $e] = N.useState(null), $ = "blogDrafts", [U, be] = N.useState([]), [Ie, it] = N.useState(null), [P, ee] = N.useState({ title: "", slug: "", category: "guides", is_active: !0, mark_as_hero: !1, content: "", cover_photo: null, tags: [], headings: [] }), [_, I] = N.useState({ id: null, title: "", slug: "", category: "guides", is_active: !0, mark_as_hero: !1, content: "", cover_photo: null, existing_cover_photo: null, tags: [], headings: [] }), { data: se, refetch: ae } = Jt({ queryKey: ["blogFaqs", pe], queryFn: () => pe ? Ve.get(`https://api.nexus.com/api/admin/blogs/${pe}/manage/faq`, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }).then(j => j.data.data) : Promise.resolve([]), enabled: !!pe }), Ae = js({ mutationFn: j => Ve.post(`https://api.nexus.com/api/admin/blogs/${pe}/manage/faq`, j, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), onSuccess: () => { me.success("FAQ added successfully"), ae(), Oe({ question: "", answer: "", order: "" }) }, onError: j => { me.error(j.response?.data?.message || "Failed to add FAQ"), j.response?.status === 401 && (localStorage.removeItem("userToken"), r("/login")), j.response?.status === 403 && me.error("You are not authorized to perform this action") } }), qe = js({ mutationFn: j => Ve.put(`https://api.nexus.com/api/admin/blogs/${pe}/manage/faq/${et}`, j, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), onSuccess: () => { me.success("FAQ updated successfully"), ae(), Xe(null), Oe({ question: "", answer: "", order: "" }) }, onError: j => { me.error(j.response?.data?.message || "Failed to update FAQ"), j.response?.status === 401 && (localStorage.removeItem("userToken"), r("/login")), j.response?.status === 403 && me.error("You are not authorized to perform this action") } }), rt = js({ mutationFn: j => Ve.delete(`https://api.nexus.com/api/admin/blogs/${pe}/manage/faq/${j}`, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), onSuccess: () => { me.success("FAQ deleted successfully"), ae() }, onError: j => { me.error(j.response?.data?.message || "Failed to delete FAQ"), j.response?.status === 401 && (localStorage.removeItem("userToken"), r("/login")), j.response?.status === 403 && me.error("You are not authorized to perform this action") } }), Tt = j => { we(j), ee(F => ({ ...F, headings: j })) }, yn = "blogDrafts_beforeunload_fallback", Gt = async () => { try { const j = await k3.getItem($), F = Array.isArray(j) ? j : []; be(F); const J = localStorage.getItem(yn); if (J) { try { const X = JSON.parse(J); X && typeof X == "object" && cn(X) } catch { } localStorage.removeItem(yn) } } catch { } }, $n = async j => { try { await k3.setItem($, j) } catch (F) { console.error("Persist drafts failed", F), me.error("Could not save drafts locally") } }, cn = async j => { be(F => { const J = F.findIndex(Pe => Pe.id === j.id); let X = [...F]; const Me = new Date().toISOString(); if (J >= 0) X[J] = { ...F[J], ...j, updatedAt: Me }; else { const Pe = j.slug ? F.findIndex(Re => Re.slug === j.slug && Re.slug) : -1; Pe >= 0 ? X[Pe] = { ...F[Pe], ...j, id: F[Pe].id, updatedAt: Me } : X.push({ ...j, updatedAt: Me }) } return X.length > 20 && (X = X.slice().sort((Pe, Re) => new Date(Re.updatedAt) - new Date(Pe.updatedAt)).slice(0, 20)), $n(X), X }) }, je = async j => { be(F => { const J = F.filter(X => X.id !== j); return $n(J), J }), Ie === j && it(null) }, tt = async j => { j && be(F => { const J = F.filter(X => X.slug !== j); return $n(J), J }) }; N.useEffect(() => { Gt() }, []); const lt = () => { if (!(P.title && P.title.trim() !== "" || P.content && P.content.trim() !== "")) return null; let F = Ie; if (!F && P.slug) { const J = U.find(X => X.slug === P.slug); J && (F = J.id) } return { id: F || `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`, title: P.title, slug: P.slug, category: P.category, is_active: P.is_active, mark_as_hero: P.mark_as_hero, content: P.content, cover_photo_meta: P.cover_photo ? { name: P.cover_photo.name, type: P.cover_photo.type, size: P.cover_photo.size } : null, tags: P.tags, headings: P.headings } }, le = () => { const j = lt(); j && (it(j.id), cn(j), me.success("Draft saved locally")) }, st = j => { ee({ title: j.title || "", slug: j.slug || "", category: j.category || "guides", is_active: j.is_active ?? !0, mark_as_hero: j.mark_as_hero ?? !1, content: j.content || "", cover_photo: null, tags: j.tags || [], headings: j.headings || [] }), we(j.headings || []), ye(!0), it(j.id), O(!0), me("Draft loaded") }, wt = N.useRef(null); N.useEffect(() => { if (M) { wt.current = setInterval(() => { const F = lt(); F && (it(J => J || F.id), cn(F)) }, 5e3); const j = () => { const F = lt(); if (F) { cn(F); try { localStorage.setItem(yn, JSON.stringify(F)) } catch { } } }; return window.addEventListener("beforeunload", j), () => { wt.current && clearInterval(wt.current), window.removeEventListener("beforeunload", j) } } else wt.current && clearInterval(wt.current) }, [M, P]); const Qe = j => { K(j), I(F => ({ ...F, headings: j })) }, Te = j => j.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, ""), Ze = (j, F) => { g(J => ({ ...J, [j]: F })), v(1) }, { data: gt, isLoading: vt } = Jt({ queryKey: ["currentUser"], queryFn: () => Ve.get("https://api.nexus.com/api/auth/me", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")} ` } }) }), Nt = async (j, F) => { A(j); try { await Ve.patch(`https://api.nexus.com/api/admin/blogs/${j}/toggle-active`, {}, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success(`Blog ${F ? "deactivated" : "activated"} successfully`, { duration: 2e3 }), n() } catch (J) { me.error(J.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), J.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), J.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } finally { A(null) } }, rn = j => { ue(j), V(!0) }, Un = async () => { if (q) { C(q), V(!1); try { await Ve.delete(`https://api.nexus.com/api/admin/blogs/${q}`, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success("Blog deleted successfully", { duration: 2e3 }), n() } catch (j) { me.error(j.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), j.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), j.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } finally { C(null), ue(null) } } }, Z = j => { const { name: F, value: J, type: X, checked: Me, files: Pe } = j.target; if (ee(X === "file" ? Re => ({ ...Re, [F]: Pe[0] }) : Re => ({ ...Re, [F]: X === "checkbox" ? Me : J })), F === "title" && !te) { const Re = Te(J); ee(Ke => ({ ...Ke, slug: Re })) } }, ce = j => { const { value: F } = j.target; ee(J => ({ ...J, slug: F })), ye(!0) }, Se = () => { const j = Te(P.title); ee(F => ({ ...F, slug: j })), ye(!1) }, Le = j => { const { name: F, value: J, type: X, checked: Me, files: Pe } = j.target; if (I(X === "file" ? Re => ({ ...Re, [F]: Pe[0] }) : Re => ({ ...Re, [F]: X === "checkbox" ? Me : J })), F === "title" && !He) { const Re = Te(J); I(Ke => ({ ...Ke, slug: Re })) } }, We = j => { const { value: F } = j.target; I(J => ({ ...J, slug: F })), B(!0) }, ct = () => { const j = Te(_.title); I(F => ({ ...F, slug: j })), B(!1) }, xt = j => { ee(F => ({ ...F, tags: j.value })) }, at = j => { I(F => ({ ...F, tags: j.value })) }, dt = () => { ee({ title: "", slug: "", category: "guides", is_active: !0, mark_as_hero: !0, content: "", cover_photo: null, tags: [], headings: [] }), we([]), ye(!1) }, ut = j => { I({ id: j.id, title: j.title, slug: j.slug, category: j.category, is_active: j.is_active, mark_as_hero: j.mark_as_hero, content: j.content, cover_photo: null, existing_cover_photo: j.cover_photo, tags: j.tags || [], headings: j.headings || [] }), K(j.headings || []), B(!0), k(!0) }, jt = async j => { j.preventDefault(), ne(!0); try { const F = new FormData; F.append("title", P.title), F.append("slug", P.slug), F.append("category", P.category), F.append("is_active", P.is_active ? 1 : 0), F.append("mark_as_hero", P.mark_as_hero ? 1 : 0), F.append("content", P.content), F.append("headings", JSON.stringify(P.headings)), P.tags.forEach(J => { F.append("tags[]", J) }), P.cover_photo && F.append("cover_photo", P.cover_photo), await Ve.post("https://api.nexus.com/api/admin/blogs", F, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}`, "Content-Type": "multipart/form-data" } }), ne(!1), me.success("Blog added successfully", { duration: 2e3 }), O(!1), dt(), n(), tt(P.slug), it(null) } catch (F) { ne(!1), me.error(F.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), F.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), F.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } }, St = async j => { j.preventDefault(), zt.current && clearInterval(zt.current), ne(!0); try { const F = new FormData; F.append("title", _.title), F.append("slug", _.slug), F.append("category", _.category), F.append("is_active", _.is_active ? 1 : 0), F.append("mark_as_hero", _.mark_as_hero ? 1 : 0), F.append("content", _.content), F.append("headings", JSON.stringify(_.headings)), _.tags.forEach(J => { F.append("tags[]", J) }), F.append("_method", "POST"), _.cover_photo && F.append("cover_photo", _.cover_photo), await Ve.post(`https://api.nexus.com/api/admin/blogs/${_.id}`, F, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}`, "Content-Type": "multipart/form-data" } }), ne(!1), me.success("Blog updated successfully", { duration: 2e3 }), k(!1), n() } catch (F) { ne(!1), me.error(F.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), F.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), F.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } }, Mt = async () => { if (!(W || !_.title || !_.content)) { ne(!0); try { const j = new FormData; j.append("title", _.title), j.append("slug", _.slug), j.append("category", _.category), j.append("is_active", _.is_active ? 1 : 0), j.append("mark_as_hero", _.mark_as_hero ? 1 : 0), j.append("content", _.content), j.append("headings", JSON.stringify(_.headings)), _.tags.forEach(F => { j.append("tags[]", F) }), j.append("_method", "POST"), _.cover_photo && j.append("cover_photo", _.cover_photo), await Ve.post(`https://api.nexus.com/api/admin/blogs/${_.id}`, j, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}`, "Content-Type": "multipart/form-data" } }), me.success("Auto-saved successfully", { duration: 2e3, icon: "" }) } catch (j) { console.error("Auto-save failed:", j) } finally { ne(!1) } } }, zt = N.useRef(null); N.useEffect(() => (E ? zt.current = setInterval(() => { Mt() }, 3e4) : zt.current && clearInterval(zt.current), () => { zt.current && clearInterval(zt.current) }), [E, _]); const hn = j => { Ee(j), oe(!0) }, pn = j => { const { name: F, value: J } = j.target; Oe(X => ({ ...X, [F]: J })) }, Zt = j => { j.preventDefault(), et ? qe.mutate(fe) : Ae.mutate(fe) }, Ht = j => { Xe(j.id), Oe({ question: j.question, answer: j.answer, order: j.order }) }, Hi = () => { Xe(null), Oe({ question: "", answer: "", order: "" }) }, pr = j => { Y(j), he(!0) }, $r = () => { Be && (rt.mutate(Be), he(!1), Y(null)) }, Pn = t?.filter(j => { const F = p.global === "" || j.title.toLowerCase().includes(p.global.toLowerCase()) || j.category.toLowerCase().includes(p.global.toLowerCase()) || (j.author?.name ? j.author.name.toLowerCase().includes(p.global.toLowerCase()) : !1), J = p.title === "" || j.title.toLowerCase().includes(p.title.toLowerCase()), X = p.category === "" || j.category.includes(p.category.toLowerCase()), Me = p.status === "" || (p.status === "active" ? j.is_active : !j.is_active), Pe = p.author === "" || (j.author?.name ? j.author.name.toLowerCase().includes(p.author.toLowerCase()) : !1); let Re = !0; if (j.created_at) { const Ke = new Date(j.created_at); if (p.created_from) { const Ge = new Date(`${p.created_from}T00:00:00`); Ke < Ge && (Re = !1) } if (Re && p.created_to) { const Ge = new Date(`${p.created_to}T23:59:59.999`); Ke > Ge && (Re = !1) } } return F && J && X && Me && Pe && Re }) || [], Ur = Math.ceil(Pn.length / b), Mr = Pn.slice((y - 1) * b, y * b), Ls = j => { const F = { guides: "bg-blue-100 text-blue-800", insights: "bg-purple-100 text-purple-800", trending: "bg-pink-100 text-pink-800" }; return d.jsx("span", { className: `${F[j] || "bg-gray-100 text-gray-800"} text-xs font-medium px-2.5 py-1 rounded capitalize`, children: j }) }, Jn = j => { const F = j ? "bg-[#009379] text-white" : "bg-[#930002] text-white"; return d.jsx("span", { className: `flex justify-center w-fit items-center px-2.5 py-1 rounded-md text-xs font-medium ${F} min-w-16 text-center`, children: j ? "Active" : "Inactive" }) }, Ni = j => { const F = j || 0, J = F > 0 ? "bg-green-100 text-green-800 border-green-200" : "bg-gray-100 text-gray-600 border-gray-200"; return d.jsxs("span", { className: `inline-flex items-center gap-1 px-2.5 py-1 rounded-full text-xs font-medium border ${J}`, children: [d.jsx(fX, { size: 10 }), F] }) }, _t = () => Ur <= 1 ? null : d.jsxs("div", { className: "flex justify-between items-center mt-4 px-4 pb-1", children: [d.jsxs("div", { className: "text-xs", children: ["Showing ", (y - 1) * b + 1, "-", Math.min(y * b, Pn.length), " of ", Pn.length, " entries"] }), d.jsxs("div", { className: "flex gap-1", children: [d.jsx("button", { onClick: () => v(1), disabled: y === 1, className: "p-1 disabled:opacity-50", children: d.jsx(Ds, { className: "h-4 w-4" }) }), d.jsxs("span", { className: "px-3 py-1", children: ["Page ", y, " of ", Ur] }), d.jsx("button", { onClick: () => v(j => Math.min(Ur, j + 1)), disabled: y === Ur, className: "p-1 disabled:opacity-50", children: d.jsx(Rs, { className: "h-4 w-4" }) })] })] }), Vn = ({ blog: j, onClose: F }) => j ? d.jsx("div", { className: "fixed inset-0 z-50 overflow-y-auto", children: d.jsxs("div", { className: "flex items-center justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0", children: [d.jsx("div", { className: "fixed inset-0 transition-opacity", onClick: F, children: d.jsx("div", { className: "absolute inset-0 bg-black opacity-75" }) }), d.jsxs("div", { className: "inline-block align-bottom bg-white rounded-lg text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-5xl m-auto sm:w-full max-h-[90vh] flex flex-col", children: [d.jsxs("div", { className: "bg-white px-4 pt-5 pb-4 sm:p-6 sm:pb-4 flex-grow overflow-y-auto", children: [d.jsxs("div", { className: "sm:flex sm:items-start justify-between", children: [d.jsx("h3", { className: "text-lg leading-6 font-medium text-gray-900 mb-4", children: "Blog Preview" }), d.jsx("button", { onClick: F, className: "text-gray-400 hover:text-gray-500 focus:outline-none", children: d.jsx(xX, { className: "h-6 w-6" }) })] }), d.jsxs("div", { className: "content-container", children: [d.jsxs("div", { className: "flex flex-col lg:flex-row gap-8 mb-12", children: [d.jsxs("div", { className: "lg:w-1/2 font-bold", children: [d.jsx("span", { className: "text-blue-600 capitalize", children: j.category }), d.jsx("h1", { className: "lg:text-[54px] text-3xl font-extrabold lg:leading-[67px]", children: j.title }), d.jsxs("div", { className: "mt-5", children: [d.jsx("p", { children: "By Admin" }), d.jsxs("div", { className: "flex gap-2 items-center text-sm font-medium mt-3", children: [d.jsx("p", { children: "5 minutes read" }), d.jsx("div", { className: "h-full w-[1px] bg-gray-400" }), d.jsxs("p", { children: ["Published ", new Date(j.created_at).toLocaleDateString()] })] })] })] }), d.jsx("div", { className: "lg:w-1/2", children: j.cover_photo && d.jsx("div", { className: "flex justify-center", children: d.jsx("img", { src: j.cover_photo, alt: "cover photo", className: "w-full max-h-[500px] object-contain rounded-lg" }) }) })] }), d.jsx("div", { className: "content", dangerouslySetInnerHTML: { __html: j.content } }), j.tags && j.tags.length > 0 && d.jsx("div", { className: "flex flex-wrap gap-3 mt-8", children: j.tags.map((J, X) => d.jsx("span", { className: "px-3 py-1 bg-gray-100 text-gray-800 text-sm rounded-full", children: J }, X)) })] })] }), d.jsx("div", { className: "bg-gray-50 px-4 py-3 sm:px-6 sm:flex sm:flex-row-reverse", children: d.jsx("button", { type: "button", onClick: F, className: "w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-blue-600 text-base font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 sm:ml-3 sm:w-auto sm:text-sm", children: "Close Preview" }) })] })] }) }) : null, Jr = (j, F) => { s(F ? J => [...J, j] : J => J.filter(X => X !== j)) }, Zr = j => { j ? (s(Pn.map(F => F.id)), l(!0)) : (s([]), l(!1)) }, [ji, un] = N.useState(!1), qi = async () => { i.length && un(!0) }, L = async () => { un(!1); try { f(!0), await Ve.post("https://api.nexus.com/api/admin/blogs/bulk/delete", { ids: i }, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success(`${i.length} blog(s) deleted successfully`), s([]), l(!1), n() } catch (j) { console.error("Error deleting blogs:", j), me.error(j.response?.data?.message || "Failed to delete blogs") } finally { f(!1) } }, Q = async j => { if (i.length) try { f(!0), await Ve.post("https://api.nexus.com/api/admin/blogs/bulk/update-status", { ids: i, status: j }, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success(`Status updated for ${i.length} blog(s)`), s([]), l(!1), n() } catch (F) { console.error("Error updating blog status:", F), me.error(F.response?.data?.message || "Failed to update blog status") } finally { f(!1) } }; return d.jsxs("div", { className: "shadow-2xl rounded-2xl overflow-hidden bg-white", children: [d.jsxs("div", { className: "p-4 border-b flex justify-between items-center gap-4", children: [d.jsx("input", { type: "text", value: p.global, onChange: j => Ze("global", j.target.value), placeholder: "Search blogs...", className: "px-3 py-2 rounded-xl shadow-sm focus:outline-2 focus:outline-primary w-full border border-primary transition-all" }), gt?.data?.data?.admin?.permissions?.includes("create_blog") && d.jsxs("button", { onClick: () => O(!0), className: "bg-primary hover:bg-darkBlue transition-all text-white px-3 py-2 rounded-xl shadow-sm min-w-max flex items-center gap-2", children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Blog" })] })] }), d.jsx("div", { className: "overflow-x-auto", children: d.jsxs("table", { className: "w-full divide-y divide-gray-200", children: [d.jsx("thead", { className: "bg-gray-50", children: d.jsxs("tr", { children: [d.jsx("th", { className: "px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsxs("div", { className: "flex items-center", children: [d.jsx("input", { type: "checkbox", checked: a && Pn.length > 0, onChange: j => Zr(j.target.checked), className: "h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500" }), d.jsx("span", { className: "ml-2", children: "Title" })] }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", value: p.author, onChange: j => Ze("author", j.target.value), placeholder: "Author", className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Cover Photo" }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsxs("select", { value: p.category, onChange: j => Ze("category", j.target.value), className: "text-xs p-1 border rounded w-full", children: [d.jsx("option", { value: "", children: "All Categories" }), d.jsx("option", { value: "guides", children: "Guides" }), d.jsx("option", { value: "insights", children: "Insights" }), d.jsx("option", { value: "trending", children: "Trending" })] }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsxs("select", { value: p.status, onChange: j => Ze("status", j.target.value), className: "text-xs p-1 border rounded w-full", children: [d.jsx("option", { value: "", children: "All Statuses" }), d.jsx("option", { value: "active", children: "Active" }), d.jsx("option", { value: "inactive", children: "Inactive" })] }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx(vae, { initialRange: { startDate: p.created_from ? new Date(`${p.created_from}T00:00:00`) : null, endDate: p.created_to ? new Date(`${p.created_to}T00:00:00`) : null }, onDateChange: ({ startDate: j, endDate: F }) => { const J = X => { if (!(X instanceof Date) || isNaN(X)) return ""; const Me = X.getFullYear(), Pe = String(X.getMonth() + 1).padStart(2, "0"), Re = String(X.getDate()).padStart(2, "0"); return `${Me}-${Pe}-${Re}` }; Ze("created_from", j ? J(j) : ""), Ze("created_to", F ? J(F) : "") } }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Emails Sent" }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Actions" })] }) }), d.jsx("tbody", { className: "bg-white divide-y divide-gray-200 text-sm", children: e ? d.jsx("tr", { children: d.jsx("td", { colSpan: "8", className: "px-3 py-4 text-center", children: d.jsxs("div", { className: "flex justify-center items-center gap-2", children: [d.jsx(mt, { className: "animate-spin", size: 18 }), "Loading blogs..."] }) }) }) : Mr.length === 0 ? d.jsx("tr", { children: d.jsx("td", { colSpan: "8", className: "px-3 py-4 text-center", children: "No blogs found" }) }) : Mr.map(j => d.jsxs("tr", { className: "hover:bg-gray-50", children: [d.jsx("td", { className: "px-6 py-4 whitespace-nowrap", children: d.jsxs("div", { className: "flex items-center", children: [d.jsx("input", { type: "checkbox", checked: i.includes(j.id), onChange: F => Jr(j.id, F.target.checked), className: "h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500" }), d.jsx("span", { className: "ml-2 text-sm font-medium text-gray-900", children: j.title })] }) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: j.author?.name || "-" }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: j.cover_photo && d.jsx("img", { src: j.cover_photo, alt: "Cover", className: "h-10 w-10 object-cover rounded" }) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: Ls(j.category) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: Jn(j.is_active) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: j.created_at ? new Date(j.created_at).toLocaleDateString() : "-" }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: Ni(j.emails_sent_count) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsxs("div", { className: "flex items-center gap-2", children: [gt?.data?.data?.admin?.permissions?.includes("edit_blog") && d.jsx("button", { className: "text-blue-500 hover:text-blue-700 p-1", onClick: () => ut(j), children: d.jsx(br, { size: 18 }) }), gt?.data?.data?.admin?.permissions?.includes("toggle_blog_status") && d.jsx("button", { className: `${j.is_active ? "text-red-500 hover:text-red-700" : "text-green-500 hover:text-green-700"} p-1`, onClick: () => Nt(j.id, j.is_active), disabled: T === j.id, children: T === j.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : j.is_active ? d.jsx(vr, {}) : d.jsx(Cs, {}) }), gt?.data?.data?.admin?.permissions?.includes("delete_blog") && d.jsx("button", { className: "text-red-500 hover:text-red-700 p-1", onClick: () => rn(j.id), disabled: S === j.id, title: "Delete", children: S === j.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : d.jsx(Cn, { size: 18 }) }), d.jsx("button", { className: "text-blue-500 hover:text-blue-700 p-1", onClick: () => hn(j.id), title: "Manage FAQs", children: d.jsx(gX, { size: 18 }) }), d.jsx("button", { className: "text-green-500 hover:text-green-700 p-1", onClick: () => $e(j), title: "Preview Blog", children: d.jsx(RS, { size: 18 }) })] }) })] }, j.id)) })] }) }), ji && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", children: d.jsxs(ot.div, { initial: { scale: .9, opacity: 0 }, animate: { scale: 1, opacity: 1 }, exit: { scale: .9, opacity: 0 }, transition: { duration: .2 }, className: "bg-white rounded-lg p-6 max-w-md w-full", children: [d.jsxs("div", { className: "flex justify-between items-center mb-4", children: [d.jsx("h3", { className: "text-lg font-semibold text-gray-900", children: "Confirm Deletion" }), d.jsx("button", { onClick: () => un(!1), className: "text-gray-500 hover:text-gray-700", children: d.jsx(vr, {}) })] }), d.jsxs("p", { className: "text-gray-700 mb-6", children: ["Are you sure you want to delete ", i.length, " selected blog(s)? This action cannot be undone."] }), d.jsxs("div", { className: "flex justify-end gap-3", children: [d.jsx("button", { onClick: () => un(!1), className: "px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500", disabled: u, children: "Cancel" }), d.jsx("button", { onClick: L, className: "px-4 py-2 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 flex items-center", disabled: u, children: u ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin mr-2" }), "Deleting..."] }) : "Delete" })] })] }) }), i.length > 0 && d.jsx("div", { className: "bg-blue-50 p-4 rounded-md mb-6 border border-blue-200", children: d.jsxs("div", { className: "flex flex-wrap items-center gap-4", children: [d.jsxs("div", { className: "text-blue-800 font-medium", children: [i.length, " blog(s) selected"] }), d.jsxs("div", { className: "flex flex-wrap gap-2", children: [d.jsxs("button", { onClick: () => Q(!0), disabled: u, className: "flex items-center px-3 py-1.5 bg-green-600 text-white rounded hover:bg-green-700 disabled:opacity-50 text-sm", children: [d.jsx(Cs, { className: "mr-1.5" }), "Activate"] }), d.jsxs("button", { onClick: () => Q(!1), disabled: u, className: "flex items-center px-3 py-1.5 bg-yellow-600 text-white rounded hover:bg-yellow-700 disabled:opacity-50 text-sm", children: [d.jsx(vr, { className: "mr-1.5" }), "Deactivate"] }), d.jsxs("button", { onClick: qi, disabled: u, className: "flex items-center px-3 py-1.5 bg-red-600 text-white rounded hover:bg-red-700 disabled:opacity-50 text-sm", children: [d.jsx(Cn, { className: "mr-1.5" }), "Delete"] }), d.jsxs("button", { onClick: () => { s([]), l(!1) }, className: "flex items-center px-3 py-1.5 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 text-sm", children: [d.jsx(vr, { className: "mr-1.5" }), "Clear Selection"] }), u && d.jsxs("div", { className: "flex items-center", children: [d.jsx(mt, { className: "animate-spin mr-1.5" }), "Loading..."] })] })] }) }), !e && _t(), d.jsxs("div", { className: "p-4 border-t", children: [d.jsxs("div", { className: "flex items-center justify-between mb-3", children: [d.jsx("h2", { className: "text-lg font-semibold", children: "Drafts" }), d.jsx("div", { className: "text-xs text-gray-500", children: "Drafts are stored locally in your browser" })] }), U.length === 0 ? d.jsx("div", { className: "text-sm text-gray-500", children: "No drafts yet" }) : d.jsx("div", { className: "overflow-x-auto", children: d.jsxs("table", { className: "w-full divide-y divide-gray-200 text-sm", children: [d.jsx("thead", { className: "bg-gray-50", children: d.jsxs("tr", { children: [d.jsx("th", { className: "px-4 py-2 text-left", children: "Title" }), d.jsx("th", { className: "px-4 py-2 text-left", children: "Category" }), d.jsx("th", { className: "px-4 py-2 text-left", children: "Updated" }), d.jsx("th", { className: "px-4 py-2 text-left", children: "Note" }), d.jsx("th", { className: "px-4 py-2 text-left", children: "Actions" })] }) }), d.jsx("tbody", { className: "divide-y divide-gray-200", children: U.slice().sort((j, F) => new Date(F.updatedAt) - new Date(j.updatedAt)).map(j => d.jsxs("tr", { className: "hover:bg-gray-50", children: [d.jsx("td", { className: "px-4 py-2", children: j.title || d.jsx("span", { className: "italic text-gray-400", children: "Untitled" }) }), d.jsx("td", { className: "px-4 py-2 capitalize", children: j.category || "-" }), d.jsx("td", { className: "px-4 py-2", children: new Date(j.updatedAt).toLocaleString() }), d.jsx("td", { className: "px-4 py-2 text-xs text-gray-500", children: j.cover_photo_meta ? `Attachment: ${j.cover_photo_meta.name} (re-attach required)` : "No attachment" }), d.jsx("td", { className: "px-4 py-2", children: d.jsxs("div", { className: "flex gap-2", children: [d.jsxs("button", { className: "px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 flex items-center gap-1", onClick: () => st(j), children: [d.jsx(pX, {}), " Resume"] }), d.jsx("button", { className: "px-3 py-1 bg-red-600 text-white rounded hover:bg-red-700", onClick: () => je(j.id), children: "Delete" })] }) })] }, j.id)) })] }) })] }), M && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 ", onClick: () => { const j = lt(); j && cn(j), O(!1) }, children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full  h-[100vh] overflow-y-auto", onClick: j => j.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Add New Blog" }), d.jsxs("form", { onSubmit: jt, children: [d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4 mb-4", children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Title*" }), d.jsx("input", { type: "text", name: "title", value: P.title, onChange: Z, className: "w-full px-3 py-2 border rounded-md", required: !0 })] }), d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Category*" }), d.jsxs("select", { name: "category", value: P.category, onChange: Z, className: "w-full px-3 py-2 border rounded-md", required: !0, children: [d.jsx("option", { value: "guides", children: "Guides" }), d.jsx("option", { value: "insights", children: "Insights" }), d.jsx("option", { value: "trending", children: "Trending" })] })] })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Slug*" }), d.jsxs("div", { className: "relative", children: [d.jsx("input", { type: "text", name: "slug", value: P.slug, onChange: ce, className: "w-full px-3 py-2 border rounded-md", required: !0 }), te && d.jsx("button", { type: "button", onClick: Se, className: "absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700", title: "Reset to auto-generated slug", children: d.jsx(vr, {}) })] }), d.jsx("p", { className: "text-xs text-gray-500 mt-1", children: te ? "Slug is manually edited. Click the X to reset to auto-generated." : "Slug is auto-generated from title. You can edit it manually." })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Cover Photo" }), P.cover_photo ? d.jsxs("div", { className: "relative mb-4", children: [d.jsx("img", { src: URL.createObjectURL(P.cover_photo), alt: "Preview", className: "h-48 w-full object-cover rounded-lg" }), d.jsx("button", { type: "button", onClick: () => ee(j => ({ ...j, cover_photo: null })), className: "absolute top-2 right-2 bg-red-500 text-white rounded-full p-2", children: d.jsx(vr, { size: 16 }) })] }) : d.jsxs("label", { className: "flex flex-col items-center justify-center w-full h-32 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100", children: [d.jsxs("div", { className: "flex flex-col items-center justify-center pt-5 pb-6", children: [d.jsx(sg, { className: "w-8 h-8 mb-3 text-gray-400" }), d.jsxs("p", { className: "mb-2 text-sm text-gray-500", children: [d.jsx("span", { className: "font-semibold", children: "Click to upload" }), " or drag and drop"] }), d.jsx("p", { className: "text-xs text-gray-500", children: "PNG, JPG, JPEG (MAX. 5MB)" })] }), d.jsx("input", { id: "cover_photo", name: "cover_photo", type: "file", className: "hidden", onChange: Z, accept: "image/*" })] })] }), d.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4 mb-4", children: d.jsxs("div", { className: "flex items-center", children: [d.jsx("input", { type: "checkbox", id: "is_active", name: "is_active", checked: P.is_active, onChange: Z, className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsx("label", { htmlFor: "is_active", className: "ml-2 text-sm text-gray-700", children: "Active" })] }) }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { htmlFor: "tags", className: "block text-sm font-medium mb-1", children: "Tags" }), d.jsx(hw, { id: "tags", name: "tags", value: P.tags, onChange: xt, placeholder: "Enter tags", className: "w-full p-chips dark:bg-dark2", itemTemplate: j => d.jsx("div", { className: "bg-gray-200 dark:bg-dark1 rounded-full px-3 py-1 text-sm", children: j }) })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Content*" }), d.jsx(Yg, { content: P.content, onUpdate: j => ee(F => ({ ...F, content: j })), onHeadingsUpdate: Tt })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsxs("div", { className: "text-xs text-gray-500 mt-2 flex items-center", children: [d.jsx(mt, { className: `animate-spin mr-1 ${W ? "opacity-100" : "opacity-0"}`, size: 12 }), "Auto-saves to drafts every 10s"] }), d.jsxs("button", { type: "button", onClick: le, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50 flex items-center gap-2", children: [d.jsx(yX, { size: 16 }), " Save as Draft"] }), d.jsx("button", { type: "button", onClick: () => { const j = lt(); j && cn(j), O(!1), dt() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: W, children: W ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Adding..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Blog" })] }) })] })] })] }) }) }), E && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50", onClick: () => k(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full h-[100vh] overflow-y-auto", onClick: j => j.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsxs("div", { className: "flex items-center mb-4", children: [d.jsx("button", { type: "button", onClick: () => k(!1), className: "text-blue-600 hover:text-blue-800 font-medium", children: "Blogs" }), d.jsx("span", { className: "mx-2 text-gray-400", children: ">" }), d.jsx("span", { className: "text-xl font-bold text-gray-900", children: _.title || "Untitled Blog" })] }), d.jsxs("form", { onSubmit: St, children: [d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4 mb-4", children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Title*" }), d.jsx("input", { type: "text", name: "title", value: _.title, onChange: Le, className: "w-full px-3 py-2 border rounded-md", required: !0 })] }), d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Category*" }), d.jsxs("select", { name: "category", value: _.category, onChange: Le, className: "w-full px-3 py-2 border rounded-md", required: !0, children: [d.jsx("option", { value: "guides", children: "Guides" }), d.jsx("option", { value: "insights", children: "Insights" }), d.jsx("option", { value: "trending", children: "Trending" })] })] })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Slug*" }), d.jsxs("div", { className: "relative", children: [d.jsx("input", { type: "text", name: "slug", value: _.slug, onChange: We, className: "w-full px-3 py-2 border rounded-md", required: !0 }), He && d.jsx("button", { type: "button", onClick: ct, className: "absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700", title: "Reset to auto-generated slug", children: d.jsx(vr, {}) })] }), d.jsx("p", { className: "text-xs text-gray-500 mt-1", children: He ? "Slug is manually edited. Click the X to reset to auto-generated." : "Slug is auto-generated from title. You can edit it manually." })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Cover Photo" }), _.cover_photo ? d.jsxs("div", { className: "relative mb-4", children: [d.jsx("img", { src: URL.createObjectURL(_.cover_photo), alt: "Preview", className: "h-48 w-full object-cover rounded-lg" }), d.jsx("button", { type: "button", onClick: () => I(j => ({ ...j, cover_photo: null })), className: "absolute top-2 right-2 bg-red-500 text-white rounded-full p-2", children: d.jsx(vr, { size: 16 }) })] }) : _.existing_cover_photo ? d.jsxs("div", { className: "relative mb-4", children: [d.jsx("img", { src: _.existing_cover_photo, alt: "Current Cover", className: "h-48 w-full object-cover rounded-lg" }), d.jsx("button", { type: "button", onClick: () => I(j => ({ ...j, existing_cover_photo: null })), className: "absolute top-2 right-2 bg-red-500 text-white rounded-full p-2", children: d.jsx(vr, { size: 16 }) })] }) : d.jsxs("label", { className: "flex flex-col items-center justify-center w-full h-32 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100", children: [d.jsxs("div", { className: "flex flex-col items-center justify-center pt-5 pb-6", children: [d.jsx(sg, { className: "w-8 h-8 mb-3 text-gray-400" }), d.jsxs("p", { className: "mb-2 text-sm text-gray-500", children: [d.jsx("span", { className: "font-semibold", children: "Click to upload" }), " or drag and drop"] }), d.jsx("p", { className: "text-xs text-gray-500", children: "PNG, JPG, JPEG (MAX. 5MB)" })] }), d.jsx("input", { id: "edit_cover_photo", name: "cover_photo", type: "file", className: "hidden", onChange: Le, accept: "image/*" })] })] }), d.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4 mb-4", children: d.jsxs("div", { className: "flex items-center", children: [d.jsx("input", { type: "checkbox", id: "edit_is_active", name: "is_active", checked: _.is_active, onChange: Le, className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsx("label", { htmlFor: "edit_is_active", className: "ml-2 text-sm text-gray-700", children: "Active" })] }) }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { htmlFor: "tags", className: "block text-sm font-medium mb-1", children: "tags" }), d.jsx(hw, { id: "tags", name: "tags", value: _.tags, onChange: at, placeholder: "Enter tags", className: "w-full p-chips dark:bg-dark2", itemTemplate: j => d.jsx("div", { className: "bg-gray-200 dark:bg-dark1 rounded-full px-3 py-1 text-sm", children: j }) })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Content" }), d.jsx(Yg, { content: _.content, onUpdate: j => I(F => ({ ...F, content: j })), onHeadingsUpdate: Qe })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsxs("div", { className: "text-xs text-gray-500 mt-2 flex items-center", children: [d.jsx(mt, { className: `animate-spin mr-1 ${W ? "opacity-100" : "opacity-0"}`, size: 12 }), W ? "Auto-saving..." : "Form will auto-save every 30 seconds"] }), d.jsx("button", { type: "button", onClick: () => { k(!1), n() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: W, children: W ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Updating..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(Cs, { size: 18 }), d.jsx("span", { children: "Update Blog" })] }) })] })] })] }) }) }), z && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => V(!1), children: d.jsx(ot.div, { initial: { scale: .9, opacity: 0 }, animate: { scale: 1, opacity: 1 }, exit: { scale: .9, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md", onClick: j => j.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsxs("div", { className: "flex items-start", children: [d.jsx("div", { className: "flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100", children: d.jsx(Cn, { className: "h-5 w-5 text-red-600" }) }), d.jsxs("div", { className: "ml-4", children: [d.jsx("h3", { className: "text-lg font-medium text-gray-900", children: "Delete Blog" }), d.jsx("div", { className: "mt-2", children: d.jsx("p", { className: "text-sm text-gray-500", children: "Are you sure you want to delete this blog? This action cannot be undone." }) })] })] }), d.jsxs("div", { className: "mt-5 flex justify-end gap-3", children: [d.jsx("button", { type: "button", onClick: () => V(!1), className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "button", onClick: Un, className: "px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700", children: "Delete" })] })] }) }) }), ie && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => { oe(!1), Ee(null), Xe(null), Oe({ question: "", answer: "", order: "" }) }, children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-3xl max-h-[90vh] overflow-y-auto", onClick: j => j.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Manage FAQs" }), d.jsxs("form", { onSubmit: Zt, className: "mb-6", children: [d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-4 mb-4", children: [d.jsxs("div", { className: "md:col-span-2", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Question*" }), d.jsx("input", { type: "text", name: "question", value: fe.question, onChange: pn, className: "w-full px-3 py-2 border rounded-md", required: !0 })] }), d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Order*" }), d.jsx("input", { type: "number", name: "order", value: fe.order, onChange: pn, className: "w-full px-3 py-2 border rounded-md", required: !0 })] })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Answer*" }), d.jsx("textarea", { name: "answer", value: fe.answer, onChange: pn, className: "w-full px-3 py-2 border rounded-md", rows: "3", required: !0 })] }), d.jsxs("div", { className: "flex justify-end gap-3", children: [et && d.jsx("button", { type: "button", onClick: Hi, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: Ae.isPending || qe.isPending, children: Ae.isPending || qe.isPending ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: et ? "Updating..." : "Adding..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(Cs, { size: 18 }), d.jsx("span", { children: et ? "Update FAQ" : "Add FAQ" })] }) })] })] }), d.jsxs("div", { children: [d.jsx("h3", { className: "text-lg font-medium mb-2", children: "Existing FAQs" }), se?.length === 0 ? d.jsx("p", { className: "text-gray-500", children: "No FAQs found for this blog." }) : d.jsx("div", { className: "space-y-4", children: se?.map(j => d.jsx("div", { className: "border rounded-lg p-4", children: d.jsxs("div", { className: "flex justify-between items-start", children: [d.jsxs("div", { children: [d.jsx("h4", { className: "font-medium", children: j.question }), d.jsx("p", { className: "text-sm text-gray-600 mt-1", children: j.answer }), d.jsxs("div", { className: "text-xs text-gray-500 mt-2", children: ["Order: ", j.order] })] }), d.jsxs("div", { className: "flex gap-2", children: [d.jsx("button", { onClick: () => Ht(j), className: "text-blue-500 hover:text-blue-700 p-1", children: d.jsx(br, { size: 16 }) }), d.jsx("button", { onClick: () => pr(j.id), className: "text-red-500 hover:text-red-700 p-1", disabled: rt.isPending, children: rt.isPending && rt.variables === j.id ? d.jsx(mt, { className: "animate-spin", size: 16 }) : d.jsx(Cn, { size: 16 }) })] })] }) }, j.id)) })] }), d.jsx("div", { className: "flex justify-end mt-6", children: d.jsx("button", { type: "button", onClick: () => { oe(!1), Ee(null), Xe(null), Oe({ question: "", answer: "", order: "" }) }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Close" }) })] }) }) }), De && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => he(!1), children: d.jsx(ot.div, { initial: { scale: .9, opacity: 0 }, animate: { scale: 1, opacity: 1 }, exit: { scale: .9, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md", onClick: j => j.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsxs("div", { className: "flex items-start", children: [d.jsx("div", { className: "flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100", children: d.jsx(Cn, { className: "h-5 w-5 text-red-600" }) }), d.jsxs("div", { className: "ml-4", children: [d.jsx("h3", { className: "text-lg font-medium text-gray-900", children: "Delete FAQ" }), d.jsx("div", { className: "mt-2", children: d.jsx("p", { className: "text-sm text-gray-500", children: "Are you sure you want to delete this FAQ? This action cannot be undone." }) })] })] }), d.jsxs("div", { className: "mt-5 flex justify-end gap-3", children: [d.jsx("button", { type: "button", onClick: () => he(!1), className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "button", onClick: $r, className: "px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700", disabled: rt.isPending, children: rt.isPending ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin mr-2" }), "Deleting..."] }) : "Delete" })] })] }) }) }), d.jsx(NW, { children: Je && d.jsx(Vn, { blog: Je, onClose: () => $e(null) }) })] }) } function Koe() { const t = ln(), { data: e, isLoading: n } = Jt({ queryKey: ["currentUser"], queryFn: () => Ve.get("https://api.nexus.com/api/auth/me", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }); function r() { return Ve.get("https://api.nexus.com/api/admin/blogs", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) } const { data: i, isLoading: s, refetch: a, isError: l, error: u } = Jt({ queryKey: ["blogs"], queryFn: r }); return N.useEffect(() => { l && (u.response?.status == 401 && (localStorage.removeItem("userToken"), t("/login")), u.response?.status == 403 && (me.error("You are not authorized to view this page"), t("/home"))) }, [l]), d.jsxs("div", { className: "p-4", children: [e?.data?.data?.admin?.permissions?.includes("view_newsletter_subscribers") && d.jsxs(d.Fragment, { children: [d.jsx("h1", { className: "text-3xl font-bold text-gray-800 mb-8", children: "News letter" }), d.jsx(za, { to: "/news-letter", className: "bg-primary text-white py-2 px-3 rounded-xl", children: "Open news letter" }), d.jsx("hr", { className: "my-5" })] }), d.jsx("h1", { className: "text-3xl font-bold text-gray-800 mb-8", children: "Blogs" }), d.jsx(qoe, { blogs: i?.data?.data || [], loading: s, refetch: a })] }) } function Woe({ NewsLetter: t, loading: e, refetch: n }) { const r = ln(), [i, s] = N.useState({ global: "", email: "", status: "" }), [a, l] = N.useState(1), [u] = N.useState(10), [f, p] = N.useState(null), [g, y] = N.useState(null), [v, b] = N.useState(!1), [S, C] = N.useState(null), T = (H, we) => { s(xe => ({ ...xe, [H]: we })), l(1) }, { data: A, isLoading: M, error: O, isError: E } = Jt({ queryKey: ["currentUser"], queryFn: () => Ve.get("https://api.nexus.com/api/auth/me", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }), k = H => { C(H), b(!0) }, z = async () => { if (S) { p(S), b(!1); try { await Ve.delete(`https://api.nexus.com/api/admin/newsletter/${S}`, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success("Subscriber deleted successfully", { duration: 2e3 }), n() } catch (H) { me.error(H.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), H.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), H.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } finally { p(null), C(null) } } }, V = t?.filter(H => (i.global === "" || H.email.toLowerCase().includes(i.global.toLowerCase())) && (i.email === "" || H.email.toLowerCase().includes(i.email.toLowerCase())) && (i.status === "" || (i.status === "active" ? H.is_active : !H.is_active))) || [], q = Math.ceil(V.length / u), ue = V.slice((a - 1) * u, a * u), W = H => { const we = { year: "numeric", month: "short", day: "numeric" }; return new Date(H).toLocaleDateString(void 0, we) }, ne = () => q <= 1 ? null : d.jsxs("div", { className: "flex justify-between items-center mt-4 px-4 pb-1", children: [d.jsxs("div", { className: "text-xs", children: ["Showing ", (a - 1) * u + 1, "-", Math.min(a * u, V.length), " of ", V.length, " entries"] }), d.jsxs("div", { className: "flex gap-1", children: [d.jsx("button", { onClick: () => l(1), disabled: a === 1, className: "p-1 disabled:opacity-50", children: d.jsx(Ds, { className: "h-4 w-4" }) }), d.jsxs("span", { className: "px-3 py-1", children: ["Page ", a, " of ", q] }), d.jsx("button", { onClick: () => l(H => Math.min(q, H + 1)), disabled: a === q, className: "p-1 disabled:opacity-50", children: d.jsx(Rs, { className: "h-4 w-4" }) })] })] }); return d.jsxs("div", { className: "shadow-2xl rounded-2xl overflow-hidden bg-white", children: [d.jsx("div", { className: "p-4 border-b", children: d.jsx("input", { type: "text", value: i.global, onChange: H => T("global", H.target.value), placeholder: "Search subscribers...", className: "px-3 py-2 rounded-xl shadow-sm focus:outline-2 focus:outline-primary w-full border border-primary transition-all" }) }), d.jsx("div", { className: "overflow-x-auto", children: d.jsxs("table", { className: "w-full divide-y divide-gray-200", children: [d.jsx("thead", { className: "bg-gray-50", children: d.jsxs("tr", { children: [d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Email", value: i.email, onChange: H => T("email", H.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Subscribed At" }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Actions" })] }) }), d.jsx("tbody", { className: "bg-white divide-y divide-gray-200 text-sm", children: e ? d.jsx("tr", { children: d.jsx("td", { colSpan: "4", className: "px-3 py-4 text-center", children: d.jsxs("div", { className: "flex justify-center items-center gap-2", children: [d.jsx(mt, { className: "animate-spin", size: 18 }), "Loading subscribers..."] }) }) }) : ue.length === 0 ? d.jsx("tr", { children: d.jsx("td", { colSpan: "4", className: "px-3 py-4 text-center", children: "No subscribers found" }) }) : ue.map(H => d.jsxs("tr", { className: "hover:bg-gray-50", children: [d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsx("div", { className: "font-medium", children: H.email }) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: W(H.created_at) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsx("div", { className: "flex items-center gap-2", children: A?.data?.data?.admin?.permissions?.includes("remove_newsletter_subscriber") && d.jsx("button", { className: "text-red-500 hover:text-red-700 p-1", onClick: () => k(H.id), disabled: f === H.id, children: f === H.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : d.jsx(Cn, { size: 18 }) }) }) })] }, H.id)) })] }) }), !e && ne(), v && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => b(!1), children: d.jsx(ot.div, { initial: { scale: .9, opacity: 0 }, animate: { scale: 1, opacity: 1 }, exit: { scale: .9, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md", onClick: H => H.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsxs("div", { className: "flex items-start", children: [d.jsx("div", { className: "flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100", children: d.jsx(Cn, { className: "h-5 w-5 text-red-600" }) }), d.jsxs("div", { className: "ml-4", children: [d.jsx("h3", { className: "text-lg font-medium text-gray-900", children: "Delete Subscriber" }), d.jsx("div", { className: "mt-2", children: d.jsx("p", { className: "text-sm text-gray-500", children: "Are you sure you want to delete this subscriber? This action cannot be undone." }) })] })] }), d.jsxs("div", { className: "mt-5 flex justify-end gap-3", children: [d.jsx("button", { type: "button", onClick: () => b(!1), className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "button", onClick: z, className: "px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700", children: "Delete" })] })] }) }) })] }) } function Yoe() { const t = ln(); function e() { return Ve.get("https://api.nexus.com/api/admin/newsletter", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) } const { data: n, isLoading: r, refetch: i, isError: s, error: a } = Jt({ queryKey: ["newsletter"], queryFn: e }); return N.useEffect(() => { s && (a.response?.status == 401 && (localStorage.removeItem("userToken"), t("/login")), a.response?.status == 403 && (me.error("You are not authorized to view this page"), t("/home"))) }, [s]), d.jsxs("div", { className: "p-4", children: [d.jsx("button", { className: "bg-gray-200 text-primary p-3 rounded-full aspect-square mb-2", onClick: () => t("/blogs"), children: d.jsx($R, {}) }), d.jsx("h1", { className: "text-3xl font-bold text-gray-800 mb-8", children: "News Letter" }), d.jsx(Woe, { NewsLetter: n?.data?.data || [], loading: r, refetch: i })] }) } function Goe(t) { return Vt({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "polyline", attr: { points: "15 18 9 12 15 6" }, child: [] }] })(t) } function Xoe(t) { return Vt({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "polyline", attr: { points: "9 18 15 12 9 6" }, child: [] }] })(t) } function mm(t) { return Vt({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "rect", attr: { x: "9", y: "9", width: "13", height: "13", rx: "2", ry: "2" }, child: [] }, { tag: "path", attr: { d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" }, child: [] }] })(t) } function Qoe(t) { return Vt({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" }, child: [] }, { tag: "polyline", attr: { points: "15 3 21 3 21 9" }, child: [] }, { tag: "line", attr: { x1: "10", y1: "14", x2: "21", y2: "3" }, child: [] }] })(t) } function Joe({ demoRequests: t, loading: e, refetch: n }) { const [r, i] = N.useState({ global: "", name: "", email: "", status: "" }), [s, a] = N.useState(1), [l] = N.useState(10), [u, f] = N.useState(null), [p, g] = N.useState(!1), y = (O, E) => { i(k => ({ ...k, [O]: E })), a(1) }, v = O => { navigator.clipboard.writeText(O || ""), me.success("Copied to clipboard", { duration: 2e3 }) }, b = O => { const E = { year: "numeric", month: "short", day: "numeric", hour: "2-digit", minute: "2-digit" }; return new Date(O).toLocaleDateString(void 0, E) }, S = O => { const E = { pending: "bg-yellow-100 text-yellow-800", confirmed: "bg-green-100 text-green-800", cancelled: "bg-red-100 text-red-800", completed: "bg-blue-100 text-blue-800" }; return d.jsx("span", { className: `px-2.5 py-1 rounded-full text-xs font-medium ${E[O] || "bg-gray-100 text-gray-800"}`, children: O.charAt(0).toUpperCase() + O.slice(1) }) }, C = t?.filter(O => (r.global === "" || O.full_name.toLowerCase().includes(r.global.toLowerCase()) || O.email.toLowerCase().includes(r.global.toLowerCase())) && (r.name === "" || O.full_name.toLowerCase().includes(r.name.toLowerCase())) && (r.email === "" || O.email.toLowerCase().includes(r.email.toLowerCase())) && (r.status === "" || O.status.toLowerCase().includes(r.status.toLowerCase()))) || [], T = Math.ceil(C.length / l), A = C.slice((s - 1) * l, s * l), M = () => T <= 1 ? null : d.jsxs("div", { className: "flex justify-between items-center mt-4 px-4 pb-1", children: [d.jsxs("div", { className: "text-xs", children: ["Showing ", (s - 1) * l + 1, "-", Math.min(s * l, C.length), " of ", C.length, " entries"] }), d.jsxs("div", { className: "flex gap-1", children: [d.jsx("button", { onClick: () => a(1), disabled: s === 1, className: "p-1 disabled:opacity-50", children: d.jsx(Goe, { className: "h-4 w-4" }) }), d.jsxs("span", { className: "px-3 py-1", children: ["Page ", s, " of ", T] }), d.jsx("button", { onClick: () => a(O => Math.min(T, O + 1)), disabled: s === T, className: "p-1 disabled:opacity-50", children: d.jsx(Xoe, { className: "h-4 w-4" }) })] })] }); return d.jsxs("div", { className: "shadow-2xl rounded-2xl overflow-hidden bg-white", children: [d.jsx("div", { className: "p-4 border-b", children: d.jsx("input", { type: "text", value: r.global, onChange: O => y("global", O.target.value), placeholder: "Search demo requests...", className: "px-3 py-2 rounded-xl shadow-sm focus:outline-2 focus:outline-primary w-full border border-primary transition-all" }) }), d.jsx("div", { className: "overflow-x-auto", children: d.jsxs("table", { className: "w-full divide-y divide-gray-200", children: [d.jsx("thead", { className: "bg-gray-50", children: d.jsxs("tr", { children: [d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Name", value: r.name, onChange: O => y("name", O.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Email", value: r.email, onChange: O => y("email", O.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Scheduled Time" }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsxs("select", { value: r.status, onChange: O => y("status", O.target.value), className: "text-xs p-1 border rounded w-full", children: [d.jsx("option", { value: "", children: "All Statuses" }), d.jsx("option", { value: "pending", children: "Pending" }), d.jsx("option", { value: "confirmed", children: "Confirmed" }), d.jsx("option", { value: "cancelled", children: "Cancelled" }), d.jsx("option", { value: "completed", children: "Completed" })] }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Actions" })] }) }), d.jsx("tbody", { className: "bg-white divide-y divide-gray-200 text-sm", children: e ? d.jsx("tr", { children: d.jsx("td", { colSpan: "5", className: "px-3 py-4 text-center", children: d.jsxs("div", { className: "flex justify-center items-center gap-2", children: [d.jsx(mt, { className: "animate-spin", size: 18 }), "Loading demo requests..."] }) }) }) : A.length === 0 ? d.jsx("tr", { children: d.jsx("td", { colSpan: "5", className: "px-3 py-4 text-center", children: "No demo requests found" }) }) : A.map(O => d.jsxs("tr", { className: "hover:bg-gray-50", children: [d.jsxs("td", { className: "px-3 py-4 whitespace-nowrap", children: [d.jsx("div", { className: "font-medium", children: O.full_name }), d.jsx("div", { className: "text-gray-500 text-xs", children: O.phone })] }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsxs("div", { className: "flex items-center gap-1", children: [O.email, d.jsx("button", { onClick: () => v(O.email), className: "text-gray-400 hover:text-gray-600 p-1", title: "Copy email", children: d.jsx(mm, { className: "h-4 w-4" }) })] }) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: O.formatted_datetime }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: S(O.status) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsx("button", { onClick: () => { f(O), g(!0) }, className: "text-blue-600 hover:text-blue-800 p-1 flex items-center gap-1", children: "View Details" }) })] }, O.id)) })] }) }), !e && M(), p && u && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => g(!1), children: d.jsx(ot.div, { initial: { scale: .9, opacity: 0 }, animate: { scale: 1, opacity: 1 }, exit: { scale: .9, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto", onClick: O => O.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsxs("div", { className: "flex justify-between items-start mb-4", children: [d.jsx("h3", { className: "text-xl font-bold text-gray-900", children: "Demo Request Details" }), d.jsx("button", { onClick: () => g(!1), className: "text-gray-500 hover:text-gray-700", children: "" })] }), d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6", children: [d.jsxs("div", { className: "space-y-4", children: [d.jsxs("div", { children: [d.jsx("h4", { className: "text-sm font-medium text-gray-500", children: "Full Name" }), d.jsx("p", { className: "mt-1 text-sm text-gray-900", children: u.full_name })] }), d.jsxs("div", { children: [d.jsx("h4", { className: "text-sm font-medium text-gray-500", children: "Email" }), d.jsxs("div", { className: "flex items-center gap-1 mt-1", children: [d.jsx("p", { className: "text-sm text-gray-900", children: u.email }), d.jsx("button", { onClick: () => v(u.email), className: "text-gray-400 hover:text-gray-600 p-1", title: "Copy email", children: d.jsx(mm, { className: "h-4 w-4" }) })] })] }), d.jsxs("div", { children: [d.jsx("h4", { className: "text-sm font-medium text-gray-500", children: "Phone" }), d.jsxs("div", { className: "flex items-center gap-1 mt-1", children: [d.jsx("p", { className: "text-sm text-gray-900", children: u.phone }), d.jsx("button", { onClick: () => v(u.phone), className: "text-gray-400 hover:text-gray-600 p-1", title: "Copy phone", children: d.jsx(mm, { className: "h-4 w-4" }) })] })] }), d.jsxs("div", { children: [d.jsx("h4", { className: "text-sm font-medium text-gray-500", children: "Real Estate Experience" }), d.jsx("p", { className: "mt-1 text-sm text-gray-900", children: u.real_estate_experience })] })] }), d.jsxs("div", { className: "space-y-4", children: [d.jsxs("div", { children: [d.jsx("h4", { className: "text-sm font-medium text-gray-500", children: "Monthly Budget" }), d.jsx("p", { className: "mt-1 text-sm text-gray-900", children: u.monthly_budget })] }), d.jsxs("div", { children: [d.jsx("h4", { className: "text-sm font-medium text-gray-500", children: "Scheduled Time" }), d.jsx("p", { className: "mt-1 text-sm text-gray-900", children: u.formatted_datetime })] }), d.jsxs("div", { children: [d.jsx("h4", { className: "text-sm font-medium text-gray-500", children: "Status" }), d.jsx("div", { className: "mt-1", children: S(u.status) })] }), d.jsxs("div", { children: [d.jsx("h4", { className: "text-sm font-medium text-gray-500", children: "Google Meet Link" }), d.jsxs("div", { className: "flex items-center gap-1 mt-1", children: [d.jsxs("a", { href: u.google_meet_link, target: "_blank", rel: "noopener noreferrer", className: "text-blue-600 hover:text-blue-800 text-sm flex items-center gap-1", children: ["Join Meeting ", d.jsx(Qoe, { className: "h-3 w-3" })] }), d.jsx("button", { onClick: () => v(u.google_meet_link), className: "text-gray-400 hover:text-gray-600 p-1", title: "Copy meeting link", children: d.jsx(mm, { className: "h-4 w-4" }) })] })] })] })] }), d.jsxs("div", { className: "mt-6 pt-4 border-t", children: [d.jsx("h4", { className: "text-sm font-medium text-gray-500 mb-2", children: "Additional Information" }), d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [d.jsxs("div", { children: [d.jsx("h5", { className: "text-xs font-medium text-gray-500", children: "Created At" }), d.jsx("p", { className: "mt-1 text-xs text-gray-900", children: b(u.created_at) })] }), d.jsxs("div", { children: [d.jsx("h5", { className: "text-xs font-medium text-gray-500", children: "Last Updated" }), d.jsx("p", { className: "mt-1 text-xs text-gray-900", children: b(u.updated_at) })] }), u.failure_reason && d.jsxs("div", { className: "md:col-span-2", children: [d.jsx("h5", { className: "text-xs font-medium text-gray-500", children: "Failure Reason" }), d.jsx("p", { className: "mt-1 text-xs text-gray-900", children: u.failure_reason })] })] })] })] }) }) })] }) } function Zoe() { const t = ln(); function e() { return Ve.get("https://api.nexus.com/api/admin/request-demos", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) } const { data: n, isLoading: r, refetch: i, isError: s, error: a } = Jt({ queryKey: ["demoRequests"], queryFn: e }); return N.useEffect(() => { s && (a.response?.status == 401 && (localStorage.removeItem("userToken"), t("/login")), a.response?.status == 403 && (me.error("You are not authorized to view this page"), t("/home"))) }, [s]), d.jsxs("div", { className: "p-4", children: [d.jsx("h1", { className: "text-3xl font-bold text-gray-800 mb-8", children: "Requested demos" }), d.jsx(Joe, { demoRequests: n?.data?.data || [], loading: r, refetch: i })] }) } var pb = { exports: {} }, mb, O3; function ele() { if (O3) return mb; O3 = 1; var t = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"; return mb = t, mb } var gb, M3; function tle() { if (M3) return gb; M3 = 1; var t = ele(); function e() { } function n() { } return n.resetWarningCache = e, gb = function () { function r(a, l, u, f, p, g) { if (g !== t) { var y = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw y.name = "Invariant Violation", y } } r.isRequired = r; function i() { return r } var s = { array: r, bigint: r, bool: r, func: r, number: r, object: r, string: r, symbol: r, any: r, arrayOf: i, element: r, elementType: r, instanceOf: i, node: r, objectOf: i, oneOf: i, oneOfType: i, shape: i, exact: i, checkPropTypes: n, resetWarningCache: e }; return s.PropTypes = s, s }, gb } var D3; function nle() { return D3 || (D3 = 1, pb.exports = tle()()), pb.exports } var rle = nle(); const Dn = Ha(rle); var yb, R3; function ile() { if (R3) return yb; R3 = 1; function t(l) { return l && typeof l == "object" && "default" in l ? l.default : l } var e = sy(), n = t(e); function r(l, u, f) { return u in l ? Object.defineProperty(l, u, { value: f, enumerable: !0, configurable: !0, writable: !0 }) : l[u] = f, l } function i(l, u) { l.prototype = Object.create(u.prototype), l.prototype.constructor = l, l.__proto__ = u } var s = !!(typeof window < "u" && window.document && window.document.createElement); function a(l, u, f) { if (typeof l != "function") throw new Error("Expected reducePropsToState to be a function."); if (typeof u != "function") throw new Error("Expected handleStateChangeOnClient to be a function."); if (typeof f < "u" && typeof f != "function") throw new Error("Expected mapStateOnServer to either be undefined or a function."); function p(g) { return g.displayName || g.name || "Component" } return function (y) { if (typeof y != "function") throw new Error("Expected WrappedComponent to be a React component."); var v = [], b; function S() { b = l(v.map(function (T) { return T.props })), C.canUseDOM ? u(b) : f && (b = f(b)) } var C = function (T) { i(A, T); function A() { return T.apply(this, arguments) || this } A.peek = function () { return b }, A.rewind = function () { if (A.canUseDOM) throw new Error("You may only call rewind() on the server. Call peek() to read the current state."); var E = b; return b = void 0, v = [], E }; var M = A.prototype; return M.UNSAFE_componentWillMount = function () { v.push(this), S() }, M.componentDidUpdate = function () { S() }, M.componentWillUnmount = function () { var E = v.indexOf(this); v.splice(E, 1), S() }, M.render = function () { return n.createElement(y, this.props) }, A }(e.PureComponent); return r(C, "displayName", "SideEffect(" + p(y) + ")"), r(C, "canUseDOM", s), C } } return yb = a, yb } var sle = ile(); const ale = Ha(sle); var vb, _3; function ole() { if (_3) return vb; _3 = 1; var t = typeof Element < "u", e = typeof Map == "function", n = typeof Set == "function", r = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView; function i(s, a) { if (s === a) return !0; if (s && a && typeof s == "object" && typeof a == "object") { if (s.constructor !== a.constructor) return !1; var l, u, f; if (Array.isArray(s)) { if (l = s.length, l != a.length) return !1; for (u = l; u-- !== 0;)if (!i(s[u], a[u])) return !1; return !0 } var p; if (e && s instanceof Map && a instanceof Map) { if (s.size !== a.size) return !1; for (p = s.entries(); !(u = p.next()).done;)if (!a.has(u.value[0])) return !1; for (p = s.entries(); !(u = p.next()).done;)if (!i(u.value[1], a.get(u.value[0]))) return !1; return !0 } if (n && s instanceof Set && a instanceof Set) { if (s.size !== a.size) return !1; for (p = s.entries(); !(u = p.next()).done;)if (!a.has(u.value[0])) return !1; return !0 } if (r && ArrayBuffer.isView(s) && ArrayBuffer.isView(a)) { if (l = s.length, l != a.length) return !1; for (u = l; u-- !== 0;)if (s[u] !== a[u]) return !1; return !0 } if (s.constructor === RegExp) return s.source === a.source && s.flags === a.flags; if (s.valueOf !== Object.prototype.valueOf && typeof s.valueOf == "function" && typeof a.valueOf == "function") return s.valueOf() === a.valueOf(); if (s.toString !== Object.prototype.toString && typeof s.toString == "function" && typeof a.toString == "function") return s.toString() === a.toString(); if (f = Object.keys(s), l = f.length, l !== Object.keys(a).length) return !1; for (u = l; u-- !== 0;)if (!Object.prototype.hasOwnProperty.call(a, f[u])) return !1; if (t && s instanceof Element) return !1; for (u = l; u-- !== 0;)if (!((f[u] === "_owner" || f[u] === "__v" || f[u] === "__o") && s.$$typeof) && !i(s[f[u]], a[f[u]])) return !1; return !0 } return s !== s && a !== a } return vb = function (a, l) { try { return i(a, l) } catch (u) { if ((u.message || "").match(/stack|recursion/i)) return console.warn("react-fast-compare cannot handle circular refs"), !1; throw u } }, vb } var lle = ole(); const cle = Ha(lle);/*
object-assign
(c) Sindre Sorhus
@license MIT
*/var xb, L3; function ule() { if (L3) return xb; L3 = 1; var t = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable; function r(s) { if (s == null) throw new TypeError("Object.assign cannot be called with null or undefined"); return Object(s) } function i() { try { if (!Object.assign) return !1; var s = new String("abc"); if (s[5] = "de", Object.getOwnPropertyNames(s)[0] === "5") return !1; for (var a = {}, l = 0; l < 10; l++)a["_" + String.fromCharCode(l)] = l; var u = Object.getOwnPropertyNames(a).map(function (p) { return a[p] }); if (u.join("") !== "0123456789") return !1; var f = {}; return "abcdefghijklmnopqrst".split("").forEach(function (p) { f[p] = p }), Object.keys(Object.assign({}, f)).join("") === "abcdefghijklmnopqrst" } catch { return !1 } } return xb = i() ? Object.assign : function (s, a) { for (var l, u = r(s), f, p = 1; p < arguments.length; p++) { l = Object(arguments[p]); for (var g in l) e.call(l, g) && (u[g] = l[g]); if (t) { f = t(l); for (var y = 0; y < f.length; y++)n.call(l, f[y]) && (u[f[y]] = l[f[y]]) } } return u }, xb } var dle = ule(); const fle = Ha(dle); var Yl = { BODY: "bodyAttributes", HTML: "htmlAttributes", TITLE: "titleAttributes" }, It = { BASE: "base", BODY: "body", HEAD: "head", HTML: "html", LINK: "link", META: "meta", NOSCRIPT: "noscript", SCRIPT: "script", STYLE: "style", TITLE: "title" }; Object.keys(It).map(function (t) { return It[t] }); var _n = { CHARSET: "charset", CSS_TEXT: "cssText", HREF: "href", HTTPEQUIV: "http-equiv", INNER_HTML: "innerHTML", ITEM_PROP: "itemprop", NAME: "name", PROPERTY: "property", REL: "rel", SRC: "src", TARGET: "target" }, ty = { accesskey: "accessKey", charset: "charSet", class: "className", contenteditable: "contentEditable", contextmenu: "contextMenu", "http-equiv": "httpEquiv", itemprop: "itemProp", tabindex: "tabIndex" }, lh = { DEFAULT_TITLE: "defaultTitle", DEFER: "defer", ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters", ON_CHANGE_CLIENT_STATE: "onChangeClientState", TITLE_TEMPLATE: "titleTemplate" }, hle = Object.keys(ty).reduce(function (t, e) { return t[ty[e]] = e, t }, {}), ple = [It.NOSCRIPT, It.SCRIPT, It.STYLE], Ns = "data-react-helmet", mle = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) { return typeof t } : function (t) { return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, gle = function (t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }, yle = function () { function t(e, n) { for (var r = 0; r < n.length; r++) { var i = n[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } return function (e, n, r) { return n && t(e.prototype, n), r && t(e, r), e } }(), pi = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, vle = function (t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }, P3 = function (t, e) { var n = {}; for (var r in t) e.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]); return n }, xle = function (t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e && (typeof e == "object" || typeof e == "function") ? e : t }, pw = function (e) { var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0; return n === !1 ? String(e) : String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;") }, ble = function (e) { var n = fu(e, It.TITLE), r = fu(e, lh.TITLE_TEMPLATE); if (r && n) return r.replace(/%s/g, function () { return Array.isArray(n) ? n.join("") : n }); var i = fu(e, lh.DEFAULT_TITLE); return n || i || void 0 }, wle = function (e) { return fu(e, lh.ON_CHANGE_CLIENT_STATE) || function () { } }, bb = function (e, n) { return n.filter(function (r) { return typeof r[e] < "u" }).map(function (r) { return r[e] }).reduce(function (r, i) { return pi({}, r, i) }, {}) }, Sle = function (e, n) { return n.filter(function (r) { return typeof r[It.BASE] < "u" }).map(function (r) { return r[It.BASE] }).reverse().reduce(function (r, i) { if (!r.length) for (var s = Object.keys(i), a = 0; a < s.length; a++) { var l = s[a], u = l.toLowerCase(); if (e.indexOf(u) !== -1 && i[u]) return r.concat(i) } return r }, []) }, qd = function (e, n, r) { var i = {}; return r.filter(function (s) { return Array.isArray(s[e]) ? !0 : (typeof s[e] < "u" && jle("Helmet: " + e + ' should be of type "Array". Instead found type "' + mle(s[e]) + '"'), !1) }).map(function (s) { return s[e] }).reverse().reduce(function (s, a) { var l = {}; a.filter(function (y) { for (var v = void 0, b = Object.keys(y), S = 0; S < b.length; S++) { var C = b[S], T = C.toLowerCase(); n.indexOf(T) !== -1 && !(v === _n.REL && y[v].toLowerCase() === "canonical") && !(T === _n.REL && y[T].toLowerCase() === "stylesheet") && (v = T), n.indexOf(C) !== -1 && (C === _n.INNER_HTML || C === _n.CSS_TEXT || C === _n.ITEM_PROP) && (v = C) } if (!v || !y[v]) return !1; var A = y[v].toLowerCase(); return i[v] || (i[v] = {}), l[v] || (l[v] = {}), i[v][A] ? !1 : (l[v][A] = !0, !0) }).reverse().forEach(function (y) { return s.push(y) }); for (var u = Object.keys(l), f = 0; f < u.length; f++) { var p = u[f], g = fle({}, i[p], l[p]); i[p] = g } return s }, []).reverse() }, fu = function (e, n) { for (var r = e.length - 1; r >= 0; r--) { var i = e[r]; if (i.hasOwnProperty(n)) return i[n] } return null }, Cle = function (e) { return { baseTag: Sle([_n.HREF, _n.TARGET], e), bodyAttributes: bb(Yl.BODY, e), defer: fu(e, lh.DEFER), encode: fu(e, lh.ENCODE_SPECIAL_CHARACTERS), htmlAttributes: bb(Yl.HTML, e), linkTags: qd(It.LINK, [_n.REL, _n.HREF], e), metaTags: qd(It.META, [_n.NAME, _n.CHARSET, _n.HTTPEQUIV, _n.PROPERTY, _n.ITEM_PROP], e), noscriptTags: qd(It.NOSCRIPT, [_n.INNER_HTML], e), onChangeClientState: wle(e), scriptTags: qd(It.SCRIPT, [_n.SRC, _n.INNER_HTML], e), styleTags: qd(It.STYLE, [_n.CSS_TEXT], e), title: ble(e), titleAttributes: bb(Yl.TITLE, e) } }, mw = function () { var t = Date.now(); return function (e) { var n = Date.now(); n - t > 16 ? (t = n, e(n)) : setTimeout(function () { mw(e) }, 0) } }(), z3 = function (e) { return clearTimeout(e) }, Tle = typeof window < "u" ? window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || mw : global.requestAnimationFrame || mw, Nle = typeof window < "u" ? window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || z3 : global.cancelAnimationFrame || z3, jle = function (e) { return console && typeof console.warn == "function" && console.warn(e) }, Kd = null, Ele = function (e) { Kd && Nle(Kd), e.defer ? Kd = Tle(function () { I3(e, function () { Kd = null }) }) : (I3(e), Kd = null) }, I3 = function (e, n) { var r = e.baseTag, i = e.bodyAttributes, s = e.htmlAttributes, a = e.linkTags, l = e.metaTags, u = e.noscriptTags, f = e.onChangeClientState, p = e.scriptTags, g = e.styleTags, y = e.title, v = e.titleAttributes; gw(It.BODY, i), gw(It.HTML, s), Ale(y, v); var b = { baseTag: Yc(It.BASE, r), linkTags: Yc(It.LINK, a), metaTags: Yc(It.META, l), noscriptTags: Yc(It.NOSCRIPT, u), scriptTags: Yc(It.SCRIPT, p), styleTags: Yc(It.STYLE, g) }, S = {}, C = {}; Object.keys(b).forEach(function (T) { var A = b[T], M = A.newTags, O = A.oldTags; M.length && (S[T] = M), O.length && (C[T] = b[T].oldTags) }), n && n(), f(e, S, C) }, z6 = function (e) { return Array.isArray(e) ? e.join("") : e }, Ale = function (e, n) { typeof e < "u" && document.title !== e && (document.title = z6(e)), gw(It.TITLE, n) }, gw = function (e, n) { var r = document.getElementsByTagName(e)[0]; if (r) { for (var i = r.getAttribute(Ns), s = i ? i.split(",") : [], a = [].concat(s), l = Object.keys(n), u = 0; u < l.length; u++) { var f = l[u], p = n[f] || ""; r.getAttribute(f) !== p && r.setAttribute(f, p), s.indexOf(f) === -1 && s.push(f); var g = a.indexOf(f); g !== -1 && a.splice(g, 1) } for (var y = a.length - 1; y >= 0; y--)r.removeAttribute(a[y]); s.length === a.length ? r.removeAttribute(Ns) : r.getAttribute(Ns) !== l.join(",") && r.setAttribute(Ns, l.join(",")) } }, Yc = function (e, n) { var r = document.head || document.querySelector(It.HEAD), i = r.querySelectorAll(e + "[" + Ns + "]"), s = Array.prototype.slice.call(i), a = [], l = void 0; return n && n.length && n.forEach(function (u) { var f = document.createElement(e); for (var p in u) if (u.hasOwnProperty(p)) if (p === _n.INNER_HTML) f.innerHTML = u.innerHTML; else if (p === _n.CSS_TEXT) f.styleSheet ? f.styleSheet.cssText = u.cssText : f.appendChild(document.createTextNode(u.cssText)); else { var g = typeof u[p] > "u" ? "" : u[p]; f.setAttribute(p, g) } f.setAttribute(Ns, "true"), s.some(function (y, v) { return l = v, f.isEqualNode(y) }) ? s.splice(l, 1) : a.push(f) }), s.forEach(function (u) { return u.parentNode.removeChild(u) }), a.forEach(function (u) { return r.appendChild(u) }), { oldTags: s, newTags: a } }, I6 = function (e) { return Object.keys(e).reduce(function (n, r) { var i = typeof e[r] < "u" ? r + '="' + e[r] + '"' : "" + r; return n ? n + " " + i : i }, "") }, kle = function (e, n, r, i) { var s = I6(r), a = z6(n); return s ? "<" + e + " " + Ns + '="true" ' + s + ">" + pw(a, i) + "</" + e + ">" : "<" + e + " " + Ns + '="true">' + pw(a, i) + "</" + e + ">" }, Ole = function (e, n, r) { return n.reduce(function (i, s) { var a = Object.keys(s).filter(function (f) { return !(f === _n.INNER_HTML || f === _n.CSS_TEXT) }).reduce(function (f, p) { var g = typeof s[p] > "u" ? p : p + '="' + pw(s[p], r) + '"'; return f ? f + " " + g : g }, ""), l = s.innerHTML || s.cssText || "", u = ple.indexOf(e) === -1; return i + "<" + e + " " + Ns + '="true" ' + a + (u ? "/>" : ">" + l + "</" + e + ">") }, "") }, F6 = function (e) { var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; return Object.keys(e).reduce(function (r, i) { return r[ty[i] || i] = e[i], r }, n) }, Mle = function (e) { var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; return Object.keys(e).reduce(function (r, i) { return r[hle[i] || i] = e[i], r }, n) }, Dle = function (e, n, r) { var i, s = (i = { key: n }, i[Ns] = !0, i), a = F6(r, s); return [Pt.createElement(It.TITLE, a, n)] }, Rle = function (e, n) { return n.map(function (r, i) { var s, a = (s = { key: i }, s[Ns] = !0, s); return Object.keys(r).forEach(function (l) { var u = ty[l] || l; if (u === _n.INNER_HTML || u === _n.CSS_TEXT) { var f = r.innerHTML || r.cssText; a.dangerouslySetInnerHTML = { __html: f } } else a[u] = r[l] }), Pt.createElement(e, a) }) }, Aa = function (e, n, r) { switch (e) { case It.TITLE: return { toComponent: function () { return Dle(e, n.title, n.titleAttributes) }, toString: function () { return kle(e, n.title, n.titleAttributes, r) } }; case Yl.BODY: case Yl.HTML: return { toComponent: function () { return F6(n) }, toString: function () { return I6(n) } }; default: return { toComponent: function () { return Rle(e, n) }, toString: function () { return Ole(e, n, r) } } } }, B6 = function (e) { var n = e.baseTag, r = e.bodyAttributes, i = e.encode, s = e.htmlAttributes, a = e.linkTags, l = e.metaTags, u = e.noscriptTags, f = e.scriptTags, p = e.styleTags, g = e.title, y = g === void 0 ? "" : g, v = e.titleAttributes; return { base: Aa(It.BASE, n, i), bodyAttributes: Aa(Yl.BODY, r, i), htmlAttributes: Aa(Yl.HTML, s, i), link: Aa(It.LINK, a, i), meta: Aa(It.META, l, i), noscript: Aa(It.NOSCRIPT, u, i), script: Aa(It.SCRIPT, f, i), style: Aa(It.STYLE, p, i), title: Aa(It.TITLE, { title: y, titleAttributes: v }, i) } }, _le = function (e) { var n, r; return r = n = function (i) { vle(s, i); function s() { return gle(this, s), xle(this, i.apply(this, arguments)) } return s.prototype.shouldComponentUpdate = function (l) { return !cle(this.props, l) }, s.prototype.mapNestedChildrenToProps = function (l, u) { if (!u) return null; switch (l.type) { case It.SCRIPT: case It.NOSCRIPT: return { innerHTML: u }; case It.STYLE: return { cssText: u } }throw new Error("<" + l.type + " /> elements are self-closing and can not contain children. Refer to our API for more information.") }, s.prototype.flattenArrayTypeChildren = function (l) { var u, f = l.child, p = l.arrayTypeChildren, g = l.newChildProps, y = l.nestedChildren; return pi({}, p, (u = {}, u[f.type] = [].concat(p[f.type] || [], [pi({}, g, this.mapNestedChildrenToProps(f, y))]), u)) }, s.prototype.mapObjectTypeChildren = function (l) { var u, f, p = l.child, g = l.newProps, y = l.newChildProps, v = l.nestedChildren; switch (p.type) { case It.TITLE: return pi({}, g, (u = {}, u[p.type] = v, u.titleAttributes = pi({}, y), u)); case It.BODY: return pi({}, g, { bodyAttributes: pi({}, y) }); case It.HTML: return pi({}, g, { htmlAttributes: pi({}, y) }) }return pi({}, g, (f = {}, f[p.type] = pi({}, y), f)) }, s.prototype.mapArrayTypeChildrenToProps = function (l, u) { var f = pi({}, u); return Object.keys(l).forEach(function (p) { var g; f = pi({}, f, (g = {}, g[p] = l[p], g)) }), f }, s.prototype.warnOnInvalidChildren = function (l, u) { return !0 }, s.prototype.mapChildrenToProps = function (l, u) { var f = this, p = {}; return Pt.Children.forEach(l, function (g) { if (!(!g || !g.props)) { var y = g.props, v = y.children, b = P3(y, ["children"]), S = Mle(b); switch (f.warnOnInvalidChildren(g, v), g.type) { case It.LINK: case It.META: case It.NOSCRIPT: case It.SCRIPT: case It.STYLE: p = f.flattenArrayTypeChildren({ child: g, arrayTypeChildren: p, newChildProps: S, nestedChildren: v }); break; default: u = f.mapObjectTypeChildren({ child: g, newProps: u, newChildProps: S, nestedChildren: v }); break } } }), u = this.mapArrayTypeChildrenToProps(p, u), u }, s.prototype.render = function () { var l = this.props, u = l.children, f = P3(l, ["children"]), p = pi({}, f); return u && (p = this.mapChildrenToProps(u, p)), Pt.createElement(e, p) }, yle(s, null, [{ key: "canUseDOM", set: function (l) { e.canUseDOM = l } }]), s }(Pt.Component), n.propTypes = { base: Dn.object, bodyAttributes: Dn.object, children: Dn.oneOfType([Dn.arrayOf(Dn.node), Dn.node]), defaultTitle: Dn.string, defer: Dn.bool, encodeSpecialCharacters: Dn.bool, htmlAttributes: Dn.object, link: Dn.arrayOf(Dn.object), meta: Dn.arrayOf(Dn.object), noscript: Dn.arrayOf(Dn.object), onChangeClientState: Dn.func, script: Dn.arrayOf(Dn.object), style: Dn.arrayOf(Dn.object), title: Dn.string, titleAttributes: Dn.object, titleTemplate: Dn.string }, n.defaultProps = { defer: !0, encodeSpecialCharacters: !0 }, n.peek = e.peek, n.rewind = function () { var i = e.rewind(); return i || (i = B6({ baseTag: [], bodyAttributes: {}, htmlAttributes: {}, linkTags: [], metaTags: [], noscriptTags: [], scriptTags: [], styleTags: [], title: "", titleAttributes: {} })), i }, r }, Lle = function () { return null }, Ple = ale(Cle, Ele, B6)(Lle), F3 = _le(Ple); F3.renderStatic = F3.rewind; function zle() { const t = ln(); return N.useEffect(() => { t("/") }, []), d.jsx(d.Fragment, {}) } var Ah = t => t.type === "checkbox", Pl = t => t instanceof Date, ri = t => t == null; const $6 = t => typeof t == "object"; var ir = t => !ri(t) && !Array.isArray(t) && $6(t) && !Pl(t), Ile = t => ir(t) && t.target ? Ah(t.target) ? t.target.checked : t.target.value : t, Fle = t => t.substring(0, t.search(/\.\d+(\.|$)/)) || t, Ble = (t, e) => t.has(Fle(e)), $le = t => { const e = t.constructor && t.constructor.prototype; return ir(e) && e.hasOwnProperty("isPrototypeOf") }, R2 = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u"; function Tr(t) { let e; const n = Array.isArray(t), r = typeof FileList < "u" ? t instanceof FileList : !1; if (t instanceof Date) e = new Date(t); else if (!(R2 && (t instanceof Blob || r)) && (n || ir(t))) if (e = n ? [] : {}, !n && !$le(t)) e = t; else for (const i in t) t.hasOwnProperty(i) && (e[i] = Tr(t[i])); else return t; return e } var Yy = t => /^\w*$/.test(t), cr = t => t === void 0, _2 = t => Array.isArray(t) ? t.filter(Boolean) : [], L2 = t => _2(t.replace(/["|']|\]/g, "").split(/\.|\[/)), yt = (t, e, n) => { if (!e || !ir(t)) return n; const r = (Yy(e) ? [e] : L2(e)).reduce((i, s) => ri(i) ? i : i[s], t); return cr(r) || r === t ? cr(t[e]) ? n : t[e] : r }, Ks = t => typeof t == "boolean", Rn = (t, e, n) => { let r = -1; const i = Yy(e) ? [e] : L2(e), s = i.length, a = s - 1; for (; ++r < s;) { const l = i[r]; let u = n; if (r !== a) { const f = t[l]; u = ir(f) || Array.isArray(f) ? f : isNaN(+i[r + 1]) ? {} : [] } if (l === "__proto__" || l === "constructor" || l === "prototype") return; t[l] = u, t = t[l] } }; const B3 = { BLUR: "blur", FOCUS_OUT: "focusout" }, ws = { onBlur: "onBlur", onChange: "onChange", onSubmit: "onSubmit", onTouched: "onTouched", all: "all" }, ka = { max: "max", min: "min", maxLength: "maxLength", minLength: "minLength", pattern: "pattern", required: "required", validate: "validate" }, Ule = Pt.createContext(null); Ule.displayName = "HookFormContext"; var Vle = (t, e, n, r = !0) => { const i = { defaultValues: e._defaultValues }; for (const s in t) Object.defineProperty(i, s, { get: () => { const a = s; return e._proxyFormState[a] !== ws.all && (e._proxyFormState[a] = !r || ws.all), t[a] } }); return i }; const Hle = typeof window < "u" ? Pt.useLayoutEffect : Pt.useEffect; var Gs = t => typeof t == "string", qle = (t, e, n, r, i) => Gs(t) ? (r && e.watch.add(t), yt(n, t, i)) : Array.isArray(t) ? t.map(s => (r && e.watch.add(s), yt(n, s))) : (r && (e.watchAll = !0), n), yw = t => ri(t) || !$6(t); function ko(t, e, n = new WeakSet) { if (yw(t) || yw(e)) return t === e; if (Pl(t) && Pl(e)) return t.getTime() === e.getTime(); const r = Object.keys(t), i = Object.keys(e); if (r.length !== i.length) return !1; if (n.has(t) || n.has(e)) return !0; n.add(t), n.add(e); for (const s of r) { const a = t[s]; if (!i.includes(s)) return !1; if (s !== "ref") { const l = e[s]; if (Pl(a) && Pl(l) || ir(a) && ir(l) || Array.isArray(a) && Array.isArray(l) ? !ko(a, l, n) : a !== l) return !1 } } return !0 } var Kle = (t, e, n, r, i) => e ? { ...n[t], types: { ...n[t] && n[t].types ? n[t].types : {}, [r]: i || !0 } } : {}, Ef = t => Array.isArray(t) ? t : [t], $3 = () => { let t = []; return { get observers() { return t }, next: i => { for (const s of t) s.next && s.next(i) }, subscribe: i => (t.push(i), { unsubscribe: () => { t = t.filter(s => s !== i) } }), unsubscribe: () => { t = [] } } }, mi = t => ir(t) && !Object.keys(t).length, P2 = t => t.type === "file", Ss = t => typeof t == "function", ny = t => { if (!R2) return !1; const e = t ? t.ownerDocument : 0; return t instanceof (e && e.defaultView ? e.defaultView.HTMLElement : HTMLElement) }, U6 = t => t.type === "select-multiple", z2 = t => t.type === "radio", Wle = t => z2(t) || Ah(t), wb = t => ny(t) && t.isConnected; function Yle(t, e) { const n = e.slice(0, -1).length; let r = 0; for (; r < n;)t = cr(t) ? r++ : t[e[r++]]; return t } function Gle(t) { for (const e in t) if (t.hasOwnProperty(e) && !cr(t[e])) return !1; return !0 } function or(t, e) { const n = Array.isArray(e) ? e : Yy(e) ? [e] : L2(e), r = n.length === 1 ? t : Yle(t, n), i = n.length - 1, s = n[i]; return r && delete r[s], i !== 0 && (ir(r) && mi(r) || Array.isArray(r) && Gle(r)) && or(t, n.slice(0, -1)), t } var V6 = t => { for (const e in t) if (Ss(t[e])) return !0; return !1 }; function ry(t, e = {}) { const n = Array.isArray(t); if (ir(t) || n) for (const r in t) Array.isArray(t[r]) || ir(t[r]) && !V6(t[r]) ? (e[r] = Array.isArray(t[r]) ? [] : {}, ry(t[r], e[r])) : ri(t[r]) || (e[r] = !0); return e } function H6(t, e, n) { const r = Array.isArray(t); if (ir(t) || r) for (const i in t) Array.isArray(t[i]) || ir(t[i]) && !V6(t[i]) ? cr(e) || yw(n[i]) ? n[i] = Array.isArray(t[i]) ? ry(t[i], []) : { ...ry(t[i]) } : H6(t[i], ri(e) ? {} : e[i], n[i]) : n[i] = !ko(t[i], e[i]); return n } var Wd = (t, e) => H6(t, e, ry(e)); const U3 = { value: !1, isValid: !1 }, V3 = { value: !0, isValid: !0 }; var q6 = t => { if (Array.isArray(t)) { if (t.length > 1) { const e = t.filter(n => n && n.checked && !n.disabled).map(n => n.value); return { value: e, isValid: !!e.length } } return t[0].checked && !t[0].disabled ? t[0].attributes && !cr(t[0].attributes.value) ? cr(t[0].value) || t[0].value === "" ? V3 : { value: t[0].value, isValid: !0 } : V3 : U3 } return U3 }, K6 = (t, { valueAsNumber: e, valueAsDate: n, setValueAs: r }) => cr(t) ? t : e ? t === "" ? NaN : t && +t : n && Gs(t) ? new Date(t) : r ? r(t) : t; const H3 = { isValid: !1, value: null }; var W6 = t => Array.isArray(t) ? t.reduce((e, n) => n && n.checked && !n.disabled ? { isValid: !0, value: n.value } : e, H3) : H3; function q3(t) { const e = t.ref; return P2(e) ? e.files : z2(e) ? W6(t.refs).value : U6(e) ? [...e.selectedOptions].map(({ value: n }) => n) : Ah(e) ? q6(t.refs).value : K6(cr(e.value) ? t.ref.value : e.value, t) } var Xle = (t, e, n, r) => { const i = {}; for (const s of t) { const a = yt(e, s); a && Rn(i, s, a._f) } return { criteriaMode: n, names: [...t], fields: i, shouldUseNativeValidation: r } }, iy = t => t instanceof RegExp, Yd = t => cr(t) ? t : iy(t) ? t.source : ir(t) ? iy(t.value) ? t.value.source : t.value : t, K3 = t => ({ isOnSubmit: !t || t === ws.onSubmit, isOnBlur: t === ws.onBlur, isOnChange: t === ws.onChange, isOnAll: t === ws.all, isOnTouch: t === ws.onTouched }); const W3 = "AsyncFunction"; var Qle = t => !!t && !!t.validate && !!(Ss(t.validate) && t.validate.constructor.name === W3 || ir(t.validate) && Object.values(t.validate).find(e => e.constructor.name === W3)), Jle = t => t.mount && (t.required || t.min || t.max || t.maxLength || t.minLength || t.pattern || t.validate), Y3 = (t, e, n) => !n && (e.watchAll || e.watch.has(t) || [...e.watch].some(r => t.startsWith(r) && /^\.\w+/.test(t.slice(r.length)))); const Af = (t, e, n, r) => { for (const i of n || Object.keys(t)) { const s = yt(t, i); if (s) { const { _f: a, ...l } = s; if (a) { if (a.refs && a.refs[0] && e(a.refs[0], i) && !r) return !0; if (a.ref && e(a.ref, a.name) && !r) return !0; if (Af(l, e)) break } else if (ir(l) && Af(l, e)) break } } }; function G3(t, e, n) { const r = yt(t, n); if (r || Yy(n)) return { error: r, name: n }; const i = n.split("."); for (; i.length;) { const s = i.join("."), a = yt(e, s), l = yt(t, s); if (a && !Array.isArray(a) && n !== s) return { name: n }; if (l && l.type) return { name: s, error: l }; if (l && l.root && l.root.type) return { name: `${s}.root`, error: l.root }; i.pop() } return { name: n } } var Zle = (t, e, n, r) => { n(t); const { name: i, ...s } = t; return mi(s) || Object.keys(s).length >= Object.keys(e).length || Object.keys(s).find(a => e[a] === (!r || ws.all)) }, ece = (t, e, n) => !t || !e || t === e || Ef(t).some(r => r && (n ? r === e : r.startsWith(e) || e.startsWith(r))), tce = (t, e, n, r, i) => i.isOnAll ? !1 : !n && i.isOnTouch ? !(e || t) : (n ? r.isOnBlur : i.isOnBlur) ? !t : (n ? r.isOnChange : i.isOnChange) ? t : !0, nce = (t, e) => !_2(yt(t, e)).length && or(t, e), rce = (t, e, n) => { const r = Ef(yt(t, n)); return Rn(r, "root", e[n]), Rn(t, n, r), t }, Fm = t => Gs(t); function X3(t, e, n = "validate") { if (Fm(t) || Array.isArray(t) && t.every(Fm) || Ks(t) && !t) return { type: n, message: Fm(t) ? t : "", ref: e } } var Gc = t => ir(t) && !iy(t) ? t : { value: t, message: "" }, Q3 = async (t, e, n, r, i, s) => { const { ref: a, refs: l, required: u, maxLength: f, minLength: p, min: g, max: y, pattern: v, validate: b, name: S, valueAsNumber: C, mount: T } = t._f, A = yt(n, S); if (!T || e.has(S)) return {}; const M = l ? l[0] : a, O = ne => { i && M.reportValidity && (M.setCustomValidity(Ks(ne) ? "" : ne || ""), M.reportValidity()) }, E = {}, k = z2(a), z = Ah(a), V = k || z, q = (C || P2(a)) && cr(a.value) && cr(A) || ny(a) && a.value === "" || A === "" || Array.isArray(A) && !A.length, ue = Kle.bind(null, S, r, E), W = (ne, H, we, xe = ka.maxLength, K = ka.minLength) => { const te = ne ? H : we; E[S] = { type: ne ? xe : K, message: te, ref: a, ...ue(ne ? xe : K, te) } }; if (s ? !Array.isArray(A) || !A.length : u && (!V && (q || ri(A)) || Ks(A) && !A || z && !q6(l).isValid || k && !W6(l).isValid)) { const { value: ne, message: H } = Fm(u) ? { value: !!u, message: u } : Gc(u); if (ne && (E[S] = { type: ka.required, message: H, ref: M, ...ue(ka.required, H) }, !r)) return O(H), E } if (!q && (!ri(g) || !ri(y))) { let ne, H; const we = Gc(y), xe = Gc(g); if (!ri(A) && !isNaN(A)) { const K = a.valueAsNumber || A && +A; ri(we.value) || (ne = K > we.value), ri(xe.value) || (H = K < xe.value) } else { const K = a.valueAsDate || new Date(A), te = B => new Date(new Date().toDateString() + " " + B), ye = a.type == "time", He = a.type == "week"; Gs(we.value) && A && (ne = ye ? te(A) > te(we.value) : He ? A > we.value : K > new Date(we.value)), Gs(xe.value) && A && (H = ye ? te(A) < te(xe.value) : He ? A < xe.value : K < new Date(xe.value)) } if ((ne || H) && (W(!!ne, we.message, xe.message, ka.max, ka.min), !r)) return O(E[S].message), E } if ((f || p) && !q && (Gs(A) || s && Array.isArray(A))) { const ne = Gc(f), H = Gc(p), we = !ri(ne.value) && A.length > +ne.value, xe = !ri(H.value) && A.length < +H.value; if ((we || xe) && (W(we, ne.message, H.message), !r)) return O(E[S].message), E } if (v && !q && Gs(A)) { const { value: ne, message: H } = Gc(v); if (iy(ne) && !A.match(ne) && (E[S] = { type: ka.pattern, message: H, ref: a, ...ue(ka.pattern, H) }, !r)) return O(H), E } if (b) { if (Ss(b)) { const ne = await b(A, n), H = X3(ne, M); if (H && (E[S] = { ...H, ...ue(ka.validate, H.message) }, !r)) return O(H.message), E } else if (ir(b)) { let ne = {}; for (const H in b) { if (!mi(ne) && !r) break; const we = X3(await b[H](A, n), M, H); we && (ne = { ...we, ...ue(H, we.message) }, O(we.message), r && (E[S] = ne)) } if (!mi(ne) && (E[S] = { ref: M, ...ne }, !r)) return E } } return O(!0), E }; const ice = { mode: ws.onSubmit, reValidateMode: ws.onChange, shouldFocusError: !0 }; function sce(t = {}) { let e = { ...ice, ...t }, n = { submitCount: 0, isDirty: !1, isReady: !1, isLoading: Ss(e.defaultValues), isValidating: !1, isSubmitted: !1, isSubmitting: !1, isSubmitSuccessful: !1, isValid: !1, touchedFields: {}, dirtyFields: {}, validatingFields: {}, errors: e.errors || {}, disabled: e.disabled || !1 }, r = {}, i = ir(e.defaultValues) || ir(e.values) ? Tr(e.defaultValues || e.values) || {} : {}, s = e.shouldUnregister ? {} : Tr(i), a = { action: !1, mount: !1, watch: !1 }, l = { mount: new Set, disabled: new Set, unMount: new Set, array: new Set, watch: new Set }, u, f = 0; const p = { isDirty: !1, dirtyFields: !1, validatingFields: !1, touchedFields: !1, isValidating: !1, isValid: !1, errors: !1 }; let g = { ...p }; const y = { array: $3(), state: $3() }, v = e.criteriaMode === ws.all, b = P => ee => { clearTimeout(f), f = setTimeout(P, ee) }, S = async P => { if (!e.disabled && (p.isValid || g.isValid || P)) { const ee = e.resolver ? mi((await z()).errors) : await q(r, !0); ee !== n.isValid && y.state.next({ isValid: ee }) } }, C = (P, ee) => { !e.disabled && (p.isValidating || p.validatingFields || g.isValidating || g.validatingFields) && ((P || Array.from(l.mount)).forEach(_ => { _ && (ee ? Rn(n.validatingFields, _, ee) : or(n.validatingFields, _)) }), y.state.next({ validatingFields: n.validatingFields, isValidating: !mi(n.validatingFields) })) }, T = (P, ee = [], _, I, se = !0, ae = !0) => { if (I && _ && !e.disabled) { if (a.action = !0, ae && Array.isArray(yt(r, P))) { const Ae = _(yt(r, P), I.argA, I.argB); se && Rn(r, P, Ae) } if (ae && Array.isArray(yt(n.errors, P))) { const Ae = _(yt(n.errors, P), I.argA, I.argB); se && Rn(n.errors, P, Ae), nce(n.errors, P) } if ((p.touchedFields || g.touchedFields) && ae && Array.isArray(yt(n.touchedFields, P))) { const Ae = _(yt(n.touchedFields, P), I.argA, I.argB); se && Rn(n.touchedFields, P, Ae) } (p.dirtyFields || g.dirtyFields) && (n.dirtyFields = Wd(i, s)), y.state.next({ name: P, isDirty: W(P, ee), dirtyFields: n.dirtyFields, errors: n.errors, isValid: n.isValid }) } else Rn(s, P, ee) }, A = (P, ee) => { Rn(n.errors, P, ee), y.state.next({ errors: n.errors }) }, M = P => { n.errors = P, y.state.next({ errors: n.errors, isValid: !1 }) }, O = (P, ee, _, I) => { const se = yt(r, P); if (se) { const ae = yt(s, P, cr(_) ? yt(i, P) : _); cr(ae) || I && I.defaultChecked || ee ? Rn(s, P, ee ? ae : q3(se._f)) : we(P, ae), a.mount && S() } }, E = (P, ee, _, I, se) => { let ae = !1, Ae = !1; const qe = { name: P }; if (!e.disabled) { if (!_ || I) { (p.isDirty || g.isDirty) && (Ae = n.isDirty, n.isDirty = qe.isDirty = W(), ae = Ae !== qe.isDirty); const rt = ko(yt(i, P), ee); Ae = !!yt(n.dirtyFields, P), rt ? or(n.dirtyFields, P) : Rn(n.dirtyFields, P, !0), qe.dirtyFields = n.dirtyFields, ae = ae || (p.dirtyFields || g.dirtyFields) && Ae !== !rt } if (_) { const rt = yt(n.touchedFields, P); rt || (Rn(n.touchedFields, P, _), qe.touchedFields = n.touchedFields, ae = ae || (p.touchedFields || g.touchedFields) && rt !== _) } ae && se && y.state.next(qe) } return ae ? qe : {} }, k = (P, ee, _, I) => { const se = yt(n.errors, P), ae = (p.isValid || g.isValid) && Ks(ee) && n.isValid !== ee; if (e.delayError && _ ? (u = b(() => A(P, _)), u(e.delayError)) : (clearTimeout(f), u = null, _ ? Rn(n.errors, P, _) : or(n.errors, P)), (_ ? !ko(se, _) : se) || !mi(I) || ae) { const Ae = { ...I, ...ae && Ks(ee) ? { isValid: ee } : {}, errors: n.errors, name: P }; n = { ...n, ...Ae }, y.state.next(Ae) } }, z = async P => { C(P, !0); const ee = await e.resolver(s, e.context, Xle(P || l.mount, r, e.criteriaMode, e.shouldUseNativeValidation)); return C(P), ee }, V = async P => { const { errors: ee } = await z(P); if (P) for (const _ of P) { const I = yt(ee, _); I ? Rn(n.errors, _, I) : or(n.errors, _) } else n.errors = ee; return ee }, q = async (P, ee, _ = { valid: !0 }) => { for (const I in P) { const se = P[I]; if (se) { const { _f: ae, ...Ae } = se; if (ae) { const qe = l.array.has(ae.name), rt = se._f && Qle(se._f); rt && p.validatingFields && C([I], !0); const Tt = await Q3(se, l.disabled, s, v, e.shouldUseNativeValidation && !ee, qe); if (rt && p.validatingFields && C([I]), Tt[ae.name] && (_.valid = !1, ee)) break; !ee && (yt(Tt, ae.name) ? qe ? rce(n.errors, Tt, ae.name) : Rn(n.errors, ae.name, Tt[ae.name]) : or(n.errors, ae.name)) } !mi(Ae) && await q(Ae, ee, _) } } return _.valid }, ue = () => { for (const P of l.unMount) { const ee = yt(r, P); ee && (ee._f.refs ? ee._f.refs.every(_ => !wb(_)) : !wb(ee._f.ref)) && et(P) } l.unMount = new Set }, W = (P, ee) => !e.disabled && (P && ee && Rn(s, P, ee), !ko(B(), i)), ne = (P, ee, _) => qle(P, l, { ...a.mount ? s : cr(ee) ? i : Gs(P) ? { [P]: ee } : ee }, _, ee), H = P => _2(yt(a.mount ? s : i, P, e.shouldUnregister ? yt(i, P, []) : [])), we = (P, ee, _ = {}) => { const I = yt(r, P); let se = ee; if (I) { const ae = I._f; ae && (!ae.disabled && Rn(s, P, K6(ee, ae)), se = ny(ae.ref) && ri(ee) ? "" : ee, U6(ae.ref) ? [...ae.ref.options].forEach(Ae => Ae.selected = se.includes(Ae.value)) : ae.refs ? Ah(ae.ref) ? ae.refs.forEach(Ae => { (!Ae.defaultChecked || !Ae.disabled) && (Array.isArray(se) ? Ae.checked = !!se.find(qe => qe === Ae.value) : Ae.checked = se === Ae.value || !!se) }) : ae.refs.forEach(Ae => Ae.checked = Ae.value === se) : P2(ae.ref) ? ae.ref.value = "" : (ae.ref.value = se, ae.ref.type || y.state.next({ name: P, values: Tr(s) }))) } (_.shouldDirty || _.shouldTouch) && E(P, se, _.shouldTouch, _.shouldDirty, !0), _.shouldValidate && He(P) }, xe = (P, ee, _) => { for (const I in ee) { if (!ee.hasOwnProperty(I)) return; const se = ee[I], ae = P + "." + I, Ae = yt(r, ae); (l.array.has(P) || ir(se) || Ae && !Ae._f) && !Pl(se) ? xe(ae, se, _) : we(ae, se, _) } }, K = (P, ee, _ = {}) => { const I = yt(r, P), se = l.array.has(P), ae = Tr(ee); Rn(s, P, ae), se ? (y.array.next({ name: P, values: Tr(s) }), (p.isDirty || p.dirtyFields || g.isDirty || g.dirtyFields) && _.shouldDirty && y.state.next({ name: P, dirtyFields: Wd(i, s), isDirty: W(P, ae) })) : I && !I._f && !ri(ae) ? xe(P, ae, _) : we(P, ae, _), Y3(P, l) && y.state.next({ ...n, name: P }), y.state.next({ name: a.mount ? P : void 0, values: Tr(s) }) }, te = async P => { a.mount = !0; const ee = P.target; let _ = ee.name, I = !0; const se = yt(r, _), ae = rt => { I = Number.isNaN(rt) || Pl(rt) && isNaN(rt.getTime()) || ko(rt, yt(s, _, rt)) }, Ae = K3(e.mode), qe = K3(e.reValidateMode); if (se) { let rt, Tt; const yn = ee.type ? q3(se._f) : Ile(P), Gt = P.type === B3.BLUR || P.type === B3.FOCUS_OUT, $n = !Jle(se._f) && !e.resolver && !yt(n.errors, _) && !se._f.deps || tce(Gt, yt(n.touchedFields, _), n.isSubmitted, qe, Ae), cn = Y3(_, l, Gt); Rn(s, _, yn), Gt ? (se._f.onBlur && se._f.onBlur(P), u && u(0)) : se._f.onChange && se._f.onChange(P); const je = E(_, yn, Gt), tt = !mi(je) || cn; if (!Gt && y.state.next({ name: _, type: P.type, values: Tr(s) }), $n) return (p.isValid || g.isValid) && (e.mode === "onBlur" ? Gt && S() : Gt || S()), tt && y.state.next({ name: _, ...cn ? {} : je }); if (!Gt && cn && y.state.next({ ...n }), e.resolver) { const { errors: lt } = await z([_]); if (ae(yn), I) { const le = G3(n.errors, r, _), st = G3(lt, r, le.name || _); rt = st.error, _ = st.name, Tt = mi(lt) } } else C([_], !0), rt = (await Q3(se, l.disabled, s, v, e.shouldUseNativeValidation))[_], C([_]), ae(yn), I && (rt ? Tt = !1 : (p.isValid || g.isValid) && (Tt = await q(r, !0))); I && (se._f.deps && He(se._f.deps), k(_, Tt, rt, je)) } }, ye = (P, ee) => { if (yt(n.errors, ee) && P.focus) return P.focus(), 1 }, He = async (P, ee = {}) => { let _, I; const se = Ef(P); if (e.resolver) { const ae = await V(cr(P) ? P : se); _ = mi(ae), I = P ? !se.some(Ae => yt(ae, Ae)) : _ } else P ? (I = (await Promise.all(se.map(async ae => { const Ae = yt(r, ae); return await q(Ae && Ae._f ? { [ae]: Ae } : Ae) }))).every(Boolean), !(!I && !n.isValid) && S()) : I = _ = await q(r); return y.state.next({ ...!Gs(P) || (p.isValid || g.isValid) && _ !== n.isValid ? {} : { name: P }, ...e.resolver || !P ? { isValid: _ } : {}, errors: n.errors }), ee.shouldFocus && !I && Af(r, ye, P ? se : l.mount), I }, B = P => { const ee = { ...a.mount ? s : i }; return cr(P) ? ee : Gs(P) ? yt(ee, P) : P.map(_ => yt(ee, _)) }, ie = (P, ee) => ({ invalid: !!yt((ee || n).errors, P), isDirty: !!yt((ee || n).dirtyFields, P), error: yt((ee || n).errors, P), isValidating: !!yt(n.validatingFields, P), isTouched: !!yt((ee || n).touchedFields, P) }), oe = P => { P && Ef(P).forEach(ee => or(n.errors, ee)), y.state.next({ errors: P ? n.errors : {} }) }, pe = (P, ee, _) => { const I = (yt(r, P, { _f: {} })._f || {}).ref, se = yt(n.errors, P) || {}, { ref: ae, message: Ae, type: qe, ...rt } = se; Rn(n.errors, P, { ...rt, ...ee, ref: I }), y.state.next({ name: P, errors: n.errors, isValid: !1 }), _ && _.shouldFocus && I && I.focus && I.focus() }, Ee = (P, ee) => Ss(P) ? y.state.subscribe({ next: _ => "values" in _ && P(ne(void 0, ee), _) }) : ne(P, ee, !0), fe = P => y.state.subscribe({ next: ee => { ece(P.name, ee.name, P.exact) && Zle(ee, P.formState || p, be, P.reRenderRoot) && P.callback({ values: { ...s }, ...n, ...ee, defaultValues: i }) } }).unsubscribe, Oe = P => (a.mount = !0, g = { ...g, ...P.formState }, fe({ ...P, formState: g })), et = (P, ee = {}) => { for (const _ of P ? Ef(P) : l.mount) l.mount.delete(_), l.array.delete(_), ee.keepValue || (or(r, _), or(s, _)), !ee.keepError && or(n.errors, _), !ee.keepDirty && or(n.dirtyFields, _), !ee.keepTouched && or(n.touchedFields, _), !ee.keepIsValidating && or(n.validatingFields, _), !e.shouldUnregister && !ee.keepDefaultValue && or(i, _); y.state.next({ values: Tr(s) }), y.state.next({ ...n, ...ee.keepDirty ? { isDirty: W() } : {} }), !ee.keepIsValid && S() }, Xe = ({ disabled: P, name: ee }) => { (Ks(P) && a.mount || P || l.disabled.has(ee)) && (P ? l.disabled.add(ee) : l.disabled.delete(ee)) }, De = (P, ee = {}) => { let _ = yt(r, P); const I = Ks(ee.disabled) || Ks(e.disabled); return Rn(r, P, { ..._ || {}, _f: { ..._ && _._f ? _._f : { ref: { name: P } }, name: P, mount: !0, ...ee } }), l.mount.add(P), _ ? Xe({ disabled: Ks(ee.disabled) ? ee.disabled : e.disabled, name: P }) : O(P, !0, ee.value), { ...I ? { disabled: ee.disabled || e.disabled } : {}, ...e.progressive ? { required: !!ee.required, min: Yd(ee.min), max: Yd(ee.max), minLength: Yd(ee.minLength), maxLength: Yd(ee.maxLength), pattern: Yd(ee.pattern) } : {}, name: P, onChange: te, onBlur: te, ref: se => { if (se) { De(P, ee), _ = yt(r, P); const ae = cr(se.value) && se.querySelectorAll && se.querySelectorAll("input,select,textarea")[0] || se, Ae = Wle(ae), qe = _._f.refs || []; if (Ae ? qe.find(rt => rt === ae) : ae === _._f.ref) return; Rn(r, P, { _f: { ..._._f, ...Ae ? { refs: [...qe.filter(wb), ae, ...Array.isArray(yt(i, P)) ? [{}] : []], ref: { type: ae.type, name: P } } : { ref: ae } } }), O(P, !1, void 0, ae) } else _ = yt(r, P, {}), _._f && (_._f.mount = !1), (e.shouldUnregister || ee.shouldUnregister) && !(Ble(l.array, P) && a.action) && l.unMount.add(P) } } }, he = () => e.shouldFocusError && Af(r, ye, l.mount), Be = P => { Ks(P) && (y.state.next({ disabled: P }), Af(r, (ee, _) => { const I = yt(r, _); I && (ee.disabled = I._f.disabled || P, Array.isArray(I._f.refs) && I._f.refs.forEach(se => { se.disabled = I._f.disabled || P })) }, 0, !1)) }, Y = (P, ee) => async _ => { let I; _ && (_.preventDefault && _.preventDefault(), _.persist && _.persist()); let se = Tr(s); if (y.state.next({ isSubmitting: !0 }), e.resolver) { const { errors: ae, values: Ae } = await z(); n.errors = ae, se = Tr(Ae) } else await q(r); if (l.disabled.size) for (const ae of l.disabled) or(se, ae); if (or(n.errors, "root"), mi(n.errors)) { y.state.next({ errors: {} }); try { await P(se, _) } catch (ae) { I = ae } } else ee && await ee({ ...n.errors }, _), he(), setTimeout(he); if (y.state.next({ isSubmitted: !0, isSubmitting: !1, isSubmitSuccessful: mi(n.errors) && !I, submitCount: n.submitCount + 1, errors: n.errors }), I) throw I }, Je = (P, ee = {}) => { yt(r, P) && (cr(ee.defaultValue) ? K(P, Tr(yt(i, P))) : (K(P, ee.defaultValue), Rn(i, P, Tr(ee.defaultValue))), ee.keepTouched || or(n.touchedFields, P), ee.keepDirty || (or(n.dirtyFields, P), n.isDirty = ee.defaultValue ? W(P, Tr(yt(i, P))) : W()), ee.keepError || (or(n.errors, P), p.isValid && S()), y.state.next({ ...n })) }, $e = (P, ee = {}) => { const _ = P ? Tr(P) : i, I = Tr(_), se = mi(P), ae = se ? i : I; if (ee.keepDefaultValues || (i = _), !ee.keepValues) { if (ee.keepDirtyValues) { const Ae = new Set([...l.mount, ...Object.keys(Wd(i, s))]); for (const qe of Array.from(Ae)) yt(n.dirtyFields, qe) ? Rn(ae, qe, yt(s, qe)) : K(qe, yt(ae, qe)) } else { if (R2 && cr(P)) for (const Ae of l.mount) { const qe = yt(r, Ae); if (qe && qe._f) { const rt = Array.isArray(qe._f.refs) ? qe._f.refs[0] : qe._f.ref; if (ny(rt)) { const Tt = rt.closest("form"); if (Tt) { Tt.reset(); break } } } } if (ee.keepFieldsRef) for (const Ae of l.mount) K(Ae, yt(ae, Ae)); else r = {} } s = e.shouldUnregister ? ee.keepDefaultValues ? Tr(i) : {} : Tr(ae), y.array.next({ values: { ...ae } }), y.state.next({ values: { ...ae } }) } l = { mount: ee.keepDirtyValues ? l.mount : new Set, unMount: new Set, array: new Set, disabled: new Set, watch: new Set, watchAll: !1, focus: "" }, a.mount = !p.isValid || !!ee.keepIsValid || !!ee.keepDirtyValues, a.watch = !!e.shouldUnregister, y.state.next({ submitCount: ee.keepSubmitCount ? n.submitCount : 0, isDirty: se ? !1 : ee.keepDirty ? n.isDirty : !!(ee.keepDefaultValues && !ko(P, i)), isSubmitted: ee.keepIsSubmitted ? n.isSubmitted : !1, dirtyFields: se ? {} : ee.keepDirtyValues ? ee.keepDefaultValues && s ? Wd(i, s) : n.dirtyFields : ee.keepDefaultValues && P ? Wd(i, P) : ee.keepDirty ? n.dirtyFields : {}, touchedFields: ee.keepTouched ? n.touchedFields : {}, errors: ee.keepErrors ? n.errors : {}, isSubmitSuccessful: ee.keepIsSubmitSuccessful ? n.isSubmitSuccessful : !1, isSubmitting: !1 }) }, $ = (P, ee) => $e(Ss(P) ? P(s) : P, ee), U = (P, ee = {}) => { const _ = yt(r, P), I = _ && _._f; if (I) { const se = I.refs ? I.refs[0] : I.ref; se.focus && (se.focus(), ee.shouldSelect && Ss(se.select) && se.select()) } }, be = P => { n = { ...n, ...P } }, it = { control: { register: De, unregister: et, getFieldState: ie, handleSubmit: Y, setError: pe, _subscribe: fe, _runSchema: z, _focusError: he, _getWatch: ne, _getDirty: W, _setValid: S, _setFieldArray: T, _setDisabledField: Xe, _setErrors: M, _getFieldArray: H, _reset: $e, _resetDefaultValues: () => Ss(e.defaultValues) && e.defaultValues().then(P => { $(P, e.resetOptions), y.state.next({ isLoading: !1 }) }), _removeUnmounted: ue, _disableForm: Be, _subjects: y, _proxyFormState: p, get _fields() { return r }, get _formValues() { return s }, get _state() { return a }, set _state(P) { a = P }, get _defaultValues() { return i }, get _names() { return l }, set _names(P) { l = P }, get _formState() { return n }, get _options() { return e }, set _options(P) { e = { ...e, ...P } } }, subscribe: Oe, trigger: He, register: De, handleSubmit: Y, watch: Ee, setValue: K, getValues: B, reset: $, resetField: Je, clearErrors: oe, unregister: et, setError: pe, setFocus: U, getFieldState: ie }; return { ...it, formControl: it } } function ace(t = {}) { const e = Pt.useRef(void 0), n = Pt.useRef(void 0), [r, i] = Pt.useState({ isDirty: !1, isValidating: !1, isLoading: Ss(t.defaultValues), isSubmitted: !1, isSubmitting: !1, isSubmitSuccessful: !1, isValid: !1, submitCount: 0, dirtyFields: {}, touchedFields: {}, validatingFields: {}, errors: t.errors || {}, disabled: t.disabled || !1, isReady: !1, defaultValues: Ss(t.defaultValues) ? void 0 : t.defaultValues }); if (!e.current) if (t.formControl) e.current = { ...t.formControl, formState: r }, t.defaultValues && !Ss(t.defaultValues) && t.formControl.reset(t.defaultValues, t.resetOptions); else { const { formControl: a, ...l } = sce(t); e.current = { ...l, formState: r } } const s = e.current.control; return s._options = t, Hle(() => { const a = s._subscribe({ formState: s._proxyFormState, callback: () => i({ ...s._formState }), reRenderRoot: !0 }); return i(l => ({ ...l, isReady: !0 })), s._formState.isReady = !0, a }, [s]), Pt.useEffect(() => s._disableForm(t.disabled), [s, t.disabled]), Pt.useEffect(() => { t.mode && (s._options.mode = t.mode), t.reValidateMode && (s._options.reValidateMode = t.reValidateMode) }, [s, t.mode, t.reValidateMode]), Pt.useEffect(() => { t.errors && (s._setErrors(t.errors), s._focusError()) }, [s, t.errors]), Pt.useEffect(() => { t.shouldUnregister && s._subjects.state.next({ values: s._getWatch() }) }, [s, t.shouldUnregister]), Pt.useEffect(() => { if (s._proxyFormState.isDirty) { const a = s._getDirty(); a !== r.isDirty && s._subjects.state.next({ isDirty: a }) } }, [s, r.isDirty]), Pt.useEffect(() => { t.values && !ko(t.values, n.current) ? (s._reset(t.values, { keepFieldsRef: !0, ...s._options.resetOptions }), n.current = t.values, i(a => ({ ...a }))) : s._resetDefaultValues() }, [s, t.values]), Pt.useEffect(() => { s._state.mount || (s._setValid(), s._state.mount = !0), s._state.watch && (s._state.watch = !1, s._subjects.state.next({ ...s._formState })), s._removeUnmounted() }), e.current.formState = Vle(r, s), e.current } function oce() { const t = Ou(), [e, n] = N.useState(!1), [r, i] = N.useState(null), [s, a] = N.useState(null), [l, u] = N.useState(!1), [f, p] = N.useState(""), [g, y] = N.useState(null), { register: v, handleSubmit: b, reset: S, watch: C, setValue: T, formState: { errors: A } } = ace(), { data: M, isLoading: O } = Jt({ queryKey: ["currentUser"], queryFn: () => Ve.get("https://api.nexus.com/api/auth/me", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }); N.useEffect(() => { e && M?.data?.data?.user && (T("name", M.data.data.user.name), T("email", M.data.data.user.email), T("bio", M.data.data.user.bio || "")) }, [e, M, T]); const E = js({ mutationFn: async () => Ve.post("https://api.nexus.com/api/admin/settings/request-update", {}, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), onSuccess: () => { ur.success("Verification code sent to your email"), u(!0) }, onError: W => { ur.error(W.response?.data?.message || "Failed to send verification code") } }), k = js({ mutationFn: async ({ formData: W, verificationCode: ne }) => { const H = new FormData; return H.append("name", W.name), H.append("email", W.email), H.append("bio", W.bio), H.append("code", ne), W.password && H.append("password", W.password), r && H.append("profile_image", r), Ve.post("https://api.nexus.com/api/admin/settings/confirm-update", H, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}`, "Content-Type": "multipart/form-data" } }) }, onSuccess: () => { ur.success("Profile updated successfully"), t.invalidateQueries(["currentUser"]), n(!1), i(null), a(null), u(!1), p(""), y(null) }, onError: W => { ur.error(W.response?.data?.message || "Failed to update profile") } }), z = W => { const ne = W.target.files[0]; if (ne) { i(ne); const H = new FileReader; H.onloadend = () => { a(H.result) }, H.readAsDataURL(ne) } }, V = W => { y(W), E.mutate() }, q = () => { if (!f.trim()) { ur.error("Please enter verification code"); return } k.mutate({ formData: g, verificationCode: f.trim() }) }, ue = () => { u(!1), p(""), y(null) }; return O ? d.jsxs("div", { className: "mx-auto p-6", children: [d.jsx("div", { className: "h-8 bg-gray-200 rounded w-1/4 mb-8 animate-pulse" }), d.jsxs("div", { className: "flex flex-col gap-8", children: [d.jsxs("div", { className: "bg-white rounded-xl shadow-lg p-6", children: [d.jsxs("div", { className: "flex items-center mb-8", children: [d.jsx("div", { className: "relative", children: d.jsx("div", { className: "w-24 h-24 rounded-full bg-gray-200 animate-pulse" }) }), d.jsxs("div", { className: "ml-6 space-y-2", children: [d.jsx("div", { className: "h-6 bg-gray-200 rounded w-40 animate-pulse" }), d.jsx("div", { className: "h-4 bg-gray-200 rounded w-48 animate-pulse" }), d.jsx("div", { className: "h-3 bg-gray-200 rounded w-32 animate-pulse" })] })] }), d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6", children: [[1, 2, 3, 4].map(W => d.jsxs("div", { children: [d.jsx("div", { className: "h-4 bg-gray-200 rounded w-1/3 mb-1 animate-pulse" }), d.jsx("div", { className: "h-10 bg-gray-100 rounded-md animate-pulse" })] }, W)), d.jsxs("div", { className: "md:col-span-2", children: [d.jsx("div", { className: "h-4 bg-gray-200 rounded w-1/6 mb-1 animate-pulse" }), d.jsx("div", { className: "h-20 bg-gray-100 rounded-md animate-pulse" })] })] }), d.jsx("div", { className: "mt-8 flex justify-end", children: d.jsx("div", { className: "h-10 bg-gray-200 rounded w-32 animate-pulse" }) })] }), d.jsxs("div", { className: "bg-white rounded-xl shadow-lg p-6", children: [d.jsx("div", { className: "h-6 bg-gray-200 rounded w-1/4 mb-6 animate-pulse" }), d.jsx("div", { className: "flex flex-wrap gap-3", children: [1, 2, 3, 4, 5].map(W => d.jsx("div", { className: "h-8 bg-gray-100 rounded-xl w-24 animate-pulse" }, W)) })] })] })] }) : d.jsxs("div", { className: "mx-auto p-6", children: [d.jsxs("h1", { className: "text-3xl font-bold text-gray-800 mb-8", children: ["Welcome ", M?.data?.data?.user?.name.split(" ")[0]] }), d.jsxs("div", { className: "flex flex-col gap-8", children: [d.jsxs("div", { className: "bg-white rounded-xl shadow-lg p-6", children: [d.jsxs("div", { className: "flex items-center mb-8", children: [d.jsxs("div", { className: "relative", children: [d.jsx("img", { src: s || M?.data?.data?.user?.profile_image, alt: "Profile", className: "w-24 h-24 rounded-full object-cover border-2 border-gray-200" }), e && d.jsxs("label", { className: "absolute bottom-0 right-0 bg-blue-500 text-white rounded-full p-2 cursor-pointer", children: [d.jsx("input", { type: "file", className: "hidden", accept: "image/*", onChange: z }), d.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5", viewBox: "0 0 20 20", fill: "currentColor", children: d.jsx("path", { fillRule: "evenodd", d: "M4 5a2 2 0 00-2 2v8a2 2 0 002 2h12a2 2 0 002-2V7a2 2 0 00-2-2h-1.586a1 1 0 01-.707-.293l-1.121-1.121A2 2 0 0011.172 3H8.828a2 2 0 00-1.414.586L6.293 4.707A1 1 0 015.586 5H4zm6 9a3 3 0 100-6 3 3 0 000 6z", clipRule: "evenodd" }) })] })] }), d.jsxs("div", { className: "ml-6", children: [d.jsx("h2", { className: "text-xl font-semibold", children: M?.data?.data?.user?.name }), d.jsx("p", { className: "text-gray-600", children: M?.data?.data?.user?.email }), d.jsxs("p", { className: "text-sm text-gray-500 mt-1", children: ["Member since: ", new Date(M?.data?.data?.user?.created_at).toLocaleDateString()] })] })] }), d.jsxs("form", { onSubmit: b(V), children: [d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-6", children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Name" }), e ? d.jsx("input", { type: "text", ...v("name", { required: "Name is required" }), className: "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500", disabled: E.isPending }) : d.jsx("p", { className: "px-3 py-2 bg-gray-50 rounded-md", children: M?.data?.data?.user?.name }), A.name && d.jsx("p", { className: "text-red-500 text-sm mt-1", children: A.name.message })] }), d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Email" }), e ? d.jsx("input", { type: "email", ...v("email", { required: "Email is required", pattern: { value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i, message: "Invalid email address" } }), className: "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" }) : d.jsx("p", { className: "px-3 py-2 bg-gray-50 rounded-md", children: M?.data?.data?.user?.email }), A.email && d.jsx("p", { className: "text-red-500 text-sm mt-1", children: A.email.message })] }), d.jsxs("div", { className: "md:col-span-2", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Bio" }), e ? d.jsx("textarea", { ...v("bio"), rows: 3, className: "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500", placeholder: "Tell us about yourself...", disabled: E.isPending }) : d.jsx("p", { className: "px-3 py-2 bg-gray-50 rounded-md whitespace-pre-line", children: M?.data?.data?.user?.bio || "No bio yet" })] }), e && d.jsxs(d.Fragment, { children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "New Password" }), d.jsx("input", { type: "password", ...v("password"), className: "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500", placeholder: "Leave blank to keep current password", disabled: E.isPending })] }), d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Confirm Password" }), d.jsx("input", { type: "password", ...v("confirmPassword", { validate: W => { const ne = C("password"); return !ne && !W ? !0 : W === ne || "Passwords do not match" } }), className: "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500", placeholder: "Confirm new password", disabled: E.isPending }), A.confirmPassword && d.jsx("p", { className: "text-red-500 text-sm mt-1", children: A.confirmPassword.message })] })] })] }), d.jsx("div", { className: "mt-8 flex justify-end space-x-3", children: e ? d.jsxs(d.Fragment, { children: [d.jsx("button", { type: "button", onClick: () => { n(!1), S(), i(null), a(null) }, className: "px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50", disabled: E.isPending, children: "Cancel" }), d.jsxs("button", { type: "submit", disabled: E.isPending, className: "px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2", children: [E.isPending && d.jsxs("svg", { className: "animate-spin h-4 w-4", viewBox: "0 0 24 24", children: [d.jsx("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4", fill: "none" }), d.jsx("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 714 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" })] }), E.isPending ? "Sending Code..." : "Save Changes"] })] }) : d.jsx("button", { type: "button", onClick: () => n(!0), className: "px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600", children: "Edit Profile" }) })] })] }), d.jsxs("div", { className: "bg-white rounded-xl shadow-lg p-6", children: [d.jsx("h2", { className: "text-2xl font-bold mb-6", children: "Permissions" }), d.jsx("div", { className: "flex flex-wrap gap-3", children: M?.data?.data?.admin?.permissions?.map((W, ne) => d.jsx("div", { className: "bg-gray-100 shadow p-1 rounded-xl", children: W.replaceAll("_", " ") }, ne)) })] })] }), l && d.jsx("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50", children: d.jsxs("div", { className: "bg-white rounded-lg p-6 w-full max-w-md mx-4", children: [d.jsxs("div", { className: "flex justify-between items-center mb-4", children: [d.jsx("h3", { className: "text-lg font-semibold", children: "Email Verification" }), d.jsx("button", { onClick: ue, className: "text-gray-500 hover:text-gray-700", disabled: k.isPending, children: d.jsx("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: d.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) }) })] }), d.jsx("p", { className: "text-gray-600 mb-4", children: "We've sent a verification code to your email address. Please enter it below to confirm your profile changes." }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-2", children: "Verification Code" }), d.jsx("input", { type: "text", value: f, onChange: W => p(W.target.value), className: "w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500", placeholder: "Enter 6-digit code", maxLength: 6, disabled: k.isPending })] }), d.jsxs("div", { className: "flex justify-end space-x-3", children: [d.jsx("button", { type: "button", onClick: ue, className: "px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50", disabled: k.isPending, children: "Cancel" }), d.jsxs("button", { onClick: q, disabled: k.isPending || !f.trim(), className: "px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2", children: [k.isPending && d.jsxs("svg", { className: "animate-spin h-4 w-4", viewBox: "0 0 24 24", children: [d.jsx("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4", fill: "none" }), d.jsx("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 714 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" })] }), k.isPending ? "Updating..." : "Verify & Update"] })] }), d.jsx("div", { className: "mt-4 text-center", children: d.jsxs("button", { onClick: () => E.mutate(), disabled: E.isPending || k.isPending, className: "text-blue-500 hover:text-blue-600 text-sm disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2 mx-auto", children: [E.isPending && d.jsxs("svg", { className: "animate-spin h-3 w-3", viewBox: "0 0 24 24", children: [d.jsx("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4", fill: "none" }), d.jsx("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 714 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" })] }), E.isPending ? "Sending..." : "Resend Code"] }) })] }) })] }) } function lce() { return d.jsxs("div", { className: " mx-auto p-6", children: [d.jsx("h1", { className: "text-3xl font-bold text-gray-900 mb-10", children: "Help Center" }), d.jsxs("div", { className: "space-y-6", children: [d.jsx("div", { className: "group", children: d.jsxs(za, { to: "categories", className: "block bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition-all duration-200 group-hover:border-primary border-l-4 border-transparent", children: [d.jsx("h2", { className: "text-2xl font-semibold text-gray-800 mb-2", children: "Categories" }), d.jsx("p", { className: "text-gray-600", children: "Browse help topics by category" })] }) }), d.jsx("div", { className: "group", children: d.jsxs(za, { to: "subcategories", className: "block bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition-all duration-200 group-hover:border-primary border-l-4 border-transparent", children: [d.jsx("h2", { className: "text-2xl font-semibold text-gray-800 mb-2", children: "Subcategories" }), d.jsx("p", { className: "text-gray-600", children: "Find more specific help topics" })] }) }), d.jsx("div", { className: "group", children: d.jsxs(za, { to: "articles", className: "block bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition-all duration-200 group-hover:border-primary border-l-4 border-transparent", children: [d.jsx("h2", { className: "text-2xl font-semibold text-gray-800 mb-2", children: "Articles" }), d.jsx("p", { className: "text-gray-600", children: "Read detailed help articles" })] }) })] })] }) } function cce({ helpcenterCategoriesData: t, loading: e, refetch: n }) { const r = ln(), [i, s] = N.useState({ global: "", name: "", description: "", status: "" }), [a, l] = N.useState(1), [u] = N.useState(10), [f, p] = N.useState(null), [g, y] = N.useState(null), [v, b] = N.useState(!1), [S, C] = N.useState(!1), [T, A] = N.useState(!1), [M, O] = N.useState(null), [E, k] = N.useState(!1), [z, V] = N.useState(null), [q, ue] = N.useState({ name: "", description: "", order: "", is_active: !0 }), { data: W } = Jt({ queryKey: ["currentUser"], queryFn: () => Ve.get("https://api.nexus.com/api/auth/me", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }), ne = (fe, Oe) => { s(et => ({ ...et, [fe]: Oe })), l(1) }, H = fe => { O(fe), A(!0) }, we = async () => { if (M) { y(M), A(!1); try { await Ve.delete(`https://api.nexus.com/api/admin/help-center/categories/${M}`, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success("Category deleted successfully", { duration: 2e3 }), n() } catch (fe) { me.error(fe.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), fe.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), fe.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } finally { y(null), O(null) } } }, xe = fe => { const { name: Oe, value: et, type: Xe, checked: De } = fe.target; ue(he => ({ ...he, [Oe]: Xe === "checkbox" ? De : et })) }, K = () => { ue({ name: "", description: "", order: "", is_active: !0 }) }, te = fe => { V(fe), ue({ name: fe.name, description: fe.description, order: fe.order, is_active: fe.is_active }), C(!0) }, ye = async fe => { fe.preventDefault(), k(!0); try { await Ve.post("https://api.nexus.com/api/admin/help-center/categories", { name: q.name, description: q.description, order: parseInt(q.order), is_active: q.is_active }, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success("Category added successfully", { duration: 2e3 }), b(!1), K(), n() } catch (Oe) { me.error(Oe.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), Oe.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), Oe.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } finally { k(!1) } }, He = async fe => { fe.preventDefault(), k(!0); try { await Ve.put(`https://api.nexus.com/api/admin/help-center/categories/${z.id}`, { name: q.name, description: q.description, order: parseInt(q.order), is_active: q.is_active }, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success("Category updated successfully", { duration: 2e3 }), C(!1), K(), n() } catch (Oe) { me.error(Oe.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), Oe.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), Oe.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } finally { k(!1) } }, B = t?.filter(fe => (i.global === "" || fe.name.toLowerCase().includes(i.global.toLowerCase()) || fe.description.toLowerCase().includes(i.global.toLowerCase())) && (i.name === "" || fe.name.toLowerCase().includes(i.name.toLowerCase())) && (i.description === "" || fe.description.toLowerCase().includes(i.description.toLowerCase())) && (i.status === "" || i.status.toLowerCase() === "active" && fe.is_active || i.status.toLowerCase() === "inactive" && !fe.is_active)) || [], ie = Math.ceil(B.length / u), oe = B.slice((a - 1) * u, a * u), pe = fe => { const Oe = fe ? "bg-[#009379] text-white" : "bg-[#930002] text-white"; return d.jsx("span", { className: `flex justify-center w-fit items-center px-2.5 py-1 rounded-md text-xs font-medium ${Oe} min-w-16 text-center`, children: fe ? "Active" : "Inactive" }) }, Ee = () => ie <= 1 ? null : d.jsxs("div", { className: "flex justify-between items-center mt-4 px-4 pb-1", children: [d.jsxs("div", { className: "text-xs", children: ["Showing ", (a - 1) * u + 1, "-", Math.min(a * u, B.length), " of ", B.length, " entries"] }), d.jsxs("div", { className: "flex gap-1", children: [d.jsx("button", { onClick: () => l(1), disabled: a === 1, className: "p-1 disabled:opacity-50", children: d.jsx(Ds, { className: "h-4 w-4" }) }), d.jsxs("span", { className: "px-3 py-1", children: ["Page ", a, " of ", ie] }), d.jsx("button", { onClick: () => l(fe => Math.min(ie, fe + 1)), disabled: a === ie, className: "p-1 disabled:opacity-50", children: d.jsx(Rs, { className: "h-4 w-4" }) })] })] }); return d.jsxs("div", { className: "shadow-2xl rounded-2xl overflow-hidden bg-white", children: [d.jsxs("div", { className: "p-4 border-b flex justify-between items-center gap-4", children: [d.jsx("input", { type: "text", value: i.global, onChange: fe => ne("global", fe.target.value), placeholder: "Search categories...", className: "px-3 py-2 rounded-xl shadow-sm focus:outline-2 focus:outline-primary w-full border border-primary transition-all" }), W?.data?.data?.admin?.permissions?.includes("create_help_category") && d.jsxs("button", { onClick: () => b(!0), className: "bg-primary hover:bg-darkBlue transition-all text-white px-3 py-2 rounded-xl shadow-sm min-w-max flex items-center gap-2", children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Category" })] })] }), d.jsx("div", { className: "overflow-x-auto", children: d.jsxs("table", { className: "w-full divide-y divide-gray-200", children: [d.jsx("thead", { className: "bg-gray-50", children: d.jsxs("tr", { children: [d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Name", value: i.name, onChange: fe => ne("name", fe.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Description", value: i.description, onChange: fe => ne("description", fe.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Order" }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Subcategories" }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Status", value: i.status, onChange: fe => ne("status", fe.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Actions" })] }) }), d.jsx("tbody", { className: "bg-white divide-y divide-gray-200 text-sm", children: e ? d.jsx("tr", { children: d.jsx("td", { colSpan: "6", className: "px-3 py-4 text-center", children: d.jsxs("div", { className: "flex justify-center items-center gap-2", children: [d.jsx(mt, { className: "animate-spin", size: 18 }), "Loading categories..."] }) }) }) : oe.length === 0 ? d.jsx("tr", { children: d.jsx("td", { colSpan: "6", className: "px-3 py-4 text-center", children: "No categories found" }) }) : oe.map(fe => d.jsxs("tr", { className: "hover:bg-gray-50", children: [d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsx("div", { className: "font-medium", children: fe.name }) }), d.jsx("td", { className: "px-3 py-4", children: d.jsx("div", { className: "line-clamp-2", children: fe.description }) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: fe.order }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: fe.subcategories?.length || 0 }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: pe(fe.is_active) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsxs("div", { className: "flex items-center gap-2", children: [W?.data?.data?.admin?.permissions?.includes("edit_help_category") && d.jsx("button", { className: "text-blue-500 hover:text-blue-700 p-1", onClick: () => te(fe), children: d.jsx(br, { size: 18 }) }), W?.data?.data?.admin?.permissions?.includes("delete_help_category") && d.jsx("button", { className: "text-red-500 hover:text-red-700 p-1", onClick: () => H(fe.id), disabled: g === fe.id, children: g === fe.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : d.jsx(Cn, { size: 18 }) })] }) })] }, fe.id)) })] }) }), !e && Ee(), v && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => b(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto", onClick: fe => fe.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Add New Category" }), d.jsxs("form", { onSubmit: ye, children: [d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Name*" }), d.jsx("input", { required: !0, type: "text", name: "name", value: q.name, onChange: xe, className: "w-full px-3 py-2 border rounded-md" })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Description*" }), d.jsx("textarea", { name: "description", value: q.description, onChange: xe, className: "w-full px-3 py-2 border rounded-md", rows: "3", required: !0 })] }), d.jsxs("div", { className: "grid grid-cols-2 gap-4 mb-4", children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Order*" }), d.jsx("input", { required: !0, type: "number", name: "order", value: q.order, onChange: xe, className: "w-full px-3 py-2 border rounded-md", min: "1" })] }), d.jsx("div", { className: "flex items-center justify-end", children: d.jsxs("div", { className: "flex items-center", children: [d.jsx("input", { type: "checkbox", name: "is_active", checked: q.is_active, onChange: xe, className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsx("label", { htmlFor: "is_active", className: "ml-2 text-sm text-gray-700", children: "Active" })] }) })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsx("button", { type: "button", onClick: () => { b(!1), K() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: E, children: E ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Adding..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Category" })] }) })] })] })] }) }) }), S && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => C(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto", onClick: fe => fe.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Edit Category" }), d.jsxs("form", { onSubmit: He, children: [d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Name*" }), d.jsx("input", { required: !0, type: "text", name: "name", value: q.name, onChange: xe, className: "w-full px-3 py-2 border rounded-md" })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Description*" }), d.jsx("textarea", { name: "description", value: q.description, onChange: xe, className: "w-full px-3 py-2 border rounded-md", rows: "3", required: !0 })] }), d.jsxs("div", { className: "grid grid-cols-2 gap-4 mb-4", children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Order*" }), d.jsx("input", { required: !0, type: "number", name: "order", value: q.order, onChange: xe, className: "w-full px-3 py-2 border rounded-md", min: "1" })] }), d.jsx("div", { className: "flex items-center justify-end", children: d.jsxs("div", { className: "flex items-center", children: [d.jsx("input", { type: "checkbox", name: "is_active", checked: q.is_active, onChange: xe, className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsx("label", { htmlFor: "is_active", className: "ml-2 text-sm text-gray-700", children: "Active" })] }) })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsx("button", { type: "button", onClick: () => { C(!1), K() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: E, children: E ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Updating..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(br, { size: 18 }), d.jsx("span", { children: "Update Category" })] }) })] })] })] }) }) }), T && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => A(!1), children: d.jsx(ot.div, { initial: { scale: .9, opacity: 0 }, animate: { scale: 1, opacity: 1 }, exit: { scale: .9, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md", onClick: fe => fe.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsxs("div", { className: "flex items-start", children: [d.jsx("div", { className: "flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100", children: d.jsx(Cn, { className: "h-5 w-5 text-red-600" }) }), d.jsxs("div", { className: "ml-4", children: [d.jsx("h3", { className: "text-lg font-medium text-gray-900", children: "Delete Category" }), d.jsx("div", { className: "mt-2", children: d.jsx("p", { className: "text-sm text-gray-500", children: "Are you sure you want to delete this category? This action cannot be undone." }) })] })] }), d.jsxs("div", { className: "mt-5 flex justify-end gap-3", children: [d.jsx("button", { type: "button", onClick: () => A(!1), className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "button", onClick: we, className: "px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700", children: "Delete" })] })] }) }) })] }) } function uce() { const t = ln(), { data: e, isLoading: n, isError: r, error: i, isLoading: s, refetch: a } = Jt({ queryKey: ["helpcenterCategories"], queryFn: () => Ve.get("https://api.nexus.com/api/admin/help-center/categories", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }); return N.useEffect(() => { r && (i.response?.status == 401 && (localStorage.removeItem("userToken"), t("/login")), i.response?.status == 403 && (me.error("You are not authorized to view this page"), t("/home"))) }, [r]), d.jsxs("div", { className: "p-4", children: [d.jsx("h1", { className: "text-3xl font-bold text-gray-800 mb-8", children: "Help Center Categories" }), d.jsx(cce, { helpcenterCategoriesData: e?.data?.data || [], loading: s, refetch: a })] }) } function dce({ helpcenterSubcategoriesData: t, helpcenterCategoriesData: e, loading: n, refetch: r }) { const i = ln(), s = Ou(), [a, l] = N.useState({ global: "", name: "", category: "", description: "", status: "" }), [u, f] = N.useState(1), [p] = N.useState(10), [g, y] = N.useState(null), [v, b] = N.useState(null), [S, C] = N.useState(!1), [T, A] = N.useState(!1), [M, O] = N.useState(!1), [E, k] = N.useState(null), [z, V] = N.useState(!1), [q, ue] = N.useState(null), [W, ne] = N.useState({ category_id: "", name: "", description: "", order: "", is_active: !0 }), { data: H } = Jt({ queryKey: ["currentUser"], queryFn: () => Ve.get("https://api.nexus.com/api/auth/me", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }), we = js({ mutationFn: Y => Ve.post("https://api.nexus.com/api/admin/help-center/subcategories", Y, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), onSuccess: () => { s.invalidateQueries(["helpcenterSubcategories"]), me.success("Subcategory created successfully"), C(!1), oe(), r() }, onError: Y => { me.error(Y.response?.data?.message || "Failed to create subcategory"), Y.response?.status == 401 && (localStorage.removeItem("userToken"), i("/login")), Y.response?.status == 403 && me.error("You are not authorized to perform this action") } }), xe = js({ mutationFn: Y => Ve.put(`https://api.nexus.com/api/admin/help-center/subcategories/${Y.id}`, Y, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), onSuccess: () => { s.invalidateQueries(["helpcenterSubcategories"]), me.success("Subcategory updated successfully"), A(!1), oe(), r() }, onError: Y => { me.error(Y.response?.data?.message || "Failed to update subcategory"), Y.response?.status == 401 && (localStorage.removeItem("userToken"), i("/login")), Y.response?.status == 403 && me.error("You are not authorized to perform this action") } }), K = js({ mutationFn: Y => Ve.delete(`https://api.nexus.com/api/admin/help-center/subcategories/${Y}`, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), onSuccess: () => { s.invalidateQueries(["helpcenterSubcategories"]), me.success("Subcategory deleted successfully"), O(!1), r() }, onError: Y => { me.error(Y.response?.data?.message || "Failed to delete subcategory"), Y.response?.status == 401 && (localStorage.removeItem("userToken"), i("/login")), Y.response?.status == 403 && me.error("You are not authorized to perform this action") } }), te = (Y, Je) => { l($e => ({ ...$e, [Y]: Je })), f(1) }, ye = async (Y, Je) => { y(Y); try { await Ve.patch(`https://api.nexus.com/api/admin/help-center/subcategories/${Y}/toggle-status`, {}, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success(`Subcategory ${Je ? "deactivated" : "activated"} successfully`, { duration: 2e3 }), r() } catch ($e) { me.error($e.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), $e.response?.status == 401 && (localStorage.removeItem("userToken"), i("/login")), $e.response?.status == 403 && (me.error("You are not authorized to view this page"), i("/home")) } finally { y(null) } }, He = Y => { k(Y), O(!0) }, B = async () => { E && K.mutate(E) }, ie = Y => { const { name: Je, value: $e, type: $, checked: U } = Y.target; ne(be => ({ ...be, [Je]: $ === "checkbox" ? U : $e })) }, oe = () => { ne({ category_id: "", name: "", description: "", order: "", is_active: !0 }) }, pe = Y => { ue(Y), ne({ category_id: Y.category_id, name: Y.name, description: Y.description, order: Y.order, is_active: Y.is_active }), A(!0) }, Ee = Y => { Y.preventDefault(), we.mutate(W) }, fe = Y => { Y.preventDefault(), xe.mutate({ id: q.id, ...W }) }, Oe = t?.filter(Y => { const Je = e?.find($ => $.id === Y.category_id), $e = Je ? Je.name.toLowerCase() : ""; return (a.global === "" || Y.name.toLowerCase().includes(a.global.toLowerCase()) || Y.description.toLowerCase().includes(a.global.toLowerCase()) || $e.includes(a.global.toLowerCase())) && (a.name === "" || Y.name.toLowerCase().includes(a.name.toLowerCase())) && (a.category === "" || $e.includes(a.category.toLowerCase())) && (a.description === "" || Y.description.toLowerCase().includes(a.description.toLowerCase())) && (a.status === "" || a.status.toLowerCase() === "active" && Y.is_active || a.status.toLowerCase() === "inactive" && !Y.is_active) }) || [], et = Math.ceil(Oe.length / p), Xe = Oe.slice((u - 1) * p, u * p), De = Y => { const Je = Y ? "bg-[#009379] text-white" : "bg-[#930002] text-white"; return d.jsx("span", { className: `flex justify-center w-fit items-center px-2.5 py-1 rounded-md text-xs font-medium ${Je} min-w-16 text-center`, children: Y ? "Active" : "Inactive" }) }, he = Y => { const Je = e?.find($e => $e.id === Y); return Je ? Je.name : "Unknown Category" }, Be = () => et <= 1 ? null : d.jsxs("div", { className: "flex justify-between items-center mt-4 px-4 pb-1", children: [d.jsxs("div", { className: "text-xs", children: ["Showing ", (u - 1) * p + 1, "-", Math.min(u * p, Oe.length), " of ", Oe.length, " entries"] }), d.jsxs("div", { className: "flex gap-1", children: [d.jsx("button", { onClick: () => f(1), disabled: u === 1, className: "p-1 disabled:opacity-50", children: d.jsx(Ds, { className: "h-4 w-4" }) }), d.jsxs("span", { className: "px-3 py-1", children: ["Page ", u, " of ", et] }), d.jsx("button", { onClick: () => f(Y => Math.min(et, Y + 1)), disabled: u === et, className: "p-1 disabled:opacity-50", children: d.jsx(Rs, { className: "h-4 w-4" }) })] })] }); return d.jsxs("div", { className: "shadow-2xl rounded-2xl overflow-hidden bg-white", children: [d.jsxs("div", { className: "p-4 border-b flex justify-between items-center gap-4", children: [d.jsx("input", { type: "text", value: a.global, onChange: Y => te("global", Y.target.value), placeholder: "Search subcategories...", className: "px-3 py-2 rounded-xl shadow-sm focus:outline-2 focus:outline-primary w-full border border-primary transition-all" }), H?.data?.data?.admin?.permissions?.includes("create_help_subcategory") && d.jsxs("button", { onClick: () => C(!0), className: "bg-primary hover:bg-darkBlue transition-all text-white px-3 py-2 rounded-xl shadow-sm min-w-max flex items-center gap-2", children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Subcategory" })] })] }), d.jsx("div", { className: "overflow-x-auto", children: d.jsxs("table", { className: "w-full divide-y divide-gray-200", children: [d.jsx("thead", { className: "bg-gray-50", children: d.jsxs("tr", { children: [d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Name", value: a.name, onChange: Y => te("name", Y.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Category", value: a.category, onChange: Y => te("category", Y.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Description", value: a.description, onChange: Y => te("description", Y.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Order" }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Status", value: a.status, onChange: Y => te("status", Y.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Actions" })] }) }), d.jsx("tbody", { className: "bg-white divide-y divide-gray-200 text-sm", children: n ? d.jsx("tr", { children: d.jsx("td", { colSpan: "6", className: "px-3 py-4 text-center", children: d.jsxs("div", { className: "flex justify-center items-center gap-2", children: [d.jsx(mt, { className: "animate-spin", size: 18 }), "Loading subcategories..."] }) }) }) : Xe.length === 0 ? d.jsx("tr", { children: d.jsx("td", { colSpan: "6", className: "px-3 py-4 text-center", children: "No subcategories found" }) }) : Xe.map(Y => d.jsxs("tr", { className: "hover:bg-gray-50", children: [d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsx("div", { className: "font-medium", children: Y.name }) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: he(Y.category_id) }), d.jsx("td", { className: "px-3 py-4", children: d.jsx("div", { className: "line-clamp-2", children: Y.description }) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: Y.order }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: De(Y.is_active) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsxs("div", { className: "flex items-center gap-2", children: [H?.data?.data?.admin?.permissions?.includes("edit_help_subcategory") && d.jsx("button", { className: "text-blue-500 hover:text-blue-700 p-1", onClick: () => pe(Y), disabled: xe.isPending, children: xe.isPending && q?.id === Y.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : d.jsx(br, { size: 18 }) }), H?.data?.data?.admin?.permissions?.includes("toggle_help_center_subcategory_status") && d.jsx("button", { className: `${Y.is_active ? "text-red-500 hover:text-red-700" : "text-green-500 hover:text-green-700"} p-1`, onClick: () => ye(Y.id, Y.is_active), disabled: g === Y.id, children: g === Y.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : Y.is_active ? d.jsx(BR, {}) : d.jsx(RS, {}) }), H?.data?.data?.admin?.permissions?.includes("delete_help_subcategory") && d.jsx("button", { className: "text-red-500 hover:text-red-700 p-1", onClick: () => He(Y.id), disabled: K.isPending, children: K.isPending && E === Y.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : d.jsx(Cn, { size: 18 }) })] }) })] }, Y.id)) })] }) }), !n && Be(), S && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => C(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto", onClick: Y => Y.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Add New Subcategory" }), d.jsxs("form", { onSubmit: Ee, children: [d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Category*" }), d.jsxs("select", { name: "category_id", value: W.category_id, onChange: ie, className: "w-full px-3 py-2 border rounded-md", required: !0, children: [d.jsx("option", { value: "", children: "Select a category" }), e?.map(Y => d.jsx("option", { value: Y.id, children: Y.name }, Y.id))] })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Name*" }), d.jsx("input", { type: "text", name: "name", value: W.name, onChange: ie, className: "w-full px-3 py-2 border rounded-md", required: !0 })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Description*" }), d.jsx("textarea", { name: "description", value: W.description, onChange: ie, className: "w-full px-3 py-2 border rounded-md", rows: "3", required: !0 })] }), d.jsxs("div", { className: "grid grid-cols-2 gap-4 mb-4", children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Order*" }), d.jsx("input", { type: "number", name: "order", value: W.order, onChange: ie, className: "w-full px-3 py-2 border rounded-md", min: "1", required: !0 })] }), d.jsx("div", { className: "flex items-center justify-end", children: d.jsxs("div", { className: "flex items-center", children: [d.jsx("input", { type: "checkbox", name: "is_active", checked: W.is_active, onChange: ie, className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsx("label", { htmlFor: "is_active", className: "ml-2 text-sm text-gray-700", children: "Active" })] }) })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsx("button", { type: "button", onClick: () => { C(!1), oe() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: we.isPending, children: we.isPending ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Adding..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Subcategory" })] }) })] })] })] }) }) }), T && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => A(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto", onClick: Y => Y.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Edit Subcategory" }), d.jsxs("form", { onSubmit: fe, children: [d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Category*" }), d.jsxs("select", { name: "category_id", value: W.category_id, onChange: ie, className: "w-full px-3 py-2 border rounded-md", required: !0, children: [d.jsx("option", { value: "", children: "Select a category" }), e?.map(Y => d.jsx("option", { value: Y.id, children: Y.name }, Y.id))] })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Name*" }), d.jsx("input", { type: "text", name: "name", value: W.name, onChange: ie, className: "w-full px-3 py-2 border rounded-md", required: !0 })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Description*" }), d.jsx("textarea", { name: "description", value: W.description, onChange: ie, className: "w-full px-3 py-2 border rounded-md", rows: "3", required: !0 })] }), d.jsxs("div", { className: "grid grid-cols-2 gap-4 mb-4", children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Order*" }), d.jsx("input", { type: "number", name: "order", value: W.order, onChange: ie, className: "w-full px-3 py-2 border rounded-md", min: "1", required: !0 })] }), d.jsx("div", { className: "flex items-center justify-end", children: d.jsxs("div", { className: "flex items-center", children: [d.jsx("input", { type: "checkbox", name: "is_active", checked: W.is_active, onChange: ie, className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsx("label", { htmlFor: "is_active", className: "ml-2 text-sm text-gray-700", children: "Active" })] }) })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsx("button", { type: "button", onClick: () => { A(!1), oe() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: xe.isPending, children: xe.isPending ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Updating..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(br, { size: 18 }), d.jsx("span", { children: "Update Subcategory" })] }) })] })] })] }) }) }), M && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => O(!1), children: d.jsx(ot.div, { initial: { scale: .9, opacity: 0 }, animate: { scale: 1, opacity: 1 }, exit: { scale: .9, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md", onClick: Y => Y.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsxs("div", { className: "flex items-start", children: [d.jsx("div", { className: "flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100", children: d.jsx(Cn, { className: "h-5 w-5 text-red-600" }) }), d.jsxs("div", { className: "ml-4", children: [d.jsx("h3", { className: "text-lg font-medium text-gray-900", children: "Delete Subcategory" }), d.jsx("div", { className: "mt-2", children: d.jsxs("p", { className: "text-sm text-gray-500", children: ['Are you sure you want to delete the subcategory "', E && t.find(Y => Y.id === E)?.name, '"? This action cannot be undone.'] }) })] })] }), d.jsxs("div", { className: "mt-5 flex justify-end gap-3", children: [d.jsx("button", { type: "button", onClick: () => O(!1), className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "button", onClick: B, className: "px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 flex items-center justify-center gap-2", disabled: K.isPending, children: K.isPending ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Deleting..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(Cn, { size: 18 }), d.jsx("span", { children: "Delete" })] }) })] })] }) }) })] }) } function fce() { const t = ln(), { data: e, isLoading: n, isError: r, error: i, isLoading: s, refetch: a } = Jt({ queryKey: ["helpcenterSubcategories"], queryFn: () => Ve.get("https://api.nexus.com/api/admin/help-center/subcategories", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }), { data: l, isLoading: u } = Jt({ queryKey: ["helpcenterCategories"], queryFn: () => Ve.get("https://api.nexus.com/api/admin/help-center/categories", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }); return N.useEffect(() => { r && (i.response?.status == 401 && (localStorage.removeItem("userToken"), t("/login")), i.response?.status == 403 && (me.error("You are not authorized to view this page"), t("/home"))) }, [r]), d.jsxs("div", { className: "p-4", children: [d.jsx("h1", { className: "text-3xl font-bold text-gray-800 mb-8", children: "Help Center Subcategories" }), d.jsx(dce, { helpcenterSubcategoriesData: e?.data?.data || [], helpcenterCategoriesData: l?.data?.data || [], loading: s, refetch: a })] }) } function hce({ helpcenterArticlesData: t, helpcenterSubcategoriesData: e, helpcenterCategoriesData: n, loading: r, refetch: i }) { const s = ln(), a = Ou(), [l, u] = N.useState({ global: "", title: "", subcategory: "", category: "", status: "" }), [f, p] = N.useState(1), [g] = N.useState(10), [y, v] = N.useState(null), [b, S] = N.useState(null), [C, T] = N.useState(!1), [A, M] = N.useState(!1), [O, E] = N.useState(!1), [k, z] = N.useState(null), [V, q] = N.useState(null), [ue, W] = N.useState([]), [ne, H] = N.useState([]), [we, xe] = N.useState(!1), [K, te] = N.useState({ subcategory_id: "", title: "", slug: "", content: "", order: "", is_active: !0, headings: [] }), { data: ye } = Jt({ queryKey: ["currentUser"], queryFn: () => Ve.get("https://api.nexus.com/api/auth/me", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }), He = I => { const se = Array.isArray(I) ? I : []; H(se), te(ae => ({ ...ae, headings: se })) }, B = js({ mutationFn: I => Ve.post("https://api.nexus.com/api/admin/help-center/topics", { ...I, headings: JSON.stringify(I.headings) }, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), onSuccess: () => { a.invalidateQueries(["helpcenterarticles"]), me.success("Article created successfully"), T(!1), Y(), i() }, onError: I => { me.error(I.response?.data?.message || "Failed to create article"), I.response?.status == 401 && (localStorage.removeItem("userToken"), s("/login")), I.response?.status == 403 && me.error("You are not authorized to perform this action") } }), ie = js({ mutationFn: I => Ve.put(`https://api.nexus.com/api/admin/help-center/topics/${I.id}`, { ...I, headings: JSON.stringify(I.headings) }, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), onSuccess: () => { a.invalidateQueries(["helpcenterarticles"]), me.success("Article updated successfully"), M(!1), Y(), i() }, onError: I => { me.error(I.response?.data?.message || "Failed to update article"), I.response?.status == 401 && (localStorage.removeItem("userToken"), s("/login")), I.response?.status == 403 && me.error("You are not authorized to perform this action") } }), oe = js({ mutationFn: I => Ve.delete(`https://api.nexus.com/api/admin/help-center/topics/${I}`, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), onSuccess: () => { a.invalidateQueries(["helpcenterarticles"]), me.success("Article deleted successfully"), E(!1), i() }, onError: I => { me.error(I.response?.data?.message || "Failed to delete article"), I.response?.status == 401 && (localStorage.removeItem("userToken"), s("/login")), I.response?.status == 403 && me.error("You are not authorized to perform this action") } }), pe = I => { const se = e?.filter(ae => ae.category_id == I) || []; W(se), te(ae => ({ ...ae, category_id: I, subcategory_id: "" })) }, Ee = (I, se) => { u(ae => ({ ...ae, [I]: se })), p(1) }, fe = async (I, se) => { v(I); try { await Ve.patch(`https://api.nexus.com/api/admin/help-center/topics/${I}/toggle-status`, {}, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success(`Article ${se ? "deactivated" : "activated"} successfully`, { duration: 2e3 }), i() } catch (ae) { me.error(ae.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), ae.response?.status == 401 && (localStorage.removeItem("userToken"), s("/login")), ae.response?.status == 403 && (me.error("You are not authorized to view this page"), s("/home")) } finally { v(null) } }, Oe = I => { z(I), E(!0) }, et = async () => { k && oe.mutate(k) }, Xe = I => I.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, ""), De = I => { const { name: se, value: ae, type: Ae, checked: qe } = I.target; if (te(rt => ({ ...rt, [se]: Ae === "checkbox" ? qe : ae })), se === "title" && !we) { const rt = Xe(ae); te(Tt => ({ ...Tt, slug: rt })) } }, he = I => { const { value: se } = I.target; te(ae => ({ ...ae, slug: se })), xe(!0) }, Be = () => { const I = Xe(K.title); te(se => ({ ...se, slug: I })), xe(!1) }, Y = () => { te({ subcategory_id: "", title: "", slug: "", content: "", order: "", is_active: !0, headings: [] }), H([]), W([]), xe(!1) }, Je = I => { q(I); const se = e?.find(qe => qe.id === I.subcategory_id)?.category_id, ae = e?.filter(qe => qe.category_id == se) || []; W(ae); let Ae = []; if (I.headings && typeof I.headings == "string" && I.headings.trim() !== "") try { Ae = JSON.parse(I.headings), Array.isArray(Ae) || (Ae = []) } catch (qe) { console.error("Error parsing headings:", qe), Ae = [] } te({ subcategory_id: I.subcategory_id, title: I.title, slug: I.slug, content: I.content, order: I.order, is_active: I.is_active, headings: Ae }), H(Ae), M(!0), xe(!0) }, $e = I => { I.preventDefault(), B.mutate(K) }, $ = I => { I.preventDefault(), ie.mutate({ id: V.id, ...K }) }, U = I => { const se = e?.find(Ae => Ae.id === I); if (!se) return "Unknown"; const ae = n?.find(Ae => Ae.id === se.category_id); return ae ? ae.name : "Unknown" }, be = I => { const se = e?.find(ae => ae.id === I); return se ? se.name : "Unknown" }, Ie = t?.filter(I => { const se = be(I.subcategory_id).toLowerCase(), ae = U(I.subcategory_id).toLowerCase(); return (l.global === "" || I.title.toLowerCase().includes(l.global.toLowerCase()) || se.includes(l.global.toLowerCase()) || ae.includes(l.global.toLowerCase())) && (l.title === "" || I.title.toLowerCase().includes(l.title.toLowerCase())) && (l.subcategory === "" || se.includes(l.subcategory.toLowerCase())) && (l.category === "" || ae.includes(l.category.toLowerCase())) && (l.status === "" || l.status.toLowerCase() === "active" && I.is_active || l.status.toLowerCase() === "inactive" && !I.is_active) }) || [], it = Math.ceil(Ie.length / g), P = Ie.slice((f - 1) * g, f * g), ee = I => { const se = I ? "bg-[#009379] text-white" : "bg-[#930002] text-white"; return d.jsx("span", { className: `flex justify-center w-fit items-center px-2.5 py-1 rounded-md text-xs font-medium ${se} min-w-16 text-center`, children: I ? "Active" : "Inactive" }) }, _ = () => it <= 1 ? null : d.jsxs("div", { className: "flex justify-between items-center mt-4 px-4 pb-1", children: [d.jsxs("div", { className: "text-xs", children: ["Showing ", (f - 1) * g + 1, "-", Math.min(f * g, Ie.length), " of ", Ie.length, " entries"] }), d.jsxs("div", { className: "flex gap-1", children: [d.jsx("button", { onClick: () => p(1), disabled: f === 1, className: "p-1 disabled:opacity-50", children: d.jsx(Ds, { className: "h-4 w-4" }) }), d.jsxs("span", { className: "px-3 py-1", children: ["Page ", f, " of ", it] }), d.jsx("button", { onClick: () => p(I => Math.min(it, I + 1)), disabled: f === it, className: "p-1 disabled:opacity-50", children: d.jsx(Rs, { className: "h-4 w-4" }) })] })] }); return d.jsxs("div", { className: "shadow-2xl rounded-2xl overflow-hidden bg-white", children: [d.jsxs("div", { className: "p-4 border-b flex justify-between items-center gap-4", children: [d.jsx("input", { type: "text", value: l.global, onChange: I => Ee("global", I.target.value), placeholder: "Search articles...", className: "px-3 py-2 rounded-xl shadow-sm focus:outline-2 focus:outline-primary w-full border border-primary transition-all" }), ye?.data?.data?.admin?.permissions?.includes("create_help_topic") && d.jsxs("button", { onClick: () => T(!0), className: "bg-primary hover:bg-darkBlue transition-all text-white px-3 py-2 rounded-xl shadow-sm min-w-max flex items-center gap-2", children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Article" })] })] }), d.jsx("div", { className: "overflow-x-auto", children: d.jsxs("table", { className: "w-full divide-y divide-gray-200", children: [d.jsx("thead", { className: "bg-gray-50", children: d.jsxs("tr", { children: [d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Title", value: l.title, onChange: I => Ee("title", I.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Category", value: l.category, onChange: I => Ee("category", I.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Subcategory", value: l.subcategory, onChange: I => Ee("subcategory", I.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Order" }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Status", value: l.status, onChange: I => Ee("status", I.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Actions" })] }) }), d.jsx("tbody", { className: "bg-white divide-y divide-gray-200 text-sm", children: r ? d.jsx("tr", { children: d.jsx("td", { colSpan: "6", className: "px-3 py-4 text-center", children: d.jsxs("div", { className: "flex justify-center items-center gap-2", children: [d.jsx(mt, { className: "animate-spin", size: 18 }), "Loading articles..."] }) }) }) : P.length === 0 ? d.jsx("tr", { children: d.jsx("td", { colSpan: "6", className: "px-3 py-4 text-center", children: "No articles found" }) }) : P.map(I => d.jsxs("tr", { className: "hover:bg-gray-50", children: [d.jsxs("td", { className: "px-3 py-4 whitespace-nowrap", children: [d.jsx("div", { className: "font-medium", children: I.title }), d.jsx("div", { className: "text-xs text-gray-500", children: I.slug })] }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: U(I.subcategory_id) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: be(I.subcategory_id) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: I.order }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: ee(I.is_active) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsxs("div", { className: "flex items-center gap-2", children: [ye?.data?.data?.admin?.permissions?.includes("edit_help_topic") && d.jsx("button", { className: "text-blue-500 hover:text-blue-700 p-1", onClick: () => Je(I), disabled: ie.isPending, children: ie.isPending && V?.id === I.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : d.jsx(br, { size: 18 }) }), ye?.data?.data?.admin?.permissions?.includes("toggle_help_center_topic_status") && d.jsx("button", { className: `${I.is_active ? "text-red-500 hover:text-red-700" : "text-green-500 hover:text-green-700"} p-1`, onClick: () => fe(I.id, I.is_active), disabled: y === I.id, children: y === I.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : I.is_active ? d.jsx(BR, {}) : d.jsx(RS, {}) }), ye?.data?.data?.admin?.permissions?.includes("delete_help_topic") && d.jsx("button", { className: "text-red-500 hover:text-red-700 p-1", onClick: () => Oe(I.id), disabled: oe.isPending, children: oe.isPending && k === I.id ? d.jsx(mt, { className: "animate-spin", size: 18 }) : d.jsx(Cn, { size: 18 }) })] }) })] }, I.id)) })] }) }), !r && _(), C && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => T(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] overflow-y-auto", onClick: I => I.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Add New Article" }), d.jsxs("form", { onSubmit: $e, children: [d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4 mb-4", children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Category*" }), d.jsxs("select", { onChange: I => pe(I.target.value), className: "w-full px-3 py-2 border rounded-md", required: !0, children: [d.jsx("option", { value: "", children: "Select a category" }), n?.map(I => d.jsx("option", { value: I.id, children: I.name }, I.id))] })] }), d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Subcategory*" }), d.jsxs("select", { name: "subcategory_id", value: K.subcategory_id, onChange: De, className: "w-full px-3 py-2 border rounded-md", required: !0, disabled: !K.category_id, children: [d.jsx("option", { value: "", children: "Select a subcategory" }), ue?.map(I => d.jsx("option", { value: I.id, children: I.name }, I.id))] })] })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Title*" }), d.jsx("input", { type: "text", name: "title", value: K.title, onChange: De, className: "w-full px-3 py-2 border rounded-md", required: !0 })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Slug*" }), d.jsxs("div", { className: "relative", children: [d.jsx("input", { type: "text", name: "slug", value: K.slug, onChange: he, className: "w-full px-3 py-2 border rounded-md", required: !0 }), we && d.jsx("button", { type: "button", onClick: Be, className: "absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700", title: "Reset to auto-generated slug", children: d.jsx(vr, {}) })] }), d.jsx("p", { className: "text-xs text-gray-500 mt-1", children: we ? "Slug is manually edited. Click the X to reset to auto-generated." : "Slug is auto-generated from title. You can edit it manually." })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Order*" }), d.jsx("input", { type: "number", name: "order", value: K.order, onChange: De, className: "w-full px-3 py-2 border rounded-md", min: "1", required: !0 })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Content*" }), d.jsx(Yg, { uploadImgUrl: "https://api.nexus.com/api/admin/help-center/topics/upload-image", content: K.content, onUpdate: I => te(se => ({ ...se, content: I })), onHeadingsUpdate: He })] }), d.jsxs("div", { className: "flex items-center mb-4", children: [d.jsx("input", { type: "checkbox", name: "is_active", checked: K.is_active, onChange: De, className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsx("label", { htmlFor: "is_active", className: "ml-2 text-sm text-gray-700", children: "Active" })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsx("button", { type: "button", onClick: () => { T(!1), Y() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: B.isPending, children: B.isPending ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Adding..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Article" })] }) })] })] })] }) }) }), A && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => M(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] overflow-y-auto overflow-hidden", onClick: I => I.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Edit Article" }), d.jsxs("form", { onSubmit: $, children: [d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4 mb-4", children: [d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Category*" }), d.jsxs("select", { onChange: I => pe(I.target.value), className: "w-full px-3 py-2 border rounded-md", required: !0, value: e?.find(I => I.id === V?.subcategory_id)?.category_id || "", children: [d.jsx("option", { value: "", children: "Select a category" }), n?.map(I => d.jsx("option", { value: I.id, children: I.name }, I.id))] })] }), d.jsxs("div", { children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Subcategory*" }), d.jsxs("select", { name: "subcategory_id", value: K.subcategory_id, onChange: De, className: "w-full px-3 py-2 border rounded-md", required: !0, children: [d.jsx("option", { value: "", children: "Select a subcategory" }), ue?.map(I => d.jsx("option", { value: I.id, children: I.name }, I.id))] })] })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Title*" }), d.jsx("input", { type: "text", name: "title", value: K.title, onChange: De, className: "w-full px-3 py-2 border rounded-md", required: !0 })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Slug*" }), d.jsxs("div", { className: "relative", children: [d.jsx("input", { type: "text", name: "slug", value: K.slug, onChange: he, className: "w-full px-3 py-2 border rounded-md", required: !0 }), we && d.jsx("button", { type: "button", onClick: Be, className: "absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-500 hover:text-gray-700", title: "Reset to auto-generated slug", children: d.jsx(vr, {}) })] }), d.jsx("p", { className: "text-xs text-gray-500 mt-1", children: we ? "Slug is manually edited. Click the X to reset to auto-generated." : "Slug is auto-generated from title. You can edit it manually." })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Order*" }), d.jsx("input", { type: "number", name: "order", value: K.order, onChange: De, className: "w-full px-3 py-2 border rounded-md", min: "1", required: !0 })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Content*" }), d.jsx(Yg, { uploadImgUrl: "https://api.nexus.com/api/admin/help-center/topics/upload-image", content: K.content, onUpdate: I => te(se => ({ ...se, content: I })), onHeadingsUpdate: He })] }), d.jsxs("div", { className: "flex items-center mb-4", children: [d.jsx("input", { type: "checkbox", name: "is_active", checked: K.is_active, onChange: De, className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" }), d.jsx("label", { htmlFor: "is_active", className: "ml-2 text-sm text-gray-700", children: "Active" })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsx("button", { type: "button", onClick: () => { M(!1), Y() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: ie.isPending, children: ie.isPending ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Updating..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(br, { size: 18 }), d.jsx("span", { children: "Update Article" })] }) })] })] })] }) }) }), O && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => E(!1), children: d.jsx(ot.div, { initial: { scale: .9, opacity: 0 }, animate: { scale: 1, opacity: 1 }, exit: { scale: .9, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md", onClick: I => I.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsxs("div", { className: "flex items-start", children: [d.jsx("div", { className: "flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100", children: d.jsx(Cn, { className: "h-5 w-5 text-red-600" }) }), d.jsxs("div", { className: "ml-4", children: [d.jsx("h3", { className: "text-lg font-medium text-gray-900", children: "Delete Article" }), d.jsx("div", { className: "mt-2", children: d.jsxs("p", { className: "text-sm text-gray-500", children: ['Are you sure you want to delete the article "', k && t.find(I => I.id === k)?.title, '"? This action cannot be undone.'] }) })] })] }), d.jsxs("div", { className: "mt-5 flex justify-end gap-3", children: [d.jsx("button", { type: "button", onClick: () => E(!1), className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "button", onClick: et, className: "px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 flex items-center justify-center gap-2", disabled: oe.isPending, children: oe.isPending ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Deleting..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(Cn, { size: 18 }), d.jsx("span", { children: "Delete" })] }) })] })] }) }) })] }) } function pce() { const t = ln(), { data: e, isLoading: n, isError: r, error: i, isLoading: s, refetch: a } = Jt({ queryKey: ["helpcenterarticles"], queryFn: () => Ve.get("https://api.nexus.com/api/admin/help-center/topics", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }), { data: l, isLoading: u } = Jt({ queryKey: ["helpcenterSubcategories"], queryFn: () => Ve.get("https://api.nexus.com/api/admin/help-center/subcategories", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }), { data: f, isLoading: p } = Jt({ queryKey: ["helpcenterCategories"], queryFn: () => Ve.get("https://api.nexus.com/api/admin/help-center/categories", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }); return N.useEffect(() => { r && (i.response?.status == 401 && (localStorage.removeItem("userToken"), t("/login")), i.response?.status == 403 && (me.error("You are not authorized to view this page"), t("/home"))) }, [r]), d.jsxs("div", { className: "p-4", children: [d.jsx("h1", { className: "text-3xl font-bold text-gray-800 mb-8", children: "Help Center Articles" }), d.jsx(hce, { helpcenterArticlesData: e?.data?.data || [], helpcenterSubcategoriesData: l?.data?.data || [], helpcenterCategoriesData: f?.data?.data || [], loading: s, refetch: a })] }) } function mce() { return d.jsxs("div", { className: " mx-auto p-6", children: [d.jsx("h1", { className: "text-3xl font-bold text-gray-900 mb-10", children: "Webinars" }), d.jsxs("div", { className: "space-y-6", children: [d.jsx("div", { className: "group", children: d.jsxs(za, { to: "events", className: "block bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition-all duration-200 group-hover:border-primary border-l-4 border-transparent", children: [d.jsx("h2", { className: "text-2xl font-semibold text-gray-800 mb-2", children: "Events" }), d.jsx("p", { className: "text-gray-600", children: "Browse Webinars upcomming events" })] }) }), d.jsx("div", { className: "group", children: d.jsxs(za, { to: "videos", className: "block bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition-all duration-200 group-hover:border-primary border-l-4 border-transparent", children: [d.jsx("h2", { className: "text-2xl font-semibold text-gray-800 mb-2", children: "Videos" }), d.jsx("p", { className: "text-gray-600", children: "Browse Webinars Videos" })] }) })] })] }) } function gce({ WebinarsEventsData: t, loading: e, refetch: n }) { const r = ln(), [i, s] = N.useState({ global: "", title: "", date: "", presented_by: "", subscribers: "" }), [a, l] = N.useState(1), [u] = N.useState(10), [f, p] = N.useState(null), [g, y] = N.useState(!1), [v, b] = N.useState(!1), [S, C] = N.useState(!1), [T, A] = N.useState(null), [M, O] = N.useState(!1), [E, k] = N.useState(null), [z, V] = N.useState(null), [q, ue] = N.useState(null), [W, ne] = N.useState({ title: "", date: "", cover_photo: null, host_image: null, duration: "", presented_by: "", description: "" }), { data: H } = Jt({ queryKey: ["currentUser"], queryFn: () => Ve.get("https://api.nexus.com/api/auth/me", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }), we = (De, he) => { s(Be => ({ ...Be, [De]: he })), l(1) }, xe = De => { A(De), C(!0) }, K = async () => { if (T) { p(T), C(!1); try { await Ve.delete(`https://api.nexus.com/api/admin/webinars/events/${T}`, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success("Event deleted successfully", { duration: 2e3 }), n() } catch (De) { me.error(De.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), De.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), De.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } finally { p(null), A(null) } } }, te = De => { const { name: he, value: Be } = De.target; ne(Y => ({ ...Y, [he]: Be })) }, ye = De => { const he = De.target.files[0]; if (he) { ne(Y => ({ ...Y, cover_photo: he })); const Be = new FileReader; Be.onloadend = () => { V(Be.result) }, Be.readAsDataURL(he) } }, He = De => { const he = De.target.files[0]; if (he) { ne(Y => ({ ...Y, host_image: he })); const Be = new FileReader; Be.onloadend = () => { ue(Be.result) }, Be.readAsDataURL(he) } }, B = () => { ne({ title: "", date: "", cover_photo: null, host_image: null, duration: "", presented_by: "", description: "" }), V(null), ue(null) }, ie = De => { k(De), ne({ title: De.title, date: De.date, cover_photo: null, host_image: null, duration: De.duration, presented_by: De.presented_by, description: De.description || "" }), V(De.cover_photo ? `${De.cover_photo}` : null), ue(De.host_image ? `${De.host_image}` : null), b(!0) }, oe = async De => { De.preventDefault(), O(!0); const he = new FormData; he.append("title", W.title), he.append("date", W.date), he.append("duration", W.duration), he.append("presented_by", W.presented_by), he.append("description", W.description), W.cover_photo && he.append("cover_photo", W.cover_photo), W.host_image && he.append("host_image", W.host_image); try { await Ve.post("https://api.nexus.com/api/admin/webinars/events", he, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}`, "Content-Type": "multipart/form-data" } }), me.success("Event added successfully", { duration: 2e3 }), y(!1), B(), n() } catch (Be) { me.error(Be.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), Be.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), Be.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } finally { O(!1) } }, pe = async De => { De.preventDefault(), O(!0); const he = new FormData; he.append("title", W.title), he.append("date", W.date), he.append("duration", W.duration), he.append("presented_by", W.presented_by), he.append("description", W.description), W.cover_photo && he.append("cover_photo", W.cover_photo), W.host_image && he.append("host_image", W.host_image); try { await Ve.post(`https://api.nexus.com/api/admin/webinars/events/${E.slug}`, he, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}`, "Content-Type": "multipart/form-data" } }), me.success("Event updated successfully", { duration: 2e3 }), b(!1), B(), n() } catch (Be) { me.error(Be.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), Be.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), Be.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } finally { O(!1) } }, Ee = t?.filter(De => { const he = new Date(De.date).toLocaleDateString(); return (i.global === "" || De.title.toLowerCase().includes(i.global.toLowerCase()) || De.presented_by.toLowerCase().includes(i.global.toLowerCase()) || De.description?.toLowerCase().includes(i.global.toLowerCase())) && (i.title === "" || De.title.toLowerCase().includes(i.title.toLowerCase())) && (i.date === "" || he.includes(i.date)) && (i.presented_by === "" || De.presented_by.toLowerCase().includes(i.presented_by.toLowerCase())) && (i.subscribers === "" || De.subscribers.length.toString().includes(i.subscribers)) }) || [], fe = Math.ceil(Ee.length / u), Oe = Ee.slice((a - 1) * u, a * u), et = De => { const he = { year: "numeric", month: "short", day: "numeric", hour: "2-digit", minute: "2-digit" }; return new Date(De).toLocaleDateString(void 0, he) }, Xe = () => fe <= 1 ? null : d.jsxs("div", { className: "flex justify-between items-center mt-4 px-4 pb-1", children: [d.jsxs("div", { className: "text-xs", children: ["Showing ", (a - 1) * u + 1, "-", Math.min(a * u, Ee.length), " of ", Ee.length, " entries"] }), d.jsxs("div", { className: "flex gap-1", children: [d.jsx("button", { onClick: () => l(1), disabled: a === 1, className: "p-1 disabled:opacity-50", children: d.jsx(Ds, { className: "h-4 w-4" }) }), d.jsxs("span", { className: "px-3 py-1", children: ["Page ", a, " of ", fe] }), d.jsx("button", { onClick: () => l(De => Math.min(fe, De + 1)), disabled: a === fe, className: "p-1 disabled:opacity-50", children: d.jsx(Rs, { className: "h-4 w-4" }) })] })] }); return d.jsxs("div", { className: "shadow-2xl rounded-2xl overflow-hidden bg-white", children: [d.jsxs("div", { className: "p-4 border-b flex justify-between items-center gap-4", children: [d.jsx("input", { type: "text", value: i.global, onChange: De => we("global", De.target.value), placeholder: "Search events...", className: "px-3 py-2 rounded-xl shadow-sm focus:outline-2 focus:outline-primary w-full border border-primary transition-all" }), H?.data?.data?.admin?.permissions?.includes("manage_webinars") && d.jsxs("button", { onClick: () => y(!0), className: "bg-primary hover:bg-darkBlue transition-all text-white px-3 py-2 rounded-xl shadow-sm min-w-max flex items-center gap-2", children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Event" })] })] }), d.jsx("div", { className: "overflow-x-auto", children: d.jsxs("table", { className: "w-full divide-y divide-gray-200", children: [d.jsx("thead", { className: "bg-gray-50", children: d.jsxs("tr", { children: [d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Title", value: i.title, onChange: De => we("title", De.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Date", value: i.date, onChange: De => we("date", De.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Duration" }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Presented By", value: i.presented_by, onChange: De => we("presented_by", De.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Description" }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Subscribers", value: i.subscribers, onChange: De => we("subscribers", De.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Actions" })] }) }), d.jsx("tbody", { className: "bg-white divide-y divide-gray-200 text-sm", children: e ? d.jsx("tr", { children: d.jsx("td", { colSpan: "7", className: "px-3 py-4 text-center", children: d.jsxs("div", { className: "flex justify-center items-center gap-2", children: [d.jsx(mt, { className: "animate-spin", size: 18 }), "Loading events..."] }) }) }) : Oe.length === 0 ? d.jsx("tr", { children: d.jsx("td", { colSpan: "7", className: "px-3 py-4 text-center", children: "No events found" }) }) : Oe.map(De => d.jsxs("tr", { className: "hover:bg-gray-50", children: [d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsx("div", { className: "font-medium", children: De.title }) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsxs("div", { className: "flex items-center gap-2", children: [d.jsx(uX, { className: "text-gray-400" }), et(De.date)] }) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsxs("div", { className: "flex items-center gap-2", children: [d.jsx(dX, { className: "text-gray-400" }), De.duration] }) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsxs("div", { className: "flex items-center gap-2", children: [d.jsx(bX, { className: "text-gray-400" }), De.presented_by] }) }), d.jsx("td", { className: "px-3 py-4", children: d.jsx("div", { className: "line-clamp-2", children: De.description }) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsxs("div", { className: "flex items-center gap-2", children: [d.jsx(wX, { className: "text-gray-400" }), De.subscribers?.length || 0] }) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsxs("div", { className: "flex items-center gap-2", children: [H?.data?.data?.admin?.permissions?.includes("manage_webinars") && d.jsx("button", { className: "text-blue-500 hover:text-blue-700 p-1", onClick: () => ie(De), children: d.jsx(br, { size: 18 }) }), H?.data?.data?.admin?.permissions?.includes("manage_webinars") && d.jsx("button", { className: "text-red-500 hover:text-red-700 p-1", onClick: () => xe(De.slug), disabled: f === De.slug, children: f === De.slug ? d.jsx(mt, { className: "animate-spin", size: 18 }) : d.jsx(Cn, { size: 18 }) })] }) })] }, De.id)) })] }) }), !e && Xe(), g && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => y(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-lg max-h-[90vh] overflow-y-auto", onClick: De => De.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Add New Webinar Event" }), d.jsxs("form", { onSubmit: oe, children: [d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Title*" }), d.jsx("input", { required: !0, type: "text", name: "title", value: W.title, onChange: te, className: "w-full px-3 py-2 border rounded-md" })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Date and Time*" }), d.jsx("input", { required: !0, type: "datetime-local", name: "date", value: W.date, onChange: te, className: "w-full px-3 py-2 border rounded-md" })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Duration*" }), d.jsx("input", { required: !0, type: "text", name: "duration", value: W.duration, onChange: te, placeholder: "e.g. 2h, 1.5h", className: "w-full px-3 py-2 border rounded-md" })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Presented By*" }), d.jsx("input", { required: !0, type: "text", name: "presented_by", value: W.presented_by, onChange: te, className: "w-full px-3 py-2 border rounded-md" })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Description*" }), d.jsx("textarea", { required: !0, name: "description", value: W.description, onChange: te, className: "w-full px-3 py-2 border rounded-md", rows: "3" })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Cover Photo" }), d.jsx("input", { type: "file", name: "cover_photo", onChange: ye, accept: "image/*", className: "w-full px-3 py-2 border rounded-md" }), z && d.jsx("div", { className: "mt-2", children: d.jsx("img", { src: z, alt: "Cover preview", className: "h-32 object-contain" }) })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Host Image" }), d.jsx("input", { type: "file", name: "host_image", onChange: He, accept: "image/*", className: "w-full px-3 py-2 border rounded-md" }), q && d.jsx("div", { className: "mt-2", children: d.jsx("img", { src: q, alt: "Host preview", className: "h-32 object-contain" }) })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsx("button", { type: "button", onClick: () => { y(!1), B() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: M, children: M ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Adding..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Event" })] }) })] })] })] }) }) }), v && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => b(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-lg max-h-[90vh] overflow-y-auto", onClick: De => De.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Edit Webinar Event" }), d.jsxs("form", { onSubmit: pe, children: [d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Title*" }), d.jsx("input", { required: !0, type: "text", name: "title", value: W.title, onChange: te, className: "w-full px-3 py-2 border rounded-md" })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Date and Time*" }), d.jsx("input", { required: !0, type: "datetime-local", name: "date", value: W.date, onChange: te, className: "w-full px-3 py-2 border rounded-md" })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Duration*" }), d.jsx("input", { required: !0, type: "text", name: "duration", value: W.duration, onChange: te, placeholder: "e.g. 2h, 1.5h", className: "w-full px-3 py-2 border rounded-md" })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Presented By*" }), d.jsx("input", { required: !0, type: "text", name: "presented_by", value: W.presented_by, onChange: te, className: "w-full px-3 py-2 border rounded-md" })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Description*" }), d.jsx("textarea", { required: !0, name: "description", value: W.description, onChange: te, className: "w-full px-3 py-2 border rounded-md", rows: "3" })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Cover Photo" }), d.jsx("input", { type: "file", name: "cover_photo", onChange: ye, accept: "image/*", className: "w-full px-3 py-2 border rounded-md" }), z && d.jsxs("div", { className: "mt-2", children: [d.jsx("img", { src: z, alt: "Cover preview", className: "h-32 object-contain" }), d.jsx("p", { className: "text-xs text-gray-500 mt-1", children: "Current cover photo" })] })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Host Image" }), d.jsx("input", { type: "file", name: "host_image", onChange: He, accept: "image/*", className: "w-full px-3 py-2 border rounded-md" }), q && d.jsxs("div", { className: "mt-2", children: [d.jsx("img", { src: q, alt: "Host preview", className: "h-32 object-contain" }), d.jsx("p", { className: "text-xs text-gray-500 mt-1", children: "Current host image" })] })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsx("button", { type: "button", onClick: () => { b(!1), B() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: M, children: M ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Updating..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(br, { size: 18 }), d.jsx("span", { children: "Update Event" })] }) })] })] })] }) }) }), S && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => C(!1), children: d.jsx(ot.div, { initial: { scale: .9, opacity: 0 }, animate: { scale: 1, opacity: 1 }, exit: { scale: .9, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md", onClick: De => De.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsxs("div", { className: "flex items-start", children: [d.jsx("div", { className: "flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100", children: d.jsx(Cn, { className: "h-5 w-5 text-red-600" }) }), d.jsxs("div", { className: "ml-4", children: [d.jsx("h3", { className: "text-lg font-medium text-gray-900", children: "Delete Webinar Event" }), d.jsx("div", { className: "mt-2", children: d.jsx("p", { className: "text-sm text-gray-500", children: "Are you sure you want to delete this event? All subscribers will also be removed. This action cannot be undone." }) })] })] }), d.jsxs("div", { className: "mt-5 flex justify-end gap-3", children: [d.jsx("button", { type: "button", onClick: () => C(!1), className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "button", onClick: K, className: "px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700", children: "Delete" })] })] }) }) })] }) } function yce() { const t = ln(), { data: e, isLoading: n, isError: r, error: i, isLoading: s, refetch: a } = Jt({ queryKey: ["WebinarsEvents"], queryFn: () => Ve.get("https://api.nexus.com/api/admin/webinars/events", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }); return N.useEffect(() => { r && (i.response?.status == 401 && (localStorage.removeItem("userToken"), t("/login")), i.response?.status == 403 && (me.error("You are not authorized to view this page"), t("/home"))) }, [r]), d.jsxs("div", { className: "p-4", children: [d.jsx("h1", { className: "text-3xl font-bold text-gray-800 mb-8", children: "Webinars Events" }), d.jsx(gce, { WebinarsEventsData: e?.data?.data || [], loading: s, refetch: a })] }) } function vce({ WebinarsVideosData: t, loading: e, refetch: n }) { const r = ln(), [i, s] = N.useState({ global: "", title: "", type: "" }), [a, l] = N.useState(1), [u] = N.useState(10), [f, p] = N.useState(null), [g, y] = N.useState(!1), [v, b] = N.useState(!1), [S, C] = N.useState(!1), [T, A] = N.useState(null), [M, O] = N.useState(!1), [E, k] = N.useState(null), [z, V] = N.useState(null), [q, ue] = N.useState(null), [W, ne] = N.useState({ title: "", type: "youtube", video_url: "", cover_photo: null }), { data: H } = Jt({ queryKey: ["currentUser"], queryFn: () => Ve.get("https://api.nexus.com/api/auth/me", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }), we = (he, Be) => { s(Y => ({ ...Y, [he]: Be })), l(1) }, xe = he => { A(he), C(!0) }, K = async () => { if (T) { p(T), C(!1); try { await Ve.delete(`https://api.nexus.com/api/admin/webinars/videos/${T}`, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }), me.success("Video deleted successfully", { duration: 2e3 }), n() } catch (he) { me.error(he.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), he.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), he.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } finally { p(null), A(null) } } }, te = he => { const { name: Be, value: Y } = he.target; ne(Je => ({ ...Je, [Be]: Y })) }, ye = he => { const Be = he.target.files[0]; if (Be) { ne(Je => ({ ...Je, cover_photo: Be })); const Y = new FileReader; Y.onloadend = () => { V(Y.result) }, Y.readAsDataURL(Be) } }, He = he => { const Be = he.target.files[0]; Be && (ue(Be), ne(Y => ({ ...Y, video_url: Be }))) }, B = () => { ne({ title: "", type: "youtube", video_url: "", cover_photo: null }), V(null), ue(null) }, ie = he => { k(he), ne({ title: he.title, type: he.type, video_url: he.video_url, cover_photo: null }), V(he.cover_photo ? `${he.cover_photo}` : null), b(!0) }, oe = async he => { he.preventDefault(), O(!0); const Be = new FormData; Be.append("title", W.title), Be.append("type", W.type), W.type, Be.append("video_url", W.video_url), W.cover_photo && Be.append("cover_photo", W.cover_photo); try { await Ve.post("https://api.nexus.com/api/admin/webinars/videos", Be, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}`, "Content-Type": "multipart/form-data" } }), me.success("Video added successfully", { duration: 2e3 }), y(!1), B(), n() } catch (Y) { me.error(Y.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), Y.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), Y.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } finally { O(!1) } }, pe = async he => { he.preventDefault(), O(!0); const Be = new FormData; Be.append("title", W.title), Be.append("type", W.type), W.type === "youtube" ? Be.append("video_url", W.video_url) : q && Be.append("video_url", q), W.cover_photo && Be.append("cover_photo", W.cover_photo); try { await Ve.post(`https://api.nexus.com/api/admin/webinars/videos/${E.slug}`, Be, { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}`, "Content-Type": "multipart/form-data" } }), me.success("Video updated successfully", { duration: 2e3 }), b(!1), B(), n() } catch (Y) { me.error(Y.response?.data?.message || "An unexpected error occurred", { duration: 3e3 }), Y.response?.status == 401 && (localStorage.removeItem("userToken"), r("/login")), Y.response?.status == 403 && (me.error("You are not authorized to view this page"), r("/home")) } finally { O(!1) } }, Ee = t?.filter(he => (i.global === "" || he.title.toLowerCase().includes(i.global.toLowerCase())) && (i.title === "" || he.title.toLowerCase().includes(i.title.toLowerCase())) && (i.type === "" || he.type.toLowerCase().includes(i.type.toLowerCase()))) || [], fe = Math.ceil(Ee.length / u), Oe = Ee.slice((a - 1) * u, a * u), et = he => { const Be = { year: "numeric", month: "short", day: "numeric" }; return new Date(he).toLocaleDateString(void 0, Be) }, Xe = () => fe <= 1 ? null : d.jsxs("div", { className: "flex justify-between items-center mt-4 px-4 pb-1", children: [d.jsxs("div", { className: "text-xs", children: ["Showing ", (a - 1) * u + 1, "-", Math.min(a * u, Ee.length), " of ", Ee.length, " entries"] }), d.jsxs("div", { className: "flex gap-1", children: [d.jsx("button", { onClick: () => l(1), disabled: a === 1, className: "p-1 disabled:opacity-50", children: d.jsx(Ds, { className: "h-4 w-4" }) }), d.jsxs("span", { className: "px-3 py-1", children: ["Page ", a, " of ", fe] }), d.jsx("button", { onClick: () => l(he => Math.min(fe, he + 1)), disabled: a === fe, className: "p-1 disabled:opacity-50", children: d.jsx(Rs, { className: "h-4 w-4" }) })] })] }), De = he => he === "youtube" ? d.jsx(cX, { className: "text-red-500" }) : d.jsx(hX, { className: "text-blue-500" }); return d.jsxs("div", { className: "shadow-2xl rounded-2xl overflow-hidden bg-white", children: [d.jsxs("div", { className: "p-4 border-b flex justify-between items-center gap-4", children: [d.jsx("input", { type: "text", value: i.global, onChange: he => we("global", he.target.value), placeholder: "Search videos...", className: "px-3 py-2 rounded-xl shadow-sm focus:outline-2 focus:outline-primary w-full border border-primary transition-all" }), H?.data?.data?.admin?.permissions?.includes("manage_webinars") && d.jsxs("button", { onClick: () => y(!0), className: "bg-primary hover:bg-darkBlue transition-all text-white px-3 py-2 rounded-xl shadow-sm min-w-max flex items-center gap-2", children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Video" })] })] }), d.jsx("div", { className: "overflow-x-auto", children: d.jsxs("table", { className: "w-full divide-y divide-gray-200", children: [d.jsx("thead", { className: "bg-gray-50", children: d.jsxs("tr", { children: [d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: d.jsx("input", { type: "text", placeholder: "Title", value: i.title, onChange: he => we("title", he.target.value), className: "text-xs p-1 border rounded w-full" }) }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Type" }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Created At" }), d.jsx("th", { className: "px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider", children: "Actions" })] }) }), d.jsx("tbody", { className: "bg-white divide-y divide-gray-200 text-sm", children: e ? d.jsx("tr", { children: d.jsx("td", { colSpan: "4", className: "px-3 py-4 text-center", children: d.jsxs("div", { className: "flex justify-center items-center gap-2", children: [d.jsx(mt, { className: "animate-spin", size: 18 }), "Loading videos..."] }) }) }) : Oe.length === 0 ? d.jsx("tr", { children: d.jsx("td", { colSpan: "4", className: "px-3 py-4 text-center", children: "No videos found" }) }) : Oe.map(he => d.jsxs("tr", { className: "hover:bg-gray-50", children: [d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsx("div", { className: "font-medium", children: he.title }) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsxs("div", { className: "flex items-center gap-2", children: [De(he.type), he.type === "youtube" ? "YouTube" : "Uploaded Video"] }) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: et(he.created_at) }), d.jsx("td", { className: "px-3 py-4 whitespace-nowrap", children: d.jsxs("div", { className: "flex items-center gap-2", children: [d.jsx("a", { href: he.type === "youtube" ? he.video_url : `${he.video_url}`, target: "_blank", rel: "noopener noreferrer", className: "text-green-500 hover:text-green-700 p-1", children: d.jsx(mX, { size: 18 }) }), H?.data?.data?.admin?.permissions?.includes("manage_webinars") && d.jsx("button", { className: "text-blue-500 hover:text-blue-700 p-1", onClick: () => ie(he), children: d.jsx(br, { size: 18 }) }), H?.data?.data?.admin?.permissions?.includes("manage_webinars") && d.jsx("button", { className: "text-red-500 hover:text-red-700 p-1", onClick: () => xe(he.slug), disabled: f === he.slug, children: f === he.slug ? d.jsx(mt, { className: "animate-spin", size: 18 }) : d.jsx(Cn, { size: 18 }) })] }) })] }, he.id)) })] }) }), !e && Xe(), g && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => y(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto", onClick: he => he.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Add New Webinar Video" }), d.jsxs("form", { onSubmit: oe, children: [d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Title*" }), d.jsx("input", { required: !0, type: "text", name: "title", value: W.title, onChange: te, className: "w-full px-3 py-2 border rounded-md" })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Type*" }), d.jsxs("select", { name: "type", value: W.type, onChange: te, className: "w-full px-3 py-2 border rounded-md", required: !0, children: [d.jsx("option", { value: "youtube", children: "YouTube" }), d.jsx("option", { value: "upload", children: "Upload Video" })] })] }), W.type === "youtube" ? d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "YouTube URL*" }), d.jsx("input", { required: !0, type: "url", name: "video_url", value: W.video_url, onChange: te, placeholder: "https://www.youtube.com/watch?v=...", className: "w-full px-3 py-2 border rounded-md" })] }) : d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Video File*" }), d.jsx("input", { required: !0, type: "file", name: "video_url", onChange: He, accept: "video/*", className: "w-full px-3 py-2 border rounded-md" }), q && d.jsx("p", { className: "text-xs text-gray-500 mt-1", children: q.name })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Cover Photo" }), d.jsx("input", { type: "file", name: "cover_photo", onChange: ye, accept: "image/*", className: "w-full px-3 py-2 border rounded-md" }), z && d.jsx("div", { className: "mt-2", children: d.jsx("img", { src: z, alt: "Cover preview", className: "h-32 object-contain" }) })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsx("button", { type: "button", onClick: () => { y(!1), B() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: M, children: M ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Adding..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(fr, { size: 18 }), d.jsx("span", { children: "Add Video" })] }) })] })] })] }) }) }), v && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => b(!1), children: d.jsx(ot.div, { initial: { y: -50, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: 50, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md max-h-[90vh] overflow-y-auto", onClick: he => he.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsx("h2", { className: "text-xl font-bold mb-4", children: "Edit Webinar Video" }), d.jsxs("form", { onSubmit: pe, children: [d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Title*" }), d.jsx("input", { required: !0, type: "text", name: "title", value: W.title, onChange: te, className: "w-full px-3 py-2 border rounded-md" })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Type*" }), d.jsxs("select", { name: "type", value: W.type, onChange: te, className: "w-full px-3 py-2 border rounded-md", required: !0, children: [d.jsx("option", { value: "youtube", children: "YouTube" }), d.jsx("option", { value: "upload", children: "Upload Video" })] })] }), W.type === "youtube" ? d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "YouTube URL*" }), d.jsx("input", { required: !0, type: "url", name: "video_url", value: W.video_url, onChange: te, placeholder: "https://www.youtube.com/watch?v=...", className: "w-full px-3 py-2 border rounded-md" })] }) : d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Video File*" }), d.jsx("input", { type: "file", name: "video_url", onChange: He, accept: "video/*", className: "w-full px-3 py-2 border rounded-md" }), !q && d.jsxs("p", { className: "text-xs text-gray-500 mt-1", children: ["Current video: ", E.video_url.split("/").pop()] }), q && d.jsxs("p", { className: "text-xs text-gray-500 mt-1", children: ["New file: ", q.name] })] }), d.jsxs("div", { className: "mb-4", children: [d.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-1", children: "Cover Photo" }), d.jsx("input", { type: "file", name: "cover_photo", onChange: ye, accept: "image/*", className: "w-full px-3 py-2 border rounded-md" }), z && d.jsxs("div", { className: "mt-2", children: [d.jsx("img", { src: z, alt: "Cover preview", className: "h-32 object-contain" }), d.jsx("p", { className: "text-xs text-gray-500 mt-1", children: "Current cover photo" })] })] }), d.jsxs("div", { className: "flex justify-end gap-3 mt-6", children: [d.jsx("button", { type: "button", onClick: () => { b(!1), B() }, className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "submit", className: "px-4 py-2 bg-primary text-white rounded-md hover:bg-darkBlue transition-all flex items-center justify-center gap-2", disabled: M, children: M ? d.jsxs(d.Fragment, { children: [d.jsx(mt, { className: "animate-spin", size: 18 }), d.jsx("span", { children: "Updating..." })] }) : d.jsxs(d.Fragment, { children: [d.jsx(br, { size: 18 }), d.jsx("span", { children: "Update Video" })] }) })] })] })] }) }) }), S && d.jsx(ot.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4", onClick: () => C(!1), children: d.jsx(ot.div, { initial: { scale: .9, opacity: 0 }, animate: { scale: 1, opacity: 1 }, exit: { scale: .9, opacity: 0 }, className: "bg-white rounded-lg shadow-xl w-full max-w-md", onClick: he => he.stopPropagation(), children: d.jsxs("div", { className: "p-6", children: [d.jsxs("div", { className: "flex items-start", children: [d.jsx("div", { className: "flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100", children: d.jsx(Cn, { className: "h-5 w-5 text-red-600" }) }), d.jsxs("div", { className: "ml-4", children: [d.jsx("h3", { className: "text-lg font-medium text-gray-900", children: "Delete Webinar Video" }), d.jsx("div", { className: "mt-2", children: d.jsx("p", { className: "text-sm text-gray-500", children: "Are you sure you want to delete this video? This action cannot be undone." }) })] })] }), d.jsxs("div", { className: "mt-5 flex justify-end gap-3", children: [d.jsx("button", { type: "button", onClick: () => C(!1), className: "px-4 py-2 border rounded-md text-gray-700 hover:bg-gray-50", children: "Cancel" }), d.jsx("button", { type: "button", onClick: K, className: "px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700", children: "Delete" })] })] }) }) })] }) } function xce() { const t = ln(), { data: e, isLoading: n, isError: r, error: i, isLoading: s, refetch: a } = Jt({ queryKey: ["WebinarsVideos"], queryFn: () => Ve.get("https://api.nexus.com/api/admin/webinars/videos", { headers: { Authorization: `Bearer ${localStorage.getItem("userToken")}` } }) }); return N.useEffect(() => { r && (i.response?.status == 401 && (localStorage.removeItem("userToken"), t("/login")), i.response?.status == 403 && (me.error("You are not authorized to view this page"), t("/home"))) }, [r]), d.jsxs("div", { className: "p-4", children: [d.jsx("h1", { className: "text-3xl font-bold text-gray-800 mb-8", children: "Webinars Events" }), d.jsx(vce, { WebinarsVideosData: e?.data?.data || [], loading: s, refetch: a })] }) } function bce() { const t = eI([{ path: "/login", element: d.jsx(EV, {}) }, { path: "/", element: d.jsx(yr, { children: d.jsx(Tq, {}) }), children: [{ index: !0, element: d.jsx(yr, { children: d.jsx(fI, {}) }) }, { path: "/integrations", element: d.jsx(yr, { children: d.jsx(CX, {}) }) }, { path: "/admins", element: d.jsx(yr, { children: d.jsx(NX, {}) }) }, { path: "/plans", element: d.jsx(yr, { children: d.jsx(kX, {}) }) }, { path: "/plans/features", element: d.jsx(yr, { children: d.jsx(EX, {}) }) }, { path: "/privacy-Policy", element: d.jsx(yr, { children: d.jsx(Tie, {}) }) }, { path: "/terms-of-services", element: d.jsx(yr, { children: d.jsx(Nie, {}) }) }, { path: "/blogs", element: d.jsx(yr, { children: d.jsx(Koe, {}) }) }, { path: "/news-letter", element: d.jsx(yr, { children: d.jsx(Yoe, {}) }) }, { path: "/requested-demos", element: d.jsx(yr, { children: d.jsx(Zoe, {}) }) }, { path: "/user-setting", element: d.jsx(yr, { children: d.jsx(oce, {}) }) }, { path: "/help-center", element: d.jsx(yr, { children: d.jsx(lce, {}) }) }, { path: "/help-center/categories", element: d.jsxs(yr, { children: [" ", d.jsx(uce, {})] }) }, { path: "/help-center/subcategories", element: d.jsxs(yr, { children: [d.jsx(fce, {}), " "] }) }, { path: "/help-center/articles", element: d.jsx(yr, { children: d.jsx(pce, {}) }) }, { path: "/webinars", element: d.jsx(yr, { children: d.jsx(mce, {}) }) }, { path: "/webinars/events", element: d.jsx(yr, { children: d.jsx(yce, {}) }) }, { path: "/webinars/videos", element: d.jsx(yr, { children: d.jsx(xce, {}) }) }] }, { path: "*", element: d.jsx(zle, {}) }]); let e = new ZV({ defaultOptions: { queries: { retry: !1 } } }); return d.jsx(d.Fragment, { children: d.jsx(AV, { children: d.jsxs(iH, { client: e, children: [d.jsx(dI, { router: t }), d.jsx(X$, { position: "bottom-right", reverseOrder: !1 })] }) }) }) } r8.createRoot(document.getElementById("root")).render(d.jsx(N.StrictMode, { children: d.jsx(bce, {}) }))
}); export default wce();
